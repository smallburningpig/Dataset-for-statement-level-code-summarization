{"code": "float delta = variancePercent / 100f;", "comments": "e.g., 20 / 100f == 0.2f", "lines": 2, "repo": "square/retrofit", "path": "retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java", "func_name": "NetworkBehavior.calculateDelay", "original_string": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "language": "java", "Allcodes": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "code_tokens": ["public", "long", "calculateDelay", "(", "TimeUnit", "unit", ")", "{", "float", "delta", "=", "variancePercent", "/", "100f", ";", "// e.g., 20 / 100f == 0.2f", "float", "lowerBound", "=", "1f", "-", "delta", ";", "// 0.2f --> 0.8f", "float", "upperBound", "=", "1f", "+", "delta", ";", "// 0.2f --> 1.2f", "float", "bound", "=", "upperBound", "-", "lowerBound", ";", "// 1.2f - 0.8f == 0.4f", "float", "delayPercent", "=", "lowerBound", "+", "(", "random", ".", "nextFloat", "(", ")", "*", "bound", ")", ";", "// 0.8 + (rnd * 0.4)", "long", "callDelayMs", "=", "(", "long", ")", "(", "delayMs", "*", "delayPercent", ")", ";", "return", "MILLISECONDS", ".", "convert", "(", "callDelayMs", ",", "unit", ")", ";", "}"], "docstring": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "docstring_tokens": ["Get", "the", "delay", "that", "should", "be", "used", "for", "delaying", "a", "response", "in", "accordance", "with", "configured", "behavior", "."]}
{"code": "float lowerBound = 1f - delta;", "comments": "0.2f --> 0.8f", "lines": 3, "repo": "square/retrofit", "path": "retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java", "func_name": "NetworkBehavior.calculateDelay", "original_string": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "language": "java", "Allcodes": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "code_tokens": ["public", "long", "calculateDelay", "(", "TimeUnit", "unit", ")", "{", "float", "delta", "=", "variancePercent", "/", "100f", ";", "// e.g., 20 / 100f == 0.2f", "float", "lowerBound", "=", "1f", "-", "delta", ";", "// 0.2f --> 0.8f", "float", "upperBound", "=", "1f", "+", "delta", ";", "// 0.2f --> 1.2f", "float", "bound", "=", "upperBound", "-", "lowerBound", ";", "// 1.2f - 0.8f == 0.4f", "float", "delayPercent", "=", "lowerBound", "+", "(", "random", ".", "nextFloat", "(", ")", "*", "bound", ")", ";", "// 0.8 + (rnd * 0.4)", "long", "callDelayMs", "=", "(", "long", ")", "(", "delayMs", "*", "delayPercent", ")", ";", "return", "MILLISECONDS", ".", "convert", "(", "callDelayMs", ",", "unit", ")", ";", "}"], "docstring": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "docstring_tokens": ["Get", "the", "delay", "that", "should", "be", "used", "for", "delaying", "a", "response", "in", "accordance", "with", "configured", "behavior", "."]}
{"code": "float upperBound = 1f + delta;", "comments": "0.2f --> 1.2f", "lines": 4, "repo": "square/retrofit", "path": "retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java", "func_name": "NetworkBehavior.calculateDelay", "original_string": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "language": "java", "Allcodes": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "code_tokens": ["public", "long", "calculateDelay", "(", "TimeUnit", "unit", ")", "{", "float", "delta", "=", "variancePercent", "/", "100f", ";", "// e.g., 20 / 100f == 0.2f", "float", "lowerBound", "=", "1f", "-", "delta", ";", "// 0.2f --> 0.8f", "float", "upperBound", "=", "1f", "+", "delta", ";", "// 0.2f --> 1.2f", "float", "bound", "=", "upperBound", "-", "lowerBound", ";", "// 1.2f - 0.8f == 0.4f", "float", "delayPercent", "=", "lowerBound", "+", "(", "random", ".", "nextFloat", "(", ")", "*", "bound", ")", ";", "// 0.8 + (rnd * 0.4)", "long", "callDelayMs", "=", "(", "long", ")", "(", "delayMs", "*", "delayPercent", ")", ";", "return", "MILLISECONDS", ".", "convert", "(", "callDelayMs", ",", "unit", ")", ";", "}"], "docstring": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "docstring_tokens": ["Get", "the", "delay", "that", "should", "be", "used", "for", "delaying", "a", "response", "in", "accordance", "with", "configured", "behavior", "."]}
{"code": "float bound = upperBound - lowerBound;", "comments": "1.2f - 0.8f == 0.4f", "lines": 5, "repo": "square/retrofit", "path": "retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java", "func_name": "NetworkBehavior.calculateDelay", "original_string": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "language": "java", "Allcodes": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "code_tokens": ["public", "long", "calculateDelay", "(", "TimeUnit", "unit", ")", "{", "float", "delta", "=", "variancePercent", "/", "100f", ";", "// e.g., 20 / 100f == 0.2f", "float", "lowerBound", "=", "1f", "-", "delta", ";", "// 0.2f --> 0.8f", "float", "upperBound", "=", "1f", "+", "delta", ";", "// 0.2f --> 1.2f", "float", "bound", "=", "upperBound", "-", "lowerBound", ";", "// 1.2f - 0.8f == 0.4f", "float", "delayPercent", "=", "lowerBound", "+", "(", "random", ".", "nextFloat", "(", ")", "*", "bound", ")", ";", "// 0.8 + (rnd * 0.4)", "long", "callDelayMs", "=", "(", "long", ")", "(", "delayMs", "*", "delayPercent", ")", ";", "return", "MILLISECONDS", ".", "convert", "(", "callDelayMs", ",", "unit", ")", ";", "}"], "docstring": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "docstring_tokens": ["Get", "the", "delay", "that", "should", "be", "used", "for", "delaying", "a", "response", "in", "accordance", "with", "configured", "behavior", "."]}
{"code": "float delayPercent = lowerBound + (random.nextFloat() * bound);", "comments": "0.8 + (rnd * 0.4)", "lines": 6, "repo": "square/retrofit", "path": "retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java", "func_name": "NetworkBehavior.calculateDelay", "original_string": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "language": "java", "Allcodes": "public long calculateDelay(TimeUnit unit) {\n    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f\n    float lowerBound = 1f - delta; // 0.2f --> 0.8f\n    float upperBound = 1f + delta; // 0.2f --> 1.2f\n    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f\n    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)\n    long callDelayMs = (long) (delayMs * delayPercent);\n    return MILLISECONDS.convert(callDelayMs, unit);\n  }", "code_tokens": ["public", "long", "calculateDelay", "(", "TimeUnit", "unit", ")", "{", "float", "delta", "=", "variancePercent", "/", "100f", ";", "// e.g., 20 / 100f == 0.2f", "float", "lowerBound", "=", "1f", "-", "delta", ";", "// 0.2f --> 0.8f", "float", "upperBound", "=", "1f", "+", "delta", ";", "// 0.2f --> 1.2f", "float", "bound", "=", "upperBound", "-", "lowerBound", ";", "// 1.2f - 0.8f == 0.4f", "float", "delayPercent", "=", "lowerBound", "+", "(", "random", ".", "nextFloat", "(", ")", "*", "bound", ")", ";", "// 0.8 + (rnd * 0.4)", "long", "callDelayMs", "=", "(", "long", ")", "(", "delayMs", "*", "delayPercent", ")", ";", "return", "MILLISECONDS", ".", "convert", "(", "callDelayMs", ",", "unit", ")", ";", "}"], "docstring": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "docstring_tokens": ["Get", "the", "delay", "that", "should", "be", "used", "for", "delaying", "a", "response", "in", "accordance", "with", "configured", "behavior", "."]}
{"code": "boolean failed = cleanup(depBinding, encountered);", "comments": "if children fail, we fail", "lines": 10, "repo": "google/guice", "path": "core/src/com/google/inject/internal/InjectorImpl.java", "func_name": "InjectorImpl.cleanup", "original_string": "private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) {\n    boolean bindingFailed = false;\n    Set<Dependency<?>> deps = getInternalDependencies(binding);\n    for (Dependency dep : deps) {\n      Key<?> depKey = dep.getKey();\n      InjectionPoint ip = dep.getInjectionPoint();\n      if (encountered.add(depKey)) { // only check if we haven't looked at this key yet\n        BindingImpl depBinding = jitBindings.get(depKey);\n        if (depBinding != null) { // if the binding still exists, validate\n          boolean failed = cleanup(depBinding, encountered); // if children fail, we fail\n          if (depBinding instanceof ConstructorBindingImpl) {\n            ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding;\n            ip = ctorBinding.getInternalConstructor();\n            if (!ctorBinding.isInitialized()) {\n              failed = true;\n            }\n          }\n          if (failed) {\n            removeFailedJitBinding(depBinding, ip);\n            bindingFailed = true;\n          }\n        } else if (state.getExplicitBinding(depKey) == null) {\n          // ignore keys if they were explicitly bound, but if neither JIT\n          // nor explicit, it's also invalid & should let parent know.\n          bindingFailed = true;\n        }\n      }\n    }\n    return bindingFailed;\n  }", "language": "java", "Allcodes": "private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) {\n    boolean bindingFailed = false;\n    Set<Dependency<?>> deps = getInternalDependencies(binding);\n    for (Dependency dep : deps) {\n      Key<?> depKey = dep.getKey();\n      InjectionPoint ip = dep.getInjectionPoint();\n      if (encountered.add(depKey)) { // only check if we haven't looked at this key yet\n        BindingImpl depBinding = jitBindings.get(depKey);\n        if (depBinding != null) { // if the binding still exists, validate\n          boolean failed = cleanup(depBinding, encountered); // if children fail, we fail\n          if (depBinding instanceof ConstructorBindingImpl) {\n            ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding;\n            ip = ctorBinding.getInternalConstructor();\n            if (!ctorBinding.isInitialized()) {\n              failed = true;\n            }\n          }\n          if (failed) {\n            removeFailedJitBinding(depBinding, ip);\n            bindingFailed = true;\n          }\n        } else if (state.getExplicitBinding(depKey) == null) {\n          // ignore keys if they were explicitly bound, but if neither JIT\n          // nor explicit, it's also invalid & should let parent know.\n          bindingFailed = true;\n        }\n      }\n    }\n    return bindingFailed;\n  }", "code_tokens": ["private", "boolean", "cleanup", "(", "BindingImpl", "<", "?", ">", "binding", ",", "Set", "<", "Key", ">", "encountered", ")", "{", "boolean", "bindingFailed", "=", "false", ";", "Set", "<", "Dependency", "<", "?", ">", ">", "deps", "=", "getInternalDependencies", "(", "binding", ")", ";", "for", "(", "Dependency", "dep", ":", "deps", ")", "{", "Key", "<", "?", ">", "depKey", "=", "dep", ".", "getKey", "(", ")", ";", "InjectionPoint", "ip", "=", "dep", ".", "getInjectionPoint", "(", ")", ";", "if", "(", "encountered", ".", "add", "(", "depKey", ")", ")", "{", "// only check if we haven't looked at this key yet", "BindingImpl", "depBinding", "=", "jitBindings", ".", "get", "(", "depKey", ")", ";", "if", "(", "depBinding", "!=", "null", ")", "{", "// if the binding still exists, validate", "boolean", "failed", "=", "cleanup", "(", "depBinding", ",", "encountered", ")", ";", "// if children fail, we fail", "if", "(", "depBinding", "instanceof", "ConstructorBindingImpl", ")", "{", "ConstructorBindingImpl", "ctorBinding", "=", "(", "ConstructorBindingImpl", ")", "depBinding", ";", "ip", "=", "ctorBinding", ".", "getInternalConstructor", "(", ")", ";", "if", "(", "!", "ctorBinding", ".", "isInitialized", "(", ")", ")", "{", "failed", "=", "true", ";", "}", "}", "if", "(", "failed", ")", "{", "removeFailedJitBinding", "(", "depBinding", ",", "ip", ")", ";", "bindingFailed", "=", "true", ";", "}", "}", "else", "if", "(", "state", ".", "getExplicitBinding", "(", "depKey", ")", "==", "null", ")", "{", "// ignore keys if they were explicitly bound, but if neither JIT", "// nor explicit, it's also invalid & should let parent know.", "bindingFailed", "=", "true", ";", "}", "}", "}", "return", "bindingFailed", ";", "}"], "docstring": "Iterates through the binding's dependencies to clean up any stray bindings that were leftover\nfrom a failed JIT binding. This is required because the bindings are eagerly & optimistically\nadded to allow circular dependency support, so dependencies may pass where they should have\nfailed.", "docstring_tokens": ["Iterates", "through", "the", "binding", "s", "dependencies", "to", "clean", "up", "any", "stray", "bindings", "that", "were", "leftover", "from", "a", "failed", "JIT", "binding", ".", "This", "is", "required", "because", "the", "bindings", "are", "eagerly", "&", "optimistically", "added", "to", "allow", "circular", "dependency", "support", "so", "dependencies", "may", "pass", "where", "they", "should", "have", "failed", "."]}
{"code": "Set<Dependency<?>> badDeps = null;", "comments": "optimization: create lazily", "lines": 3, "repo": "google/guice", "path": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java", "func_name": "FactoryProvider2.isValidForOptimizedAssistedInject", "original_string": "private boolean isValidForOptimizedAssistedInject(\n      Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) {\n    Set<Dependency<?>> badDeps = null; // optimization: create lazily\n    for (Dependency<?> dep : dependencies) {\n      if (isInjectorOrAssistedProvider(dep)) {\n        if (badDeps == null) {\n          badDeps = Sets.newHashSet();\n        }\n        badDeps.add(dep);\n      }\n    }\n    if (badDeps != null && !badDeps.isEmpty()) {\n      logger.log(\n          Level.WARNING,\n          \"AssistedInject factory {0} will be slow \"\n              + \"because {1} has assisted Provider dependencies or injects the Injector. \"\n              + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \"\n              + \"or Injector to speed things up. (It will be a ~6500% speed bump!)  \"\n              + \"The exact offending deps are: {2}\",\n          new Object[] {factoryType, implementation, badDeps});\n      return false;\n    }\n    return true;\n  }", "language": "java", "Allcodes": "private boolean isValidForOptimizedAssistedInject(\n      Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) {\n    Set<Dependency<?>> badDeps = null; // optimization: create lazily\n    for (Dependency<?> dep : dependencies) {\n      if (isInjectorOrAssistedProvider(dep)) {\n        if (badDeps == null) {\n          badDeps = Sets.newHashSet();\n        }\n        badDeps.add(dep);\n      }\n    }\n    if (badDeps != null && !badDeps.isEmpty()) {\n      logger.log(\n          Level.WARNING,\n          \"AssistedInject factory {0} will be slow \"\n              + \"because {1} has assisted Provider dependencies or injects the Injector. \"\n              + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \"\n              + \"or Injector to speed things up. (It will be a ~6500% speed bump!)  \"\n              + \"The exact offending deps are: {2}\",\n          new Object[] {factoryType, implementation, badDeps});\n      return false;\n    }\n    return true;\n  }", "code_tokens": ["private", "boolean", "isValidForOptimizedAssistedInject", "(", "Set", "<", "Dependency", "<", "?", ">", ">", "dependencies", ",", "Class", "<", "?", ">", "implementation", ",", "TypeLiteral", "<", "?", ">", "factoryType", ")", "{", "Set", "<", "Dependency", "<", "?", ">", ">", "badDeps", "=", "null", ";", "// optimization: create lazily", "for", "(", "Dependency", "<", "?", ">", "dep", ":", "dependencies", ")", "{", "if", "(", "isInjectorOrAssistedProvider", "(", "dep", ")", ")", "{", "if", "(", "badDeps", "==", "null", ")", "{", "badDeps", "=", "Sets", ".", "newHashSet", "(", ")", ";", "}", "badDeps", ".", "add", "(", "dep", ")", ";", "}", "}", "if", "(", "badDeps", "!=", "null", "&&", "!", "badDeps", ".", "isEmpty", "(", ")", ")", "{", "logger", ".", "log", "(", "Level", ".", "WARNING", ",", "\"AssistedInject factory {0} will be slow \"", "+", "\"because {1} has assisted Provider dependencies or injects the Injector. \"", "+", "\"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \"", "+", "\"or Injector to speed things up. (It will be a ~6500% speed bump!)  \"", "+", "\"The exact offending deps are: {2}\"", ",", "new", "Object", "[", "]", "{", "factoryType", ",", "implementation", ",", "badDeps", "}", ")", ";", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Returns true if all dependencies are suitable for the optimized version of AssistedInject. The\noptimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if\nthe assisted bindings are immediately provided. This looks for hints that the values may be\nlazily retrieved, by looking for injections of Injector or a Provider for the assisted values.", "docstring_tokens": ["Returns", "true", "if", "all", "dependencies", "are", "suitable", "for", "the", "optimized", "version", "of", "AssistedInject", ".", "The", "optimized", "version", "caches", "the", "binding", "&", "uses", "a", "ThreadLocal", "Provider", "so", "can", "only", "be", "applied", "if", "the", "assisted", "bindings", "are", "immediately", "provided", ".", "This", "looks", "for", "hints", "that", "the", "values", "may", "be", "lazily", "retrieved", "by", "looking", "for", "injections", "of", "Injector", "or", "a", "Provider", "for", "the", "assisted", "values", "."]}
{"code": ".in(Scopes.NO_SCOPE);", "comments": "make sure we erase any scope on the implementation type", "lines": 44, "repo": "google/guice", "path": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java", "func_name": "FactoryProvider2.getBindingFromNewInjector", "original_string": "public Binding<?> getBindingFromNewInjector(\n      final Method method, final Object[] args, final AssistData data) {\n    checkState(\n        injector != null,\n        \"Factories.create() factories cannot be used until they're initialized by Guice.\");\n\n    final Key<?> returnType = data.returnType;\n\n    // We ignore any pre-existing binding annotation.\n    final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION);\n\n    Module assistedModule =\n        new AbstractModule() {\n          @Override\n          @SuppressWarnings({\n            \"unchecked\",\n            \"rawtypes\"\n          }) // raw keys are necessary for the args array and return value\n          protected void configure() {\n            Binder binder = binder().withSource(method);\n\n            int p = 0;\n            if (!data.optimized) {\n              for (Key<?> paramKey : data.paramTypes) {\n                // Wrap in a Provider to cover null, and to prevent Guice from injecting the\n                // parameter\n                binder.bind((Key) paramKey).toProvider(Providers.of(args[p++]));\n              }\n            } else {\n              for (Key<?> paramKey : data.paramTypes) {\n                // Bind to our ThreadLocalProviders.\n                binder.bind((Key) paramKey).toProvider(data.providers.get(p++));\n              }\n            }\n\n            Constructor constructor = data.constructor;\n            // Constructor *should* always be non-null here,\n            // but if it isn't, we'll end up throwing a fairly good error\n            // message for the user.\n            if (constructor != null) {\n              binder\n                  .bind(returnKey)\n                  .toConstructor(constructor, (TypeLiteral) data.implementationType)\n                  .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type\n            }\n          }\n        };\n\n    Injector forCreate = injector.createChildInjector(assistedModule);\n    Binding<?> binding = forCreate.getBinding(returnKey);\n    // If we have providers cached in data, cache the binding for future optimizations.\n    if (data.optimized) {\n      data.cachedBinding = binding;\n    }\n    return binding;\n  }", "language": "java", "Allcodes": "public Binding<?> getBindingFromNewInjector(\n      final Method method, final Object[] args, final AssistData data) {\n    checkState(\n        injector != null,\n        \"Factories.create() factories cannot be used until they're initialized by Guice.\");\n\n    final Key<?> returnType = data.returnType;\n\n    // We ignore any pre-existing binding annotation.\n    final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION);\n\n    Module assistedModule =\n        new AbstractModule() {\n          @Override\n          @SuppressWarnings({\n            \"unchecked\",\n            \"rawtypes\"\n          }) // raw keys are necessary for the args array and return value\n          protected void configure() {\n            Binder binder = binder().withSource(method);\n\n            int p = 0;\n            if (!data.optimized) {\n              for (Key<?> paramKey : data.paramTypes) {\n                // Wrap in a Provider to cover null, and to prevent Guice from injecting the\n                // parameter\n                binder.bind((Key) paramKey).toProvider(Providers.of(args[p++]));\n              }\n            } else {\n              for (Key<?> paramKey : data.paramTypes) {\n                // Bind to our ThreadLocalProviders.\n                binder.bind((Key) paramKey).toProvider(data.providers.get(p++));\n              }\n            }\n\n            Constructor constructor = data.constructor;\n            // Constructor *should* always be non-null here,\n            // but if it isn't, we'll end up throwing a fairly good error\n            // message for the user.\n            if (constructor != null) {\n              binder\n                  .bind(returnKey)\n                  .toConstructor(constructor, (TypeLiteral) data.implementationType)\n                  .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type\n            }\n          }\n        };\n\n    Injector forCreate = injector.createChildInjector(assistedModule);\n    Binding<?> binding = forCreate.getBinding(returnKey);\n    // If we have providers cached in data, cache the binding for future optimizations.\n    if (data.optimized) {\n      data.cachedBinding = binding;\n    }\n    return binding;\n  }", "code_tokens": ["public", "Binding", "<", "?", ">", "getBindingFromNewInjector", "(", "final", "Method", "method", ",", "final", "Object", "[", "]", "args", ",", "final", "AssistData", "data", ")", "{", "checkState", "(", "injector", "!=", "null", ",", "\"Factories.create() factories cannot be used until they're initialized by Guice.\"", ")", ";", "final", "Key", "<", "?", ">", "returnType", "=", "data", ".", "returnType", ";", "// We ignore any pre-existing binding annotation.", "final", "Key", "<", "?", ">", "returnKey", "=", "Key", ".", "get", "(", "returnType", ".", "getTypeLiteral", "(", ")", ",", "RETURN_ANNOTATION", ")", ";", "Module", "assistedModule", "=", "new", "AbstractModule", "(", ")", "{", "@", "Override", "@", "SuppressWarnings", "(", "{", "\"unchecked\"", ",", "\"rawtypes\"", "}", ")", "// raw keys are necessary for the args array and return value", "protected", "void", "configure", "(", ")", "{", "Binder", "binder", "=", "binder", "(", ")", ".", "withSource", "(", "method", ")", ";", "int", "p", "=", "0", ";", "if", "(", "!", "data", ".", "optimized", ")", "{", "for", "(", "Key", "<", "?", ">", "paramKey", ":", "data", ".", "paramTypes", ")", "{", "// Wrap in a Provider to cover null, and to prevent Guice from injecting the", "// parameter", "binder", ".", "bind", "(", "(", "Key", ")", "paramKey", ")", ".", "toProvider", "(", "Providers", ".", "of", "(", "args", "[", "p", "++", "]", ")", ")", ";", "}", "}", "else", "{", "for", "(", "Key", "<", "?", ">", "paramKey", ":", "data", ".", "paramTypes", ")", "{", "// Bind to our ThreadLocalProviders.", "binder", ".", "bind", "(", "(", "Key", ")", "paramKey", ")", ".", "toProvider", "(", "data", ".", "providers", ".", "get", "(", "p", "++", ")", ")", ";", "}", "}", "Constructor", "constructor", "=", "data", ".", "constructor", ";", "// Constructor *should* always be non-null here,", "// but if it isn't, we'll end up throwing a fairly good error", "// message for the user.", "if", "(", "constructor", "!=", "null", ")", "{", "binder", ".", "bind", "(", "returnKey", ")", ".", "toConstructor", "(", "constructor", ",", "(", "TypeLiteral", ")", "data", ".", "implementationType", ")", ".", "in", "(", "Scopes", ".", "NO_SCOPE", ")", ";", "// make sure we erase any scope on the implementation type", "}", "}", "}", ";", "Injector", "forCreate", "=", "injector", ".", "createChildInjector", "(", "assistedModule", ")", ";", "Binding", "<", "?", ">", "binding", "=", "forCreate", ".", "getBinding", "(", "returnKey", ")", ";", "// If we have providers cached in data, cache the binding for future optimizations.", "if", "(", "data", ".", "optimized", ")", "{", "data", ".", "cachedBinding", "=", "binding", ";", "}", "return", "binding", ";", "}"], "docstring": "Creates a child injector that binds the args, and returns the binding for the method's result.", "docstring_tokens": ["Creates", "a", "child", "injector", "that", "binds", "the", "args", "and", "returns", "the", "binding", "for", "the", "method", "s", "result", "."]}
{"code": "pool.markAsyncCreationStart();", "comments": "mark the start of async", "lines": 32, "repo": "alipay/sofa-bolt", "path": "src/main/java/com/alipay/remoting/DefaultConnectionManager.java", "func_name": "DefaultConnectionManager.doCreate", "original_string": "private void doCreate(final Url url, final ConnectionPool pool, final String taskName,\n                          final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum,\n                    taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum; ++i) {\n                    Connection connection = create(url);\n                    pool.add(connection);\n                }\n            } else {\n                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {\n                    throw new IllegalArgumentException(\n                        \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\");\n                }\n                // create connection in sync way\n                if (syncCreateNumWhenNotWarmup > 0) {\n                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {\n                        Connection connection = create(url);\n                        pool.add(connection);\n                    }\n                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {\n                        return;\n                    }\n                }\n                // initialize executor in lazy way\n                initializeExecutor();\n                pool.markAsyncCreationStart();// mark the start of async\n                try {\n                    this.asyncCreateConnectionExecutor.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                for (int i = pool.size(); i < url.getConnNum(); ++i) {\n                                    Connection conn = null;\n                                    try {\n                                        conn = create(url);\n                                    } catch (RemotingException e) {\n                                        logger\n                                            .error(\n                                                \"Exception occurred in async create connection thread for {}, taskName {}\",\n                                                url.getUniqueKey(), taskName, e);\n                                    }\n                                    pool.add(conn);\n                                }\n                            } finally {\n                                pool.markAsyncCreationDone();// mark the end of async\n                            }\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    pool.markAsyncCreationDone();// mark the end of async when reject\n                    throw e;\n                }\n            } // end of NOT warm up\n        } // end of if\n    }", "language": "java", "Allcodes": "private void doCreate(final Url url, final ConnectionPool pool, final String taskName,\n                          final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum,\n                    taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum; ++i) {\n                    Connection connection = create(url);\n                    pool.add(connection);\n                }\n            } else {\n                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {\n                    throw new IllegalArgumentException(\n                        \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\");\n                }\n                // create connection in sync way\n                if (syncCreateNumWhenNotWarmup > 0) {\n                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {\n                        Connection connection = create(url);\n                        pool.add(connection);\n                    }\n                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {\n                        return;\n                    }\n                }\n                // initialize executor in lazy way\n                initializeExecutor();\n                pool.markAsyncCreationStart();// mark the start of async\n                try {\n                    this.asyncCreateConnectionExecutor.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                for (int i = pool.size(); i < url.getConnNum(); ++i) {\n                                    Connection conn = null;\n                                    try {\n                                        conn = create(url);\n                                    } catch (RemotingException e) {\n                                        logger\n                                            .error(\n                                                \"Exception occurred in async create connection thread for {}, taskName {}\",\n                                                url.getUniqueKey(), taskName, e);\n                                    }\n                                    pool.add(conn);\n                                }\n                            } finally {\n                                pool.markAsyncCreationDone();// mark the end of async\n                            }\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    pool.markAsyncCreationDone();// mark the end of async when reject\n                    throw e;\n                }\n            } // end of NOT warm up\n        } // end of if\n    }", "code_tokens": ["private", "void", "doCreate", "(", "final", "Url", "url", ",", "final", "ConnectionPool", "pool", ",", "final", "String", "taskName", ",", "final", "int", "syncCreateNumWhenNotWarmup", ")", "throws", "RemotingException", "{", "final", "int", "actualNum", "=", "pool", ".", "size", "(", ")", ";", "final", "int", "expectNum", "=", "url", ".", "getConnNum", "(", ")", ";", "if", "(", "actualNum", "<", "expectNum", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"actual num {}, expect num {}, task name {}\"", ",", "actualNum", ",", "expectNum", ",", "taskName", ")", ";", "}", "if", "(", "url", ".", "isConnWarmup", "(", ")", ")", "{", "for", "(", "int", "i", "=", "actualNum", ";", "i", "<", "expectNum", ";", "++", "i", ")", "{", "Connection", "connection", "=", "create", "(", "url", ")", ";", "pool", ".", "add", "(", "connection", ")", ";", "}", "}", "else", "{", "if", "(", "syncCreateNumWhenNotWarmup", "<", "0", "||", "syncCreateNumWhenNotWarmup", ">", "url", ".", "getConnNum", "(", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"sync create number when not warmup should be [0,\"", "+", "url", ".", "getConnNum", "(", ")", "+", "\"]\"", ")", ";", "}", "// create connection in sync way", "if", "(", "syncCreateNumWhenNotWarmup", ">", "0", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "syncCreateNumWhenNotWarmup", ";", "++", "i", ")", "{", "Connection", "connection", "=", "create", "(", "url", ")", ";", "pool", ".", "add", "(", "connection", ")", ";", "}", "if", "(", "syncCreateNumWhenNotWarmup", "==", "url", ".", "getConnNum", "(", ")", ")", "{", "return", ";", "}", "}", "// initialize executor in lazy way", "initializeExecutor", "(", ")", ";", "pool", ".", "markAsyncCreationStart", "(", ")", ";", "// mark the start of async", "try", "{", "this", ".", "asyncCreateConnectionExecutor", ".", "execute", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "for", "(", "int", "i", "=", "pool", ".", "size", "(", ")", ";", "i", "<", "url", ".", "getConnNum", "(", ")", ";", "++", "i", ")", "{", "Connection", "conn", "=", "null", ";", "try", "{", "conn", "=", "create", "(", "url", ")", ";", "}", "catch", "(", "RemotingException", "e", ")", "{", "logger", ".", "error", "(", "\"Exception occurred in async create connection thread for {}, taskName {}\"", ",", "url", ".", "getUniqueKey", "(", ")", ",", "taskName", ",", "e", ")", ";", "}", "pool", ".", "add", "(", "conn", ")", ";", "}", "}", "finally", "{", "pool", ".", "markAsyncCreationDone", "(", ")", ";", "// mark the end of async", "}", "}", "}", ")", ";", "}", "catch", "(", "RejectedExecutionException", "e", ")", "{", "pool", ".", "markAsyncCreationDone", "(", ")", ";", "// mark the end of async when reject", "throw", "e", ";", "}", "}", "// end of NOT warm up", "}", "// end of if", "}"], "docstring": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "docstring_tokens": ["do", "create", "connections"]}
{"code": "pool.markAsyncCreationDone();", "comments": "mark the end of async", "lines": 51, "repo": "alipay/sofa-bolt", "path": "src/main/java/com/alipay/remoting/DefaultConnectionManager.java", "func_name": "DefaultConnectionManager.doCreate", "original_string": "private void doCreate(final Url url, final ConnectionPool pool, final String taskName,\n                          final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum,\n                    taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum; ++i) {\n                    Connection connection = create(url);\n                    pool.add(connection);\n                }\n            } else {\n                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {\n                    throw new IllegalArgumentException(\n                        \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\");\n                }\n                // create connection in sync way\n                if (syncCreateNumWhenNotWarmup > 0) {\n                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {\n                        Connection connection = create(url);\n                        pool.add(connection);\n                    }\n                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {\n                        return;\n                    }\n                }\n                // initialize executor in lazy way\n                initializeExecutor();\n                pool.markAsyncCreationStart();// mark the start of async\n                try {\n                    this.asyncCreateConnectionExecutor.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                for (int i = pool.size(); i < url.getConnNum(); ++i) {\n                                    Connection conn = null;\n                                    try {\n                                        conn = create(url);\n                                    } catch (RemotingException e) {\n                                        logger\n                                            .error(\n                                                \"Exception occurred in async create connection thread for {}, taskName {}\",\n                                                url.getUniqueKey(), taskName, e);\n                                    }\n                                    pool.add(conn);\n                                }\n                            } finally {\n                                pool.markAsyncCreationDone();// mark the end of async\n                            }\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    pool.markAsyncCreationDone();// mark the end of async when reject\n                    throw e;\n                }\n            } // end of NOT warm up\n        } // end of if\n    }", "language": "java", "Allcodes": "private void doCreate(final Url url, final ConnectionPool pool, final String taskName,\n                          final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum,\n                    taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum; ++i) {\n                    Connection connection = create(url);\n                    pool.add(connection);\n                }\n            } else {\n                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {\n                    throw new IllegalArgumentException(\n                        \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\");\n                }\n                // create connection in sync way\n                if (syncCreateNumWhenNotWarmup > 0) {\n                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {\n                        Connection connection = create(url);\n                        pool.add(connection);\n                    }\n                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {\n                        return;\n                    }\n                }\n                // initialize executor in lazy way\n                initializeExecutor();\n                pool.markAsyncCreationStart();// mark the start of async\n                try {\n                    this.asyncCreateConnectionExecutor.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                for (int i = pool.size(); i < url.getConnNum(); ++i) {\n                                    Connection conn = null;\n                                    try {\n                                        conn = create(url);\n                                    } catch (RemotingException e) {\n                                        logger\n                                            .error(\n                                                \"Exception occurred in async create connection thread for {}, taskName {}\",\n                                                url.getUniqueKey(), taskName, e);\n                                    }\n                                    pool.add(conn);\n                                }\n                            } finally {\n                                pool.markAsyncCreationDone();// mark the end of async\n                            }\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    pool.markAsyncCreationDone();// mark the end of async when reject\n                    throw e;\n                }\n            } // end of NOT warm up\n        } // end of if\n    }", "code_tokens": ["private", "void", "doCreate", "(", "final", "Url", "url", ",", "final", "ConnectionPool", "pool", ",", "final", "String", "taskName", ",", "final", "int", "syncCreateNumWhenNotWarmup", ")", "throws", "RemotingException", "{", "final", "int", "actualNum", "=", "pool", ".", "size", "(", ")", ";", "final", "int", "expectNum", "=", "url", ".", "getConnNum", "(", ")", ";", "if", "(", "actualNum", "<", "expectNum", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"actual num {}, expect num {}, task name {}\"", ",", "actualNum", ",", "expectNum", ",", "taskName", ")", ";", "}", "if", "(", "url", ".", "isConnWarmup", "(", ")", ")", "{", "for", "(", "int", "i", "=", "actualNum", ";", "i", "<", "expectNum", ";", "++", "i", ")", "{", "Connection", "connection", "=", "create", "(", "url", ")", ";", "pool", ".", "add", "(", "connection", ")", ";", "}", "}", "else", "{", "if", "(", "syncCreateNumWhenNotWarmup", "<", "0", "||", "syncCreateNumWhenNotWarmup", ">", "url", ".", "getConnNum", "(", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"sync create number when not warmup should be [0,\"", "+", "url", ".", "getConnNum", "(", ")", "+", "\"]\"", ")", ";", "}", "// create connection in sync way", "if", "(", "syncCreateNumWhenNotWarmup", ">", "0", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "syncCreateNumWhenNotWarmup", ";", "++", "i", ")", "{", "Connection", "connection", "=", "create", "(", "url", ")", ";", "pool", ".", "add", "(", "connection", ")", ";", "}", "if", "(", "syncCreateNumWhenNotWarmup", "==", "url", ".", "getConnNum", "(", ")", ")", "{", "return", ";", "}", "}", "// initialize executor in lazy way", "initializeExecutor", "(", ")", ";", "pool", ".", "markAsyncCreationStart", "(", ")", ";", "// mark the start of async", "try", "{", "this", ".", "asyncCreateConnectionExecutor", ".", "execute", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "for", "(", "int", "i", "=", "pool", ".", "size", "(", ")", ";", "i", "<", "url", ".", "getConnNum", "(", ")", ";", "++", "i", ")", "{", "Connection", "conn", "=", "null", ";", "try", "{", "conn", "=", "create", "(", "url", ")", ";", "}", "catch", "(", "RemotingException", "e", ")", "{", "logger", ".", "error", "(", "\"Exception occurred in async create connection thread for {}, taskName {}\"", ",", "url", ".", "getUniqueKey", "(", ")", ",", "taskName", ",", "e", ")", ";", "}", "pool", ".", "add", "(", "conn", ")", ";", "}", "}", "finally", "{", "pool", ".", "markAsyncCreationDone", "(", ")", ";", "// mark the end of async", "}", "}", "}", ")", ";", "}", "catch", "(", "RejectedExecutionException", "e", ")", "{", "pool", ".", "markAsyncCreationDone", "(", ")", ";", "// mark the end of async when reject", "throw", "e", ";", "}", "}", "// end of NOT warm up", "}", "// end of if", "}"], "docstring": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "docstring_tokens": ["do", "create", "connections"]}
{"code": "pool.markAsyncCreationDone();", "comments": "mark the end of async when reject", "lines": 56, "repo": "alipay/sofa-bolt", "path": "src/main/java/com/alipay/remoting/DefaultConnectionManager.java", "func_name": "DefaultConnectionManager.doCreate", "original_string": "private void doCreate(final Url url, final ConnectionPool pool, final String taskName,\n                          final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum,\n                    taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum; ++i) {\n                    Connection connection = create(url);\n                    pool.add(connection);\n                }\n            } else {\n                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {\n                    throw new IllegalArgumentException(\n                        \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\");\n                }\n                // create connection in sync way\n                if (syncCreateNumWhenNotWarmup > 0) {\n                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {\n                        Connection connection = create(url);\n                        pool.add(connection);\n                    }\n                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {\n                        return;\n                    }\n                }\n                // initialize executor in lazy way\n                initializeExecutor();\n                pool.markAsyncCreationStart();// mark the start of async\n                try {\n                    this.asyncCreateConnectionExecutor.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                for (int i = pool.size(); i < url.getConnNum(); ++i) {\n                                    Connection conn = null;\n                                    try {\n                                        conn = create(url);\n                                    } catch (RemotingException e) {\n                                        logger\n                                            .error(\n                                                \"Exception occurred in async create connection thread for {}, taskName {}\",\n                                                url.getUniqueKey(), taskName, e);\n                                    }\n                                    pool.add(conn);\n                                }\n                            } finally {\n                                pool.markAsyncCreationDone();// mark the end of async\n                            }\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    pool.markAsyncCreationDone();// mark the end of async when reject\n                    throw e;\n                }\n            } // end of NOT warm up\n        } // end of if\n    }", "language": "java", "Allcodes": "private void doCreate(final Url url, final ConnectionPool pool, final String taskName,\n                          final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum,\n                    taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum; ++i) {\n                    Connection connection = create(url);\n                    pool.add(connection);\n                }\n            } else {\n                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {\n                    throw new IllegalArgumentException(\n                        \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\");\n                }\n                // create connection in sync way\n                if (syncCreateNumWhenNotWarmup > 0) {\n                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {\n                        Connection connection = create(url);\n                        pool.add(connection);\n                    }\n                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {\n                        return;\n                    }\n                }\n                // initialize executor in lazy way\n                initializeExecutor();\n                pool.markAsyncCreationStart();// mark the start of async\n                try {\n                    this.asyncCreateConnectionExecutor.execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                for (int i = pool.size(); i < url.getConnNum(); ++i) {\n                                    Connection conn = null;\n                                    try {\n                                        conn = create(url);\n                                    } catch (RemotingException e) {\n                                        logger\n                                            .error(\n                                                \"Exception occurred in async create connection thread for {}, taskName {}\",\n                                                url.getUniqueKey(), taskName, e);\n                                    }\n                                    pool.add(conn);\n                                }\n                            } finally {\n                                pool.markAsyncCreationDone();// mark the end of async\n                            }\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    pool.markAsyncCreationDone();// mark the end of async when reject\n                    throw e;\n                }\n            } // end of NOT warm up\n        } // end of if\n    }", "code_tokens": ["private", "void", "doCreate", "(", "final", "Url", "url", ",", "final", "ConnectionPool", "pool", ",", "final", "String", "taskName", ",", "final", "int", "syncCreateNumWhenNotWarmup", ")", "throws", "RemotingException", "{", "final", "int", "actualNum", "=", "pool", ".", "size", "(", ")", ";", "final", "int", "expectNum", "=", "url", ".", "getConnNum", "(", ")", ";", "if", "(", "actualNum", "<", "expectNum", ")", "{", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "{", "logger", ".", "debug", "(", "\"actual num {}, expect num {}, task name {}\"", ",", "actualNum", ",", "expectNum", ",", "taskName", ")", ";", "}", "if", "(", "url", ".", "isConnWarmup", "(", ")", ")", "{", "for", "(", "int", "i", "=", "actualNum", ";", "i", "<", "expectNum", ";", "++", "i", ")", "{", "Connection", "connection", "=", "create", "(", "url", ")", ";", "pool", ".", "add", "(", "connection", ")", ";", "}", "}", "else", "{", "if", "(", "syncCreateNumWhenNotWarmup", "<", "0", "||", "syncCreateNumWhenNotWarmup", ">", "url", ".", "getConnNum", "(", ")", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"sync create number when not warmup should be [0,\"", "+", "url", ".", "getConnNum", "(", ")", "+", "\"]\"", ")", ";", "}", "// create connection in sync way", "if", "(", "syncCreateNumWhenNotWarmup", ">", "0", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "syncCreateNumWhenNotWarmup", ";", "++", "i", ")", "{", "Connection", "connection", "=", "create", "(", "url", ")", ";", "pool", ".", "add", "(", "connection", ")", ";", "}", "if", "(", "syncCreateNumWhenNotWarmup", "==", "url", ".", "getConnNum", "(", ")", ")", "{", "return", ";", "}", "}", "// initialize executor in lazy way", "initializeExecutor", "(", ")", ";", "pool", ".", "markAsyncCreationStart", "(", ")", ";", "// mark the start of async", "try", "{", "this", ".", "asyncCreateConnectionExecutor", ".", "execute", "(", "new", "Runnable", "(", ")", "{", "@", "Override", "public", "void", "run", "(", ")", "{", "try", "{", "for", "(", "int", "i", "=", "pool", ".", "size", "(", ")", ";", "i", "<", "url", ".", "getConnNum", "(", ")", ";", "++", "i", ")", "{", "Connection", "conn", "=", "null", ";", "try", "{", "conn", "=", "create", "(", "url", ")", ";", "}", "catch", "(", "RemotingException", "e", ")", "{", "logger", ".", "error", "(", "\"Exception occurred in async create connection thread for {}, taskName {}\"", ",", "url", ".", "getUniqueKey", "(", ")", ",", "taskName", ",", "e", ")", ";", "}", "pool", ".", "add", "(", "conn", ")", ";", "}", "}", "finally", "{", "pool", ".", "markAsyncCreationDone", "(", ")", ";", "// mark the end of async", "}", "}", "}", ")", ";", "}", "catch", "(", "RejectedExecutionException", "e", ")", "{", "pool", ".", "markAsyncCreationDone", "(", ")", ";", "// mark the end of async when reject", "throw", "e", ";", "}", "}", "// end of NOT warm up", "}", "// end of if", "}"], "docstring": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "docstring_tokens": ["do", "create", "connections"]}
{"code": "ws.outQueue.poll();", "comments": "Buffer finished. Remove it.", "lines": 21, "repo": "TooTallNate/Java-WebSocket", "path": "src/main/java/org/java_websocket/SocketChannelIOHelper.java", "func_name": "SocketChannelIOHelper.batch", "original_string": "public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException {\n\t\tif (ws == null) {\n\t\t\treturn false;\n\t\t}\n\t\tByteBuffer buffer = ws.outQueue.peek();\n\t\tWrappedByteChannel c = null;\n\n\t\tif( buffer == null ) {\n\t\t\tif( sockchannel instanceof WrappedByteChannel ) {\n\t\t\t\tc = (WrappedByteChannel) sockchannel;\n\t\t\t\tif( c.isNeedWrite() ) {\n\t\t\t\t\tc.writeMore();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdo {// FIXME writing as much as possible is unfair!!\n\t\t\t\t/*int written = */sockchannel.write( buffer );\n\t\t\t\tif( buffer.remaining() > 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tws.outQueue.poll(); // Buffer finished. Remove it.\n\t\t\t\t\tbuffer = ws.outQueue.peek();\n\t\t\t\t}\n\t\t\t} while ( buffer != null );\n\t\t}\n\n\t\tif( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {//\n\t\t\tws.closeConnection();\n\t\t}\n\t\treturn c == null || !((WrappedByteChannel) sockchannel).isNeedWrite();\n\t}", "language": "java", "Allcodes": "public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException {\n\t\tif (ws == null) {\n\t\t\treturn false;\n\t\t}\n\t\tByteBuffer buffer = ws.outQueue.peek();\n\t\tWrappedByteChannel c = null;\n\n\t\tif( buffer == null ) {\n\t\t\tif( sockchannel instanceof WrappedByteChannel ) {\n\t\t\t\tc = (WrappedByteChannel) sockchannel;\n\t\t\t\tif( c.isNeedWrite() ) {\n\t\t\t\t\tc.writeMore();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdo {// FIXME writing as much as possible is unfair!!\n\t\t\t\t/*int written = */sockchannel.write( buffer );\n\t\t\t\tif( buffer.remaining() > 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tws.outQueue.poll(); // Buffer finished. Remove it.\n\t\t\t\t\tbuffer = ws.outQueue.peek();\n\t\t\t\t}\n\t\t\t} while ( buffer != null );\n\t\t}\n\n\t\tif( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {//\n\t\t\tws.closeConnection();\n\t\t}\n\t\treturn c == null || !((WrappedByteChannel) sockchannel).isNeedWrite();\n\t}", "code_tokens": ["public", "static", "boolean", "batch", "(", "WebSocketImpl", "ws", ",", "ByteChannel", "sockchannel", ")", "throws", "IOException", "{", "if", "(", "ws", "==", "null", ")", "{", "return", "false", ";", "}", "ByteBuffer", "buffer", "=", "ws", ".", "outQueue", ".", "peek", "(", ")", ";", "WrappedByteChannel", "c", "=", "null", ";", "if", "(", "buffer", "==", "null", ")", "{", "if", "(", "sockchannel", "instanceof", "WrappedByteChannel", ")", "{", "c", "=", "(", "WrappedByteChannel", ")", "sockchannel", ";", "if", "(", "c", ".", "isNeedWrite", "(", ")", ")", "{", "c", ".", "writeMore", "(", ")", ";", "}", "}", "}", "else", "{", "do", "{", "// FIXME writing as much as possible is unfair!!", "/*int written = */", "sockchannel", ".", "write", "(", "buffer", ")", ";", "if", "(", "buffer", ".", "remaining", "(", ")", ">", "0", ")", "{", "return", "false", ";", "}", "else", "{", "ws", ".", "outQueue", ".", "poll", "(", ")", ";", "// Buffer finished. Remove it.", "buffer", "=", "ws", ".", "outQueue", ".", "peek", "(", ")", ";", "}", "}", "while", "(", "buffer", "!=", "null", ")", ";", "}", "if", "(", "ws", ".", "outQueue", ".", "isEmpty", "(", ")", "&&", "ws", ".", "isFlushAndClose", "(", ")", "&&", "ws", ".", "getDraft", "(", ")", "!=", "null", "&&", "ws", ".", "getDraft", "(", ")", ".", "getRole", "(", ")", "!=", "null", "&&", "ws", ".", "getDraft", "(", ")", ".", "getRole", "(", ")", "==", "Role", ".", "SERVER", ")", "{", "//", "ws", ".", "closeConnection", "(", ")", ";", "}", "return", "c", "==", "null", "||", "!", "(", "(", "WrappedByteChannel", ")", "sockchannel", ")", ".", "isNeedWrite", "(", ")", ";", "}"], "docstring": "Returns whether the whole outQueue has been flushed\n@param ws The WebSocketImpl associated with the channels\n@param sockchannel The channel to write to\n@throws IOException May be thrown by {@link WrappedByteChannel#writeMore()}\n@return returns Whether there is more data to write", "docstring_tokens": ["Returns", "whether", "the", "whole", "outQueue", "has", "been", "flushed"]}
{"code": "assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() );", "comments": "the buffers will never have remaining bytes at the same time", "lines": 11, "repo": "TooTallNate/Java-WebSocket", "path": "src/main/java/org/java_websocket/WebSocketImpl.java", "func_name": "WebSocketImpl.decode", "original_string": "public void decode( ByteBuffer socketBuffer ) {\n\t\tassert ( socketBuffer.hasRemaining() );\n\t\tlog.trace( \"process({}): ({})\", socketBuffer.remaining(),  ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) ));\n\n\t\tif( readyState != ReadyState.NOT_YET_CONNECTED ) {\n\t\t\tif( readyState == ReadyState.OPEN ) {\n\t\t\t\tdecodeFrames( socketBuffer );\n\t\t\t}\n\t\t} else {\n\t\t\tif( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) {\n\t\t\t\tassert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time\n\t\t\t\tif( socketBuffer.hasRemaining() ) {\n\t\t\t\t\tdecodeFrames( socketBuffer );\n\t\t\t\t} else if( tmpHandshakeBytes.hasRemaining() ) {\n\t\t\t\t\tdecodeFrames( tmpHandshakeBytes );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "public void decode( ByteBuffer socketBuffer ) {\n\t\tassert ( socketBuffer.hasRemaining() );\n\t\tlog.trace( \"process({}): ({})\", socketBuffer.remaining(),  ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) ));\n\n\t\tif( readyState != ReadyState.NOT_YET_CONNECTED ) {\n\t\t\tif( readyState == ReadyState.OPEN ) {\n\t\t\t\tdecodeFrames( socketBuffer );\n\t\t\t}\n\t\t} else {\n\t\t\tif( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) {\n\t\t\t\tassert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time\n\t\t\t\tif( socketBuffer.hasRemaining() ) {\n\t\t\t\t\tdecodeFrames( socketBuffer );\n\t\t\t\t} else if( tmpHandshakeBytes.hasRemaining() ) {\n\t\t\t\t\tdecodeFrames( tmpHandshakeBytes );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "void", "decode", "(", "ByteBuffer", "socketBuffer", ")", "{", "assert", "(", "socketBuffer", ".", "hasRemaining", "(", ")", ")", ";", "log", ".", "trace", "(", "\"process({}): ({})\"", ",", "socketBuffer", ".", "remaining", "(", ")", ",", "(", "socketBuffer", ".", "remaining", "(", ")", ">", "1000", "?", "\"too big to display\"", ":", "new", "String", "(", "socketBuffer", ".", "array", "(", ")", ",", "socketBuffer", ".", "position", "(", ")", ",", "socketBuffer", ".", "remaining", "(", ")", ")", ")", ")", ";", "if", "(", "readyState", "!=", "ReadyState", ".", "NOT_YET_CONNECTED", ")", "{", "if", "(", "readyState", "==", "ReadyState", ".", "OPEN", ")", "{", "decodeFrames", "(", "socketBuffer", ")", ";", "}", "}", "else", "{", "if", "(", "decodeHandshake", "(", "socketBuffer", ")", "&&", "(", "!", "isClosing", "(", ")", "&&", "!", "isClosed", "(", ")", ")", ")", "{", "assert", "(", "tmpHandshakeBytes", ".", "hasRemaining", "(", ")", "!=", "socketBuffer", ".", "hasRemaining", "(", ")", "||", "!", "socketBuffer", ".", "hasRemaining", "(", ")", ")", ";", "// the buffers will never have remaining bytes at the same time", "if", "(", "socketBuffer", ".", "hasRemaining", "(", ")", ")", "{", "decodeFrames", "(", "socketBuffer", ")", ";", "}", "else", "if", "(", "tmpHandshakeBytes", ".", "hasRemaining", "(", ")", ")", "{", "decodeFrames", "(", "tmpHandshakeBytes", ")", ";", "}", "}", "}", "}"], "docstring": "Method to decode the provided ByteBuffer\n\n@param socketBuffer the ByteBuffer to decode", "docstring_tokens": ["Method", "to", "decode", "the", "provided", "ByteBuffer"]}
{"code": "StringWriter writer = new StringWriter();", "comments": "flush & close not needed for StringWriter-instance", "lines": 3, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/io/PathUtil.java", "func_name": "PathUtil.readString", "original_string": "public static String readString(final Path path) throws IOException {\n\t\ttry (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n\t\t\tStringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance\n\t\t\tStreamUtil.copy(reader, writer);\n\t\t\treturn writer.toString();\n\t\t}\n\t}", "language": "java", "Allcodes": "public static String readString(final Path path) throws IOException {\n\t\ttry (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n\t\t\tStringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance\n\t\t\tStreamUtil.copy(reader, writer);\n\t\t\treturn writer.toString();\n\t\t}\n\t}", "code_tokens": ["public", "static", "String", "readString", "(", "final", "Path", "path", ")", "throws", "IOException", "{", "try", "(", "BufferedReader", "reader", "=", "Files", ".", "newBufferedReader", "(", "path", ",", "StandardCharsets", ".", "UTF_8", ")", ")", "{", "StringWriter", "writer", "=", "new", "StringWriter", "(", ")", ";", "// flush & close not needed for StringWriter-instance", "StreamUtil", ".", "copy", "(", "reader", ",", "writer", ")", ";", "return", "writer", ".", "toString", "(", ")", ";", "}", "}"], "docstring": "Reads path content.", "docstring_tokens": ["Reads", "path", "content", "."]}
{"code": "beansAlt.put(altName, null);", "comments": "store null as value to mark that alt name is duplicate", "lines": 31, "repo": "oblac/jodd", "path": "jodd-petite/src/main/java/jodd/petite/PetiteBeans.java", "func_name": "PetiteBeans.registerBean", "original_string": "protected void registerBean(final String name, final BeanDefinition beanDefinition) {\n\t\tbeans.put(name, beanDefinition);\n\n\t\tif (!petiteConfig.isUseAltBeanNames()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass type = beanDefinition.type();\n\n\t\tif (annotationResolver.beanHasAnnotationName(type)) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass[] interfaces = ClassUtil.resolveAllInterfaces(type);\n\n\t\tfor (Class anInterface : interfaces) {\n\t\t\tString altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames());\n\n\t\t\tif (name.equals(altName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (beans.containsKey(altName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (beansAlt.containsKey(altName)) {\n\t\t\t\tBeanDefinition existing = beansAlt.get(altName);\n\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tbeansAlt.put(altName, null);\t\t// store null as value to mark that alt name is duplicate\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeansAlt.put(altName, beanDefinition);\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "protected void registerBean(final String name, final BeanDefinition beanDefinition) {\n\t\tbeans.put(name, beanDefinition);\n\n\t\tif (!petiteConfig.isUseAltBeanNames()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass type = beanDefinition.type();\n\n\t\tif (annotationResolver.beanHasAnnotationName(type)) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass[] interfaces = ClassUtil.resolveAllInterfaces(type);\n\n\t\tfor (Class anInterface : interfaces) {\n\t\t\tString altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames());\n\n\t\t\tif (name.equals(altName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (beans.containsKey(altName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (beansAlt.containsKey(altName)) {\n\t\t\t\tBeanDefinition existing = beansAlt.get(altName);\n\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tbeansAlt.put(altName, null);\t\t// store null as value to mark that alt name is duplicate\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeansAlt.put(altName, beanDefinition);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["protected", "void", "registerBean", "(", "final", "String", "name", ",", "final", "BeanDefinition", "beanDefinition", ")", "{", "beans", ".", "put", "(", "name", ",", "beanDefinition", ")", ";", "if", "(", "!", "petiteConfig", ".", "isUseAltBeanNames", "(", ")", ")", "{", "return", ";", "}", "Class", "type", "=", "beanDefinition", ".", "type", "(", ")", ";", "if", "(", "annotationResolver", ".", "beanHasAnnotationName", "(", "type", ")", ")", "{", "return", ";", "}", "Class", "[", "]", "interfaces", "=", "ClassUtil", ".", "resolveAllInterfaces", "(", "type", ")", ";", "for", "(", "Class", "anInterface", ":", "interfaces", ")", "{", "String", "altName", "=", "annotationResolver", ".", "resolveBeanName", "(", "anInterface", ",", "petiteConfig", ".", "getUseFullTypeNames", "(", ")", ")", ";", "if", "(", "name", ".", "equals", "(", "altName", ")", ")", "{", "continue", ";", "}", "if", "(", "beans", ".", "containsKey", "(", "altName", ")", ")", "{", "continue", ";", "}", "if", "(", "beansAlt", ".", "containsKey", "(", "altName", ")", ")", "{", "BeanDefinition", "existing", "=", "beansAlt", ".", "get", "(", "altName", ")", ";", "if", "(", "existing", "!=", "null", ")", "{", "beansAlt", ".", "put", "(", "altName", ",", "null", ")", ";", "// store null as value to mark that alt name is duplicate", "}", "}", "else", "{", "beansAlt", ".", "put", "(", "altName", ",", "beanDefinition", ")", ";", "}", "}", "}"], "docstring": "Registers bean definition by putting it in the beans map. If bean does\nnot have petite name explicitly defined, alternative bean names\nwill be registered.", "docstring_tokens": ["Registers", "bean", "definition", "by", "putting", "it", "in", "the", "beans", "map", ".", "If", "bean", "does", "not", "have", "petite", "name", "explicitly", "defined", "alternative", "bean", "names", "will", "be", "registered", "."]}
{"code": "AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible);", "comments": "[A4]", "lines": 3, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaMethodBuilder.java", "func_name": "ProxettaMethodBuilder.visitAnnotation", "original_string": "@Override\n\tpublic AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n\t\tAnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4]\n\t\treturn new AnnotationVisitorAdapter(destAnn);\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n\t\tAnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4]\n\t\treturn new AnnotationVisitorAdapter(destAnn);\n\t}", "code_tokens": ["@", "Override", "public", "AnnotationVisitor", "visitAnnotation", "(", "final", "String", "desc", ",", "final", "boolean", "visible", ")", "{", "AnnotationVisitor", "destAnn", "=", "methodVisitor", ".", "visitAnnotation", "(", "desc", ",", "visible", ")", ";", "// [A4]", "return", "new", "AnnotationVisitorAdapter", "(", "destAnn", ")", ";", "}"], "docstring": "Copies target method annotations.", "docstring_tokens": ["Copies", "target", "method", "annotations", "."]}
{"code": "int count = 0;", "comments": "total count", "lines": 7, "repo": "oblac/jodd", "path": "jodd-http/src/main/java/jodd/http/Buffer.java", "func_name": "Buffer.writeTo", "original_string": "public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException {\n\n\t\t// start\n\n\t\tfinal int size = size();\n\t\tfinal int callbackSize = progressListener.callbackSize(size);\n\t\tint count = 0;\t\t// total count\n\t\tint step = 0;\t\t// step is offset in current chunk\n\n\t\tprogressListener.transferred(count);\n\n\t\t// loop\n\n\t\tfor (Object o : list) {\n\t\t\tif (o instanceof FastByteBuffer) {\n\t\t\t\tFastByteBuffer fastByteBuffer = (FastByteBuffer) o;\n\t\t\t\tbyte[] bytes = fastByteBuffer.toArray();\n\n\t\t\t\tint offset = 0;\n\n\t\t\t\twhile (offset < bytes.length) {\n\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t// check if this chunk size fits the bytes array\n\t\t\t\t\tif (offset + chunk > bytes.length) {\n\t\t\t\t\t\tchunk = bytes.length - offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// writes the chunk\n\t\t\t\t\tout.write(bytes, offset, chunk);\n\n\t\t\t\t\toffset += chunk;\n\t\t\t\t\tstep += chunk;\n\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t// listener\n\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (o instanceof Uploadable) {\n\t\t\t\tUploadable uploadable = (Uploadable) o;\n\n\t\t\t\tInputStream inputStream = uploadable.openInputStream();\n\n\t\t\t\tint remaining = uploadable.getSize();\n\n\t\t\t\ttry {\n\t\t\t\t\twhile (remaining > 0) {\n\t\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t\t// check if this chunk size fits the remaining size\n\t\t\t\t\t\tif (chunk > remaining) {\n\t\t\t\t\t\t\tchunk = remaining;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// writes remaining chunk\n\t\t\t\t\t\tStreamUtil.copy(inputStream, out, chunk);\n\n\t\t\t\t\t\tremaining -= chunk;\n\t\t\t\t\t\tstep += chunk;\n\t\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t\t// listener\n\t\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// end\n\n\t\tif (step != 0) {\n\t\t\tprogressListener.transferred(count);\n\t\t}\n\t}", "language": "java", "Allcodes": "public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException {\n\n\t\t// start\n\n\t\tfinal int size = size();\n\t\tfinal int callbackSize = progressListener.callbackSize(size);\n\t\tint count = 0;\t\t// total count\n\t\tint step = 0;\t\t// step is offset in current chunk\n\n\t\tprogressListener.transferred(count);\n\n\t\t// loop\n\n\t\tfor (Object o : list) {\n\t\t\tif (o instanceof FastByteBuffer) {\n\t\t\t\tFastByteBuffer fastByteBuffer = (FastByteBuffer) o;\n\t\t\t\tbyte[] bytes = fastByteBuffer.toArray();\n\n\t\t\t\tint offset = 0;\n\n\t\t\t\twhile (offset < bytes.length) {\n\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t// check if this chunk size fits the bytes array\n\t\t\t\t\tif (offset + chunk > bytes.length) {\n\t\t\t\t\t\tchunk = bytes.length - offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// writes the chunk\n\t\t\t\t\tout.write(bytes, offset, chunk);\n\n\t\t\t\t\toffset += chunk;\n\t\t\t\t\tstep += chunk;\n\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t// listener\n\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (o instanceof Uploadable) {\n\t\t\t\tUploadable uploadable = (Uploadable) o;\n\n\t\t\t\tInputStream inputStream = uploadable.openInputStream();\n\n\t\t\t\tint remaining = uploadable.getSize();\n\n\t\t\t\ttry {\n\t\t\t\t\twhile (remaining > 0) {\n\t\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t\t// check if this chunk size fits the remaining size\n\t\t\t\t\t\tif (chunk > remaining) {\n\t\t\t\t\t\t\tchunk = remaining;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// writes remaining chunk\n\t\t\t\t\t\tStreamUtil.copy(inputStream, out, chunk);\n\n\t\t\t\t\t\tremaining -= chunk;\n\t\t\t\t\t\tstep += chunk;\n\t\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t\t// listener\n\t\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// end\n\n\t\tif (step != 0) {\n\t\t\tprogressListener.transferred(count);\n\t\t}\n\t}", "code_tokens": ["public", "void", "writeTo", "(", "final", "OutputStream", "out", ",", "final", "HttpProgressListener", "progressListener", ")", "throws", "IOException", "{", "// start", "final", "int", "size", "=", "size", "(", ")", ";", "final", "int", "callbackSize", "=", "progressListener", ".", "callbackSize", "(", "size", ")", ";", "int", "count", "=", "0", ";", "// total count", "int", "step", "=", "0", ";", "// step is offset in current chunk", "progressListener", ".", "transferred", "(", "count", ")", ";", "// loop", "for", "(", "Object", "o", ":", "list", ")", "{", "if", "(", "o", "instanceof", "FastByteBuffer", ")", "{", "FastByteBuffer", "fastByteBuffer", "=", "(", "FastByteBuffer", ")", "o", ";", "byte", "[", "]", "bytes", "=", "fastByteBuffer", ".", "toArray", "(", ")", ";", "int", "offset", "=", "0", ";", "while", "(", "offset", "<", "bytes", ".", "length", ")", "{", "// calc the remaining sending chunk size", "int", "chunk", "=", "callbackSize", "-", "step", ";", "// check if this chunk size fits the bytes array", "if", "(", "offset", "+", "chunk", ">", "bytes", ".", "length", ")", "{", "chunk", "=", "bytes", ".", "length", "-", "offset", ";", "}", "// writes the chunk", "out", ".", "write", "(", "bytes", ",", "offset", ",", "chunk", ")", ";", "offset", "+=", "chunk", ";", "step", "+=", "chunk", ";", "count", "+=", "chunk", ";", "// listener", "if", "(", "step", ">=", "callbackSize", ")", "{", "progressListener", ".", "transferred", "(", "count", ")", ";", "step", "-=", "callbackSize", ";", "}", "}", "}", "else", "if", "(", "o", "instanceof", "Uploadable", ")", "{", "Uploadable", "uploadable", "=", "(", "Uploadable", ")", "o", ";", "InputStream", "inputStream", "=", "uploadable", ".", "openInputStream", "(", ")", ";", "int", "remaining", "=", "uploadable", ".", "getSize", "(", ")", ";", "try", "{", "while", "(", "remaining", ">", "0", ")", "{", "// calc the remaining sending chunk size", "int", "chunk", "=", "callbackSize", "-", "step", ";", "// check if this chunk size fits the remaining size", "if", "(", "chunk", ">", "remaining", ")", "{", "chunk", "=", "remaining", ";", "}", "// writes remaining chunk", "StreamUtil", ".", "copy", "(", "inputStream", ",", "out", ",", "chunk", ")", ";", "remaining", "-=", "chunk", ";", "step", "+=", "chunk", ";", "count", "+=", "chunk", ";", "// listener", "if", "(", "step", ">=", "callbackSize", ")", "{", "progressListener", ".", "transferred", "(", "count", ")", ";", "step", "-=", "callbackSize", ";", "}", "}", "}", "finally", "{", "StreamUtil", ".", "close", "(", "inputStream", ")", ";", "}", "}", "}", "// end", "if", "(", "step", "!=", "0", ")", "{", "progressListener", ".", "transferred", "(", "count", ")", ";", "}", "}"], "docstring": "Writes content to the output stream, using progress listener to track the sending progress.", "docstring_tokens": ["Writes", "content", "to", "the", "output", "stream", "using", "progress", "listener", "to", "track", "the", "sending", "progress", "."]}
{"code": "int step = 0;", "comments": "step is offset in current chunk", "lines": 8, "repo": "oblac/jodd", "path": "jodd-http/src/main/java/jodd/http/Buffer.java", "func_name": "Buffer.writeTo", "original_string": "public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException {\n\n\t\t// start\n\n\t\tfinal int size = size();\n\t\tfinal int callbackSize = progressListener.callbackSize(size);\n\t\tint count = 0;\t\t// total count\n\t\tint step = 0;\t\t// step is offset in current chunk\n\n\t\tprogressListener.transferred(count);\n\n\t\t// loop\n\n\t\tfor (Object o : list) {\n\t\t\tif (o instanceof FastByteBuffer) {\n\t\t\t\tFastByteBuffer fastByteBuffer = (FastByteBuffer) o;\n\t\t\t\tbyte[] bytes = fastByteBuffer.toArray();\n\n\t\t\t\tint offset = 0;\n\n\t\t\t\twhile (offset < bytes.length) {\n\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t// check if this chunk size fits the bytes array\n\t\t\t\t\tif (offset + chunk > bytes.length) {\n\t\t\t\t\t\tchunk = bytes.length - offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// writes the chunk\n\t\t\t\t\tout.write(bytes, offset, chunk);\n\n\t\t\t\t\toffset += chunk;\n\t\t\t\t\tstep += chunk;\n\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t// listener\n\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (o instanceof Uploadable) {\n\t\t\t\tUploadable uploadable = (Uploadable) o;\n\n\t\t\t\tInputStream inputStream = uploadable.openInputStream();\n\n\t\t\t\tint remaining = uploadable.getSize();\n\n\t\t\t\ttry {\n\t\t\t\t\twhile (remaining > 0) {\n\t\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t\t// check if this chunk size fits the remaining size\n\t\t\t\t\t\tif (chunk > remaining) {\n\t\t\t\t\t\t\tchunk = remaining;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// writes remaining chunk\n\t\t\t\t\t\tStreamUtil.copy(inputStream, out, chunk);\n\n\t\t\t\t\t\tremaining -= chunk;\n\t\t\t\t\t\tstep += chunk;\n\t\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t\t// listener\n\t\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// end\n\n\t\tif (step != 0) {\n\t\t\tprogressListener.transferred(count);\n\t\t}\n\t}", "language": "java", "Allcodes": "public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException {\n\n\t\t// start\n\n\t\tfinal int size = size();\n\t\tfinal int callbackSize = progressListener.callbackSize(size);\n\t\tint count = 0;\t\t// total count\n\t\tint step = 0;\t\t// step is offset in current chunk\n\n\t\tprogressListener.transferred(count);\n\n\t\t// loop\n\n\t\tfor (Object o : list) {\n\t\t\tif (o instanceof FastByteBuffer) {\n\t\t\t\tFastByteBuffer fastByteBuffer = (FastByteBuffer) o;\n\t\t\t\tbyte[] bytes = fastByteBuffer.toArray();\n\n\t\t\t\tint offset = 0;\n\n\t\t\t\twhile (offset < bytes.length) {\n\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t// check if this chunk size fits the bytes array\n\t\t\t\t\tif (offset + chunk > bytes.length) {\n\t\t\t\t\t\tchunk = bytes.length - offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// writes the chunk\n\t\t\t\t\tout.write(bytes, offset, chunk);\n\n\t\t\t\t\toffset += chunk;\n\t\t\t\t\tstep += chunk;\n\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t// listener\n\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (o instanceof Uploadable) {\n\t\t\t\tUploadable uploadable = (Uploadable) o;\n\n\t\t\t\tInputStream inputStream = uploadable.openInputStream();\n\n\t\t\t\tint remaining = uploadable.getSize();\n\n\t\t\t\ttry {\n\t\t\t\t\twhile (remaining > 0) {\n\t\t\t\t\t\t// calc the remaining sending chunk size\n\t\t\t\t\t\tint chunk = callbackSize - step;\n\n\t\t\t\t\t\t// check if this chunk size fits the remaining size\n\t\t\t\t\t\tif (chunk > remaining) {\n\t\t\t\t\t\t\tchunk = remaining;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// writes remaining chunk\n\t\t\t\t\t\tStreamUtil.copy(inputStream, out, chunk);\n\n\t\t\t\t\t\tremaining -= chunk;\n\t\t\t\t\t\tstep += chunk;\n\t\t\t\t\t\tcount += chunk;\n\n\t\t\t\t\t\t// listener\n\t\t\t\t\t\tif (step >= callbackSize) {\n\t\t\t\t\t\t\tprogressListener.transferred(count);\n\t\t\t\t\t\t\tstep -= callbackSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// end\n\n\t\tif (step != 0) {\n\t\t\tprogressListener.transferred(count);\n\t\t}\n\t}", "code_tokens": ["public", "void", "writeTo", "(", "final", "OutputStream", "out", ",", "final", "HttpProgressListener", "progressListener", ")", "throws", "IOException", "{", "// start", "final", "int", "size", "=", "size", "(", ")", ";", "final", "int", "callbackSize", "=", "progressListener", ".", "callbackSize", "(", "size", ")", ";", "int", "count", "=", "0", ";", "// total count", "int", "step", "=", "0", ";", "// step is offset in current chunk", "progressListener", ".", "transferred", "(", "count", ")", ";", "// loop", "for", "(", "Object", "o", ":", "list", ")", "{", "if", "(", "o", "instanceof", "FastByteBuffer", ")", "{", "FastByteBuffer", "fastByteBuffer", "=", "(", "FastByteBuffer", ")", "o", ";", "byte", "[", "]", "bytes", "=", "fastByteBuffer", ".", "toArray", "(", ")", ";", "int", "offset", "=", "0", ";", "while", "(", "offset", "<", "bytes", ".", "length", ")", "{", "// calc the remaining sending chunk size", "int", "chunk", "=", "callbackSize", "-", "step", ";", "// check if this chunk size fits the bytes array", "if", "(", "offset", "+", "chunk", ">", "bytes", ".", "length", ")", "{", "chunk", "=", "bytes", ".", "length", "-", "offset", ";", "}", "// writes the chunk", "out", ".", "write", "(", "bytes", ",", "offset", ",", "chunk", ")", ";", "offset", "+=", "chunk", ";", "step", "+=", "chunk", ";", "count", "+=", "chunk", ";", "// listener", "if", "(", "step", ">=", "callbackSize", ")", "{", "progressListener", ".", "transferred", "(", "count", ")", ";", "step", "-=", "callbackSize", ";", "}", "}", "}", "else", "if", "(", "o", "instanceof", "Uploadable", ")", "{", "Uploadable", "uploadable", "=", "(", "Uploadable", ")", "o", ";", "InputStream", "inputStream", "=", "uploadable", ".", "openInputStream", "(", ")", ";", "int", "remaining", "=", "uploadable", ".", "getSize", "(", ")", ";", "try", "{", "while", "(", "remaining", ">", "0", ")", "{", "// calc the remaining sending chunk size", "int", "chunk", "=", "callbackSize", "-", "step", ";", "// check if this chunk size fits the remaining size", "if", "(", "chunk", ">", "remaining", ")", "{", "chunk", "=", "remaining", ";", "}", "// writes remaining chunk", "StreamUtil", ".", "copy", "(", "inputStream", ",", "out", ",", "chunk", ")", ";", "remaining", "-=", "chunk", ";", "step", "+=", "chunk", ";", "count", "+=", "chunk", ";", "// listener", "if", "(", "step", ">=", "callbackSize", ")", "{", "progressListener", ".", "transferred", "(", "count", ")", ";", "step", "-=", "callbackSize", ";", "}", "}", "}", "finally", "{", "StreamUtil", ".", "close", "(", "inputStream", ")", ";", "}", "}", "}", "// end", "if", "(", "step", "!=", "0", ")", "{", "progressListener", ".", "transferred", "(", "count", ")", ";", "}", "}"], "docstring": "Writes content to the output stream, using progress listener to track the sending progress.", "docstring_tokens": ["Writes", "content", "to", "the", "output", "stream", "using", "progress", "listener", "to", "track", "the", "sending", "progress", "."]}
{"code": "vd = new long[nw];", "comments": "v is the intermediate value v{d} at round d", "lines": 31, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/Threefish.java", "func_name": "Threefish.init", "original_string": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "language": "java", "Allcodes": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "code_tokens": ["public", "void", "init", "(", "final", "long", "[", "]", "key", ",", "final", "long", "[", "]", "tweak", ")", "{", "final", "int", "newNw", "=", "key", ".", "length", ";", "// only create new arrays if the value of N{w} changes (different key size)", "if", "(", "nw", "!=", "newNw", ")", "{", "nw", "=", "newNw", ";", "switch", "(", "nw", ")", "{", "case", "WORDS_4", ":", "pi", "=", "PI4", ";", "rpi", "=", "RPI4", ";", "r", "=", "R4", ";", "break", ";", "case", "WORDS_8", ":", "pi", "=", "PI8", ";", "rpi", "=", "RPI8", ";", "r", "=", "R8", ";", "break", ";", "case", "WORDS_16", ":", "pi", "=", "PI16", ";", "rpi", "=", "RPI16", ";", "r", "=", "R16", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"Invalid threefish key\"", ")", ";", "}", "this", ".", "k", "=", "new", "long", "[", "nw", "+", "1", "]", ";", "// instantiation of these fields here for performance reasons", "vd", "=", "new", "long", "[", "nw", "]", ";", "// v is the intermediate value v{d} at round d", "ed", "=", "new", "long", "[", "nw", "]", ";", "// ed is the value of e{d} at round d", "fd", "=", "new", "long", "[", "nw", "]", ";", "// fd is the value of f{d} at round d", "ksd", "=", "new", "long", "[", "nw", "]", ";", "// ksd is the value of k{s} at round d", "}", "System", ".", "arraycopy", "(", "key", ",", "0", ",", "this", ".", "k", ",", "0", ",", "key", ".", "length", ")", ";", "long", "knw", "=", "EXTENDED_KEY_SCHEDULE_CONST", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nw", ";", "i", "++", ")", "{", "knw", "^=", "this", ".", "k", "[", "i", "]", ";", "}", "this", ".", "k", "[", "nw", "]", "=", "knw", ";", "// set tweak values", "t", "[", "0", "]", "=", "tweak", "[", "0", "]", ";", "t", "[", "1", "]", "=", "tweak", "[", "1", "]", ";", "t", "[", "2", "]", "=", "t", "[", "0", "]", "^", "t", "[", "1", "]", ";", "}"], "docstring": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "docstring_tokens": ["Initialize", "the", "cipher", "using", "the", "key", "and", "the", "tweak", "value", "."]}
{"code": "ed = new long[nw];", "comments": "ed is the value of e{d} at round d", "lines": 32, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/Threefish.java", "func_name": "Threefish.init", "original_string": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "language": "java", "Allcodes": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "code_tokens": ["public", "void", "init", "(", "final", "long", "[", "]", "key", ",", "final", "long", "[", "]", "tweak", ")", "{", "final", "int", "newNw", "=", "key", ".", "length", ";", "// only create new arrays if the value of N{w} changes (different key size)", "if", "(", "nw", "!=", "newNw", ")", "{", "nw", "=", "newNw", ";", "switch", "(", "nw", ")", "{", "case", "WORDS_4", ":", "pi", "=", "PI4", ";", "rpi", "=", "RPI4", ";", "r", "=", "R4", ";", "break", ";", "case", "WORDS_8", ":", "pi", "=", "PI8", ";", "rpi", "=", "RPI8", ";", "r", "=", "R8", ";", "break", ";", "case", "WORDS_16", ":", "pi", "=", "PI16", ";", "rpi", "=", "RPI16", ";", "r", "=", "R16", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"Invalid threefish key\"", ")", ";", "}", "this", ".", "k", "=", "new", "long", "[", "nw", "+", "1", "]", ";", "// instantiation of these fields here for performance reasons", "vd", "=", "new", "long", "[", "nw", "]", ";", "// v is the intermediate value v{d} at round d", "ed", "=", "new", "long", "[", "nw", "]", ";", "// ed is the value of e{d} at round d", "fd", "=", "new", "long", "[", "nw", "]", ";", "// fd is the value of f{d} at round d", "ksd", "=", "new", "long", "[", "nw", "]", ";", "// ksd is the value of k{s} at round d", "}", "System", ".", "arraycopy", "(", "key", ",", "0", ",", "this", ".", "k", ",", "0", ",", "key", ".", "length", ")", ";", "long", "knw", "=", "EXTENDED_KEY_SCHEDULE_CONST", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nw", ";", "i", "++", ")", "{", "knw", "^=", "this", ".", "k", "[", "i", "]", ";", "}", "this", ".", "k", "[", "nw", "]", "=", "knw", ";", "// set tweak values", "t", "[", "0", "]", "=", "tweak", "[", "0", "]", ";", "t", "[", "1", "]", "=", "tweak", "[", "1", "]", ";", "t", "[", "2", "]", "=", "t", "[", "0", "]", "^", "t", "[", "1", "]", ";", "}"], "docstring": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "docstring_tokens": ["Initialize", "the", "cipher", "using", "the", "key", "and", "the", "tweak", "value", "."]}
{"code": "fd = new long[nw];", "comments": "fd is the value of f{d} at round d", "lines": 33, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/Threefish.java", "func_name": "Threefish.init", "original_string": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "language": "java", "Allcodes": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "code_tokens": ["public", "void", "init", "(", "final", "long", "[", "]", "key", ",", "final", "long", "[", "]", "tweak", ")", "{", "final", "int", "newNw", "=", "key", ".", "length", ";", "// only create new arrays if the value of N{w} changes (different key size)", "if", "(", "nw", "!=", "newNw", ")", "{", "nw", "=", "newNw", ";", "switch", "(", "nw", ")", "{", "case", "WORDS_4", ":", "pi", "=", "PI4", ";", "rpi", "=", "RPI4", ";", "r", "=", "R4", ";", "break", ";", "case", "WORDS_8", ":", "pi", "=", "PI8", ";", "rpi", "=", "RPI8", ";", "r", "=", "R8", ";", "break", ";", "case", "WORDS_16", ":", "pi", "=", "PI16", ";", "rpi", "=", "RPI16", ";", "r", "=", "R16", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"Invalid threefish key\"", ")", ";", "}", "this", ".", "k", "=", "new", "long", "[", "nw", "+", "1", "]", ";", "// instantiation of these fields here for performance reasons", "vd", "=", "new", "long", "[", "nw", "]", ";", "// v is the intermediate value v{d} at round d", "ed", "=", "new", "long", "[", "nw", "]", ";", "// ed is the value of e{d} at round d", "fd", "=", "new", "long", "[", "nw", "]", ";", "// fd is the value of f{d} at round d", "ksd", "=", "new", "long", "[", "nw", "]", ";", "// ksd is the value of k{s} at round d", "}", "System", ".", "arraycopy", "(", "key", ",", "0", ",", "this", ".", "k", ",", "0", ",", "key", ".", "length", ")", ";", "long", "knw", "=", "EXTENDED_KEY_SCHEDULE_CONST", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nw", ";", "i", "++", ")", "{", "knw", "^=", "this", ".", "k", "[", "i", "]", ";", "}", "this", ".", "k", "[", "nw", "]", "=", "knw", ";", "// set tweak values", "t", "[", "0", "]", "=", "tweak", "[", "0", "]", ";", "t", "[", "1", "]", "=", "tweak", "[", "1", "]", ";", "t", "[", "2", "]", "=", "t", "[", "0", "]", "^", "t", "[", "1", "]", ";", "}"], "docstring": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "docstring_tokens": ["Initialize", "the", "cipher", "using", "the", "key", "and", "the", "tweak", "value", "."]}
{"code": "ksd = new long[nw];", "comments": "ksd is the value of k{s} at round d", "lines": 34, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/Threefish.java", "func_name": "Threefish.init", "original_string": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "language": "java", "Allcodes": "public void init(final long[] key, final long[] tweak) {\n\t\tfinal int newNw = key.length;\n\n\t\t// only create new arrays if the value of N{w} changes (different key size)\n\t\tif (nw != newNw) {\n\t\t\tnw = newNw;\n\n\t\t\tswitch (nw) {\n\t\t\t\tcase WORDS_4:\n\t\t\t\t\tpi = PI4;\n\t\t\t\t\trpi = RPI4;\n\t\t\t\t\tr = R4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_8:\n\t\t\t\t\tpi = PI8;\n\t\t\t\t\trpi = RPI8;\n\t\t\t\t\tr = R8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WORDS_16:\n\t\t\t\t\tpi = PI16;\n\t\t\t\t\trpi = RPI16;\n\t\t\t\t\tr = R16;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Invalid threefish key\");\n\t\t\t}\n\n\t\t\tthis.k = new long[nw + 1];\n\n\t\t\t// instantiation of these fields here for performance reasons\n\t\t\tvd = new long[nw]; // v is the intermediate value v{d} at round d\n\t\t\ted = new long[nw]; // ed is the value of e{d} at round d\n\t\t\tfd = new long[nw]; // fd is the value of f{d} at round d\n\t\t\tksd = new long[nw]; // ksd is the value of k{s} at round d\n\t\t}\n\n\t\tSystem.arraycopy(key, 0, this.k, 0, key.length);\n\n\t\tlong knw = EXTENDED_KEY_SCHEDULE_CONST;\n\t\tfor (int i = 0; i < nw; i++) {\n\t\t\tknw ^= this.k[i];\n\t\t}\n\t\tthis.k[nw] = knw;\n\n\t\t// set tweak values\n\t\tt[0] = tweak[0];\n\t\tt[1] = tweak[1];\n\t\tt[2] = t[0] ^ t[1];\n\t}", "code_tokens": ["public", "void", "init", "(", "final", "long", "[", "]", "key", ",", "final", "long", "[", "]", "tweak", ")", "{", "final", "int", "newNw", "=", "key", ".", "length", ";", "// only create new arrays if the value of N{w} changes (different key size)", "if", "(", "nw", "!=", "newNw", ")", "{", "nw", "=", "newNw", ";", "switch", "(", "nw", ")", "{", "case", "WORDS_4", ":", "pi", "=", "PI4", ";", "rpi", "=", "RPI4", ";", "r", "=", "R4", ";", "break", ";", "case", "WORDS_8", ":", "pi", "=", "PI8", ";", "rpi", "=", "RPI8", ";", "r", "=", "R8", ";", "break", ";", "case", "WORDS_16", ":", "pi", "=", "PI16", ";", "rpi", "=", "RPI16", ";", "r", "=", "R16", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"Invalid threefish key\"", ")", ";", "}", "this", ".", "k", "=", "new", "long", "[", "nw", "+", "1", "]", ";", "// instantiation of these fields here for performance reasons", "vd", "=", "new", "long", "[", "nw", "]", ";", "// v is the intermediate value v{d} at round d", "ed", "=", "new", "long", "[", "nw", "]", ";", "// ed is the value of e{d} at round d", "fd", "=", "new", "long", "[", "nw", "]", ";", "// fd is the value of f{d} at round d", "ksd", "=", "new", "long", "[", "nw", "]", ";", "// ksd is the value of k{s} at round d", "}", "System", ".", "arraycopy", "(", "key", ",", "0", ",", "this", ".", "k", ",", "0", ",", "key", ".", "length", ")", ";", "long", "knw", "=", "EXTENDED_KEY_SCHEDULE_CONST", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nw", ";", "i", "++", ")", "{", "knw", "^=", "this", ".", "k", "[", "i", "]", ";", "}", "this", ".", "k", "[", "nw", "]", "=", "knw", ";", "// set tweak values", "t", "[", "0", "]", "=", "tweak", "[", "0", "]", ";", "t", "[", "1", "]", "=", "tweak", "[", "1", "]", ";", "t", "[", "2", "]", "=", "t", "[", "0", "]", "^", "t", "[", "1", "]", ";", "}"], "docstring": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "docstring_tokens": ["Initialize", "the", "cipher", "using", "the", "key", "and", "the", "tweak", "value", "."]}
{"code": "final long rotr = r[d % DEPTH_OF_D_IN_R][j];", "comments": "NOTE performance: darn, creation on stack!", "lines": 3, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/Threefish.java", "func_name": "Threefish.demix", "original_string": "private void demix(final int j, final int d) {\n\t\ty[1] ^= y[0];\n\t\tfinal long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack!\n\t\t// right shift\n\t\tx[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr);\n\t\tx[0] = y[0] - x[1];\n\t}", "language": "java", "Allcodes": "private void demix(final int j, final int d) {\n\t\ty[1] ^= y[0];\n\t\tfinal long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack!\n\t\t// right shift\n\t\tx[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr);\n\t\tx[0] = y[0] - x[1];\n\t}", "code_tokens": ["private", "void", "demix", "(", "final", "int", "j", ",", "final", "int", "d", ")", "{", "y", "[", "1", "]", "^=", "y", "[", "0", "]", ";", "final", "long", "rotr", "=", "r", "[", "d", "%", "DEPTH_OF_D_IN_R", "]", "[", "j", "]", ";", "// NOTE performance: darn, creation on stack!", "// right shift", "x", "[", "1", "]", "=", "(", "y", "[", "1", "]", "<<", "(", "Long", ".", "SIZE", "-", "rotr", ")", ")", "|", "(", "y", "[", "1", "]", ">>>", "rotr", ")", ";", "x", "[", "0", "]", "=", "y", "[", "0", "]", "-", "x", "[", "1", "]", ";", "}"], "docstring": "Implementation of the un-MIX function.", "docstring_tokens": ["Implementation", "of", "the", "un", "-", "MIX", "function", "."]}
{"code": "| ((buf[offset] & 0xffL));", "comments": "no shift needed", "lines": 9, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/MurmurHash3.java", "func_name": "MurmurHash3.getLongLittleEndian", "original_string": "public static long getLongLittleEndian(final byte[] buf, final int offset) {\n\t\treturn ((long) buf[offset + 7] << 56)   // no mask needed\n\t\t\t| ((buf[offset + 6] & 0xffL) << 48)\n\t\t\t| ((buf[offset + 5] & 0xffL) << 40)\n\t\t\t| ((buf[offset + 4] & 0xffL) << 32)\n\t\t\t| ((buf[offset + 3] & 0xffL) << 24)\n\t\t\t| ((buf[offset + 2] & 0xffL) << 16)\n\t\t\t| ((buf[offset + 1] & 0xffL) << 8)\n\t\t\t| ((buf[offset] & 0xffL));        // no shift needed\n\t}", "language": "java", "Allcodes": "public static long getLongLittleEndian(final byte[] buf, final int offset) {\n\t\treturn ((long) buf[offset + 7] << 56)   // no mask needed\n\t\t\t| ((buf[offset + 6] & 0xffL) << 48)\n\t\t\t| ((buf[offset + 5] & 0xffL) << 40)\n\t\t\t| ((buf[offset + 4] & 0xffL) << 32)\n\t\t\t| ((buf[offset + 3] & 0xffL) << 24)\n\t\t\t| ((buf[offset + 2] & 0xffL) << 16)\n\t\t\t| ((buf[offset + 1] & 0xffL) << 8)\n\t\t\t| ((buf[offset] & 0xffL));        // no shift needed\n\t}", "code_tokens": ["public", "static", "long", "getLongLittleEndian", "(", "final", "byte", "[", "]", "buf", ",", "final", "int", "offset", ")", "{", "return", "(", "(", "long", ")", "buf", "[", "offset", "+", "7", "]", "<<", "56", ")", "// no mask needed", "|", "(", "(", "buf", "[", "offset", "+", "6", "]", "&", "0xff", "L", ")", "<<", "48", ")", "|", "(", "(", "buf", "[", "offset", "+", "5", "]", "&", "0xff", "L", ")", "<<", "40", ")", "|", "(", "(", "buf", "[", "offset", "+", "4", "]", "&", "0xff", "L", ")", "<<", "32", ")", "|", "(", "(", "buf", "[", "offset", "+", "3", "]", "&", "0xff", "L", ")", "<<", "24", ")", "|", "(", "(", "buf", "[", "offset", "+", "2", "]", "&", "0xff", "L", ")", "<<", "16", ")", "|", "(", "(", "buf", "[", "offset", "+", "1", "]", "&", "0xff", "L", ")", "<<", "8", ")", "|", "(", "(", "buf", "[", "offset", "]", "&", "0xff", "L", ")", ")", ";", "// no shift needed", "}"], "docstring": "Gets a long from a byte buffer in little endian byte order.", "docstring_tokens": ["Gets", "a", "long", "from", "a", "byte", "buffer", "in", "little", "endian", "byte", "order", "."]}
{"code": "AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible);", "comments": "[A3]", "lines": 3, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaClassBuilder.java", "func_name": "ProxettaClassBuilder.visitAnnotation", "original_string": "@Override\n\tpublic AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n\t\tAnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3]\n\t\treturn new AnnotationVisitorAdapter(destAnn);\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\n\t\tAnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3]\n\t\treturn new AnnotationVisitorAdapter(destAnn);\n\t}", "code_tokens": ["@", "Override", "public", "AnnotationVisitor", "visitAnnotation", "(", "final", "String", "desc", ",", "final", "boolean", "visible", ")", "{", "AnnotationVisitor", "destAnn", "=", "wd", ".", "dest", ".", "visitAnnotation", "(", "desc", ",", "visible", ")", ";", "// [A3]", "return", "new", "AnnotationVisitorAdapter", "(", "destAnn", ")", ";", "}"], "docstring": "Copies all destination type annotations to the target.", "docstring_tokens": ["Copies", "all", "destination", "type", "annotations", "to", "the", "target", "."]}
{"code": "txList.add(tx);", "comments": "add last", "lines": 8, "repo": "oblac/jodd", "path": "jodd-jtx/src/main/java/jodd/jtx/JtxTransactionManager.java", "func_name": "JtxTransactionManager.associateTransaction", "original_string": "protected void associateTransaction(final JtxTransaction tx) {\n\t\ttotalTransactions++;\n\t\tArrayList<JtxTransaction> txList = txStack.get();\n\t\tif (txList == null) {\n\t\t\ttxList = new ArrayList<>();\n\t\t\ttxStack.set(txList);\n\t\t}\n\t\ttxList.add(tx);\t// add last\n\t}", "language": "java", "Allcodes": "protected void associateTransaction(final JtxTransaction tx) {\n\t\ttotalTransactions++;\n\t\tArrayList<JtxTransaction> txList = txStack.get();\n\t\tif (txList == null) {\n\t\t\ttxList = new ArrayList<>();\n\t\t\ttxStack.set(txList);\n\t\t}\n\t\ttxList.add(tx);\t// add last\n\t}", "code_tokens": ["protected", "void", "associateTransaction", "(", "final", "JtxTransaction", "tx", ")", "{", "totalTransactions", "++", ";", "ArrayList", "<", "JtxTransaction", ">", "txList", "=", "txStack", ".", "get", "(", ")", ";", "if", "(", "txList", "==", "null", ")", "{", "txList", "=", "new", "ArrayList", "<>", "(", ")", ";", "txStack", ".", "set", "(", "txList", ")", ";", "}", "txList", ".", "add", "(", "tx", ")", ";", "// add last", "}"], "docstring": "Associate transaction to current thread.", "docstring_tokens": ["Associate", "transaction", "to", "current", "thread", "."]}
{"code": "return string;", "comments": "no changes", "lines": 18, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/util/StringUtil.java", "func_name": "StringUtil.remove", "original_string": "public static String remove(final String string, final char ch) {\n\t\tint stringLen = string.length();\n\t\tchar[] result = new char[stringLen];\n\t\tint offset = 0;\n\n\t\tfor (int i = 0; i < stringLen; i++) {\n\t\t\tchar c = string.charAt(i);\n\n\t\t\tif (c == ch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult[offset] = c;\n\t\t\toffset++;\n\t\t}\n\n\t\tif (offset == stringLen) {\n\t\t\treturn string;\t// no changes\n\t\t}\n\n\t\treturn new String(result, 0, offset);\n\t}", "language": "java", "Allcodes": "public static String remove(final String string, final char ch) {\n\t\tint stringLen = string.length();\n\t\tchar[] result = new char[stringLen];\n\t\tint offset = 0;\n\n\t\tfor (int i = 0; i < stringLen; i++) {\n\t\t\tchar c = string.charAt(i);\n\n\t\t\tif (c == ch) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult[offset] = c;\n\t\t\toffset++;\n\t\t}\n\n\t\tif (offset == stringLen) {\n\t\t\treturn string;\t// no changes\n\t\t}\n\n\t\treturn new String(result, 0, offset);\n\t}", "code_tokens": ["public", "static", "String", "remove", "(", "final", "String", "string", ",", "final", "char", "ch", ")", "{", "int", "stringLen", "=", "string", ".", "length", "(", ")", ";", "char", "[", "]", "result", "=", "new", "char", "[", "stringLen", "]", ";", "int", "offset", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "stringLen", ";", "i", "++", ")", "{", "char", "c", "=", "string", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "ch", ")", "{", "continue", ";", "}", "result", "[", "offset", "]", "=", "c", ";", "offset", "++", ";", "}", "if", "(", "offset", "==", "stringLen", ")", "{", "return", "string", ";", "// no changes", "}", "return", "new", "String", "(", "result", ",", "0", ",", "offset", ")", ";", "}"], "docstring": "Removes a single character from string.\n\n@param string    source string\n@param ch  character to remove", "docstring_tokens": ["Removes", "a", "single", "character", "from", "string", "."]}
{"code": "session.invalidate();", "comments": "clear session if session id in URL", "lines": 12, "repo": "oblac/jodd", "path": "jodd-servlet/src/main/java/jodd/servlet/filter/RemoveSessionFromUrlFilter.java", "func_name": "RemoveSessionFromUrlFilter.doFilter", "original_string": "@Override\n\tpublic void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tHttpServletResponse httpResponse = (HttpServletResponse) response;\n\n\t\tif (isRequestedSessionIdFromURL(httpRequest)) {\n\t\t\tHttpSession session = httpRequest.getSession(false);\n\n\t\t\tif (session != null) {\n\t\t\t\tsession.invalidate();\t\t// clear session if session id in URL\n\t\t\t}\n\t\t}\n\n\t\t// wrap response to remove URL encoding\n\t\tHttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) {\n\t\t\t@Override\n\t\t\tpublic String encodeRedirectUrl(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String encodeRedirectURL(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String encodeUrl(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String encodeURL(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\t\t};\n\n\t\tchain.doFilter(request, wrappedResponse);\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tHttpServletResponse httpResponse = (HttpServletResponse) response;\n\n\t\tif (isRequestedSessionIdFromURL(httpRequest)) {\n\t\t\tHttpSession session = httpRequest.getSession(false);\n\n\t\t\tif (session != null) {\n\t\t\t\tsession.invalidate();\t\t// clear session if session id in URL\n\t\t\t}\n\t\t}\n\n\t\t// wrap response to remove URL encoding\n\t\tHttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) {\n\t\t\t@Override\n\t\t\tpublic String encodeRedirectUrl(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String encodeRedirectURL(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String encodeUrl(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String encodeURL(final String url) {\n\t\t\t\treturn url;\n\t\t\t}\n\t\t};\n\n\t\tchain.doFilter(request, wrappedResponse);\n\t}", "code_tokens": ["@", "Override", "public", "void", "doFilter", "(", "final", "ServletRequest", "request", ",", "final", "ServletResponse", "response", ",", "final", "FilterChain", "chain", ")", "throws", "IOException", ",", "ServletException", "{", "HttpServletRequest", "httpRequest", "=", "(", "HttpServletRequest", ")", "request", ";", "HttpServletResponse", "httpResponse", "=", "(", "HttpServletResponse", ")", "response", ";", "if", "(", "isRequestedSessionIdFromURL", "(", "httpRequest", ")", ")", "{", "HttpSession", "session", "=", "httpRequest", ".", "getSession", "(", "false", ")", ";", "if", "(", "session", "!=", "null", ")", "{", "session", ".", "invalidate", "(", ")", ";", "// clear session if session id in URL", "}", "}", "// wrap response to remove URL encoding", "HttpServletResponseWrapper", "wrappedResponse", "=", "new", "HttpServletResponseWrapper", "(", "httpResponse", ")", "{", "@", "Override", "public", "String", "encodeRedirectUrl", "(", "final", "String", "url", ")", "{", "return", "url", ";", "}", "@", "Override", "public", "String", "encodeRedirectURL", "(", "final", "String", "url", ")", "{", "return", "url", ";", "}", "@", "Override", "public", "String", "encodeUrl", "(", "final", "String", "url", ")", "{", "return", "url", ";", "}", "@", "Override", "public", "String", "encodeURL", "(", "final", "String", "url", ")", "{", "return", "url", ";", "}", "}", ";", "chain", ".", "doFilter", "(", "request", ",", "wrappedResponse", ")", ";", "}"], "docstring": "Filters requests to remove URL-based session identifiers.", "docstring_tokens": ["Filters", "requests", "to", "remove", "URL", "-", "based", "session", "identifiers", "."]}
{"code": "sql = sql.substring(ndx + 6);", "comments": "select.length()", "lines": 4, "repo": "oblac/jodd", "path": "jodd-joy/src/main/java/jodd/joy/page/DbPager.java", "func_name": "DbPager.removeSelect", "original_string": "protected String removeSelect(String sql) {\n\t\tint ndx = StringUtil.indexOfIgnoreCase(sql, \"select\");\n\t\tif (ndx != -1) {\n\t\t\tsql = sql.substring(ndx + 6);\t// select.length()\n\t\t}\n\t\treturn sql;\n\t}", "language": "java", "Allcodes": "protected String removeSelect(String sql) {\n\t\tint ndx = StringUtil.indexOfIgnoreCase(sql, \"select\");\n\t\tif (ndx != -1) {\n\t\t\tsql = sql.substring(ndx + 6);\t// select.length()\n\t\t}\n\t\treturn sql;\n\t}", "code_tokens": ["protected", "String", "removeSelect", "(", "String", "sql", ")", "{", "int", "ndx", "=", "StringUtil", ".", "indexOfIgnoreCase", "(", "sql", ",", "\"select\"", ")", ";", "if", "(", "ndx", "!=", "-", "1", ")", "{", "sql", "=", "sql", ".", "substring", "(", "ndx", "+", "6", ")", ";", "// select.length()", "}", "return", "sql", ";", "}"], "docstring": "Removes the first 'select' from the sql query.", "docstring_tokens": ["Removes", "the", "first", "select", "from", "the", "sql", "query", "."]}
{"code": "return false;", "comments": "ignore non-files", "lines": 3, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/io/watch/DirWatcher.java", "func_name": "DirWatcher.acceptFile", "original_string": "protected boolean acceptFile(final File file) {\n\t\tif (!file.isFile()) {\n\t\t\treturn false;\t\t\t// ignore non-files\n\t\t}\n\n\t\tString fileName = file.getName();\n\n\t\tif (ignoreDotFiles) {\n\t\t\tif (fileName.startsWith(StringPool.DOT)) {\n\t\t\t\treturn false;        // ignore hidden files\n\t\t\t}\n\t\t}\n\n\t\tif (patterns == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn Wildcard.matchOne(fileName, patterns) != -1;\n\t}", "language": "java", "Allcodes": "protected boolean acceptFile(final File file) {\n\t\tif (!file.isFile()) {\n\t\t\treturn false;\t\t\t// ignore non-files\n\t\t}\n\n\t\tString fileName = file.getName();\n\n\t\tif (ignoreDotFiles) {\n\t\t\tif (fileName.startsWith(StringPool.DOT)) {\n\t\t\t\treturn false;        // ignore hidden files\n\t\t\t}\n\t\t}\n\n\t\tif (patterns == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn Wildcard.matchOne(fileName, patterns) != -1;\n\t}", "code_tokens": ["protected", "boolean", "acceptFile", "(", "final", "File", "file", ")", "{", "if", "(", "!", "file", ".", "isFile", "(", ")", ")", "{", "return", "false", ";", "// ignore non-files", "}", "String", "fileName", "=", "file", ".", "getName", "(", ")", ";", "if", "(", "ignoreDotFiles", ")", "{", "if", "(", "fileName", ".", "startsWith", "(", "StringPool", ".", "DOT", ")", ")", "{", "return", "false", ";", "// ignore hidden files", "}", "}", "if", "(", "patterns", "==", "null", ")", "{", "return", "true", ";", "}", "return", "Wildcard", ".", "matchOne", "(", "fileName", ",", "patterns", ")", "!=", "-", "1", ";", "}"], "docstring": "Accepts if a file is going to be watched.", "docstring_tokens": ["Accepts", "if", "a", "file", "is", "going", "to", "be", "watched", "."]}
{"code": "return false;", "comments": "ignore hidden files", "lines": 10, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/io/watch/DirWatcher.java", "func_name": "DirWatcher.acceptFile", "original_string": "protected boolean acceptFile(final File file) {\n\t\tif (!file.isFile()) {\n\t\t\treturn false;\t\t\t// ignore non-files\n\t\t}\n\n\t\tString fileName = file.getName();\n\n\t\tif (ignoreDotFiles) {\n\t\t\tif (fileName.startsWith(StringPool.DOT)) {\n\t\t\t\treturn false;        // ignore hidden files\n\t\t\t}\n\t\t}\n\n\t\tif (patterns == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn Wildcard.matchOne(fileName, patterns) != -1;\n\t}", "language": "java", "Allcodes": "protected boolean acceptFile(final File file) {\n\t\tif (!file.isFile()) {\n\t\t\treturn false;\t\t\t// ignore non-files\n\t\t}\n\n\t\tString fileName = file.getName();\n\n\t\tif (ignoreDotFiles) {\n\t\t\tif (fileName.startsWith(StringPool.DOT)) {\n\t\t\t\treturn false;        // ignore hidden files\n\t\t\t}\n\t\t}\n\n\t\tif (patterns == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn Wildcard.matchOne(fileName, patterns) != -1;\n\t}", "code_tokens": ["protected", "boolean", "acceptFile", "(", "final", "File", "file", ")", "{", "if", "(", "!", "file", ".", "isFile", "(", ")", ")", "{", "return", "false", ";", "// ignore non-files", "}", "String", "fileName", "=", "file", ".", "getName", "(", ")", ";", "if", "(", "ignoreDotFiles", ")", "{", "if", "(", "fileName", ".", "startsWith", "(", "StringPool", ".", "DOT", ")", ")", "{", "return", "false", ";", "// ignore hidden files", "}", "}", "if", "(", "patterns", "==", "null", ")", "{", "return", "true", ";", "}", "return", "Wildcard", ".", "matchOne", "(", "fileName", ",", "patterns", ")", "!=", "-", "1", ";", "}"], "docstring": "Accepts if a file is going to be watched.", "docstring_tokens": ["Accepts", "if", "a", "file", "is", "going", "to", "be", "watched", "."]}
{"code": "from.value++;", "comments": "default usage for most cases", "lines": 3, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm/AsmUtil.java", "func_name": "AsmUtil.typedescToSignature", "original_string": "public static String typedescToSignature(final String desc, final MutableInteger from) {\n\t\tint fromIndex = from.get();\n\t\tfrom.value++;\t// default usage for most cases\n\n\t\tswitch (desc.charAt(fromIndex)) {\n\t\t\tcase 'B': return \"byte\";\n\t\t\tcase 'C': return \"char\";\n\t\t\tcase 'D': return \"double\";\n\t\t\tcase 'F': return \"float\";\n\t\t\tcase 'I': return \"int\";\n\t\t\tcase 'J': return \"long\";\n\t\t\tcase 'S': return \"short\";\n\t\t\tcase 'Z': return \"boolean\";\n\t\t\tcase 'V': return \"void\";\n\n\t\t\tcase 'L':\n\t\t\t\tint index = desc.indexOf(';', fromIndex);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\tfrom.set(index + 1);\n\t\t\t\tString str = desc.substring(fromIndex + 1, index);\n\t\t\t\treturn str.replace('/', '.');\n\n\t\t\tcase 'T':\n\t\t\t\treturn desc.substring(from.value);\n\n\t\t\tcase '[':\n\t\t\t\tStringBuilder brackets = new StringBuilder();\n\t\t\t\tint n = fromIndex;\n\t\t\t\twhile (desc.charAt(n) == '[') {\t// count opening brackets\n\t\t\t\t\tbrackets.append(\"[]\");\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tfrom.value = n;\n\t\t\t\tString type = typedescToSignature(desc, from);\t// the rest of the string denotes a `<field_type>'\n\t\t\t\treturn type + brackets;\n\n\t\t\tdefault:\n\t\t\t\tif (from.value == 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\t// generics!\n\t\t\t\treturn desc.substring(from.value);\n\t\t}\n\t}", "language": "java", "Allcodes": "public static String typedescToSignature(final String desc, final MutableInteger from) {\n\t\tint fromIndex = from.get();\n\t\tfrom.value++;\t// default usage for most cases\n\n\t\tswitch (desc.charAt(fromIndex)) {\n\t\t\tcase 'B': return \"byte\";\n\t\t\tcase 'C': return \"char\";\n\t\t\tcase 'D': return \"double\";\n\t\t\tcase 'F': return \"float\";\n\t\t\tcase 'I': return \"int\";\n\t\t\tcase 'J': return \"long\";\n\t\t\tcase 'S': return \"short\";\n\t\t\tcase 'Z': return \"boolean\";\n\t\t\tcase 'V': return \"void\";\n\n\t\t\tcase 'L':\n\t\t\t\tint index = desc.indexOf(';', fromIndex);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\tfrom.set(index + 1);\n\t\t\t\tString str = desc.substring(fromIndex + 1, index);\n\t\t\t\treturn str.replace('/', '.');\n\n\t\t\tcase 'T':\n\t\t\t\treturn desc.substring(from.value);\n\n\t\t\tcase '[':\n\t\t\t\tStringBuilder brackets = new StringBuilder();\n\t\t\t\tint n = fromIndex;\n\t\t\t\twhile (desc.charAt(n) == '[') {\t// count opening brackets\n\t\t\t\t\tbrackets.append(\"[]\");\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tfrom.value = n;\n\t\t\t\tString type = typedescToSignature(desc, from);\t// the rest of the string denotes a `<field_type>'\n\t\t\t\treturn type + brackets;\n\n\t\t\tdefault:\n\t\t\t\tif (from.value == 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\t// generics!\n\t\t\t\treturn desc.substring(from.value);\n\t\t}\n\t}", "code_tokens": ["public", "static", "String", "typedescToSignature", "(", "final", "String", "desc", ",", "final", "MutableInteger", "from", ")", "{", "int", "fromIndex", "=", "from", ".", "get", "(", ")", ";", "from", ".", "value", "++", ";", "// default usage for most cases", "switch", "(", "desc", ".", "charAt", "(", "fromIndex", ")", ")", "{", "case", "'", "'", ":", "return", "\"byte\"", ";", "case", "'", "'", ":", "return", "\"char\"", ";", "case", "'", "'", ":", "return", "\"double\"", ";", "case", "'", "'", ":", "return", "\"float\"", ";", "case", "'", "'", ":", "return", "\"int\"", ";", "case", "'", "'", ":", "return", "\"long\"", ";", "case", "'", "'", ":", "return", "\"short\"", ";", "case", "'", "'", ":", "return", "\"boolean\"", ";", "case", "'", "'", ":", "return", "\"void\"", ";", "case", "'", "'", ":", "int", "index", "=", "desc", ".", "indexOf", "(", "'", "'", ",", "fromIndex", ")", ";", "if", "(", "index", "<", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "INVALID_TYPE_DESCRIPTION", "+", "desc", ")", ";", "}", "from", ".", "set", "(", "index", "+", "1", ")", ";", "String", "str", "=", "desc", ".", "substring", "(", "fromIndex", "+", "1", ",", "index", ")", ";", "return", "str", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "case", "'", "'", ":", "return", "desc", ".", "substring", "(", "from", ".", "value", ")", ";", "case", "'", "'", ":", "StringBuilder", "brackets", "=", "new", "StringBuilder", "(", ")", ";", "int", "n", "=", "fromIndex", ";", "while", "(", "desc", ".", "charAt", "(", "n", ")", "==", "'", "'", ")", "{", "// count opening brackets", "brackets", ".", "append", "(", "\"[]\"", ")", ";", "n", "++", ";", "}", "from", ".", "value", "=", "n", ";", "String", "type", "=", "typedescToSignature", "(", "desc", ",", "from", ")", ";", "// the rest of the string denotes a `<field_type>'", "return", "type", "+", "brackets", ";", "default", ":", "if", "(", "from", ".", "value", "==", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "INVALID_TYPE_DESCRIPTION", "+", "desc", ")", ";", "}", "// generics!", "return", "desc", ".", "substring", "(", "from", ".", "value", ")", ";", "}", "}"], "docstring": "Returns java-like signature of a bytecode-like description.\nOnly first description is parsed.\n\nThe field signature represents the value of an argument to a function or\nthe value of a variable. It is a series of bytes generated by the\nfollowing grammar:\n\n<PRE>{@code\n<field_signature> ::= <field_type>\n<field_type>      ::= <base_type>|<object_type>|<array_type>\n<base_type>       ::= B|C|D|F|I|J|S|Z\n<object_type>     ::= L<fullclassname>;\n<array_type>      ::= [<field_type>\n\nThe meaning of the base types is as follows:\nB byte signed byte\nC char character\nD double double precision IEEE float\nF float single precision IEEE float\nI int integer\nJ long long integer\nL<fullclassname>; ... an object of the given class\nS short signed short\nZ boolean true or false\n[<field sig> ... array\n}</PRE>\n\nThis method converts this string into a Java type declaration such as\n<code>String[]</code>.", "docstring_tokens": ["Returns", "java", "-", "like", "signature", "of", "a", "bytecode", "-", "like", "description", ".", "Only", "first", "description", "is", "parsed", "."]}
{"code": "String type = typedescToSignature(desc, from);", "comments": "the rest of the string denotes a `<field_type>'", "lines": 36, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm/AsmUtil.java", "func_name": "AsmUtil.typedescToSignature", "original_string": "public static String typedescToSignature(final String desc, final MutableInteger from) {\n\t\tint fromIndex = from.get();\n\t\tfrom.value++;\t// default usage for most cases\n\n\t\tswitch (desc.charAt(fromIndex)) {\n\t\t\tcase 'B': return \"byte\";\n\t\t\tcase 'C': return \"char\";\n\t\t\tcase 'D': return \"double\";\n\t\t\tcase 'F': return \"float\";\n\t\t\tcase 'I': return \"int\";\n\t\t\tcase 'J': return \"long\";\n\t\t\tcase 'S': return \"short\";\n\t\t\tcase 'Z': return \"boolean\";\n\t\t\tcase 'V': return \"void\";\n\n\t\t\tcase 'L':\n\t\t\t\tint index = desc.indexOf(';', fromIndex);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\tfrom.set(index + 1);\n\t\t\t\tString str = desc.substring(fromIndex + 1, index);\n\t\t\t\treturn str.replace('/', '.');\n\n\t\t\tcase 'T':\n\t\t\t\treturn desc.substring(from.value);\n\n\t\t\tcase '[':\n\t\t\t\tStringBuilder brackets = new StringBuilder();\n\t\t\t\tint n = fromIndex;\n\t\t\t\twhile (desc.charAt(n) == '[') {\t// count opening brackets\n\t\t\t\t\tbrackets.append(\"[]\");\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tfrom.value = n;\n\t\t\t\tString type = typedescToSignature(desc, from);\t// the rest of the string denotes a `<field_type>'\n\t\t\t\treturn type + brackets;\n\n\t\t\tdefault:\n\t\t\t\tif (from.value == 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\t// generics!\n\t\t\t\treturn desc.substring(from.value);\n\t\t}\n\t}", "language": "java", "Allcodes": "public static String typedescToSignature(final String desc, final MutableInteger from) {\n\t\tint fromIndex = from.get();\n\t\tfrom.value++;\t// default usage for most cases\n\n\t\tswitch (desc.charAt(fromIndex)) {\n\t\t\tcase 'B': return \"byte\";\n\t\t\tcase 'C': return \"char\";\n\t\t\tcase 'D': return \"double\";\n\t\t\tcase 'F': return \"float\";\n\t\t\tcase 'I': return \"int\";\n\t\t\tcase 'J': return \"long\";\n\t\t\tcase 'S': return \"short\";\n\t\t\tcase 'Z': return \"boolean\";\n\t\t\tcase 'V': return \"void\";\n\n\t\t\tcase 'L':\n\t\t\t\tint index = desc.indexOf(';', fromIndex);\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\tfrom.set(index + 1);\n\t\t\t\tString str = desc.substring(fromIndex + 1, index);\n\t\t\t\treturn str.replace('/', '.');\n\n\t\t\tcase 'T':\n\t\t\t\treturn desc.substring(from.value);\n\n\t\t\tcase '[':\n\t\t\t\tStringBuilder brackets = new StringBuilder();\n\t\t\t\tint n = fromIndex;\n\t\t\t\twhile (desc.charAt(n) == '[') {\t// count opening brackets\n\t\t\t\t\tbrackets.append(\"[]\");\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tfrom.value = n;\n\t\t\t\tString type = typedescToSignature(desc, from);\t// the rest of the string denotes a `<field_type>'\n\t\t\t\treturn type + brackets;\n\n\t\t\tdefault:\n\t\t\t\tif (from.value == 0) {\n\t\t\t\t\tthrow new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\n\t\t\t\t}\n\t\t\t\t// generics!\n\t\t\t\treturn desc.substring(from.value);\n\t\t}\n\t}", "code_tokens": ["public", "static", "String", "typedescToSignature", "(", "final", "String", "desc", ",", "final", "MutableInteger", "from", ")", "{", "int", "fromIndex", "=", "from", ".", "get", "(", ")", ";", "from", ".", "value", "++", ";", "// default usage for most cases", "switch", "(", "desc", ".", "charAt", "(", "fromIndex", ")", ")", "{", "case", "'", "'", ":", "return", "\"byte\"", ";", "case", "'", "'", ":", "return", "\"char\"", ";", "case", "'", "'", ":", "return", "\"double\"", ";", "case", "'", "'", ":", "return", "\"float\"", ";", "case", "'", "'", ":", "return", "\"int\"", ";", "case", "'", "'", ":", "return", "\"long\"", ";", "case", "'", "'", ":", "return", "\"short\"", ";", "case", "'", "'", ":", "return", "\"boolean\"", ";", "case", "'", "'", ":", "return", "\"void\"", ";", "case", "'", "'", ":", "int", "index", "=", "desc", ".", "indexOf", "(", "'", "'", ",", "fromIndex", ")", ";", "if", "(", "index", "<", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "INVALID_TYPE_DESCRIPTION", "+", "desc", ")", ";", "}", "from", ".", "set", "(", "index", "+", "1", ")", ";", "String", "str", "=", "desc", ".", "substring", "(", "fromIndex", "+", "1", ",", "index", ")", ";", "return", "str", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "case", "'", "'", ":", "return", "desc", ".", "substring", "(", "from", ".", "value", ")", ";", "case", "'", "'", ":", "StringBuilder", "brackets", "=", "new", "StringBuilder", "(", ")", ";", "int", "n", "=", "fromIndex", ";", "while", "(", "desc", ".", "charAt", "(", "n", ")", "==", "'", "'", ")", "{", "// count opening brackets", "brackets", ".", "append", "(", "\"[]\"", ")", ";", "n", "++", ";", "}", "from", ".", "value", "=", "n", ";", "String", "type", "=", "typedescToSignature", "(", "desc", ",", "from", ")", ";", "// the rest of the string denotes a `<field_type>'", "return", "type", "+", "brackets", ";", "default", ":", "if", "(", "from", ".", "value", "==", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "INVALID_TYPE_DESCRIPTION", "+", "desc", ")", ";", "}", "// generics!", "return", "desc", ".", "substring", "(", "from", ".", "value", ")", ";", "}", "}"], "docstring": "Returns java-like signature of a bytecode-like description.\nOnly first description is parsed.\n\nThe field signature represents the value of an argument to a function or\nthe value of a variable. It is a series of bytes generated by the\nfollowing grammar:\n\n<PRE>{@code\n<field_signature> ::= <field_type>\n<field_type>      ::= <base_type>|<object_type>|<array_type>\n<base_type>       ::= B|C|D|F|I|J|S|Z\n<object_type>     ::= L<fullclassname>;\n<array_type>      ::= [<field_type>\n\nThe meaning of the base types is as follows:\nB byte signed byte\nC char character\nD double double precision IEEE float\nF float single precision IEEE float\nI int integer\nJ long long integer\nL<fullclassname>; ... an object of the given class\nS short signed short\nZ boolean true or false\n[<field sig> ... array\n}</PRE>\n\nThis method converts this string into a Java type declaration such as\n<code>String[]</code>.", "docstring_tokens": ["Returns", "java", "-", "like", "signature", "of", "a", "bytecode", "-", "like", "description", ".", "Only", "first", "description", "is", "parsed", "."]}
{"code": "return null;", "comments": "this should not happens", "lines": 11, "repo": "oblac/jodd", "path": "jodd-bean/src/main/java/jodd/bean/BeanUtilUtil.java", "func_name": "BeanUtilUtil.extractType", "original_string": "protected Class extractType(final BeanProperty bp) {\n\t\tGetter getter = bp.getGetter(isDeclared);\n\t\tif (getter != null) {\n\t\t\tif (bp.index != null) {\n\t\t\t\tClass type = getter.getGetterRawComponentType();\n\t\t\t\treturn type == null ? Object.class : type;\n\t\t\t}\n\t\t\treturn getter.getGetterRawType();\n\t\t}\n\n\t\treturn null;\t// this should not happens\n\t}", "language": "java", "Allcodes": "protected Class extractType(final BeanProperty bp) {\n\t\tGetter getter = bp.getGetter(isDeclared);\n\t\tif (getter != null) {\n\t\t\tif (bp.index != null) {\n\t\t\t\tClass type = getter.getGetterRawComponentType();\n\t\t\t\treturn type == null ? Object.class : type;\n\t\t\t}\n\t\t\treturn getter.getGetterRawType();\n\t\t}\n\n\t\treturn null;\t// this should not happens\n\t}", "code_tokens": ["protected", "Class", "extractType", "(", "final", "BeanProperty", "bp", ")", "{", "Getter", "getter", "=", "bp", ".", "getGetter", "(", "isDeclared", ")", ";", "if", "(", "getter", "!=", "null", ")", "{", "if", "(", "bp", ".", "index", "!=", "null", ")", "{", "Class", "type", "=", "getter", ".", "getGetterRawComponentType", "(", ")", ";", "return", "type", "==", "null", "?", "Object", ".", "class", ":", "type", ";", "}", "return", "getter", ".", "getGetterRawType", "(", ")", ";", "}", "return", "null", ";", "// this should not happens", "}"], "docstring": "Extracts type of current property.", "docstring_tokens": ["Extracts", "type", "of", "current", "property", "."]}
{"code": "continue;", "comments": "ignore static methods", "lines": 13, "repo": "oblac/jodd", "path": "jodd-bean/src/main/java/jodd/introspector/Properties.java", "func_name": "Properties.inspectProperties", "original_string": "protected HashMap<String, PropertyDescriptor> inspectProperties() {\n\t\tboolean scanAccessible = classDescriptor.isScanAccessible();\n\t\tClass type = classDescriptor.getType();\n\n\t\tHashMap<String, PropertyDescriptor> map = new HashMap<>();\n\n\t\tMethod[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type);\n\n\t\tfor (int iteration = 0; iteration < 2; iteration++) {\n\t\t\t// first find the getters, and then the setters!\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static methods\n\t\t\t\t}\n\n\t\t\t\tboolean add = false;\n\t\t\t\tboolean issetter = false;\n\n\t\t\t\tString propertyName;\n\n\t\t\t\tif (iteration == 0) {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertyGetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertySetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (add) {\n\t\t\t\t\tMethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true);\n\t\t\t\t\taddProperty(map, propertyName, methodDescriptor, issetter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classDescriptor.isIncludeFieldsAsProperties()) {\n\t\t\tFieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors();\n\t\t\tString[] prefix = classDescriptor.getPropertyFieldPrefix();\n\n\t\t\tfor (FieldDescriptor fieldDescriptor : fieldDescriptors) {\n\t\t\t\tField field = fieldDescriptor.getField();\n\n\t\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static fields\n\t\t\t\t}\n\n\t\t\t\tString name = field.getName();\n\n\t\t\t\tif (prefix != null) {\n\t\t\t\t\tfor (String p : prefix) {\n\t\t\t\t\t\tif (!name.startsWith(p)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname = name.substring(p.length());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!map.containsKey(name)) {\n\t\t\t\t\t// add missing field as a potential property\n\t\t\t\t\tmap.put(name, createPropertyDescriptor(name, fieldDescriptor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn map;\n\t}", "language": "java", "Allcodes": "protected HashMap<String, PropertyDescriptor> inspectProperties() {\n\t\tboolean scanAccessible = classDescriptor.isScanAccessible();\n\t\tClass type = classDescriptor.getType();\n\n\t\tHashMap<String, PropertyDescriptor> map = new HashMap<>();\n\n\t\tMethod[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type);\n\n\t\tfor (int iteration = 0; iteration < 2; iteration++) {\n\t\t\t// first find the getters, and then the setters!\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static methods\n\t\t\t\t}\n\n\t\t\t\tboolean add = false;\n\t\t\t\tboolean issetter = false;\n\n\t\t\t\tString propertyName;\n\n\t\t\t\tif (iteration == 0) {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertyGetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertySetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (add) {\n\t\t\t\t\tMethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true);\n\t\t\t\t\taddProperty(map, propertyName, methodDescriptor, issetter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classDescriptor.isIncludeFieldsAsProperties()) {\n\t\t\tFieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors();\n\t\t\tString[] prefix = classDescriptor.getPropertyFieldPrefix();\n\n\t\t\tfor (FieldDescriptor fieldDescriptor : fieldDescriptors) {\n\t\t\t\tField field = fieldDescriptor.getField();\n\n\t\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static fields\n\t\t\t\t}\n\n\t\t\t\tString name = field.getName();\n\n\t\t\t\tif (prefix != null) {\n\t\t\t\t\tfor (String p : prefix) {\n\t\t\t\t\t\tif (!name.startsWith(p)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname = name.substring(p.length());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!map.containsKey(name)) {\n\t\t\t\t\t// add missing field as a potential property\n\t\t\t\t\tmap.put(name, createPropertyDescriptor(name, fieldDescriptor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn map;\n\t}", "code_tokens": ["protected", "HashMap", "<", "String", ",", "PropertyDescriptor", ">", "inspectProperties", "(", ")", "{", "boolean", "scanAccessible", "=", "classDescriptor", ".", "isScanAccessible", "(", ")", ";", "Class", "type", "=", "classDescriptor", ".", "getType", "(", ")", ";", "HashMap", "<", "String", ",", "PropertyDescriptor", ">", "map", "=", "new", "HashMap", "<>", "(", ")", ";", "Method", "[", "]", "methods", "=", "scanAccessible", "?", "ClassUtil", ".", "getAccessibleMethods", "(", "type", ")", ":", "ClassUtil", ".", "getSupportedMethods", "(", "type", ")", ";", "for", "(", "int", "iteration", "=", "0", ";", "iteration", "<", "2", ";", "iteration", "++", ")", "{", "// first find the getters, and then the setters!", "for", "(", "Method", "method", ":", "methods", ")", "{", "if", "(", "Modifier", ".", "isStatic", "(", "method", ".", "getModifiers", "(", ")", ")", ")", "{", "continue", ";", "// ignore static methods", "}", "boolean", "add", "=", "false", ";", "boolean", "issetter", "=", "false", ";", "String", "propertyName", ";", "if", "(", "iteration", "==", "0", ")", "{", "propertyName", "=", "ClassUtil", ".", "getBeanPropertyGetterName", "(", "method", ")", ";", "if", "(", "propertyName", "!=", "null", ")", "{", "add", "=", "true", ";", "issetter", "=", "false", ";", "}", "}", "else", "{", "propertyName", "=", "ClassUtil", ".", "getBeanPropertySetterName", "(", "method", ")", ";", "if", "(", "propertyName", "!=", "null", ")", "{", "add", "=", "true", ";", "issetter", "=", "true", ";", "}", "}", "if", "(", "add", ")", "{", "MethodDescriptor", "methodDescriptor", "=", "classDescriptor", ".", "getMethodDescriptor", "(", "method", ".", "getName", "(", ")", ",", "method", ".", "getParameterTypes", "(", ")", ",", "true", ")", ";", "addProperty", "(", "map", ",", "propertyName", ",", "methodDescriptor", ",", "issetter", ")", ";", "}", "}", "}", "if", "(", "classDescriptor", ".", "isIncludeFieldsAsProperties", "(", ")", ")", "{", "FieldDescriptor", "[", "]", "fieldDescriptors", "=", "classDescriptor", ".", "getAllFieldDescriptors", "(", ")", ";", "String", "[", "]", "prefix", "=", "classDescriptor", ".", "getPropertyFieldPrefix", "(", ")", ";", "for", "(", "FieldDescriptor", "fieldDescriptor", ":", "fieldDescriptors", ")", "{", "Field", "field", "=", "fieldDescriptor", ".", "getField", "(", ")", ";", "if", "(", "Modifier", ".", "isStatic", "(", "field", ".", "getModifiers", "(", ")", ")", ")", "{", "continue", ";", "// ignore static fields", "}", "String", "name", "=", "field", ".", "getName", "(", ")", ";", "if", "(", "prefix", "!=", "null", ")", "{", "for", "(", "String", "p", ":", "prefix", ")", "{", "if", "(", "!", "name", ".", "startsWith", "(", "p", ")", ")", "{", "continue", ";", "}", "name", "=", "name", ".", "substring", "(", "p", ".", "length", "(", ")", ")", ";", "break", ";", "}", "}", "if", "(", "!", "map", ".", "containsKey", "(", "name", ")", ")", "{", "// add missing field as a potential property", "map", ".", "put", "(", "name", ",", "createPropertyDescriptor", "(", "name", ",", "fieldDescriptor", ")", ")", ";", "}", "}", "}", "return", "map", ";", "}"], "docstring": "Inspects all properties of target type.", "docstring_tokens": ["Inspects", "all", "properties", "of", "target", "type", "."]}
{"code": "continue;", "comments": "ignore static fields", "lines": 50, "repo": "oblac/jodd", "path": "jodd-bean/src/main/java/jodd/introspector/Properties.java", "func_name": "Properties.inspectProperties", "original_string": "protected HashMap<String, PropertyDescriptor> inspectProperties() {\n\t\tboolean scanAccessible = classDescriptor.isScanAccessible();\n\t\tClass type = classDescriptor.getType();\n\n\t\tHashMap<String, PropertyDescriptor> map = new HashMap<>();\n\n\t\tMethod[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type);\n\n\t\tfor (int iteration = 0; iteration < 2; iteration++) {\n\t\t\t// first find the getters, and then the setters!\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static methods\n\t\t\t\t}\n\n\t\t\t\tboolean add = false;\n\t\t\t\tboolean issetter = false;\n\n\t\t\t\tString propertyName;\n\n\t\t\t\tif (iteration == 0) {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertyGetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertySetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (add) {\n\t\t\t\t\tMethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true);\n\t\t\t\t\taddProperty(map, propertyName, methodDescriptor, issetter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classDescriptor.isIncludeFieldsAsProperties()) {\n\t\t\tFieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors();\n\t\t\tString[] prefix = classDescriptor.getPropertyFieldPrefix();\n\n\t\t\tfor (FieldDescriptor fieldDescriptor : fieldDescriptors) {\n\t\t\t\tField field = fieldDescriptor.getField();\n\n\t\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static fields\n\t\t\t\t}\n\n\t\t\t\tString name = field.getName();\n\n\t\t\t\tif (prefix != null) {\n\t\t\t\t\tfor (String p : prefix) {\n\t\t\t\t\t\tif (!name.startsWith(p)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname = name.substring(p.length());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!map.containsKey(name)) {\n\t\t\t\t\t// add missing field as a potential property\n\t\t\t\t\tmap.put(name, createPropertyDescriptor(name, fieldDescriptor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn map;\n\t}", "language": "java", "Allcodes": "protected HashMap<String, PropertyDescriptor> inspectProperties() {\n\t\tboolean scanAccessible = classDescriptor.isScanAccessible();\n\t\tClass type = classDescriptor.getType();\n\n\t\tHashMap<String, PropertyDescriptor> map = new HashMap<>();\n\n\t\tMethod[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type);\n\n\t\tfor (int iteration = 0; iteration < 2; iteration++) {\n\t\t\t// first find the getters, and then the setters!\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static methods\n\t\t\t\t}\n\n\t\t\t\tboolean add = false;\n\t\t\t\tboolean issetter = false;\n\n\t\t\t\tString propertyName;\n\n\t\t\t\tif (iteration == 0) {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertyGetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpropertyName = ClassUtil.getBeanPropertySetterName(method);\n\t\t\t\t\tif (propertyName != null) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t\tissetter = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (add) {\n\t\t\t\t\tMethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true);\n\t\t\t\t\taddProperty(map, propertyName, methodDescriptor, issetter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classDescriptor.isIncludeFieldsAsProperties()) {\n\t\t\tFieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors();\n\t\t\tString[] prefix = classDescriptor.getPropertyFieldPrefix();\n\n\t\t\tfor (FieldDescriptor fieldDescriptor : fieldDescriptors) {\n\t\t\t\tField field = fieldDescriptor.getField();\n\n\t\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\t\tcontinue;            // ignore static fields\n\t\t\t\t}\n\n\t\t\t\tString name = field.getName();\n\n\t\t\t\tif (prefix != null) {\n\t\t\t\t\tfor (String p : prefix) {\n\t\t\t\t\t\tif (!name.startsWith(p)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname = name.substring(p.length());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!map.containsKey(name)) {\n\t\t\t\t\t// add missing field as a potential property\n\t\t\t\t\tmap.put(name, createPropertyDescriptor(name, fieldDescriptor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn map;\n\t}", "code_tokens": ["protected", "HashMap", "<", "String", ",", "PropertyDescriptor", ">", "inspectProperties", "(", ")", "{", "boolean", "scanAccessible", "=", "classDescriptor", ".", "isScanAccessible", "(", ")", ";", "Class", "type", "=", "classDescriptor", ".", "getType", "(", ")", ";", "HashMap", "<", "String", ",", "PropertyDescriptor", ">", "map", "=", "new", "HashMap", "<>", "(", ")", ";", "Method", "[", "]", "methods", "=", "scanAccessible", "?", "ClassUtil", ".", "getAccessibleMethods", "(", "type", ")", ":", "ClassUtil", ".", "getSupportedMethods", "(", "type", ")", ";", "for", "(", "int", "iteration", "=", "0", ";", "iteration", "<", "2", ";", "iteration", "++", ")", "{", "// first find the getters, and then the setters!", "for", "(", "Method", "method", ":", "methods", ")", "{", "if", "(", "Modifier", ".", "isStatic", "(", "method", ".", "getModifiers", "(", ")", ")", ")", "{", "continue", ";", "// ignore static methods", "}", "boolean", "add", "=", "false", ";", "boolean", "issetter", "=", "false", ";", "String", "propertyName", ";", "if", "(", "iteration", "==", "0", ")", "{", "propertyName", "=", "ClassUtil", ".", "getBeanPropertyGetterName", "(", "method", ")", ";", "if", "(", "propertyName", "!=", "null", ")", "{", "add", "=", "true", ";", "issetter", "=", "false", ";", "}", "}", "else", "{", "propertyName", "=", "ClassUtil", ".", "getBeanPropertySetterName", "(", "method", ")", ";", "if", "(", "propertyName", "!=", "null", ")", "{", "add", "=", "true", ";", "issetter", "=", "true", ";", "}", "}", "if", "(", "add", ")", "{", "MethodDescriptor", "methodDescriptor", "=", "classDescriptor", ".", "getMethodDescriptor", "(", "method", ".", "getName", "(", ")", ",", "method", ".", "getParameterTypes", "(", ")", ",", "true", ")", ";", "addProperty", "(", "map", ",", "propertyName", ",", "methodDescriptor", ",", "issetter", ")", ";", "}", "}", "}", "if", "(", "classDescriptor", ".", "isIncludeFieldsAsProperties", "(", ")", ")", "{", "FieldDescriptor", "[", "]", "fieldDescriptors", "=", "classDescriptor", ".", "getAllFieldDescriptors", "(", ")", ";", "String", "[", "]", "prefix", "=", "classDescriptor", ".", "getPropertyFieldPrefix", "(", ")", ";", "for", "(", "FieldDescriptor", "fieldDescriptor", ":", "fieldDescriptors", ")", "{", "Field", "field", "=", "fieldDescriptor", ".", "getField", "(", ")", ";", "if", "(", "Modifier", ".", "isStatic", "(", "field", ".", "getModifiers", "(", ")", ")", ")", "{", "continue", ";", "// ignore static fields", "}", "String", "name", "=", "field", ".", "getName", "(", ")", ";", "if", "(", "prefix", "!=", "null", ")", "{", "for", "(", "String", "p", ":", "prefix", ")", "{", "if", "(", "!", "name", ".", "startsWith", "(", "p", ")", ")", "{", "continue", ";", "}", "name", "=", "name", ".", "substring", "(", "p", ".", "length", "(", ")", ")", ";", "break", ";", "}", "}", "if", "(", "!", "map", ".", "containsKey", "(", "name", ")", ")", "{", "// add missing field as a potential property", "map", ".", "put", "(", "name", ",", "createPropertyDescriptor", "(", "name", ",", "fieldDescriptor", ")", ")", ";", "}", "}", "}", "return", "map", ";", "}"], "docstring": "Inspects all properties of target type.", "docstring_tokens": ["Inspects", "all", "properties", "of", "target", "type", "."]}
{"code": "return this.isId ? -1 : 1;", "comments": "IDs should be the first in the array", "lines": 5, "repo": "oblac/jodd", "path": "jodd-db/src/main/java/jodd/db/oom/DbEntityColumnDescriptor.java", "func_name": "DbEntityColumnDescriptor.compareTo", "original_string": "@Override\n\tpublic int compareTo(final Object o) {\n\t\tDbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o;\n\t\tif (this.isId != that.isId) {\n\t\t\treturn this.isId ? -1 : 1;      // IDs should be the first in the array\n\t\t}\n\t\treturn this.columnName.compareTo(that.columnName);\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic int compareTo(final Object o) {\n\t\tDbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o;\n\t\tif (this.isId != that.isId) {\n\t\t\treturn this.isId ? -1 : 1;      // IDs should be the first in the array\n\t\t}\n\t\treturn this.columnName.compareTo(that.columnName);\n\t}", "code_tokens": ["@", "Override", "public", "int", "compareTo", "(", "final", "Object", "o", ")", "{", "DbEntityColumnDescriptor", "that", "=", "(", "DbEntityColumnDescriptor", ")", "o", ";", "if", "(", "this", ".", "isId", "!=", "that", ".", "isId", ")", "{", "return", "this", ".", "isId", "?", "-", "1", ":", "1", ";", "// IDs should be the first in the array", "}", "return", "this", ".", "columnName", ".", "compareTo", "(", "that", ".", "columnName", ")", ";", "}"], "docstring": "Compares two column descriptors. Identity columns should be the first on the list.\nEach group then will be sorted by column name.", "docstring_tokens": ["Compares", "two", "column", "descriptors", ".", "Identity", "columns", "should", "be", "the", "first", "on", "the", "list", ".", "Each", "group", "then", "will", "be", "sorted", "by", "column", "name", "."]}
{"code": "response.sendError(SC_NOT_FOUND, \"Result not found: \" + target);", "comments": "should never happened", "lines": 8, "repo": "oblac/jodd", "path": "jodd-madvoc/src/main/java/jodd/madvoc/result/ServletDispatcherActionResult.java", "func_name": "ServletDispatcherActionResult.renderView", "original_string": "@Override\n\tprotected void renderView(final ActionRequest actionRequest, final String target) throws Exception {\n\t\tHttpServletRequest request = actionRequest.getHttpServletRequest();\n\t\tHttpServletResponse response = actionRequest.getHttpServletResponse();\n\n\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(target);\n\t\tif (dispatcher == null) {\n\t\t\tresponse.sendError(SC_NOT_FOUND, \"Result not found: \" + target);\t// should never happened\n\t\t\treturn;\n\t\t}\n\n\t\t// If we're included, then include the view, otherwise do forward.\n\t\t// This allow the page to, for example, set content type.\n\n\t\tif (DispatcherUtil.isPageIncluded(request, response)) {\n\t\t\tdispatcher.include(request, response);\n\t\t} else {\n\t\t\tdispatcher.forward(request, response);\n\t\t}\n\t}", "language": "java", "Allcodes": "@Override\n\tprotected void renderView(final ActionRequest actionRequest, final String target) throws Exception {\n\t\tHttpServletRequest request = actionRequest.getHttpServletRequest();\n\t\tHttpServletResponse response = actionRequest.getHttpServletResponse();\n\n\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(target);\n\t\tif (dispatcher == null) {\n\t\t\tresponse.sendError(SC_NOT_FOUND, \"Result not found: \" + target);\t// should never happened\n\t\t\treturn;\n\t\t}\n\n\t\t// If we're included, then include the view, otherwise do forward.\n\t\t// This allow the page to, for example, set content type.\n\n\t\tif (DispatcherUtil.isPageIncluded(request, response)) {\n\t\t\tdispatcher.include(request, response);\n\t\t} else {\n\t\t\tdispatcher.forward(request, response);\n\t\t}\n\t}", "code_tokens": ["@", "Override", "protected", "void", "renderView", "(", "final", "ActionRequest", "actionRequest", ",", "final", "String", "target", ")", "throws", "Exception", "{", "HttpServletRequest", "request", "=", "actionRequest", ".", "getHttpServletRequest", "(", ")", ";", "HttpServletResponse", "response", "=", "actionRequest", ".", "getHttpServletResponse", "(", ")", ";", "RequestDispatcher", "dispatcher", "=", "request", ".", "getRequestDispatcher", "(", "target", ")", ";", "if", "(", "dispatcher", "==", "null", ")", "{", "response", ".", "sendError", "(", "SC_NOT_FOUND", ",", "\"Result not found: \"", "+", "target", ")", ";", "// should never happened", "return", ";", "}", "// If we're included, then include the view, otherwise do forward.", "// This allow the page to, for example, set content type.", "if", "(", "DispatcherUtil", ".", "isPageIncluded", "(", "request", ",", "response", ")", ")", "{", "dispatcher", ".", "include", "(", "request", ",", "response", ")", ";", "}", "else", "{", "dispatcher", ".", "forward", "(", "request", ",", "response", ")", ";", "}", "}"], "docstring": "Renders the view by dispatching to the target JSP.", "docstring_tokens": ["Renders", "the", "view", "by", "dispatching", "to", "the", "target", "JSP", "."]}
{"code": "int escapesCount = countEscapes(template, mark);", "comments": "check if escaped", "lines": 13, "repo": "oblac/jodd", "path": "jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateParser.java", "func_name": "TemplateParser.parse", "original_string": "public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n\t\tint length = template.length();\n\t\tint last = 0;\n\t\twhile (true) {\n\t\t\tint mark = template.indexOf('$', last);\n\t\t\tif (mark == -1) {\n\t\t\t\tif (last < length) {\n\t\t\t\t\tsqlBuilder.appendRaw(template.substring(last));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint escapesCount = countEscapes(template, mark);                // check if escaped\n\t\t\tif (escapesCount > 0) {\n\t\t\t\tboolean isEscaped = escapesCount % 2 != 0;\n\t\t\t\tint escapesToAdd = escapesCount >> 1;\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$');\n\t\t\t\tif (isEscaped) {\n\t\t\t\t\tlast = mark + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark));\n\t\t\t}\n\n\t\t\tint end;\n\n\t\t\tif (template.startsWith(MACRO_TABLE, mark)) {\n\t\t\t\tmark += MACRO_TABLE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonTable(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_COLUMN, mark)) {\n\t\t\t\tmark += MACRO_COLUMN.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonColumn(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_MATCH, mark)) {\n\t\t\t\tmark += MACRO_MATCH.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonMatch(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_VALUE, mark)) {\n\t\t\t\tmark += MACRO_VALUE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonValue(sqlBuilder, template.substring(mark, end));\n\t\t\t} else {\n\t\t\t\tmark++;           // reference found\n\t\t\t\tend = mark;       // find macro end\n\t\t\t\twhile (end < length) {\n\t\t\t\t\tif (!isReferenceChar(template, end)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tonReference(sqlBuilder, template.substring(mark, end));\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tend++;\n\t\t\tlast = end;\n\t\t}\n\t}", "language": "java", "Allcodes": "public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n\t\tint length = template.length();\n\t\tint last = 0;\n\t\twhile (true) {\n\t\t\tint mark = template.indexOf('$', last);\n\t\t\tif (mark == -1) {\n\t\t\t\tif (last < length) {\n\t\t\t\t\tsqlBuilder.appendRaw(template.substring(last));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint escapesCount = countEscapes(template, mark);                // check if escaped\n\t\t\tif (escapesCount > 0) {\n\t\t\t\tboolean isEscaped = escapesCount % 2 != 0;\n\t\t\t\tint escapesToAdd = escapesCount >> 1;\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$');\n\t\t\t\tif (isEscaped) {\n\t\t\t\t\tlast = mark + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark));\n\t\t\t}\n\n\t\t\tint end;\n\n\t\t\tif (template.startsWith(MACRO_TABLE, mark)) {\n\t\t\t\tmark += MACRO_TABLE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonTable(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_COLUMN, mark)) {\n\t\t\t\tmark += MACRO_COLUMN.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonColumn(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_MATCH, mark)) {\n\t\t\t\tmark += MACRO_MATCH.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonMatch(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_VALUE, mark)) {\n\t\t\t\tmark += MACRO_VALUE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonValue(sqlBuilder, template.substring(mark, end));\n\t\t\t} else {\n\t\t\t\tmark++;           // reference found\n\t\t\t\tend = mark;       // find macro end\n\t\t\t\twhile (end < length) {\n\t\t\t\t\tif (!isReferenceChar(template, end)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tonReference(sqlBuilder, template.substring(mark, end));\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tend++;\n\t\t\tlast = end;\n\t\t}\n\t}", "code_tokens": ["public", "void", "parse", "(", "final", "DbSqlBuilder", "sqlBuilder", ",", "final", "String", "template", ")", "{", "int", "length", "=", "template", ".", "length", "(", ")", ";", "int", "last", "=", "0", ";", "while", "(", "true", ")", "{", "int", "mark", "=", "template", ".", "indexOf", "(", "'", "'", ",", "last", ")", ";", "if", "(", "mark", "==", "-", "1", ")", "{", "if", "(", "last", "<", "length", ")", "{", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ")", ")", ";", "}", "break", ";", "}", "int", "escapesCount", "=", "countEscapes", "(", "template", ",", "mark", ")", ";", "// check if escaped", "if", "(", "escapesCount", ">", "0", ")", "{", "boolean", "isEscaped", "=", "escapesCount", "%", "2", "!=", "0", ";", "int", "escapesToAdd", "=", "escapesCount", ">>", "1", ";", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ",", "mark", "-", "escapesCount", "+", "escapesToAdd", ")", "+", "'", "'", ")", ";", "if", "(", "isEscaped", ")", "{", "last", "=", "mark", "+", "1", ";", "continue", ";", "}", "}", "else", "{", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ",", "mark", ")", ")", ";", "}", "int", "end", ";", "if", "(", "template", ".", "startsWith", "(", "MACRO_TABLE", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_TABLE", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onTable", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_COLUMN", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_COLUMN", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onColumn", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_MATCH", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_MATCH", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onMatch", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_VALUE", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_VALUE", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onValue", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "{", "mark", "++", ";", "// reference found", "end", "=", "mark", ";", "// find macro end", "while", "(", "end", "<", "length", ")", "{", "if", "(", "!", "isReferenceChar", "(", "template", ",", "end", ")", ")", "{", "break", ";", "}", "end", "++", ";", "}", "onReference", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "end", "--", ";", "}", "end", "++", ";", "last", "=", "end", ";", "}", "}"], "docstring": "Parses template and returns generated sql builder.", "docstring_tokens": ["Parses", "template", "and", "returns", "generated", "sql", "builder", "."]}
{"code": "mark++;", "comments": "reference found", "lines": 45, "repo": "oblac/jodd", "path": "jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateParser.java", "func_name": "TemplateParser.parse", "original_string": "public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n\t\tint length = template.length();\n\t\tint last = 0;\n\t\twhile (true) {\n\t\t\tint mark = template.indexOf('$', last);\n\t\t\tif (mark == -1) {\n\t\t\t\tif (last < length) {\n\t\t\t\t\tsqlBuilder.appendRaw(template.substring(last));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint escapesCount = countEscapes(template, mark);                // check if escaped\n\t\t\tif (escapesCount > 0) {\n\t\t\t\tboolean isEscaped = escapesCount % 2 != 0;\n\t\t\t\tint escapesToAdd = escapesCount >> 1;\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$');\n\t\t\t\tif (isEscaped) {\n\t\t\t\t\tlast = mark + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark));\n\t\t\t}\n\n\t\t\tint end;\n\n\t\t\tif (template.startsWith(MACRO_TABLE, mark)) {\n\t\t\t\tmark += MACRO_TABLE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonTable(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_COLUMN, mark)) {\n\t\t\t\tmark += MACRO_COLUMN.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonColumn(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_MATCH, mark)) {\n\t\t\t\tmark += MACRO_MATCH.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonMatch(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_VALUE, mark)) {\n\t\t\t\tmark += MACRO_VALUE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonValue(sqlBuilder, template.substring(mark, end));\n\t\t\t} else {\n\t\t\t\tmark++;           // reference found\n\t\t\t\tend = mark;       // find macro end\n\t\t\t\twhile (end < length) {\n\t\t\t\t\tif (!isReferenceChar(template, end)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tonReference(sqlBuilder, template.substring(mark, end));\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tend++;\n\t\t\tlast = end;\n\t\t}\n\t}", "language": "java", "Allcodes": "public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n\t\tint length = template.length();\n\t\tint last = 0;\n\t\twhile (true) {\n\t\t\tint mark = template.indexOf('$', last);\n\t\t\tif (mark == -1) {\n\t\t\t\tif (last < length) {\n\t\t\t\t\tsqlBuilder.appendRaw(template.substring(last));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint escapesCount = countEscapes(template, mark);                // check if escaped\n\t\t\tif (escapesCount > 0) {\n\t\t\t\tboolean isEscaped = escapesCount % 2 != 0;\n\t\t\t\tint escapesToAdd = escapesCount >> 1;\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$');\n\t\t\t\tif (isEscaped) {\n\t\t\t\t\tlast = mark + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark));\n\t\t\t}\n\n\t\t\tint end;\n\n\t\t\tif (template.startsWith(MACRO_TABLE, mark)) {\n\t\t\t\tmark += MACRO_TABLE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonTable(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_COLUMN, mark)) {\n\t\t\t\tmark += MACRO_COLUMN.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonColumn(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_MATCH, mark)) {\n\t\t\t\tmark += MACRO_MATCH.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonMatch(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_VALUE, mark)) {\n\t\t\t\tmark += MACRO_VALUE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonValue(sqlBuilder, template.substring(mark, end));\n\t\t\t} else {\n\t\t\t\tmark++;           // reference found\n\t\t\t\tend = mark;       // find macro end\n\t\t\t\twhile (end < length) {\n\t\t\t\t\tif (!isReferenceChar(template, end)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tonReference(sqlBuilder, template.substring(mark, end));\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tend++;\n\t\t\tlast = end;\n\t\t}\n\t}", "code_tokens": ["public", "void", "parse", "(", "final", "DbSqlBuilder", "sqlBuilder", ",", "final", "String", "template", ")", "{", "int", "length", "=", "template", ".", "length", "(", ")", ";", "int", "last", "=", "0", ";", "while", "(", "true", ")", "{", "int", "mark", "=", "template", ".", "indexOf", "(", "'", "'", ",", "last", ")", ";", "if", "(", "mark", "==", "-", "1", ")", "{", "if", "(", "last", "<", "length", ")", "{", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ")", ")", ";", "}", "break", ";", "}", "int", "escapesCount", "=", "countEscapes", "(", "template", ",", "mark", ")", ";", "// check if escaped", "if", "(", "escapesCount", ">", "0", ")", "{", "boolean", "isEscaped", "=", "escapesCount", "%", "2", "!=", "0", ";", "int", "escapesToAdd", "=", "escapesCount", ">>", "1", ";", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ",", "mark", "-", "escapesCount", "+", "escapesToAdd", ")", "+", "'", "'", ")", ";", "if", "(", "isEscaped", ")", "{", "last", "=", "mark", "+", "1", ";", "continue", ";", "}", "}", "else", "{", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ",", "mark", ")", ")", ";", "}", "int", "end", ";", "if", "(", "template", ".", "startsWith", "(", "MACRO_TABLE", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_TABLE", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onTable", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_COLUMN", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_COLUMN", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onColumn", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_MATCH", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_MATCH", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onMatch", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_VALUE", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_VALUE", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onValue", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "{", "mark", "++", ";", "// reference found", "end", "=", "mark", ";", "// find macro end", "while", "(", "end", "<", "length", ")", "{", "if", "(", "!", "isReferenceChar", "(", "template", ",", "end", ")", ")", "{", "break", ";", "}", "end", "++", ";", "}", "onReference", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "end", "--", ";", "}", "end", "++", ";", "last", "=", "end", ";", "}", "}"], "docstring": "Parses template and returns generated sql builder.", "docstring_tokens": ["Parses", "template", "and", "returns", "generated", "sql", "builder", "."]}
{"code": "end = mark;", "comments": "find macro end", "lines": 46, "repo": "oblac/jodd", "path": "jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateParser.java", "func_name": "TemplateParser.parse", "original_string": "public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n\t\tint length = template.length();\n\t\tint last = 0;\n\t\twhile (true) {\n\t\t\tint mark = template.indexOf('$', last);\n\t\t\tif (mark == -1) {\n\t\t\t\tif (last < length) {\n\t\t\t\t\tsqlBuilder.appendRaw(template.substring(last));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint escapesCount = countEscapes(template, mark);                // check if escaped\n\t\t\tif (escapesCount > 0) {\n\t\t\t\tboolean isEscaped = escapesCount % 2 != 0;\n\t\t\t\tint escapesToAdd = escapesCount >> 1;\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$');\n\t\t\t\tif (isEscaped) {\n\t\t\t\t\tlast = mark + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark));\n\t\t\t}\n\n\t\t\tint end;\n\n\t\t\tif (template.startsWith(MACRO_TABLE, mark)) {\n\t\t\t\tmark += MACRO_TABLE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonTable(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_COLUMN, mark)) {\n\t\t\t\tmark += MACRO_COLUMN.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonColumn(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_MATCH, mark)) {\n\t\t\t\tmark += MACRO_MATCH.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonMatch(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_VALUE, mark)) {\n\t\t\t\tmark += MACRO_VALUE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonValue(sqlBuilder, template.substring(mark, end));\n\t\t\t} else {\n\t\t\t\tmark++;           // reference found\n\t\t\t\tend = mark;       // find macro end\n\t\t\t\twhile (end < length) {\n\t\t\t\t\tif (!isReferenceChar(template, end)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tonReference(sqlBuilder, template.substring(mark, end));\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tend++;\n\t\t\tlast = end;\n\t\t}\n\t}", "language": "java", "Allcodes": "public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n\t\tint length = template.length();\n\t\tint last = 0;\n\t\twhile (true) {\n\t\t\tint mark = template.indexOf('$', last);\n\t\t\tif (mark == -1) {\n\t\t\t\tif (last < length) {\n\t\t\t\t\tsqlBuilder.appendRaw(template.substring(last));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint escapesCount = countEscapes(template, mark);                // check if escaped\n\t\t\tif (escapesCount > 0) {\n\t\t\t\tboolean isEscaped = escapesCount % 2 != 0;\n\t\t\t\tint escapesToAdd = escapesCount >> 1;\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$');\n\t\t\t\tif (isEscaped) {\n\t\t\t\t\tlast = mark + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsqlBuilder.appendRaw(template.substring(last, mark));\n\t\t\t}\n\n\t\t\tint end;\n\n\t\t\tif (template.startsWith(MACRO_TABLE, mark)) {\n\t\t\t\tmark += MACRO_TABLE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonTable(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_COLUMN, mark)) {\n\t\t\t\tmark += MACRO_COLUMN.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonColumn(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_MATCH, mark)) {\n\t\t\t\tmark += MACRO_MATCH.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonMatch(sqlBuilder, template.substring(mark, end));\n\t\t\t} else if (template.startsWith(MACRO_VALUE, mark)) {\n\t\t\t\tmark += MACRO_VALUE.length();\n\t\t\t\tend = findMacroEnd(template, mark);\n\t\t\t\tonValue(sqlBuilder, template.substring(mark, end));\n\t\t\t} else {\n\t\t\t\tmark++;           // reference found\n\t\t\t\tend = mark;       // find macro end\n\t\t\t\twhile (end < length) {\n\t\t\t\t\tif (!isReferenceChar(template, end)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t\tonReference(sqlBuilder, template.substring(mark, end));\n\t\t\t\tend--;\n\t\t\t}\n\t\t\tend++;\n\t\t\tlast = end;\n\t\t}\n\t}", "code_tokens": ["public", "void", "parse", "(", "final", "DbSqlBuilder", "sqlBuilder", ",", "final", "String", "template", ")", "{", "int", "length", "=", "template", ".", "length", "(", ")", ";", "int", "last", "=", "0", ";", "while", "(", "true", ")", "{", "int", "mark", "=", "template", ".", "indexOf", "(", "'", "'", ",", "last", ")", ";", "if", "(", "mark", "==", "-", "1", ")", "{", "if", "(", "last", "<", "length", ")", "{", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ")", ")", ";", "}", "break", ";", "}", "int", "escapesCount", "=", "countEscapes", "(", "template", ",", "mark", ")", ";", "// check if escaped", "if", "(", "escapesCount", ">", "0", ")", "{", "boolean", "isEscaped", "=", "escapesCount", "%", "2", "!=", "0", ";", "int", "escapesToAdd", "=", "escapesCount", ">>", "1", ";", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ",", "mark", "-", "escapesCount", "+", "escapesToAdd", ")", "+", "'", "'", ")", ";", "if", "(", "isEscaped", ")", "{", "last", "=", "mark", "+", "1", ";", "continue", ";", "}", "}", "else", "{", "sqlBuilder", ".", "appendRaw", "(", "template", ".", "substring", "(", "last", ",", "mark", ")", ")", ";", "}", "int", "end", ";", "if", "(", "template", ".", "startsWith", "(", "MACRO_TABLE", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_TABLE", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onTable", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_COLUMN", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_COLUMN", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onColumn", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_MATCH", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_MATCH", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onMatch", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "if", "(", "template", ".", "startsWith", "(", "MACRO_VALUE", ",", "mark", ")", ")", "{", "mark", "+=", "MACRO_VALUE", ".", "length", "(", ")", ";", "end", "=", "findMacroEnd", "(", "template", ",", "mark", ")", ";", "onValue", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "}", "else", "{", "mark", "++", ";", "// reference found", "end", "=", "mark", ";", "// find macro end", "while", "(", "end", "<", "length", ")", "{", "if", "(", "!", "isReferenceChar", "(", "template", ",", "end", ")", ")", "{", "break", ";", "}", "end", "++", ";", "}", "onReference", "(", "sqlBuilder", ",", "template", ".", "substring", "(", "mark", ",", "end", ")", ")", ";", "end", "--", ";", "}", "end", "++", ";", "last", "=", "end", ";", "}", "}"], "docstring": "Parses template and returns generated sql builder.", "docstring_tokens": ["Parses", "template", "and", "returns", "generated", "sql", "builder", "."]}
{"code": "size += input.copyMax(out, maxFileSize + 1);", "comments": "one more byte to detect larger files", "lines": 8, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/io/upload/impl/MemoryFileUpload.java", "func_name": "MemoryFileUpload.processStream", "original_string": "@Override\n\tpublic void processStream() throws IOException {\n\t\tFastByteArrayOutputStream out = new FastByteArrayOutputStream();\n\t\tsize = 0;\n\t\tif (maxFileSize == -1) {\n\t\t\tsize += input.copyAll(out);\n\t\t} else {\n\t\t\tsize += input.copyMax(out, maxFileSize + 1);\t\t// one more byte to detect larger files\n\t\t\tif (size > maxFileSize) {\n\t\t\t\tfileTooBig = true;\n\t\t\t\tvalid = false;\n\t\t\t\tinput.skipToBoundary();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdata = out.toByteArray();\n\t\tsize = data.length;\n\t\tvalid = true;\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic void processStream() throws IOException {\n\t\tFastByteArrayOutputStream out = new FastByteArrayOutputStream();\n\t\tsize = 0;\n\t\tif (maxFileSize == -1) {\n\t\t\tsize += input.copyAll(out);\n\t\t} else {\n\t\t\tsize += input.copyMax(out, maxFileSize + 1);\t\t// one more byte to detect larger files\n\t\t\tif (size > maxFileSize) {\n\t\t\t\tfileTooBig = true;\n\t\t\t\tvalid = false;\n\t\t\t\tinput.skipToBoundary();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdata = out.toByteArray();\n\t\tsize = data.length;\n\t\tvalid = true;\n\t}", "code_tokens": ["@", "Override", "public", "void", "processStream", "(", ")", "throws", "IOException", "{", "FastByteArrayOutputStream", "out", "=", "new", "FastByteArrayOutputStream", "(", ")", ";", "size", "=", "0", ";", "if", "(", "maxFileSize", "==", "-", "1", ")", "{", "size", "+=", "input", ".", "copyAll", "(", "out", ")", ";", "}", "else", "{", "size", "+=", "input", ".", "copyMax", "(", "out", ",", "maxFileSize", "+", "1", ")", ";", "// one more byte to detect larger files", "if", "(", "size", ">", "maxFileSize", ")", "{", "fileTooBig", "=", "true", ";", "valid", "=", "false", ";", "input", ".", "skipToBoundary", "(", ")", ";", "return", ";", "}", "}", "data", "=", "out", ".", "toByteArray", "(", ")", ";", "size", "=", "data", ".", "length", ";", "valid", "=", "true", ";", "}"], "docstring": "Reads data from input stream into byte array and stores file size.", "docstring_tokens": ["Reads", "data", "from", "input", "stream", "into", "byte", "array", "and", "stores", "file", "size", "."]}
{"code": "config.ignoreWhitespacesBetweenTags = false;", "comments": "collect all whitespaces", "lines": 2, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.setCaseSensitive(true);", "comments": "XHTML is case sensitive", "lines": 3, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.setEnableRawTextModes(false);", "comments": "all tags are parsed in the same way", "lines": 4, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.enabledVoidTags = true;", "comments": "list of void tags", "lines": 5, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.selfCloseVoidTags = true;", "comments": "self close void tags", "lines": 6, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.impliedEndTags = false;", "comments": "no implied tag ends", "lines": 7, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.setEnableConditionalComments(false);", "comments": "don't enable IE conditional comments", "lines": 8, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "config.setParseXmlTags(false);", "comments": "enable XML mode in parsing", "lines": 9, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/LagartoDOMBuilder.java", "func_name": "LagartoDOMBuilder.enableXhtmlMode", "original_string": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "language": "java", "Allcodes": "public LagartoDOMBuilder enableXhtmlMode() {\n\t\tconfig.ignoreWhitespacesBetweenTags = false;\t\t\t// collect all whitespaces\n\t\tconfig.setCaseSensitive(true);\t\t\t\t\t\t\t// XHTML is case sensitive\n\t\tconfig.setEnableRawTextModes(false);\t\t\t\t\t// all tags are parsed in the same way\n\t\tconfig.enabledVoidTags = true;\t\t\t\t\t\t\t// list of void tags\n\t\tconfig.selfCloseVoidTags = true;\t\t\t\t\t\t// self close void tags\n\t\tconfig.impliedEndTags = false;\t\t\t\t\t\t\t// no implied tag ends\n\t\tconfig.setEnableConditionalComments(false);\t\t\t\t// don't enable IE conditional comments\n\t\tconfig.setParseXmlTags(false);\t\t\t\t\t\t\t// enable XML mode in parsing\n\t\treturn this;\n\t}", "code_tokens": ["public", "LagartoDOMBuilder", "enableXhtmlMode", "(", ")", "{", "config", ".", "ignoreWhitespacesBetweenTags", "=", "false", ";", "// collect all whitespaces", "config", ".", "setCaseSensitive", "(", "true", ")", ";", "// XHTML is case sensitive", "config", ".", "setEnableRawTextModes", "(", "false", ")", ";", "// all tags are parsed in the same way", "config", ".", "enabledVoidTags", "=", "true", ";", "// list of void tags", "config", ".", "selfCloseVoidTags", "=", "true", ";", "// self close void tags", "config", ".", "impliedEndTags", "=", "false", ";", "// no implied tag ends", "config", ".", "setEnableConditionalComments", "(", "false", ")", ";", "// don't enable IE conditional comments", "config", ".", "setParseXmlTags", "(", "false", ")", ";", "// enable XML mode in parsing", "return", "this", ";", "}"], "docstring": "Enables XHTML mode.", "docstring_tokens": ["Enables", "XHTML", "mode", "."]}
{"code": "txActive = false;", "comments": "txAction should already be false", "lines": 4, "repo": "oblac/jodd", "path": "jodd-db/src/main/java/jodd/db/DbSession.java", "func_name": "DbSession.openConnectionForQuery", "original_string": "protected void openConnectionForQuery() {\n\t\tif (connection == null) {\n\t\t\tconnection = connectionProvider.getConnection();\n\t\t\ttxActive = false;\t// txAction should already be false\n\t\t\ttry {\n\t\t\t\tconnection.setAutoCommit(true);\n\t\t\t} catch (SQLException sex) {\n\t\t\t\tthrow new DbSqlException(\"Failed to open non-TX connection\", sex);\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "protected void openConnectionForQuery() {\n\t\tif (connection == null) {\n\t\t\tconnection = connectionProvider.getConnection();\n\t\t\ttxActive = false;\t// txAction should already be false\n\t\t\ttry {\n\t\t\t\tconnection.setAutoCommit(true);\n\t\t\t} catch (SQLException sex) {\n\t\t\t\tthrow new DbSqlException(\"Failed to open non-TX connection\", sex);\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["protected", "void", "openConnectionForQuery", "(", ")", "{", "if", "(", "connection", "==", "null", ")", "{", "connection", "=", "connectionProvider", ".", "getConnection", "(", ")", ";", "txActive", "=", "false", ";", "// txAction should already be false", "try", "{", "connection", ".", "setAutoCommit", "(", "true", ")", ";", "}", "catch", "(", "SQLException", "sex", ")", "{", "throw", "new", "DbSqlException", "(", "\"Failed to open non-TX connection\"", ",", "sex", ")", ";", "}", "}", "}"], "docstring": "Opens connection in auto-commit mode, if already not opened.", "docstring_tokens": ["Opens", "connection", "in", "auto", "-", "commit", "mode", "if", "already", "not", "opened", "."]}
{"code": "childClone.parentNode = dest;", "comments": "fix parent!", "lines": 19, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/Node.java", "func_name": "Node.cloneTo", "original_string": "protected <T extends Node> T cloneTo(final T dest) {\n//\t\tdest.nodeValue = nodeValue;\t\t// already  in clone implementations!\n\t\tdest.parentNode = parentNode;\n\n\t\tif (attributes != null) {\n\t\t\tdest.attributes = new ArrayList<>(attributes.size());\n\t\t\tfor (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) {\n\t\t\t\tAttribute attr = attributes.get(i);\n\t\t\t\tdest.attributes.add(attr.clone());\n\t\t\t}\n\t\t}\n\n\t\tif (childNodes != null) {\n\t\t\tdest.childNodes = new ArrayList<>(childNodes.size());\n\t\t\tfor (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\n\t\t\t\tNode child = childNodes.get(i);\n\t\t\t\tNode childClone = child.clone();\n\n\t\t\t\tchildClone.parentNode = dest;    // fix parent!\n\t\t\t\tdest.childNodes.add(childClone);\n\t\t\t}\n\t\t}\n\n\t\treturn dest;\n\t}", "language": "java", "Allcodes": "protected <T extends Node> T cloneTo(final T dest) {\n//\t\tdest.nodeValue = nodeValue;\t\t// already  in clone implementations!\n\t\tdest.parentNode = parentNode;\n\n\t\tif (attributes != null) {\n\t\t\tdest.attributes = new ArrayList<>(attributes.size());\n\t\t\tfor (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) {\n\t\t\t\tAttribute attr = attributes.get(i);\n\t\t\t\tdest.attributes.add(attr.clone());\n\t\t\t}\n\t\t}\n\n\t\tif (childNodes != null) {\n\t\t\tdest.childNodes = new ArrayList<>(childNodes.size());\n\t\t\tfor (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\n\t\t\t\tNode child = childNodes.get(i);\n\t\t\t\tNode childClone = child.clone();\n\n\t\t\t\tchildClone.parentNode = dest;    // fix parent!\n\t\t\t\tdest.childNodes.add(childClone);\n\t\t\t}\n\t\t}\n\n\t\treturn dest;\n\t}", "code_tokens": ["protected", "<", "T", "extends", "Node", ">", "T", "cloneTo", "(", "final", "T", "dest", ")", "{", "//\t\tdest.nodeValue = nodeValue;\t\t// already  in clone implementations!", "dest", ".", "parentNode", "=", "parentNode", ";", "if", "(", "attributes", "!=", "null", ")", "{", "dest", ".", "attributes", "=", "new", "ArrayList", "<>", "(", "attributes", ".", "size", "(", ")", ")", ";", "for", "(", "int", "i", "=", "0", ",", "attributesSize", "=", "attributes", ".", "size", "(", ")", ";", "i", "<", "attributesSize", ";", "i", "++", ")", "{", "Attribute", "attr", "=", "attributes", ".", "get", "(", "i", ")", ";", "dest", ".", "attributes", ".", "add", "(", "attr", ".", "clone", "(", ")", ")", ";", "}", "}", "if", "(", "childNodes", "!=", "null", ")", "{", "dest", ".", "childNodes", "=", "new", "ArrayList", "<>", "(", "childNodes", ".", "size", "(", ")", ")", ";", "for", "(", "int", "i", "=", "0", ",", "childNodesSize", "=", "childNodes", ".", "size", "(", ")", ";", "i", "<", "childNodesSize", ";", "i", "++", ")", "{", "Node", "child", "=", "childNodes", ".", "get", "(", "i", ")", ";", "Node", "childClone", "=", "child", ".", "clone", "(", ")", ";", "childClone", ".", "parentNode", "=", "dest", ";", "// fix parent!", "dest", ".", "childNodes", ".", "add", "(", "childClone", ")", ";", "}", "}", "return", "dest", ";", "}"], "docstring": "Copies all non-final values to the empty cloned object.\nCache-related values are not copied.", "docstring_tokens": ["Copies", "all", "non", "-", "final", "values", "to", "the", "empty", "cloned", "object", ".", "Cache", "-", "related", "values", "are", "not", "copied", "."]}
{"code": "return;", "comments": "nothing to add", "lines": 3, "repo": "oblac/jodd", "path": "jodd-lagarto/src/main/java/jodd/lagarto/dom/Node.java", "func_name": "Node.addChild", "original_string": "public void addChild(final Node... nodes) {\n\t\tif (nodes.length == 0) {\n\t\t\treturn;\t// nothing to add\n\t\t}\n\t\tfor (Node node : nodes) {\n\t\t\tnode.detachFromParent();\n\t\t\tnode.parentNode = this;\n\t\t\tinitChildNodes(node);\n\t\t\tchildNodes.add(node);\n\t\t}\n\t\treindexChildrenOnAdd(nodes.length);\n\t}", "language": "java", "Allcodes": "public void addChild(final Node... nodes) {\n\t\tif (nodes.length == 0) {\n\t\t\treturn;\t// nothing to add\n\t\t}\n\t\tfor (Node node : nodes) {\n\t\t\tnode.detachFromParent();\n\t\t\tnode.parentNode = this;\n\t\t\tinitChildNodes(node);\n\t\t\tchildNodes.add(node);\n\t\t}\n\t\treindexChildrenOnAdd(nodes.length);\n\t}", "code_tokens": ["public", "void", "addChild", "(", "final", "Node", "...", "nodes", ")", "{", "if", "(", "nodes", ".", "length", "==", "0", ")", "{", "return", ";", "// nothing to add", "}", "for", "(", "Node", "node", ":", "nodes", ")", "{", "node", ".", "detachFromParent", "(", ")", ";", "node", ".", "parentNode", "=", "this", ";", "initChildNodes", "(", "node", ")", ";", "childNodes", ".", "add", "(", "node", ")", ";", "}", "reindexChildrenOnAdd", "(", "nodes", ".", "length", ")", ";", "}"], "docstring": "Appends several child nodes at once.\nReindex is done only once, after all children are added.", "docstring_tokens": ["Appends", "several", "child", "nodes", "at", "once", ".", "Reindex", "is", "done", "only", "once", "after", "all", "children", "are", "added", "."]}
{"code": "first = ((total - 1) / pageSize) * pageSize;", "comments": "first item on the last page", "lines": 10, "repo": "oblac/jodd", "path": "jodd-joy/src/main/java/jodd/joy/page/PageData.java", "func_name": "PageData.calcFirstItemIndexOfPage", "original_string": "public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) {\n\t\tif (total == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (page < 1) {\n\t\t\tpage = 1;\n\t\t}\n\t\tint first = (page - 1) * pageSize;\n\t\tif (first >= total) {\n\t\t\tfirst = ((total - 1) / pageSize) * pageSize;\t// first item on the last page\n\t\t}\n\t\treturn first;\n\t}", "language": "java", "Allcodes": "public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) {\n\t\tif (total == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (page < 1) {\n\t\t\tpage = 1;\n\t\t}\n\t\tint first = (page - 1) * pageSize;\n\t\tif (first >= total) {\n\t\t\tfirst = ((total - 1) / pageSize) * pageSize;\t// first item on the last page\n\t\t}\n\t\treturn first;\n\t}", "code_tokens": ["public", "static", "int", "calcFirstItemIndexOfPage", "(", "int", "page", ",", "final", "int", "pageSize", ",", "final", "int", "total", ")", "{", "if", "(", "total", "==", "0", ")", "{", "return", "0", ";", "}", "if", "(", "page", "<", "1", ")", "{", "page", "=", "1", ";", "}", "int", "first", "=", "(", "page", "-", "1", ")", "*", "pageSize", ";", "if", "(", "first", ">=", "total", ")", "{", "first", "=", "(", "(", "total", "-", "1", ")", "/", "pageSize", ")", "*", "pageSize", ";", "// first item on the last page", "}", "return", "first", ";", "}"], "docstring": "Calculates the first item index of requested page.", "docstring_tokens": ["Calculates", "the", "first", "item", "index", "of", "requested", "page", "."]}
{"code": "char p = pattern.charAt(pNdx);", "comments": "pattern char", "lines": 23, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/util/Wildcard.java", "func_name": "Wildcard.match", "original_string": "private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) {\n\t\tint pLen = pattern.length();\n\t\tif (pLen == 1) {\n\t\t\tif (pattern.charAt(0) == '*') {     // speed-up\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tint sLen = string.length();\n\t\tboolean nextIsNotWildcard = false;\n\n\t\twhile (true) {\n\n\t\t\t// check if end of string and/or pattern occurred\n\t\t\tif ((sNdx >= sLen)) {\t\t// end of string still may have pending '*' in pattern\n\t\t\t\twhile ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) {\n\t\t\t\t\tpNdx++;\n\t\t\t\t}\n\t\t\t\treturn pNdx >= pLen;\n\t\t\t}\n\t\t\tif (pNdx >= pLen) {\t\t\t\t\t// end of pattern, but not end of the string\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar p = pattern.charAt(pNdx);\t\t// pattern char\n\n\t\t\t// perform logic\n\t\t\tif (!nextIsNotWildcard) {\n\n\t\t\t\tif (p == '\\\\') {\n\t\t\t\t\tpNdx++;\n\t\t\t\t\tnextIsNotWildcard =  true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '?') {\n\t\t\t\t\tsNdx++; pNdx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '*') {\n\t\t\t\t\tchar pNext = 0;\t\t\t\t\t\t// next pattern char\n\t\t\t\t\tif (pNdx + 1 < pLen) {\n\t\t\t\t\t\tpNext = pattern.charAt(pNdx + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (pNext == '*') {\t\t\t\t\t// double '*' have the same effect as one '*'\n\t\t\t\t\t\tpNdx++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint i;\n\t\t\t\t\tpNdx++;\n\n\t\t\t\t\t// find recursively if there is any substring from the end of the\n\t\t\t\t\t// line that matches the rest of the pattern !!!\n\t\t\t\t\tfor (i = string.length(); i >= sNdx; i--) {\n\t\t\t\t\t\tif (match(string, pattern, i, pNdx)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnextIsNotWildcard = false;\n\t\t\t}\n\n\t\t\t// check if pattern char and string char are equals\n\t\t\tif (p != string.charAt(sNdx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// everything matches for now, continue\n\t\t\tsNdx++; pNdx++;\n\t\t}\n\t}", "language": "java", "Allcodes": "private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) {\n\t\tint pLen = pattern.length();\n\t\tif (pLen == 1) {\n\t\t\tif (pattern.charAt(0) == '*') {     // speed-up\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tint sLen = string.length();\n\t\tboolean nextIsNotWildcard = false;\n\n\t\twhile (true) {\n\n\t\t\t// check if end of string and/or pattern occurred\n\t\t\tif ((sNdx >= sLen)) {\t\t// end of string still may have pending '*' in pattern\n\t\t\t\twhile ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) {\n\t\t\t\t\tpNdx++;\n\t\t\t\t}\n\t\t\t\treturn pNdx >= pLen;\n\t\t\t}\n\t\t\tif (pNdx >= pLen) {\t\t\t\t\t// end of pattern, but not end of the string\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar p = pattern.charAt(pNdx);\t\t// pattern char\n\n\t\t\t// perform logic\n\t\t\tif (!nextIsNotWildcard) {\n\n\t\t\t\tif (p == '\\\\') {\n\t\t\t\t\tpNdx++;\n\t\t\t\t\tnextIsNotWildcard =  true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '?') {\n\t\t\t\t\tsNdx++; pNdx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '*') {\n\t\t\t\t\tchar pNext = 0;\t\t\t\t\t\t// next pattern char\n\t\t\t\t\tif (pNdx + 1 < pLen) {\n\t\t\t\t\t\tpNext = pattern.charAt(pNdx + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (pNext == '*') {\t\t\t\t\t// double '*' have the same effect as one '*'\n\t\t\t\t\t\tpNdx++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint i;\n\t\t\t\t\tpNdx++;\n\n\t\t\t\t\t// find recursively if there is any substring from the end of the\n\t\t\t\t\t// line that matches the rest of the pattern !!!\n\t\t\t\t\tfor (i = string.length(); i >= sNdx; i--) {\n\t\t\t\t\t\tif (match(string, pattern, i, pNdx)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnextIsNotWildcard = false;\n\t\t\t}\n\n\t\t\t// check if pattern char and string char are equals\n\t\t\tif (p != string.charAt(sNdx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// everything matches for now, continue\n\t\t\tsNdx++; pNdx++;\n\t\t}\n\t}", "code_tokens": ["private", "static", "boolean", "match", "(", "final", "CharSequence", "string", ",", "final", "CharSequence", "pattern", ",", "int", "sNdx", ",", "int", "pNdx", ")", "{", "int", "pLen", "=", "pattern", ".", "length", "(", ")", ";", "if", "(", "pLen", "==", "1", ")", "{", "if", "(", "pattern", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "// speed-up", "return", "true", ";", "}", "}", "int", "sLen", "=", "string", ".", "length", "(", ")", ";", "boolean", "nextIsNotWildcard", "=", "false", ";", "while", "(", "true", ")", "{", "// check if end of string and/or pattern occurred", "if", "(", "(", "sNdx", ">=", "sLen", ")", ")", "{", "// end of string still may have pending '*' in pattern", "while", "(", "(", "pNdx", "<", "pLen", ")", "&&", "(", "pattern", ".", "charAt", "(", "pNdx", ")", "==", "'", "'", ")", ")", "{", "pNdx", "++", ";", "}", "return", "pNdx", ">=", "pLen", ";", "}", "if", "(", "pNdx", ">=", "pLen", ")", "{", "// end of pattern, but not end of the string", "return", "false", ";", "}", "char", "p", "=", "pattern", ".", "charAt", "(", "pNdx", ")", ";", "// pattern char", "// perform logic", "if", "(", "!", "nextIsNotWildcard", ")", "{", "if", "(", "p", "==", "'", "'", ")", "{", "pNdx", "++", ";", "nextIsNotWildcard", "=", "true", ";", "continue", ";", "}", "if", "(", "p", "==", "'", "'", ")", "{", "sNdx", "++", ";", "pNdx", "++", ";", "continue", ";", "}", "if", "(", "p", "==", "'", "'", ")", "{", "char", "pNext", "=", "0", ";", "// next pattern char", "if", "(", "pNdx", "+", "1", "<", "pLen", ")", "{", "pNext", "=", "pattern", ".", "charAt", "(", "pNdx", "+", "1", ")", ";", "}", "if", "(", "pNext", "==", "'", "'", ")", "{", "// double '*' have the same effect as one '*'", "pNdx", "++", ";", "continue", ";", "}", "int", "i", ";", "pNdx", "++", ";", "// find recursively if there is any substring from the end of the", "// line that matches the rest of the pattern !!!", "for", "(", "i", "=", "string", ".", "length", "(", ")", ";", "i", ">=", "sNdx", ";", "i", "--", ")", "{", "if", "(", "match", "(", "string", ",", "pattern", ",", "i", ",", "pNdx", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}", "}", "else", "{", "nextIsNotWildcard", "=", "false", ";", "}", "// check if pattern char and string char are equals", "if", "(", "p", "!=", "string", ".", "charAt", "(", "sNdx", ")", ")", "{", "return", "false", ";", "}", "// everything matches for now, continue", "sNdx", "++", ";", "pNdx", "++", ";", "}", "}"], "docstring": "Internal matching recursive function.", "docstring_tokens": ["Internal", "matching", "recursive", "function", "."]}
{"code": "char pNext = 0;", "comments": "next pattern char", "lines": 38, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/util/Wildcard.java", "func_name": "Wildcard.match", "original_string": "private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) {\n\t\tint pLen = pattern.length();\n\t\tif (pLen == 1) {\n\t\t\tif (pattern.charAt(0) == '*') {     // speed-up\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tint sLen = string.length();\n\t\tboolean nextIsNotWildcard = false;\n\n\t\twhile (true) {\n\n\t\t\t// check if end of string and/or pattern occurred\n\t\t\tif ((sNdx >= sLen)) {\t\t// end of string still may have pending '*' in pattern\n\t\t\t\twhile ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) {\n\t\t\t\t\tpNdx++;\n\t\t\t\t}\n\t\t\t\treturn pNdx >= pLen;\n\t\t\t}\n\t\t\tif (pNdx >= pLen) {\t\t\t\t\t// end of pattern, but not end of the string\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar p = pattern.charAt(pNdx);\t\t// pattern char\n\n\t\t\t// perform logic\n\t\t\tif (!nextIsNotWildcard) {\n\n\t\t\t\tif (p == '\\\\') {\n\t\t\t\t\tpNdx++;\n\t\t\t\t\tnextIsNotWildcard =  true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '?') {\n\t\t\t\t\tsNdx++; pNdx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '*') {\n\t\t\t\t\tchar pNext = 0;\t\t\t\t\t\t// next pattern char\n\t\t\t\t\tif (pNdx + 1 < pLen) {\n\t\t\t\t\t\tpNext = pattern.charAt(pNdx + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (pNext == '*') {\t\t\t\t\t// double '*' have the same effect as one '*'\n\t\t\t\t\t\tpNdx++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint i;\n\t\t\t\t\tpNdx++;\n\n\t\t\t\t\t// find recursively if there is any substring from the end of the\n\t\t\t\t\t// line that matches the rest of the pattern !!!\n\t\t\t\t\tfor (i = string.length(); i >= sNdx; i--) {\n\t\t\t\t\t\tif (match(string, pattern, i, pNdx)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnextIsNotWildcard = false;\n\t\t\t}\n\n\t\t\t// check if pattern char and string char are equals\n\t\t\tif (p != string.charAt(sNdx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// everything matches for now, continue\n\t\t\tsNdx++; pNdx++;\n\t\t}\n\t}", "language": "java", "Allcodes": "private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) {\n\t\tint pLen = pattern.length();\n\t\tif (pLen == 1) {\n\t\t\tif (pattern.charAt(0) == '*') {     // speed-up\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tint sLen = string.length();\n\t\tboolean nextIsNotWildcard = false;\n\n\t\twhile (true) {\n\n\t\t\t// check if end of string and/or pattern occurred\n\t\t\tif ((sNdx >= sLen)) {\t\t// end of string still may have pending '*' in pattern\n\t\t\t\twhile ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) {\n\t\t\t\t\tpNdx++;\n\t\t\t\t}\n\t\t\t\treturn pNdx >= pLen;\n\t\t\t}\n\t\t\tif (pNdx >= pLen) {\t\t\t\t\t// end of pattern, but not end of the string\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tchar p = pattern.charAt(pNdx);\t\t// pattern char\n\n\t\t\t// perform logic\n\t\t\tif (!nextIsNotWildcard) {\n\n\t\t\t\tif (p == '\\\\') {\n\t\t\t\t\tpNdx++;\n\t\t\t\t\tnextIsNotWildcard =  true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '?') {\n\t\t\t\t\tsNdx++; pNdx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (p == '*') {\n\t\t\t\t\tchar pNext = 0;\t\t\t\t\t\t// next pattern char\n\t\t\t\t\tif (pNdx + 1 < pLen) {\n\t\t\t\t\t\tpNext = pattern.charAt(pNdx + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (pNext == '*') {\t\t\t\t\t// double '*' have the same effect as one '*'\n\t\t\t\t\t\tpNdx++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint i;\n\t\t\t\t\tpNdx++;\n\n\t\t\t\t\t// find recursively if there is any substring from the end of the\n\t\t\t\t\t// line that matches the rest of the pattern !!!\n\t\t\t\t\tfor (i = string.length(); i >= sNdx; i--) {\n\t\t\t\t\t\tif (match(string, pattern, i, pNdx)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnextIsNotWildcard = false;\n\t\t\t}\n\n\t\t\t// check if pattern char and string char are equals\n\t\t\tif (p != string.charAt(sNdx)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// everything matches for now, continue\n\t\t\tsNdx++; pNdx++;\n\t\t}\n\t}", "code_tokens": ["private", "static", "boolean", "match", "(", "final", "CharSequence", "string", ",", "final", "CharSequence", "pattern", ",", "int", "sNdx", ",", "int", "pNdx", ")", "{", "int", "pLen", "=", "pattern", ".", "length", "(", ")", ";", "if", "(", "pLen", "==", "1", ")", "{", "if", "(", "pattern", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "// speed-up", "return", "true", ";", "}", "}", "int", "sLen", "=", "string", ".", "length", "(", ")", ";", "boolean", "nextIsNotWildcard", "=", "false", ";", "while", "(", "true", ")", "{", "// check if end of string and/or pattern occurred", "if", "(", "(", "sNdx", ">=", "sLen", ")", ")", "{", "// end of string still may have pending '*' in pattern", "while", "(", "(", "pNdx", "<", "pLen", ")", "&&", "(", "pattern", ".", "charAt", "(", "pNdx", ")", "==", "'", "'", ")", ")", "{", "pNdx", "++", ";", "}", "return", "pNdx", ">=", "pLen", ";", "}", "if", "(", "pNdx", ">=", "pLen", ")", "{", "// end of pattern, but not end of the string", "return", "false", ";", "}", "char", "p", "=", "pattern", ".", "charAt", "(", "pNdx", ")", ";", "// pattern char", "// perform logic", "if", "(", "!", "nextIsNotWildcard", ")", "{", "if", "(", "p", "==", "'", "'", ")", "{", "pNdx", "++", ";", "nextIsNotWildcard", "=", "true", ";", "continue", ";", "}", "if", "(", "p", "==", "'", "'", ")", "{", "sNdx", "++", ";", "pNdx", "++", ";", "continue", ";", "}", "if", "(", "p", "==", "'", "'", ")", "{", "char", "pNext", "=", "0", ";", "// next pattern char", "if", "(", "pNdx", "+", "1", "<", "pLen", ")", "{", "pNext", "=", "pattern", ".", "charAt", "(", "pNdx", "+", "1", ")", ";", "}", "if", "(", "pNext", "==", "'", "'", ")", "{", "// double '*' have the same effect as one '*'", "pNdx", "++", ";", "continue", ";", "}", "int", "i", ";", "pNdx", "++", ";", "// find recursively if there is any substring from the end of the", "// line that matches the rest of the pattern !!!", "for", "(", "i", "=", "string", ".", "length", "(", ")", ";", "i", ">=", "sNdx", ";", "i", "--", ")", "{", "if", "(", "match", "(", "string", ",", "pattern", ",", "i", ",", "pNdx", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}", "}", "else", "{", "nextIsNotWildcard", "=", "false", ";", "}", "// check if pattern char and string char are equals", "if", "(", "p", "!=", "string", ".", "charAt", "(", "sNdx", ")", ")", "{", "return", "false", ";", "}", "// everything matches for now, continue", "sNdx", "++", ";", "pNdx", "++", ";", "}", "}"], "docstring": "Internal matching recursive function.", "docstring_tokens": ["Internal", "matching", "recursive", "function", "."]}
{"code": "result = false;", "comments": "excludes founded", "lines": 61, "repo": "oblac/jodd", "path": "jodd-servlet/src/main/java/jodd/servlet/filter/GzipFilter.java", "func_name": "GzipFilter.isGzipEligible", "original_string": "protected boolean isGzipEligible(final HttpServletRequest request) {\n\t\t// request parameter name\n\n\t\tif (requestParameterName.length() != 0) {\n\t\t\tString forceGzipString = request.getParameter(requestParameterName);\n\n\t\t\tif (forceGzipString != null) {\n\t\t\t\treturn Converter.get().toBooleanValue(forceGzipString, false);\n\t\t\t}\n\t\t}\n\n\t\t// extract uri\n\n\t\tString uri = request.getRequestURI();\n\n\t\tif (uri == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\turi = uri.toLowerCase();\n\n\t\tboolean result = false;\n\n\t\t// check uri\n\n\t\tif (matches == null) {\t\t\t\t\t// match == *\n\t\t\tif (extensions == null) {\t\t\t// extensions == *\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// extension\n\t\t\tString extension = FileNameUtil.getExtension(uri);\n\n\t\t\tif (extension.length() > 0) {\n\t\t\t\textension = extension.toLowerCase();\n\n\t\t\t\tif (StringUtil.equalsOne(extension, extensions) != -1) {\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (wildcards) {\n\t\t\t\tresult = Wildcard.matchPathOne(uri, matches) != -1;\n\t\t\t} else {\n\t\t\t\tfor (String match : matches) {\n\t\t\t\t\tif (uri.contains(match)) {\n\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((result) && (excludes != null)) {\n\t\t\tif (wildcards) {\n\t\t\t\tif (Wildcard.matchPathOne(uri, excludes) != -1) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (String exclude : excludes) {\n\t\t\t\t\tif (uri.contains(exclude)) {\n\t\t\t\t\t\tresult = false;\t\t\t\t\t\t// excludes founded\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}", "language": "java", "Allcodes": "protected boolean isGzipEligible(final HttpServletRequest request) {\n\t\t// request parameter name\n\n\t\tif (requestParameterName.length() != 0) {\n\t\t\tString forceGzipString = request.getParameter(requestParameterName);\n\n\t\t\tif (forceGzipString != null) {\n\t\t\t\treturn Converter.get().toBooleanValue(forceGzipString, false);\n\t\t\t}\n\t\t}\n\n\t\t// extract uri\n\n\t\tString uri = request.getRequestURI();\n\n\t\tif (uri == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\turi = uri.toLowerCase();\n\n\t\tboolean result = false;\n\n\t\t// check uri\n\n\t\tif (matches == null) {\t\t\t\t\t// match == *\n\t\t\tif (extensions == null) {\t\t\t// extensions == *\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// extension\n\t\t\tString extension = FileNameUtil.getExtension(uri);\n\n\t\t\tif (extension.length() > 0) {\n\t\t\t\textension = extension.toLowerCase();\n\n\t\t\t\tif (StringUtil.equalsOne(extension, extensions) != -1) {\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (wildcards) {\n\t\t\t\tresult = Wildcard.matchPathOne(uri, matches) != -1;\n\t\t\t} else {\n\t\t\t\tfor (String match : matches) {\n\t\t\t\t\tif (uri.contains(match)) {\n\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((result) && (excludes != null)) {\n\t\t\tif (wildcards) {\n\t\t\t\tif (Wildcard.matchPathOne(uri, excludes) != -1) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (String exclude : excludes) {\n\t\t\t\t\tif (uri.contains(exclude)) {\n\t\t\t\t\t\tresult = false;\t\t\t\t\t\t// excludes founded\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}", "code_tokens": ["protected", "boolean", "isGzipEligible", "(", "final", "HttpServletRequest", "request", ")", "{", "// request parameter name", "if", "(", "requestParameterName", ".", "length", "(", ")", "!=", "0", ")", "{", "String", "forceGzipString", "=", "request", ".", "getParameter", "(", "requestParameterName", ")", ";", "if", "(", "forceGzipString", "!=", "null", ")", "{", "return", "Converter", ".", "get", "(", ")", ".", "toBooleanValue", "(", "forceGzipString", ",", "false", ")", ";", "}", "}", "// extract uri", "String", "uri", "=", "request", ".", "getRequestURI", "(", ")", ";", "if", "(", "uri", "==", "null", ")", "{", "return", "false", ";", "}", "uri", "=", "uri", ".", "toLowerCase", "(", ")", ";", "boolean", "result", "=", "false", ";", "// check uri", "if", "(", "matches", "==", "null", ")", "{", "// match == *", "if", "(", "extensions", "==", "null", ")", "{", "// extensions == *", "return", "true", ";", "}", "// extension", "String", "extension", "=", "FileNameUtil", ".", "getExtension", "(", "uri", ")", ";", "if", "(", "extension", ".", "length", "(", ")", ">", "0", ")", "{", "extension", "=", "extension", ".", "toLowerCase", "(", ")", ";", "if", "(", "StringUtil", ".", "equalsOne", "(", "extension", ",", "extensions", ")", "!=", "-", "1", ")", "{", "result", "=", "true", ";", "}", "}", "}", "else", "{", "if", "(", "wildcards", ")", "{", "result", "=", "Wildcard", ".", "matchPathOne", "(", "uri", ",", "matches", ")", "!=", "-", "1", ";", "}", "else", "{", "for", "(", "String", "match", ":", "matches", ")", "{", "if", "(", "uri", ".", "contains", "(", "match", ")", ")", "{", "result", "=", "true", ";", "break", ";", "}", "}", "}", "}", "if", "(", "(", "result", ")", "&&", "(", "excludes", "!=", "null", ")", ")", "{", "if", "(", "wildcards", ")", "{", "if", "(", "Wildcard", ".", "matchPathOne", "(", "uri", ",", "excludes", ")", "!=", "-", "1", ")", "{", "result", "=", "false", ";", "}", "}", "else", "{", "for", "(", "String", "exclude", ":", "excludes", ")", "{", "if", "(", "uri", ".", "contains", "(", "exclude", ")", ")", "{", "result", "=", "false", ";", "// excludes founded", "break", ";", "}", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Determine if request is eligible for GZipping.", "docstring_tokens": ["Determine", "if", "request", "is", "eligible", "for", "GZipping", "."]}
{"code": "String valueName = targetName != null ? (targetName + '.' + name) : name;", "comments": "move up", "lines": 5, "repo": "oblac/jodd", "path": "jodd-vtor/src/main/java/jodd/vtor/Vtor.java", "func_name": "Vtor.validate", "original_string": "public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) {\n\t\tfor (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = BeanUtil.declaredSilent.getProperty(target, name);\n\t\t\tString valueName = targetName != null ? (targetName + '.' + name) : name;\t\t// move up\n\t\t\tValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName);\n\t\t\t\n\t\t\tfor (Check check : entry.getValue()) {\n\t\t\t\tString[] checkProfiles = check.getProfiles();\n\t\t\t\tif (!matchProfiles(checkProfiles)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (check.getSeverity() < severity) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tValidationConstraint constraint = check.getConstraint();\n\t\t\t\tif (!constraint.isValid(vcc, value)) {\n\t\t\t\t\taddViolation(new Violation(valueName, target, value, check));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn getViolations();\n\t}", "language": "java", "Allcodes": "public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) {\n\t\tfor (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tObject value = BeanUtil.declaredSilent.getProperty(target, name);\n\t\t\tString valueName = targetName != null ? (targetName + '.' + name) : name;\t\t// move up\n\t\t\tValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName);\n\t\t\t\n\t\t\tfor (Check check : entry.getValue()) {\n\t\t\t\tString[] checkProfiles = check.getProfiles();\n\t\t\t\tif (!matchProfiles(checkProfiles)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (check.getSeverity() < severity) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tValidationConstraint constraint = check.getConstraint();\n\t\t\t\tif (!constraint.isValid(vcc, value)) {\n\t\t\t\t\taddViolation(new Violation(valueName, target, value, check));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn getViolations();\n\t}", "code_tokens": ["public", "List", "<", "Violation", ">", "validate", "(", "final", "ValidationContext", "ctx", ",", "final", "Object", "target", ",", "final", "String", "targetName", ")", "{", "for", "(", "Map", ".", "Entry", "<", "String", ",", "List", "<", "Check", ">", ">", "entry", ":", "ctx", ".", "map", ".", "entrySet", "(", ")", ")", "{", "String", "name", "=", "entry", ".", "getKey", "(", ")", ";", "Object", "value", "=", "BeanUtil", ".", "declaredSilent", ".", "getProperty", "(", "target", ",", "name", ")", ";", "String", "valueName", "=", "targetName", "!=", "null", "?", "(", "targetName", "+", "'", "'", "+", "name", ")", ":", "name", ";", "// move up", "ValidationConstraintContext", "vcc", "=", "new", "ValidationConstraintContext", "(", "this", ",", "target", ",", "valueName", ")", ";", "for", "(", "Check", "check", ":", "entry", ".", "getValue", "(", ")", ")", "{", "String", "[", "]", "checkProfiles", "=", "check", ".", "getProfiles", "(", ")", ";", "if", "(", "!", "matchProfiles", "(", "checkProfiles", ")", ")", "{", "continue", ";", "}", "if", "(", "check", ".", "getSeverity", "(", ")", "<", "severity", ")", "{", "continue", ";", "}", "ValidationConstraint", "constraint", "=", "check", ".", "getConstraint", "(", ")", ";", "if", "(", "!", "constraint", ".", "isValid", "(", "vcc", ",", "value", ")", ")", "{", "addViolation", "(", "new", "Violation", "(", "valueName", ",", "target", ",", "value", ",", "check", ")", ")", ";", "}", "}", "}", "return", "getViolations", "(", ")", ";", "}"], "docstring": "Performs validation of provided validation context and appends violations.", "docstring_tokens": ["Performs", "validation", "of", "provided", "validation", "context", "and", "appends", "violations", "."]}
{"code": "return true;", "comments": "all profiles are considered as enabled", "lines": 8, "repo": "oblac/jodd", "path": "jodd-vtor/src/main/java/jodd/vtor/Vtor.java", "func_name": "Vtor.matchProfiles", "original_string": "protected boolean matchProfiles(final String[] checkProfiles) {\n\t\t// test for all profiles\n\t\tif ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (enabledProfiles == null || enabledProfiles.isEmpty()) {\n\t\t\tif (validateAllProfilesByDefault) {\n\t\t\t\treturn true;\t// all profiles are considered as enabled\n\t\t\t}\n\t\t\t// only default profile is enabled\n\t\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (String profile : checkProfiles) {\n\t\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\t\treturn true;\t// default profile\n\t\t\t\t}\n\t\t\t\tif (profile.equals(DEFAULT_PROFILE)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t// there are enabled profiles\n\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\treturn enabledProfiles.contains(DEFAULT_PROFILE);\n\t\t}\n\t\tboolean result = false;\n\t\tfor (String profile : checkProfiles) {\n\t\t\tboolean b = true;\n\t\t\tboolean must = false;\n\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\tprofile = DEFAULT_PROFILE;\n\t\t\t} else if (profile.charAt(0) == '-') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tb = false;\n\t\t\t} else if (profile.charAt(0) == '+') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tmust = true;\n\t\t\t}\n\n\t\t\tif (enabledProfiles.contains(profile)) {\n\t\t\t\tif (!b) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\tif (must) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "language": "java", "Allcodes": "protected boolean matchProfiles(final String[] checkProfiles) {\n\t\t// test for all profiles\n\t\tif ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (enabledProfiles == null || enabledProfiles.isEmpty()) {\n\t\t\tif (validateAllProfilesByDefault) {\n\t\t\t\treturn true;\t// all profiles are considered as enabled\n\t\t\t}\n\t\t\t// only default profile is enabled\n\t\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (String profile : checkProfiles) {\n\t\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\t\treturn true;\t// default profile\n\t\t\t\t}\n\t\t\t\tif (profile.equals(DEFAULT_PROFILE)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t// there are enabled profiles\n\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\treturn enabledProfiles.contains(DEFAULT_PROFILE);\n\t\t}\n\t\tboolean result = false;\n\t\tfor (String profile : checkProfiles) {\n\t\t\tboolean b = true;\n\t\t\tboolean must = false;\n\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\tprofile = DEFAULT_PROFILE;\n\t\t\t} else if (profile.charAt(0) == '-') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tb = false;\n\t\t\t} else if (profile.charAt(0) == '+') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tmust = true;\n\t\t\t}\n\n\t\t\tif (enabledProfiles.contains(profile)) {\n\t\t\t\tif (!b) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\tif (must) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "code_tokens": ["protected", "boolean", "matchProfiles", "(", "final", "String", "[", "]", "checkProfiles", ")", "{", "// test for all profiles", "if", "(", "(", "checkProfiles", "!=", "null", ")", "&&", "(", "checkProfiles", ".", "length", "==", "1", ")", "&&", "checkProfiles", "[", "0", "]", ".", "equals", "(", "ALL_PROFILES", ")", ")", "{", "return", "true", ";", "}", "if", "(", "enabledProfiles", "==", "null", "||", "enabledProfiles", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "validateAllProfilesByDefault", ")", "{", "return", "true", ";", "// all profiles are considered as enabled", "}", "// only default profile is enabled", "if", "(", "(", "checkProfiles", "==", "null", ")", "||", "(", "checkProfiles", ".", "length", "==", "0", ")", ")", "{", "return", "true", ";", "}", "for", "(", "String", "profile", ":", "checkProfiles", ")", "{", "if", "(", "StringUtil", ".", "isEmpty", "(", "profile", ")", ")", "{", "return", "true", ";", "// default profile", "}", "if", "(", "profile", ".", "equals", "(", "DEFAULT_PROFILE", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}", "// there are enabled profiles", "if", "(", "(", "checkProfiles", "==", "null", ")", "||", "(", "checkProfiles", ".", "length", "==", "0", ")", ")", "{", "return", "enabledProfiles", ".", "contains", "(", "DEFAULT_PROFILE", ")", ";", "}", "boolean", "result", "=", "false", ";", "for", "(", "String", "profile", ":", "checkProfiles", ")", "{", "boolean", "b", "=", "true", ";", "boolean", "must", "=", "false", ";", "if", "(", "StringUtil", ".", "isEmpty", "(", "profile", ")", ")", "{", "profile", "=", "DEFAULT_PROFILE", ";", "}", "else", "if", "(", "profile", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "profile", "=", "profile", ".", "substring", "(", "1", ")", ";", "b", "=", "false", ";", "}", "else", "if", "(", "profile", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "profile", "=", "profile", ".", "substring", "(", "1", ")", ";", "must", "=", "true", ";", "}", "if", "(", "enabledProfiles", ".", "contains", "(", "profile", ")", ")", "{", "if", "(", "!", "b", ")", "{", "return", "false", ";", "}", "result", "=", "true", ";", "}", "else", "{", "if", "(", "must", ")", "{", "return", "false", ";", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Determine if any of checks profiles is among enabled profiles.", "docstring_tokens": ["Determine", "if", "any", "of", "checks", "profiles", "is", "among", "enabled", "profiles", "."]}
{"code": "return true;", "comments": "default profile", "lines": 16, "repo": "oblac/jodd", "path": "jodd-vtor/src/main/java/jodd/vtor/Vtor.java", "func_name": "Vtor.matchProfiles", "original_string": "protected boolean matchProfiles(final String[] checkProfiles) {\n\t\t// test for all profiles\n\t\tif ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (enabledProfiles == null || enabledProfiles.isEmpty()) {\n\t\t\tif (validateAllProfilesByDefault) {\n\t\t\t\treturn true;\t// all profiles are considered as enabled\n\t\t\t}\n\t\t\t// only default profile is enabled\n\t\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (String profile : checkProfiles) {\n\t\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\t\treturn true;\t// default profile\n\t\t\t\t}\n\t\t\t\tif (profile.equals(DEFAULT_PROFILE)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t// there are enabled profiles\n\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\treturn enabledProfiles.contains(DEFAULT_PROFILE);\n\t\t}\n\t\tboolean result = false;\n\t\tfor (String profile : checkProfiles) {\n\t\t\tboolean b = true;\n\t\t\tboolean must = false;\n\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\tprofile = DEFAULT_PROFILE;\n\t\t\t} else if (profile.charAt(0) == '-') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tb = false;\n\t\t\t} else if (profile.charAt(0) == '+') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tmust = true;\n\t\t\t}\n\n\t\t\tif (enabledProfiles.contains(profile)) {\n\t\t\t\tif (!b) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\tif (must) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "language": "java", "Allcodes": "protected boolean matchProfiles(final String[] checkProfiles) {\n\t\t// test for all profiles\n\t\tif ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (enabledProfiles == null || enabledProfiles.isEmpty()) {\n\t\t\tif (validateAllProfilesByDefault) {\n\t\t\t\treturn true;\t// all profiles are considered as enabled\n\t\t\t}\n\t\t\t// only default profile is enabled\n\t\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (String profile : checkProfiles) {\n\t\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\t\treturn true;\t// default profile\n\t\t\t\t}\n\t\t\t\tif (profile.equals(DEFAULT_PROFILE)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t// there are enabled profiles\n\t\tif ((checkProfiles == null) || (checkProfiles.length == 0)) {\n\t\t\treturn enabledProfiles.contains(DEFAULT_PROFILE);\n\t\t}\n\t\tboolean result = false;\n\t\tfor (String profile : checkProfiles) {\n\t\t\tboolean b = true;\n\t\t\tboolean must = false;\n\t\t\tif (StringUtil.isEmpty(profile)) {\n\t\t\t\tprofile = DEFAULT_PROFILE;\n\t\t\t} else if (profile.charAt(0) == '-') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tb = false;\n\t\t\t} else if (profile.charAt(0) == '+') {\n\t\t\t\tprofile = profile.substring(1);\n\t\t\t\tmust = true;\n\t\t\t}\n\n\t\t\tif (enabledProfiles.contains(profile)) {\n\t\t\t\tif (!b) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tresult = true;\n\t\t\t} else {\n\t\t\t\tif (must) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "code_tokens": ["protected", "boolean", "matchProfiles", "(", "final", "String", "[", "]", "checkProfiles", ")", "{", "// test for all profiles", "if", "(", "(", "checkProfiles", "!=", "null", ")", "&&", "(", "checkProfiles", ".", "length", "==", "1", ")", "&&", "checkProfiles", "[", "0", "]", ".", "equals", "(", "ALL_PROFILES", ")", ")", "{", "return", "true", ";", "}", "if", "(", "enabledProfiles", "==", "null", "||", "enabledProfiles", ".", "isEmpty", "(", ")", ")", "{", "if", "(", "validateAllProfilesByDefault", ")", "{", "return", "true", ";", "// all profiles are considered as enabled", "}", "// only default profile is enabled", "if", "(", "(", "checkProfiles", "==", "null", ")", "||", "(", "checkProfiles", ".", "length", "==", "0", ")", ")", "{", "return", "true", ";", "}", "for", "(", "String", "profile", ":", "checkProfiles", ")", "{", "if", "(", "StringUtil", ".", "isEmpty", "(", "profile", ")", ")", "{", "return", "true", ";", "// default profile", "}", "if", "(", "profile", ".", "equals", "(", "DEFAULT_PROFILE", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}", "// there are enabled profiles", "if", "(", "(", "checkProfiles", "==", "null", ")", "||", "(", "checkProfiles", ".", "length", "==", "0", ")", ")", "{", "return", "enabledProfiles", ".", "contains", "(", "DEFAULT_PROFILE", ")", ";", "}", "boolean", "result", "=", "false", ";", "for", "(", "String", "profile", ":", "checkProfiles", ")", "{", "boolean", "b", "=", "true", ";", "boolean", "must", "=", "false", ";", "if", "(", "StringUtil", ".", "isEmpty", "(", "profile", ")", ")", "{", "profile", "=", "DEFAULT_PROFILE", ";", "}", "else", "if", "(", "profile", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "profile", "=", "profile", ".", "substring", "(", "1", ")", ";", "b", "=", "false", ";", "}", "else", "if", "(", "profile", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "{", "profile", "=", "profile", ".", "substring", "(", "1", ")", ";", "must", "=", "true", ";", "}", "if", "(", "enabledProfiles", ".", "contains", "(", "profile", ")", ")", "{", "if", "(", "!", "b", ")", "{", "return", "false", ";", "}", "result", "=", "true", ";", "}", "else", "{", "if", "(", "must", ")", "{", "return", "false", ";", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Determine if any of checks profiles is among enabled profiles.", "docstring_tokens": ["Determine", "if", "any", "of", "checks", "profiles", "is", "among", "enabled", "profiles", "."]}
{"code": "int offset = startOffset;", "comments": "Current offset in the parsed signature.", "lines": 3, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm7/signature/SignatureReader.java", "func_name": "SignatureReader.parseType", "original_string": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "language": "java", "Allcodes": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "code_tokens": ["private", "static", "int", "parseType", "(", "final", "String", "signature", ",", "final", "int", "startOffset", ",", "final", "SignatureVisitor", "signatureVisitor", ")", "{", "int", "offset", "=", "startOffset", ";", "// Current offset in the parsed signature.", "char", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "// The signature character at 'offset'.", "// Switch based on the first character of the JavaTypeSignature, which indicates its kind.", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "// Case of a BaseType or a VoidDescriptor.", "signatureVisitor", ".", "visitBaseType", "(", "currentChar", ")", ";", "return", "offset", ";", "case", "'", "'", ":", "// Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.", "return", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitArrayType", "(", ")", ")", ";", "case", "'", "'", ":", "// Case of TypeVariableSignature, an identifier between 'T' and ';'.", "int", "endOffset", "=", "signature", ".", "indexOf", "(", "'", "'", ",", "offset", ")", ";", "signatureVisitor", ".", "visitTypeVariable", "(", "signature", ".", "substring", "(", "offset", ",", "endOffset", ")", ")", ";", "return", "endOffset", "+", "1", ";", "case", "'", "'", ":", "// Case of a ClassTypeSignature, which ends with ';'.", "// These signatures have a main class type followed by zero or more inner class types", "// (separated by '.'). Each can have type arguments, inside '<' and '>'.", "int", "start", "=", "offset", ";", "// The start offset of the currently parsed main or inner class name.", "boolean", "visited", "=", "false", ";", "// Whether the currently parsed class name has been visited.", "boolean", "inner", "=", "false", ";", "// Whether we are currently parsing an inner class type.", "// Parses the signature, one character at a time.", "while", "(", "true", ")", "{", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "if", "(", "currentChar", "==", "'", "'", "||", "currentChar", "==", "'", "'", ")", "{", "// If a '.' or ';' is encountered, this means we have fully parsed the main class name", "// or an inner class name. This name may already have been visited it is was followed by", "// type arguments between '<' and '>'. If not, we need to visit it here.", "if", "(", "!", "visited", ")", "{", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "}", "// If we reached the end of the ClassTypeSignature return, otherwise start the parsing", "// of a new class name, which is necessarily an inner class name.", "if", "(", "currentChar", "==", "'", "'", ")", "{", "signatureVisitor", ".", "visitEnd", "(", ")", ";", "break", ";", "}", "start", "=", "offset", ";", "visited", "=", "false", ";", "inner", "=", "true", ";", "}", "else", "if", "(", "currentChar", "==", "'", "'", ")", "{", "// If a '<' is encountered, this means we have fully parsed the main class name or an", "// inner class name, and that we now need to parse TypeArguments. First, we need to", "// visit the parsed class name.", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "visited", "=", "true", ";", "// Now, parse the TypeArgument(s), one at a time.", "while", "(", "(", "currentChar", "=", "signature", ".", "charAt", "(", "offset", ")", ")", "!=", "'", "'", ")", "{", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "// Unbounded TypeArgument.", "++", "offset", ";", "signatureVisitor", ".", "visitTypeArgument", "(", ")", ";", "break", ";", "case", "'", "'", ":", "case", "'", "'", ":", "// Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.", "offset", "=", "parseType", "(", "signature", ",", "offset", "+", "1", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "currentChar", ")", ")", ";", "break", ";", "default", ":", "// Instanceof TypeArgument. The '=' is implicit.", "offset", "=", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "'", "'", ")", ")", ";", "break", ";", "}", "}", "}", "}", "return", "offset", ";", "default", ":", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "}"], "docstring": "Parses a JavaTypeSignature and makes the given visitor visit it.\n\n@param signature a string containing the signature that must be parsed.\n@param startOffset index of the first character of the signature to parsed.\n@param signatureVisitor the visitor that must visit this signature.\n@return the index of the first character after the parsed signature.", "docstring_tokens": ["Parses", "a", "JavaTypeSignature", "and", "makes", "the", "given", "visitor", "visit", "it", "."]}
{"code": "char currentChar = signature.charAt(offset++);", "comments": "The signature character at 'offset'.", "lines": 4, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm7/signature/SignatureReader.java", "func_name": "SignatureReader.parseType", "original_string": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "language": "java", "Allcodes": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "code_tokens": ["private", "static", "int", "parseType", "(", "final", "String", "signature", ",", "final", "int", "startOffset", ",", "final", "SignatureVisitor", "signatureVisitor", ")", "{", "int", "offset", "=", "startOffset", ";", "// Current offset in the parsed signature.", "char", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "// The signature character at 'offset'.", "// Switch based on the first character of the JavaTypeSignature, which indicates its kind.", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "// Case of a BaseType or a VoidDescriptor.", "signatureVisitor", ".", "visitBaseType", "(", "currentChar", ")", ";", "return", "offset", ";", "case", "'", "'", ":", "// Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.", "return", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitArrayType", "(", ")", ")", ";", "case", "'", "'", ":", "// Case of TypeVariableSignature, an identifier between 'T' and ';'.", "int", "endOffset", "=", "signature", ".", "indexOf", "(", "'", "'", ",", "offset", ")", ";", "signatureVisitor", ".", "visitTypeVariable", "(", "signature", ".", "substring", "(", "offset", ",", "endOffset", ")", ")", ";", "return", "endOffset", "+", "1", ";", "case", "'", "'", ":", "// Case of a ClassTypeSignature, which ends with ';'.", "// These signatures have a main class type followed by zero or more inner class types", "// (separated by '.'). Each can have type arguments, inside '<' and '>'.", "int", "start", "=", "offset", ";", "// The start offset of the currently parsed main or inner class name.", "boolean", "visited", "=", "false", ";", "// Whether the currently parsed class name has been visited.", "boolean", "inner", "=", "false", ";", "// Whether we are currently parsing an inner class type.", "// Parses the signature, one character at a time.", "while", "(", "true", ")", "{", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "if", "(", "currentChar", "==", "'", "'", "||", "currentChar", "==", "'", "'", ")", "{", "// If a '.' or ';' is encountered, this means we have fully parsed the main class name", "// or an inner class name. This name may already have been visited it is was followed by", "// type arguments between '<' and '>'. If not, we need to visit it here.", "if", "(", "!", "visited", ")", "{", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "}", "// If we reached the end of the ClassTypeSignature return, otherwise start the parsing", "// of a new class name, which is necessarily an inner class name.", "if", "(", "currentChar", "==", "'", "'", ")", "{", "signatureVisitor", ".", "visitEnd", "(", ")", ";", "break", ";", "}", "start", "=", "offset", ";", "visited", "=", "false", ";", "inner", "=", "true", ";", "}", "else", "if", "(", "currentChar", "==", "'", "'", ")", "{", "// If a '<' is encountered, this means we have fully parsed the main class name or an", "// inner class name, and that we now need to parse TypeArguments. First, we need to", "// visit the parsed class name.", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "visited", "=", "true", ";", "// Now, parse the TypeArgument(s), one at a time.", "while", "(", "(", "currentChar", "=", "signature", ".", "charAt", "(", "offset", ")", ")", "!=", "'", "'", ")", "{", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "// Unbounded TypeArgument.", "++", "offset", ";", "signatureVisitor", ".", "visitTypeArgument", "(", ")", ";", "break", ";", "case", "'", "'", ":", "case", "'", "'", ":", "// Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.", "offset", "=", "parseType", "(", "signature", ",", "offset", "+", "1", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "currentChar", ")", ")", ";", "break", ";", "default", ":", "// Instanceof TypeArgument. The '=' is implicit.", "offset", "=", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "'", "'", ")", ")", ";", "break", ";", "}", "}", "}", "}", "return", "offset", ";", "default", ":", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "}"], "docstring": "Parses a JavaTypeSignature and makes the given visitor visit it.\n\n@param signature a string containing the signature that must be parsed.\n@param startOffset index of the first character of the signature to parsed.\n@param signatureVisitor the visitor that must visit this signature.\n@return the index of the first character after the parsed signature.", "docstring_tokens": ["Parses", "a", "JavaTypeSignature", "and", "makes", "the", "given", "visitor", "visit", "it", "."]}
{"code": "int start = offset;", "comments": "The start offset of the currently parsed main or inner class name.", "lines": 35, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm7/signature/SignatureReader.java", "func_name": "SignatureReader.parseType", "original_string": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "language": "java", "Allcodes": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "code_tokens": ["private", "static", "int", "parseType", "(", "final", "String", "signature", ",", "final", "int", "startOffset", ",", "final", "SignatureVisitor", "signatureVisitor", ")", "{", "int", "offset", "=", "startOffset", ";", "// Current offset in the parsed signature.", "char", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "// The signature character at 'offset'.", "// Switch based on the first character of the JavaTypeSignature, which indicates its kind.", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "// Case of a BaseType or a VoidDescriptor.", "signatureVisitor", ".", "visitBaseType", "(", "currentChar", ")", ";", "return", "offset", ";", "case", "'", "'", ":", "// Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.", "return", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitArrayType", "(", ")", ")", ";", "case", "'", "'", ":", "// Case of TypeVariableSignature, an identifier between 'T' and ';'.", "int", "endOffset", "=", "signature", ".", "indexOf", "(", "'", "'", ",", "offset", ")", ";", "signatureVisitor", ".", "visitTypeVariable", "(", "signature", ".", "substring", "(", "offset", ",", "endOffset", ")", ")", ";", "return", "endOffset", "+", "1", ";", "case", "'", "'", ":", "// Case of a ClassTypeSignature, which ends with ';'.", "// These signatures have a main class type followed by zero or more inner class types", "// (separated by '.'). Each can have type arguments, inside '<' and '>'.", "int", "start", "=", "offset", ";", "// The start offset of the currently parsed main or inner class name.", "boolean", "visited", "=", "false", ";", "// Whether the currently parsed class name has been visited.", "boolean", "inner", "=", "false", ";", "// Whether we are currently parsing an inner class type.", "// Parses the signature, one character at a time.", "while", "(", "true", ")", "{", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "if", "(", "currentChar", "==", "'", "'", "||", "currentChar", "==", "'", "'", ")", "{", "// If a '.' or ';' is encountered, this means we have fully parsed the main class name", "// or an inner class name. This name may already have been visited it is was followed by", "// type arguments between '<' and '>'. If not, we need to visit it here.", "if", "(", "!", "visited", ")", "{", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "}", "// If we reached the end of the ClassTypeSignature return, otherwise start the parsing", "// of a new class name, which is necessarily an inner class name.", "if", "(", "currentChar", "==", "'", "'", ")", "{", "signatureVisitor", ".", "visitEnd", "(", ")", ";", "break", ";", "}", "start", "=", "offset", ";", "visited", "=", "false", ";", "inner", "=", "true", ";", "}", "else", "if", "(", "currentChar", "==", "'", "'", ")", "{", "// If a '<' is encountered, this means we have fully parsed the main class name or an", "// inner class name, and that we now need to parse TypeArguments. First, we need to", "// visit the parsed class name.", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "visited", "=", "true", ";", "// Now, parse the TypeArgument(s), one at a time.", "while", "(", "(", "currentChar", "=", "signature", ".", "charAt", "(", "offset", ")", ")", "!=", "'", "'", ")", "{", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "// Unbounded TypeArgument.", "++", "offset", ";", "signatureVisitor", ".", "visitTypeArgument", "(", ")", ";", "break", ";", "case", "'", "'", ":", "case", "'", "'", ":", "// Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.", "offset", "=", "parseType", "(", "signature", ",", "offset", "+", "1", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "currentChar", ")", ")", ";", "break", ";", "default", ":", "// Instanceof TypeArgument. The '=' is implicit.", "offset", "=", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "'", "'", ")", ")", ";", "break", ";", "}", "}", "}", "}", "return", "offset", ";", "default", ":", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "}"], "docstring": "Parses a JavaTypeSignature and makes the given visitor visit it.\n\n@param signature a string containing the signature that must be parsed.\n@param startOffset index of the first character of the signature to parsed.\n@param signatureVisitor the visitor that must visit this signature.\n@return the index of the first character after the parsed signature.", "docstring_tokens": ["Parses", "a", "JavaTypeSignature", "and", "makes", "the", "given", "visitor", "visit", "it", "."]}
{"code": "boolean visited = false;", "comments": "Whether the currently parsed class name has been visited.", "lines": 36, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm7/signature/SignatureReader.java", "func_name": "SignatureReader.parseType", "original_string": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "language": "java", "Allcodes": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "code_tokens": ["private", "static", "int", "parseType", "(", "final", "String", "signature", ",", "final", "int", "startOffset", ",", "final", "SignatureVisitor", "signatureVisitor", ")", "{", "int", "offset", "=", "startOffset", ";", "// Current offset in the parsed signature.", "char", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "// The signature character at 'offset'.", "// Switch based on the first character of the JavaTypeSignature, which indicates its kind.", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "// Case of a BaseType or a VoidDescriptor.", "signatureVisitor", ".", "visitBaseType", "(", "currentChar", ")", ";", "return", "offset", ";", "case", "'", "'", ":", "// Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.", "return", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitArrayType", "(", ")", ")", ";", "case", "'", "'", ":", "// Case of TypeVariableSignature, an identifier between 'T' and ';'.", "int", "endOffset", "=", "signature", ".", "indexOf", "(", "'", "'", ",", "offset", ")", ";", "signatureVisitor", ".", "visitTypeVariable", "(", "signature", ".", "substring", "(", "offset", ",", "endOffset", ")", ")", ";", "return", "endOffset", "+", "1", ";", "case", "'", "'", ":", "// Case of a ClassTypeSignature, which ends with ';'.", "// These signatures have a main class type followed by zero or more inner class types", "// (separated by '.'). Each can have type arguments, inside '<' and '>'.", "int", "start", "=", "offset", ";", "// The start offset of the currently parsed main or inner class name.", "boolean", "visited", "=", "false", ";", "// Whether the currently parsed class name has been visited.", "boolean", "inner", "=", "false", ";", "// Whether we are currently parsing an inner class type.", "// Parses the signature, one character at a time.", "while", "(", "true", ")", "{", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "if", "(", "currentChar", "==", "'", "'", "||", "currentChar", "==", "'", "'", ")", "{", "// If a '.' or ';' is encountered, this means we have fully parsed the main class name", "// or an inner class name. This name may already have been visited it is was followed by", "// type arguments between '<' and '>'. If not, we need to visit it here.", "if", "(", "!", "visited", ")", "{", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "}", "// If we reached the end of the ClassTypeSignature return, otherwise start the parsing", "// of a new class name, which is necessarily an inner class name.", "if", "(", "currentChar", "==", "'", "'", ")", "{", "signatureVisitor", ".", "visitEnd", "(", ")", ";", "break", ";", "}", "start", "=", "offset", ";", "visited", "=", "false", ";", "inner", "=", "true", ";", "}", "else", "if", "(", "currentChar", "==", "'", "'", ")", "{", "// If a '<' is encountered, this means we have fully parsed the main class name or an", "// inner class name, and that we now need to parse TypeArguments. First, we need to", "// visit the parsed class name.", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "visited", "=", "true", ";", "// Now, parse the TypeArgument(s), one at a time.", "while", "(", "(", "currentChar", "=", "signature", ".", "charAt", "(", "offset", ")", ")", "!=", "'", "'", ")", "{", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "// Unbounded TypeArgument.", "++", "offset", ";", "signatureVisitor", ".", "visitTypeArgument", "(", ")", ";", "break", ";", "case", "'", "'", ":", "case", "'", "'", ":", "// Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.", "offset", "=", "parseType", "(", "signature", ",", "offset", "+", "1", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "currentChar", ")", ")", ";", "break", ";", "default", ":", "// Instanceof TypeArgument. The '=' is implicit.", "offset", "=", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "'", "'", ")", ")", ";", "break", ";", "}", "}", "}", "}", "return", "offset", ";", "default", ":", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "}"], "docstring": "Parses a JavaTypeSignature and makes the given visitor visit it.\n\n@param signature a string containing the signature that must be parsed.\n@param startOffset index of the first character of the signature to parsed.\n@param signatureVisitor the visitor that must visit this signature.\n@return the index of the first character after the parsed signature.", "docstring_tokens": ["Parses", "a", "JavaTypeSignature", "and", "makes", "the", "given", "visitor", "visit", "it", "."]}
{"code": "boolean inner = false;", "comments": "Whether we are currently parsing an inner class type.", "lines": 37, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/asm7/signature/SignatureReader.java", "func_name": "SignatureReader.parseType", "original_string": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "language": "java", "Allcodes": "private static int parseType(\n      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {\n    int offset = startOffset; // Current offset in the parsed signature.\n    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.\n\n    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.\n    switch (currentChar) {\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n      case 'F':\n      case 'J':\n      case 'D':\n      case 'V':\n        // Case of a BaseType or a VoidDescriptor.\n        signatureVisitor.visitBaseType(currentChar);\n        return offset;\n\n      case '[':\n        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.\n        return parseType(signature, offset, signatureVisitor.visitArrayType());\n\n      case 'T':\n        // Case of TypeVariableSignature, an identifier between 'T' and ';'.\n        int endOffset = signature.indexOf(';', offset);\n        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));\n        return endOffset + 1;\n\n      case 'L':\n        // Case of a ClassTypeSignature, which ends with ';'.\n        // These signatures have a main class type followed by zero or more inner class types\n        // (separated by '.'). Each can have type arguments, inside '<' and '>'.\n        int start = offset; // The start offset of the currently parsed main or inner class name.\n        boolean visited = false; // Whether the currently parsed class name has been visited.\n        boolean inner = false; // Whether we are currently parsing an inner class type.\n        // Parses the signature, one character at a time.\n        while (true) {\n          currentChar = signature.charAt(offset++);\n          if (currentChar == '.' || currentChar == ';') {\n            // If a '.' or ';' is encountered, this means we have fully parsed the main class name\n            // or an inner class name. This name may already have been visited it is was followed by\n            // type arguments between '<' and '>'. If not, we need to visit it here.\n            if (!visited) {\n              String name = signature.substring(start, offset - 1);\n              if (inner) {\n                signatureVisitor.visitInnerClassType(name);\n              } else {\n                signatureVisitor.visitClassType(name);\n              }\n            }\n            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing\n            // of a new class name, which is necessarily an inner class name.\n            if (currentChar == ';') {\n              signatureVisitor.visitEnd();\n              break;\n            }\n            start = offset;\n            visited = false;\n            inner = true;\n          } else if (currentChar == '<') {\n            // If a '<' is encountered, this means we have fully parsed the main class name or an\n            // inner class name, and that we now need to parse TypeArguments. First, we need to\n            // visit the parsed class name.\n            String name = signature.substring(start, offset - 1);\n            if (inner) {\n              signatureVisitor.visitInnerClassType(name);\n            } else {\n              signatureVisitor.visitClassType(name);\n            }\n            visited = true;\n            // Now, parse the TypeArgument(s), one at a time.\n            while ((currentChar = signature.charAt(offset)) != '>') {\n              switch (currentChar) {\n                case '*':\n                  // Unbounded TypeArgument.\n                  ++offset;\n                  signatureVisitor.visitTypeArgument();\n                  break;\n                case '+':\n                case '-':\n                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.\n                  offset =\n                      parseType(\n                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));\n                  break;\n                default:\n                  // Instanceof TypeArgument. The '=' is implicit.\n                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));\n                  break;\n              }\n            }\n          }\n        }\n        return offset;\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }", "code_tokens": ["private", "static", "int", "parseType", "(", "final", "String", "signature", ",", "final", "int", "startOffset", ",", "final", "SignatureVisitor", "signatureVisitor", ")", "{", "int", "offset", "=", "startOffset", ";", "// Current offset in the parsed signature.", "char", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "// The signature character at 'offset'.", "// Switch based on the first character of the JavaTypeSignature, which indicates its kind.", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "// Case of a BaseType or a VoidDescriptor.", "signatureVisitor", ".", "visitBaseType", "(", "currentChar", ")", ";", "return", "offset", ";", "case", "'", "'", ":", "// Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.", "return", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitArrayType", "(", ")", ")", ";", "case", "'", "'", ":", "// Case of TypeVariableSignature, an identifier between 'T' and ';'.", "int", "endOffset", "=", "signature", ".", "indexOf", "(", "'", "'", ",", "offset", ")", ";", "signatureVisitor", ".", "visitTypeVariable", "(", "signature", ".", "substring", "(", "offset", ",", "endOffset", ")", ")", ";", "return", "endOffset", "+", "1", ";", "case", "'", "'", ":", "// Case of a ClassTypeSignature, which ends with ';'.", "// These signatures have a main class type followed by zero or more inner class types", "// (separated by '.'). Each can have type arguments, inside '<' and '>'.", "int", "start", "=", "offset", ";", "// The start offset of the currently parsed main or inner class name.", "boolean", "visited", "=", "false", ";", "// Whether the currently parsed class name has been visited.", "boolean", "inner", "=", "false", ";", "// Whether we are currently parsing an inner class type.", "// Parses the signature, one character at a time.", "while", "(", "true", ")", "{", "currentChar", "=", "signature", ".", "charAt", "(", "offset", "++", ")", ";", "if", "(", "currentChar", "==", "'", "'", "||", "currentChar", "==", "'", "'", ")", "{", "// If a '.' or ';' is encountered, this means we have fully parsed the main class name", "// or an inner class name. This name may already have been visited it is was followed by", "// type arguments between '<' and '>'. If not, we need to visit it here.", "if", "(", "!", "visited", ")", "{", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "}", "// If we reached the end of the ClassTypeSignature return, otherwise start the parsing", "// of a new class name, which is necessarily an inner class name.", "if", "(", "currentChar", "==", "'", "'", ")", "{", "signatureVisitor", ".", "visitEnd", "(", ")", ";", "break", ";", "}", "start", "=", "offset", ";", "visited", "=", "false", ";", "inner", "=", "true", ";", "}", "else", "if", "(", "currentChar", "==", "'", "'", ")", "{", "// If a '<' is encountered, this means we have fully parsed the main class name or an", "// inner class name, and that we now need to parse TypeArguments. First, we need to", "// visit the parsed class name.", "String", "name", "=", "signature", ".", "substring", "(", "start", ",", "offset", "-", "1", ")", ";", "if", "(", "inner", ")", "{", "signatureVisitor", ".", "visitInnerClassType", "(", "name", ")", ";", "}", "else", "{", "signatureVisitor", ".", "visitClassType", "(", "name", ")", ";", "}", "visited", "=", "true", ";", "// Now, parse the TypeArgument(s), one at a time.", "while", "(", "(", "currentChar", "=", "signature", ".", "charAt", "(", "offset", ")", ")", "!=", "'", "'", ")", "{", "switch", "(", "currentChar", ")", "{", "case", "'", "'", ":", "// Unbounded TypeArgument.", "++", "offset", ";", "signatureVisitor", ".", "visitTypeArgument", "(", ")", ";", "break", ";", "case", "'", "'", ":", "case", "'", "'", ":", "// Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.", "offset", "=", "parseType", "(", "signature", ",", "offset", "+", "1", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "currentChar", ")", ")", ";", "break", ";", "default", ":", "// Instanceof TypeArgument. The '=' is implicit.", "offset", "=", "parseType", "(", "signature", ",", "offset", ",", "signatureVisitor", ".", "visitTypeArgument", "(", "'", "'", ")", ")", ";", "break", ";", "}", "}", "}", "}", "return", "offset", ";", "default", ":", "throw", "new", "IllegalArgumentException", "(", ")", ";", "}", "}"], "docstring": "Parses a JavaTypeSignature and makes the given visitor visit it.\n\n@param signature a string containing the signature that must be parsed.\n@param startOffset index of the first character of the signature to parsed.\n@param signatureVisitor the visitor that must visit this signature.\n@return the index of the first character after the parsed signature.", "docstring_tokens": ["Parses", "a", "JavaTypeSignature", "and", "makes", "the", "given", "visitor", "visit", "it", "."]}
{"code": "superClassReaders.add(cr);", "comments": "remember the super class reader", "lines": 33, "repo": "oblac/jodd", "path": "jodd-proxetta/src/main/java/jodd/proxetta/asm/TargetClassInfoReader.java", "func_name": "TargetClassInfoReader.visitEnd", "original_string": "@Override\n\tpublic void visitEnd() {\n\n\t\t// prepare class annotations\n\t\tif (classAnnotations != null) {\n\t\t\tannotations = classAnnotations.toArray(new AnnotationInfo[0]);\n\t\t\tclassAnnotations = null;\n\t\t}\n\n\t\tList<String> superList = new ArrayList<>();\n\n\t\tSet<String> allInterfaces = new HashSet<>();\n\n\t\tif (nextInterfaces != null) {\n\t\t\tallInterfaces.addAll(nextInterfaces);\n\t\t}\n\n\t\t// check all public super methods that are not overridden in superclass\n\t\twhile (nextSupername != null) {\n\t\t\tInputStream inputStream = null;\n\t\t\tClassReader cr;\n\n\t\t\ttry {\n\t\t\t\tinputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader);\n\t\t\t\tcr = new ClassReader(inputStream);\n\t\t\t} catch (IOException ioex) {\n\t\t\t\tthrow new ProxettaException(\"Unable to inspect super class: \" + nextSupername, ioex);\n\t\t\t} finally {\n\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t}\n\n\t\t\tsuperList.add(nextSupername);\n\t\t\tsuperClassReaders.add(cr);\t// remember the super class reader\n\t\t\tcr.accept(new SuperClassVisitor(), 0);\n\n\t\t\tif (cr.getInterfaces() != null) {\n\t\t\t\tCollections.addAll(allInterfaces, cr.getInterfaces());\n\t\t\t}\n\t\t}\n\t\tsuperClasses = superList.toArray(new String[0]);\n\n\t\t// check all interface methods that are not overridden in super-interface\n\n\t\tSet<String> todoInterfaces = new HashSet<>(allInterfaces);\n\t\tSet<String> newCollectedInterfaces = new HashSet<>();\n\n\t\twhile (true) {\n\n\t\t\tfor (String next : todoInterfaces) {\n\t\t\t\tInputStream inputStream = null;\n\t\t\t\tClassReader cr;\n\t\t\t\ttry {\n\t\t\t\t\tinputStream = ClassLoaderUtil.getClassAsStream(next, classLoader);\n\t\t\t\t\tcr = new ClassReader(inputStream);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioex) {\n\t\t\t\t\tthrow new ProxettaException(\"Unable to inspect super interface: \" + next, ioex);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t\t}\n\t\t\t\tsuperClassReaders.add(cr);\t\t\t\t// remember the super class reader\n\t\t\t\tcr.accept(new SuperClassVisitor(), 0);\n\n\t\t\t\tif (cr.getInterfaces() != null) {\n\t\t\t\t\tfor (String newInterface : cr.getInterfaces()) {\n\t\t\t\t\t\tif (!allInterfaces.contains(newInterface) && !todoInterfaces.contains(newInterface)) {\n\t\t\t\t\t\t\t// new interface found\n\t\t\t\t\t\t\tnewCollectedInterfaces.add(newInterface);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// perform collection\n\t\t\tallInterfaces.addAll(todoInterfaces);\n\n\t\t\tif (newCollectedInterfaces.isEmpty()) {\n\t\t\t\t// no new interface found\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttodoInterfaces.clear();\n\t\t\ttodoInterfaces.addAll(newCollectedInterfaces);\n\n\t\t\tnewCollectedInterfaces.clear();\n\t\t}\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic void visitEnd() {\n\n\t\t// prepare class annotations\n\t\tif (classAnnotations != null) {\n\t\t\tannotations = classAnnotations.toArray(new AnnotationInfo[0]);\n\t\t\tclassAnnotations = null;\n\t\t}\n\n\t\tList<String> superList = new ArrayList<>();\n\n\t\tSet<String> allInterfaces = new HashSet<>();\n\n\t\tif (nextInterfaces != null) {\n\t\t\tallInterfaces.addAll(nextInterfaces);\n\t\t}\n\n\t\t// check all public super methods that are not overridden in superclass\n\t\twhile (nextSupername != null) {\n\t\t\tInputStream inputStream = null;\n\t\t\tClassReader cr;\n\n\t\t\ttry {\n\t\t\t\tinputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader);\n\t\t\t\tcr = new ClassReader(inputStream);\n\t\t\t} catch (IOException ioex) {\n\t\t\t\tthrow new ProxettaException(\"Unable to inspect super class: \" + nextSupername, ioex);\n\t\t\t} finally {\n\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t}\n\n\t\t\tsuperList.add(nextSupername);\n\t\t\tsuperClassReaders.add(cr);\t// remember the super class reader\n\t\t\tcr.accept(new SuperClassVisitor(), 0);\n\n\t\t\tif (cr.getInterfaces() != null) {\n\t\t\t\tCollections.addAll(allInterfaces, cr.getInterfaces());\n\t\t\t}\n\t\t}\n\t\tsuperClasses = superList.toArray(new String[0]);\n\n\t\t// check all interface methods that are not overridden in super-interface\n\n\t\tSet<String> todoInterfaces = new HashSet<>(allInterfaces);\n\t\tSet<String> newCollectedInterfaces = new HashSet<>();\n\n\t\twhile (true) {\n\n\t\t\tfor (String next : todoInterfaces) {\n\t\t\t\tInputStream inputStream = null;\n\t\t\t\tClassReader cr;\n\t\t\t\ttry {\n\t\t\t\t\tinputStream = ClassLoaderUtil.getClassAsStream(next, classLoader);\n\t\t\t\t\tcr = new ClassReader(inputStream);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioex) {\n\t\t\t\t\tthrow new ProxettaException(\"Unable to inspect super interface: \" + next, ioex);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.close(inputStream);\n\t\t\t\t}\n\t\t\t\tsuperClassReaders.add(cr);\t\t\t\t// remember the super class reader\n\t\t\t\tcr.accept(new SuperClassVisitor(), 0);\n\n\t\t\t\tif (cr.getInterfaces() != null) {\n\t\t\t\t\tfor (String newInterface : cr.getInterfaces()) {\n\t\t\t\t\t\tif (!allInterfaces.contains(newInterface) && !todoInterfaces.contains(newInterface)) {\n\t\t\t\t\t\t\t// new interface found\n\t\t\t\t\t\t\tnewCollectedInterfaces.add(newInterface);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// perform collection\n\t\t\tallInterfaces.addAll(todoInterfaces);\n\n\t\t\tif (newCollectedInterfaces.isEmpty()) {\n\t\t\t\t// no new interface found\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttodoInterfaces.clear();\n\t\t\ttodoInterfaces.addAll(newCollectedInterfaces);\n\n\t\t\tnewCollectedInterfaces.clear();\n\t\t}\n\t}", "code_tokens": ["@", "Override", "public", "void", "visitEnd", "(", ")", "{", "// prepare class annotations", "if", "(", "classAnnotations", "!=", "null", ")", "{", "annotations", "=", "classAnnotations", ".", "toArray", "(", "new", "AnnotationInfo", "[", "0", "]", ")", ";", "classAnnotations", "=", "null", ";", "}", "List", "<", "String", ">", "superList", "=", "new", "ArrayList", "<>", "(", ")", ";", "Set", "<", "String", ">", "allInterfaces", "=", "new", "HashSet", "<>", "(", ")", ";", "if", "(", "nextInterfaces", "!=", "null", ")", "{", "allInterfaces", ".", "addAll", "(", "nextInterfaces", ")", ";", "}", "// check all public super methods that are not overridden in superclass", "while", "(", "nextSupername", "!=", "null", ")", "{", "InputStream", "inputStream", "=", "null", ";", "ClassReader", "cr", ";", "try", "{", "inputStream", "=", "ClassLoaderUtil", ".", "getClassAsStream", "(", "nextSupername", ",", "classLoader", ")", ";", "cr", "=", "new", "ClassReader", "(", "inputStream", ")", ";", "}", "catch", "(", "IOException", "ioex", ")", "{", "throw", "new", "ProxettaException", "(", "\"Unable to inspect super class: \"", "+", "nextSupername", ",", "ioex", ")", ";", "}", "finally", "{", "StreamUtil", ".", "close", "(", "inputStream", ")", ";", "}", "superList", ".", "add", "(", "nextSupername", ")", ";", "superClassReaders", ".", "add", "(", "cr", ")", ";", "// remember the super class reader", "cr", ".", "accept", "(", "new", "SuperClassVisitor", "(", ")", ",", "0", ")", ";", "if", "(", "cr", ".", "getInterfaces", "(", ")", "!=", "null", ")", "{", "Collections", ".", "addAll", "(", "allInterfaces", ",", "cr", ".", "getInterfaces", "(", ")", ")", ";", "}", "}", "superClasses", "=", "superList", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ";", "// check all interface methods that are not overridden in super-interface", "Set", "<", "String", ">", "todoInterfaces", "=", "new", "HashSet", "<>", "(", "allInterfaces", ")", ";", "Set", "<", "String", ">", "newCollectedInterfaces", "=", "new", "HashSet", "<>", "(", ")", ";", "while", "(", "true", ")", "{", "for", "(", "String", "next", ":", "todoInterfaces", ")", "{", "InputStream", "inputStream", "=", "null", ";", "ClassReader", "cr", ";", "try", "{", "inputStream", "=", "ClassLoaderUtil", ".", "getClassAsStream", "(", "next", ",", "classLoader", ")", ";", "cr", "=", "new", "ClassReader", "(", "inputStream", ")", ";", "}", "catch", "(", "IOException", "ioex", ")", "{", "throw", "new", "ProxettaException", "(", "\"Unable to inspect super interface: \"", "+", "next", ",", "ioex", ")", ";", "}", "finally", "{", "StreamUtil", ".", "close", "(", "inputStream", ")", ";", "}", "superClassReaders", ".", "add", "(", "cr", ")", ";", "// remember the super class reader", "cr", ".", "accept", "(", "new", "SuperClassVisitor", "(", ")", ",", "0", ")", ";", "if", "(", "cr", ".", "getInterfaces", "(", ")", "!=", "null", ")", "{", "for", "(", "String", "newInterface", ":", "cr", ".", "getInterfaces", "(", ")", ")", "{", "if", "(", "!", "allInterfaces", ".", "contains", "(", "newInterface", ")", "&&", "!", "todoInterfaces", ".", "contains", "(", "newInterface", ")", ")", "{", "// new interface found", "newCollectedInterfaces", ".", "add", "(", "newInterface", ")", ";", "}", "}", "}", "}", "// perform collection", "allInterfaces", ".", "addAll", "(", "todoInterfaces", ")", ";", "if", "(", "newCollectedInterfaces", ".", "isEmpty", "(", ")", ")", "{", "// no new interface found", "break", ";", "}", "todoInterfaces", ".", "clear", "(", ")", ";", "todoInterfaces", ".", "addAll", "(", "newCollectedInterfaces", ")", ";", "newCollectedInterfaces", ".", "clear", "(", ")", ";", "}", "}"], "docstring": "Stores signatures for all super public methods not already overridden by target class.\nAll this methods will be accepted for proxyfication.", "docstring_tokens": ["Stores", "signatures", "for", "all", "super", "public", "methods", "not", "already", "overridden", "by", "target", "class", ".", "All", "this", "methods", "will", "be", "accepted", "for", "proxyfication", "."]}
{"code": "i++;", "comments": "and skip the comma", "lines": 20, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/util/CsvUtil.java", "func_name": "CsvUtil.toStringArray", "original_string": "public static String[] toStringArray(final String line) {\n\t\tList<String> row = new ArrayList<>();\n\n        boolean inQuotedField = false;\n        int fieldStart = 0;\n\n        final int len = line.length();\n        for (int i = 0; i < len; i++) {\n            char c = line.charAt(i);\n            if (c == FIELD_SEPARATOR) {\n                if (!inQuotedField) {\t// ignore we are quoting\n                    addField(row, line, fieldStart, i, inQuotedField);\n                    fieldStart = i + 1;\n                }\n            } else if (c == FIELD_QUOTE) {\n                if (inQuotedField) {\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\t// we are already quoting - peek to see if this is the end of the field\n                        addField(row, line, fieldStart, i, inQuotedField);\n                        fieldStart = i + 2;\n                        i++; // and skip the comma\n                        inQuotedField = false;\n                    }\n                } else if (fieldStart == i) {\n                    inQuotedField = true;\t// this is a beginning of a quote\n                    fieldStart++;\t\t\t// move field start\n                }\n            }\n        }\n        // add last field - but only if string was not empty\n        if (len > 0 && fieldStart <= len) {\n            addField(row, line, fieldStart, len, inQuotedField);\n        }\n        return row.toArray(new String[0]);\n\t}", "language": "java", "Allcodes": "public static String[] toStringArray(final String line) {\n\t\tList<String> row = new ArrayList<>();\n\n        boolean inQuotedField = false;\n        int fieldStart = 0;\n\n        final int len = line.length();\n        for (int i = 0; i < len; i++) {\n            char c = line.charAt(i);\n            if (c == FIELD_SEPARATOR) {\n                if (!inQuotedField) {\t// ignore we are quoting\n                    addField(row, line, fieldStart, i, inQuotedField);\n                    fieldStart = i + 1;\n                }\n            } else if (c == FIELD_QUOTE) {\n                if (inQuotedField) {\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\t// we are already quoting - peek to see if this is the end of the field\n                        addField(row, line, fieldStart, i, inQuotedField);\n                        fieldStart = i + 2;\n                        i++; // and skip the comma\n                        inQuotedField = false;\n                    }\n                } else if (fieldStart == i) {\n                    inQuotedField = true;\t// this is a beginning of a quote\n                    fieldStart++;\t\t\t// move field start\n                }\n            }\n        }\n        // add last field - but only if string was not empty\n        if (len > 0 && fieldStart <= len) {\n            addField(row, line, fieldStart, len, inQuotedField);\n        }\n        return row.toArray(new String[0]);\n\t}", "code_tokens": ["public", "static", "String", "[", "]", "toStringArray", "(", "final", "String", "line", ")", "{", "List", "<", "String", ">", "row", "=", "new", "ArrayList", "<>", "(", ")", ";", "boolean", "inQuotedField", "=", "false", ";", "int", "fieldStart", "=", "0", ";", "final", "int", "len", "=", "line", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "c", "=", "line", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "FIELD_SEPARATOR", ")", "{", "if", "(", "!", "inQuotedField", ")", "{", "// ignore we are quoting", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "i", ",", "inQuotedField", ")", ";", "fieldStart", "=", "i", "+", "1", ";", "}", "}", "else", "if", "(", "c", "==", "FIELD_QUOTE", ")", "{", "if", "(", "inQuotedField", ")", "{", "if", "(", "i", "+", "1", "==", "len", "||", "line", ".", "charAt", "(", "i", "+", "1", ")", "==", "FIELD_SEPARATOR", ")", "{", "// we are already quoting - peek to see if this is the end of the field", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "i", ",", "inQuotedField", ")", ";", "fieldStart", "=", "i", "+", "2", ";", "i", "++", ";", "// and skip the comma", "inQuotedField", "=", "false", ";", "}", "}", "else", "if", "(", "fieldStart", "==", "i", ")", "{", "inQuotedField", "=", "true", ";", "// this is a beginning of a quote", "fieldStart", "++", ";", "// move field start", "}", "}", "}", "// add last field - but only if string was not empty", "if", "(", "len", ">", "0", "&&", "fieldStart", "<=", "len", ")", "{", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "len", ",", "inQuotedField", ")", ";", "}", "return", "row", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ";", "}"], "docstring": "Converts CSV line to string array.", "docstring_tokens": ["Converts", "CSV", "line", "to", "string", "array", "."]}
{"code": "inQuotedField = true;", "comments": "this is a beginning of a quote", "lines": 24, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/util/CsvUtil.java", "func_name": "CsvUtil.toStringArray", "original_string": "public static String[] toStringArray(final String line) {\n\t\tList<String> row = new ArrayList<>();\n\n        boolean inQuotedField = false;\n        int fieldStart = 0;\n\n        final int len = line.length();\n        for (int i = 0; i < len; i++) {\n            char c = line.charAt(i);\n            if (c == FIELD_SEPARATOR) {\n                if (!inQuotedField) {\t// ignore we are quoting\n                    addField(row, line, fieldStart, i, inQuotedField);\n                    fieldStart = i + 1;\n                }\n            } else if (c == FIELD_QUOTE) {\n                if (inQuotedField) {\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\t// we are already quoting - peek to see if this is the end of the field\n                        addField(row, line, fieldStart, i, inQuotedField);\n                        fieldStart = i + 2;\n                        i++; // and skip the comma\n                        inQuotedField = false;\n                    }\n                } else if (fieldStart == i) {\n                    inQuotedField = true;\t// this is a beginning of a quote\n                    fieldStart++;\t\t\t// move field start\n                }\n            }\n        }\n        // add last field - but only if string was not empty\n        if (len > 0 && fieldStart <= len) {\n            addField(row, line, fieldStart, len, inQuotedField);\n        }\n        return row.toArray(new String[0]);\n\t}", "language": "java", "Allcodes": "public static String[] toStringArray(final String line) {\n\t\tList<String> row = new ArrayList<>();\n\n        boolean inQuotedField = false;\n        int fieldStart = 0;\n\n        final int len = line.length();\n        for (int i = 0; i < len; i++) {\n            char c = line.charAt(i);\n            if (c == FIELD_SEPARATOR) {\n                if (!inQuotedField) {\t// ignore we are quoting\n                    addField(row, line, fieldStart, i, inQuotedField);\n                    fieldStart = i + 1;\n                }\n            } else if (c == FIELD_QUOTE) {\n                if (inQuotedField) {\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\t// we are already quoting - peek to see if this is the end of the field\n                        addField(row, line, fieldStart, i, inQuotedField);\n                        fieldStart = i + 2;\n                        i++; // and skip the comma\n                        inQuotedField = false;\n                    }\n                } else if (fieldStart == i) {\n                    inQuotedField = true;\t// this is a beginning of a quote\n                    fieldStart++;\t\t\t// move field start\n                }\n            }\n        }\n        // add last field - but only if string was not empty\n        if (len > 0 && fieldStart <= len) {\n            addField(row, line, fieldStart, len, inQuotedField);\n        }\n        return row.toArray(new String[0]);\n\t}", "code_tokens": ["public", "static", "String", "[", "]", "toStringArray", "(", "final", "String", "line", ")", "{", "List", "<", "String", ">", "row", "=", "new", "ArrayList", "<>", "(", ")", ";", "boolean", "inQuotedField", "=", "false", ";", "int", "fieldStart", "=", "0", ";", "final", "int", "len", "=", "line", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "c", "=", "line", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "FIELD_SEPARATOR", ")", "{", "if", "(", "!", "inQuotedField", ")", "{", "// ignore we are quoting", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "i", ",", "inQuotedField", ")", ";", "fieldStart", "=", "i", "+", "1", ";", "}", "}", "else", "if", "(", "c", "==", "FIELD_QUOTE", ")", "{", "if", "(", "inQuotedField", ")", "{", "if", "(", "i", "+", "1", "==", "len", "||", "line", ".", "charAt", "(", "i", "+", "1", ")", "==", "FIELD_SEPARATOR", ")", "{", "// we are already quoting - peek to see if this is the end of the field", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "i", ",", "inQuotedField", ")", ";", "fieldStart", "=", "i", "+", "2", ";", "i", "++", ";", "// and skip the comma", "inQuotedField", "=", "false", ";", "}", "}", "else", "if", "(", "fieldStart", "==", "i", ")", "{", "inQuotedField", "=", "true", ";", "// this is a beginning of a quote", "fieldStart", "++", ";", "// move field start", "}", "}", "}", "// add last field - but only if string was not empty", "if", "(", "len", ">", "0", "&&", "fieldStart", "<=", "len", ")", "{", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "len", ",", "inQuotedField", ")", ";", "}", "return", "row", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ";", "}"], "docstring": "Converts CSV line to string array.", "docstring_tokens": ["Converts", "CSV", "line", "to", "string", "array", "."]}
{"code": "fieldStart++;", "comments": "move field start", "lines": 25, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/util/CsvUtil.java", "func_name": "CsvUtil.toStringArray", "original_string": "public static String[] toStringArray(final String line) {\n\t\tList<String> row = new ArrayList<>();\n\n        boolean inQuotedField = false;\n        int fieldStart = 0;\n\n        final int len = line.length();\n        for (int i = 0; i < len; i++) {\n            char c = line.charAt(i);\n            if (c == FIELD_SEPARATOR) {\n                if (!inQuotedField) {\t// ignore we are quoting\n                    addField(row, line, fieldStart, i, inQuotedField);\n                    fieldStart = i + 1;\n                }\n            } else if (c == FIELD_QUOTE) {\n                if (inQuotedField) {\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\t// we are already quoting - peek to see if this is the end of the field\n                        addField(row, line, fieldStart, i, inQuotedField);\n                        fieldStart = i + 2;\n                        i++; // and skip the comma\n                        inQuotedField = false;\n                    }\n                } else if (fieldStart == i) {\n                    inQuotedField = true;\t// this is a beginning of a quote\n                    fieldStart++;\t\t\t// move field start\n                }\n            }\n        }\n        // add last field - but only if string was not empty\n        if (len > 0 && fieldStart <= len) {\n            addField(row, line, fieldStart, len, inQuotedField);\n        }\n        return row.toArray(new String[0]);\n\t}", "language": "java", "Allcodes": "public static String[] toStringArray(final String line) {\n\t\tList<String> row = new ArrayList<>();\n\n        boolean inQuotedField = false;\n        int fieldStart = 0;\n\n        final int len = line.length();\n        for (int i = 0; i < len; i++) {\n            char c = line.charAt(i);\n            if (c == FIELD_SEPARATOR) {\n                if (!inQuotedField) {\t// ignore we are quoting\n                    addField(row, line, fieldStart, i, inQuotedField);\n                    fieldStart = i + 1;\n                }\n            } else if (c == FIELD_QUOTE) {\n                if (inQuotedField) {\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\t// we are already quoting - peek to see if this is the end of the field\n                        addField(row, line, fieldStart, i, inQuotedField);\n                        fieldStart = i + 2;\n                        i++; // and skip the comma\n                        inQuotedField = false;\n                    }\n                } else if (fieldStart == i) {\n                    inQuotedField = true;\t// this is a beginning of a quote\n                    fieldStart++;\t\t\t// move field start\n                }\n            }\n        }\n        // add last field - but only if string was not empty\n        if (len > 0 && fieldStart <= len) {\n            addField(row, line, fieldStart, len, inQuotedField);\n        }\n        return row.toArray(new String[0]);\n\t}", "code_tokens": ["public", "static", "String", "[", "]", "toStringArray", "(", "final", "String", "line", ")", "{", "List", "<", "String", ">", "row", "=", "new", "ArrayList", "<>", "(", ")", ";", "boolean", "inQuotedField", "=", "false", ";", "int", "fieldStart", "=", "0", ";", "final", "int", "len", "=", "line", ".", "length", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "c", "=", "line", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "FIELD_SEPARATOR", ")", "{", "if", "(", "!", "inQuotedField", ")", "{", "// ignore we are quoting", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "i", ",", "inQuotedField", ")", ";", "fieldStart", "=", "i", "+", "1", ";", "}", "}", "else", "if", "(", "c", "==", "FIELD_QUOTE", ")", "{", "if", "(", "inQuotedField", ")", "{", "if", "(", "i", "+", "1", "==", "len", "||", "line", ".", "charAt", "(", "i", "+", "1", ")", "==", "FIELD_SEPARATOR", ")", "{", "// we are already quoting - peek to see if this is the end of the field", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "i", ",", "inQuotedField", ")", ";", "fieldStart", "=", "i", "+", "2", ";", "i", "++", ";", "// and skip the comma", "inQuotedField", "=", "false", ";", "}", "}", "else", "if", "(", "fieldStart", "==", "i", ")", "{", "inQuotedField", "=", "true", ";", "// this is a beginning of a quote", "fieldStart", "++", ";", "// move field start", "}", "}", "}", "// add last field - but only if string was not empty", "if", "(", "len", ">", "0", "&&", "fieldStart", "<=", "len", ")", "{", "addField", "(", "row", ",", "line", ",", "fieldStart", ",", "len", ",", "inQuotedField", ")", ";", "}", "return", "row", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ";", "}"], "docstring": "Converts CSV line to string array.", "docstring_tokens": ["Converts", "CSV", "line", "to", "string", "array", "."]}
{"code": "defaultCtor = ctor;", "comments": "detects default ctors", "lines": 14, "repo": "oblac/jodd", "path": "jodd-petite/src/main/java/jodd/petite/resolver/CtorResolver.java", "func_name": "CtorResolver.resolve", "original_string": "public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) {\n\t\t// lookup methods\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(type);\n\t\tCtorDescriptor[] allCtors = cd.getAllCtorDescriptors();\n\t\tConstructor foundedCtor = null;\n\t\tConstructor defaultCtor = null;\n\t\tBeanReferences[] references = null;\n\n\t\tfor (CtorDescriptor ctorDescriptor : allCtors) {\n\t\t\tConstructor<?> ctor = ctorDescriptor.getConstructor();\n\n\t\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\t\tif (paramTypes.length == 0) {\n\t\t\t\tdefaultCtor = ctor;     // detects default ctors\n\t\t\t}\n\n\t\t\tif (!useAnnotation) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor);\n\n\t\t\tif (ctorReferences == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (foundedCtor != null) {\n\t\t\t\tthrow new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName());\n\t\t\t}\n\n\t\t\tfoundedCtor = ctor;\n\t\t\treferences = ctorReferences;\n\t\t}\n\n\t\tif (foundedCtor == null) {\n\t\t\t// there is no annotated constructor\n\t\t\tif (allCtors.length == 1) {\n\t\t\t\tfoundedCtor = allCtors[0].getConstructor();\n\t\t\t} else {\n\t\t\t\tfoundedCtor = defaultCtor;\n\t\t\t}\n\n\t\t\tif (foundedCtor == null) {\n\t\t\t\t// no matching ctor found\n\t\t\t\t// still this is not an error if bean is already instantiated.\n\t\t\t\treturn CtorInjectionPoint.EMPTY;\n\t\t\t}\n\n\t\t\treferences = referencesResolver.readAllReferencesFromAnnotation(foundedCtor);\n\n\t\t\tif (references == null) {\n\t\t\t\treferences = new BeanReferences[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new CtorInjectionPoint(foundedCtor, references);\n\t}", "language": "java", "Allcodes": "public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) {\n\t\t// lookup methods\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(type);\n\t\tCtorDescriptor[] allCtors = cd.getAllCtorDescriptors();\n\t\tConstructor foundedCtor = null;\n\t\tConstructor defaultCtor = null;\n\t\tBeanReferences[] references = null;\n\n\t\tfor (CtorDescriptor ctorDescriptor : allCtors) {\n\t\t\tConstructor<?> ctor = ctorDescriptor.getConstructor();\n\n\t\t\tClass<?>[] paramTypes = ctor.getParameterTypes();\n\t\t\tif (paramTypes.length == 0) {\n\t\t\t\tdefaultCtor = ctor;     // detects default ctors\n\t\t\t}\n\n\t\t\tif (!useAnnotation) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor);\n\n\t\t\tif (ctorReferences == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (foundedCtor != null) {\n\t\t\t\tthrow new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName());\n\t\t\t}\n\n\t\t\tfoundedCtor = ctor;\n\t\t\treferences = ctorReferences;\n\t\t}\n\n\t\tif (foundedCtor == null) {\n\t\t\t// there is no annotated constructor\n\t\t\tif (allCtors.length == 1) {\n\t\t\t\tfoundedCtor = allCtors[0].getConstructor();\n\t\t\t} else {\n\t\t\t\tfoundedCtor = defaultCtor;\n\t\t\t}\n\n\t\t\tif (foundedCtor == null) {\n\t\t\t\t// no matching ctor found\n\t\t\t\t// still this is not an error if bean is already instantiated.\n\t\t\t\treturn CtorInjectionPoint.EMPTY;\n\t\t\t}\n\n\t\t\treferences = referencesResolver.readAllReferencesFromAnnotation(foundedCtor);\n\n\t\t\tif (references == null) {\n\t\t\t\treferences = new BeanReferences[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new CtorInjectionPoint(foundedCtor, references);\n\t}", "code_tokens": ["public", "CtorInjectionPoint", "resolve", "(", "final", "Class", "type", ",", "final", "boolean", "useAnnotation", ")", "{", "// lookup methods", "ClassDescriptor", "cd", "=", "ClassIntrospector", ".", "get", "(", ")", ".", "lookup", "(", "type", ")", ";", "CtorDescriptor", "[", "]", "allCtors", "=", "cd", ".", "getAllCtorDescriptors", "(", ")", ";", "Constructor", "foundedCtor", "=", "null", ";", "Constructor", "defaultCtor", "=", "null", ";", "BeanReferences", "[", "]", "references", "=", "null", ";", "for", "(", "CtorDescriptor", "ctorDescriptor", ":", "allCtors", ")", "{", "Constructor", "<", "?", ">", "ctor", "=", "ctorDescriptor", ".", "getConstructor", "(", ")", ";", "Class", "<", "?", ">", "[", "]", "paramTypes", "=", "ctor", ".", "getParameterTypes", "(", ")", ";", "if", "(", "paramTypes", ".", "length", "==", "0", ")", "{", "defaultCtor", "=", "ctor", ";", "// detects default ctors", "}", "if", "(", "!", "useAnnotation", ")", "{", "continue", ";", "}", "BeanReferences", "[", "]", "ctorReferences", "=", "referencesResolver", ".", "readAllReferencesFromAnnotation", "(", "ctor", ")", ";", "if", "(", "ctorReferences", "==", "null", ")", "{", "continue", ";", "}", "if", "(", "foundedCtor", "!=", "null", ")", "{", "throw", "new", "PetiteException", "(", "\"Two or more constructors are annotated as injection points in the bean: \"", "+", "type", ".", "getName", "(", ")", ")", ";", "}", "foundedCtor", "=", "ctor", ";", "references", "=", "ctorReferences", ";", "}", "if", "(", "foundedCtor", "==", "null", ")", "{", "// there is no annotated constructor", "if", "(", "allCtors", ".", "length", "==", "1", ")", "{", "foundedCtor", "=", "allCtors", "[", "0", "]", ".", "getConstructor", "(", ")", ";", "}", "else", "{", "foundedCtor", "=", "defaultCtor", ";", "}", "if", "(", "foundedCtor", "==", "null", ")", "{", "// no matching ctor found", "// still this is not an error if bean is already instantiated.", "return", "CtorInjectionPoint", ".", "EMPTY", ";", "}", "references", "=", "referencesResolver", ".", "readAllReferencesFromAnnotation", "(", "foundedCtor", ")", ";", "if", "(", "references", "==", "null", ")", "{", "references", "=", "new", "BeanReferences", "[", "0", "]", ";", "}", "}", "return", "new", "CtorInjectionPoint", "(", "foundedCtor", ",", "references", ")", ";", "}"], "docstring": "Resolves constructor injection point from type. Looks for single annotated constructor.\nIf no annotated constructors found, the total number of constructors will be checked.\nIf there is only one constructor, that one will be used as injection point. If more\nconstructors exist, the default one will be used as injection point. Otherwise, exception\nis thrown.", "docstring_tokens": ["Resolves", "constructor", "injection", "point", "from", "type", ".", "Looks", "for", "single", "annotated", "constructor", ".", "If", "no", "annotated", "constructors", "found", "the", "total", "number", "of", "constructors", "will", "be", "checked", ".", "If", "there", "is", "only", "one", "constructor", "that", "one", "will", "be", "used", "as", "injection", "point", ".", "If", "more", "constructors", "exist", "the", "default", "one", "will", "be", "used", "as", "injection", "point", ".", "Otherwise", "exception", "is", "thrown", "."]}
{"code": "byte[] utf8 = StringUtil.getBytes(str);", "comments": "encode the string into bytes using utf-8", "lines": 3, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.encrypt", "original_string": "public String encrypt(final String str) {\n\t\ttry {\n\t\t\tbyte[] utf8 = StringUtil.getBytes(str);\t\t// encode the string into bytes using utf-8\n\t\t\tbyte[] enc = ecipher.doFinal(utf8); \t// encrypt\n\t\t\treturn Base64.encodeToString(enc);\t\t// encode bytes to base64 to get a string\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String encrypt(final String str) {\n\t\ttry {\n\t\t\tbyte[] utf8 = StringUtil.getBytes(str);\t\t// encode the string into bytes using utf-8\n\t\t\tbyte[] enc = ecipher.doFinal(utf8); \t// encrypt\n\t\t\treturn Base64.encodeToString(enc);\t\t// encode bytes to base64 to get a string\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "encrypt", "(", "final", "String", "str", ")", "{", "try", "{", "byte", "[", "]", "utf8", "=", "StringUtil", ".", "getBytes", "(", "str", ")", ";", "// encode the string into bytes using utf-8", "byte", "[", "]", "enc", "=", "ecipher", ".", "doFinal", "(", "utf8", ")", ";", "// encrypt", "return", "Base64", ".", "encodeToString", "(", "enc", ")", ";", "// encode bytes to base64 to get a string", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically encrypts the string.", "docstring_tokens": ["Symmetrically", "encrypts", "the", "string", "."]}
{"code": "byte[] enc = ecipher.doFinal(utf8);", "comments": "encrypt", "lines": 4, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.encrypt", "original_string": "public String encrypt(final String str) {\n\t\ttry {\n\t\t\tbyte[] utf8 = StringUtil.getBytes(str);\t\t// encode the string into bytes using utf-8\n\t\t\tbyte[] enc = ecipher.doFinal(utf8); \t// encrypt\n\t\t\treturn Base64.encodeToString(enc);\t\t// encode bytes to base64 to get a string\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String encrypt(final String str) {\n\t\ttry {\n\t\t\tbyte[] utf8 = StringUtil.getBytes(str);\t\t// encode the string into bytes using utf-8\n\t\t\tbyte[] enc = ecipher.doFinal(utf8); \t// encrypt\n\t\t\treturn Base64.encodeToString(enc);\t\t// encode bytes to base64 to get a string\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "encrypt", "(", "final", "String", "str", ")", "{", "try", "{", "byte", "[", "]", "utf8", "=", "StringUtil", ".", "getBytes", "(", "str", ")", ";", "// encode the string into bytes using utf-8", "byte", "[", "]", "enc", "=", "ecipher", ".", "doFinal", "(", "utf8", ")", ";", "// encrypt", "return", "Base64", ".", "encodeToString", "(", "enc", ")", ";", "// encode bytes to base64 to get a string", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically encrypts the string.", "docstring_tokens": ["Symmetrically", "encrypts", "the", "string", "."]}
{"code": "return Base64.encodeToString(enc);", "comments": "encode bytes to base64 to get a string", "lines": 5, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.encrypt", "original_string": "public String encrypt(final String str) {\n\t\ttry {\n\t\t\tbyte[] utf8 = StringUtil.getBytes(str);\t\t// encode the string into bytes using utf-8\n\t\t\tbyte[] enc = ecipher.doFinal(utf8); \t// encrypt\n\t\t\treturn Base64.encodeToString(enc);\t\t// encode bytes to base64 to get a string\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String encrypt(final String str) {\n\t\ttry {\n\t\t\tbyte[] utf8 = StringUtil.getBytes(str);\t\t// encode the string into bytes using utf-8\n\t\t\tbyte[] enc = ecipher.doFinal(utf8); \t// encrypt\n\t\t\treturn Base64.encodeToString(enc);\t\t// encode bytes to base64 to get a string\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "encrypt", "(", "final", "String", "str", ")", "{", "try", "{", "byte", "[", "]", "utf8", "=", "StringUtil", ".", "getBytes", "(", "str", ")", ";", "// encode the string into bytes using utf-8", "byte", "[", "]", "enc", "=", "ecipher", ".", "doFinal", "(", "utf8", ")", ";", "// encrypt", "return", "Base64", ".", "encodeToString", "(", "enc", ")", ";", "// encode bytes to base64 to get a string", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically encrypts the string.", "docstring_tokens": ["Symmetrically", "encrypts", "the", "string", "."]}
{"code": "str = StringUtil.replaceChar(str, ' ', '+');", "comments": "replace spaces with chars.", "lines": 3, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.decrypt", "original_string": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "decrypt", "(", "String", "str", ")", "{", "try", "{", "str", "=", "StringUtil", ".", "replaceChar", "(", "str", ",", "'", "'", ",", "'", "'", ")", ";", "// replace spaces with chars.", "byte", "[", "]", "dec", "=", "Base64", ".", "decode", "(", "str", ")", ";", "// decode base64 to get bytes", "byte", "[", "]", "utf8", "=", "dcipher", ".", "doFinal", "(", "dec", ")", ";", "// decrypt", "return", "new", "String", "(", "utf8", ",", "UTF_8", ")", ";", "// decode using utf-8", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically decrypts the string.", "docstring_tokens": ["Symmetrically", "decrypts", "the", "string", "."]}
{"code": "byte[] dec = Base64.decode(str);", "comments": "decode base64 to get bytes", "lines": 4, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.decrypt", "original_string": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "decrypt", "(", "String", "str", ")", "{", "try", "{", "str", "=", "StringUtil", ".", "replaceChar", "(", "str", ",", "'", "'", ",", "'", "'", ")", ";", "// replace spaces with chars.", "byte", "[", "]", "dec", "=", "Base64", ".", "decode", "(", "str", ")", ";", "// decode base64 to get bytes", "byte", "[", "]", "utf8", "=", "dcipher", ".", "doFinal", "(", "dec", ")", ";", "// decrypt", "return", "new", "String", "(", "utf8", ",", "UTF_8", ")", ";", "// decode using utf-8", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically decrypts the string.", "docstring_tokens": ["Symmetrically", "decrypts", "the", "string", "."]}
{"code": "byte[] utf8 = dcipher.doFinal(dec);", "comments": "decrypt", "lines": 5, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.decrypt", "original_string": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "decrypt", "(", "String", "str", ")", "{", "try", "{", "str", "=", "StringUtil", ".", "replaceChar", "(", "str", ",", "'", "'", ",", "'", "'", ")", ";", "// replace spaces with chars.", "byte", "[", "]", "dec", "=", "Base64", ".", "decode", "(", "str", ")", ";", "// decode base64 to get bytes", "byte", "[", "]", "utf8", "=", "dcipher", ".", "doFinal", "(", "dec", ")", ";", "// decrypt", "return", "new", "String", "(", "utf8", ",", "UTF_8", ")", ";", "// decode using utf-8", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically decrypts the string.", "docstring_tokens": ["Symmetrically", "decrypts", "the", "string", "."]}
{"code": "return new String(utf8, UTF_8);", "comments": "decode using utf-8", "lines": 6, "repo": "oblac/jodd", "path": "jodd-core/src/main/java/jodd/crypt/PBKDF2Encryptor.java", "func_name": "PBKDF2Encryptor.decrypt", "original_string": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "public String decrypt(String str) {\n\t\ttry {\n\t\t\tstr = StringUtil.replaceChar(str, ' ', '+');\t// replace spaces with chars.\n\t\t\tbyte[] dec = Base64.decode(str);    \t// decode base64 to get bytes\n\t\t\tbyte[] utf8 = dcipher.doFinal(dec);     // decrypt\n\t\t\treturn new String(utf8, UTF_8);\t\t\t// decode using utf-8\n\t\t} catch (Throwable ignore) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["public", "String", "decrypt", "(", "String", "str", ")", "{", "try", "{", "str", "=", "StringUtil", ".", "replaceChar", "(", "str", ",", "'", "'", ",", "'", "'", ")", ";", "// replace spaces with chars.", "byte", "[", "]", "dec", "=", "Base64", ".", "decode", "(", "str", ")", ";", "// decode base64 to get bytes", "byte", "[", "]", "utf8", "=", "dcipher", ".", "doFinal", "(", "dec", ")", ";", "// decrypt", "return", "new", "String", "(", "utf8", ",", "UTF_8", ")", ";", "// decode using utf-8", "}", "catch", "(", "Throwable", "ignore", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Symmetrically decrypts the string.", "docstring_tokens": ["Symmetrically", "decrypts", "the", "string", "."]}
{"code": "final long termCount = activeTermId - initialTermId;", "comments": "copes with negative activeTermId on rollover", "lines": 4, "repo": "real-logic/aeron", "path": "aeron-client/src/main/java/io/aeron/logbuffer/LogBufferDescriptor.java", "func_name": "LogBufferDescriptor.computePosition", "original_string": "public static long computePosition(\n        final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId)\n    {\n        final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover\n\n        return (termCount << positionBitsToShift) + termOffset;\n    }", "language": "java", "Allcodes": "public static long computePosition(\n        final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId)\n    {\n        final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover\n\n        return (termCount << positionBitsToShift) + termOffset;\n    }", "code_tokens": ["public", "static", "long", "computePosition", "(", "final", "int", "activeTermId", ",", "final", "int", "termOffset", ",", "final", "int", "positionBitsToShift", ",", "final", "int", "initialTermId", ")", "{", "final", "long", "termCount", "=", "activeTermId", "-", "initialTermId", ";", "// copes with negative activeTermId on rollover", "return", "(", "termCount", "<<", "positionBitsToShift", ")", "+", "termOffset", ";", "}"], "docstring": "Compute the current position in absolute number of bytes.\n\n@param activeTermId        active term id.\n@param termOffset          in the term.\n@param positionBitsToShift number of times to left shift the term count\n@param initialTermId       the initial term id that this stream started on\n@return the absolute position in bytes", "docstring_tokens": ["Compute", "the", "current", "position", "in", "absolute", "number", "of", "bytes", "."]}
{"code": "return null;", "comments": "TODO: should this complain?", "lines": 14, "repo": "apache/parquet-mr", "path": "parquet-hadoop/src/main/java/org/apache/parquet/hadoop/ParquetFileReader.java", "func_name": "ParquetFileReader.readDictionary", "original_string": "DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException {\n    if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) &&\n        !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) {\n      return null;\n    }\n\n    // TODO: this should use getDictionaryPageOffset() but it isn't reliable.\n    if (f.getPos() != meta.getStartingPos()) {\n      f.seek(meta.getStartingPos());\n    }\n\n    PageHeader pageHeader = Util.readPageHeader(f);\n    if (!pageHeader.isSetDictionary_page_header()) {\n      return null; // TODO: should this complain?\n    }\n\n    DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f);\n    BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec());\n\n    return new DictionaryPage(\n        decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()),\n        compressedPage.getDictionarySize(),\n        compressedPage.getEncoding());\n  }", "language": "java", "Allcodes": "DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException {\n    if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) &&\n        !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) {\n      return null;\n    }\n\n    // TODO: this should use getDictionaryPageOffset() but it isn't reliable.\n    if (f.getPos() != meta.getStartingPos()) {\n      f.seek(meta.getStartingPos());\n    }\n\n    PageHeader pageHeader = Util.readPageHeader(f);\n    if (!pageHeader.isSetDictionary_page_header()) {\n      return null; // TODO: should this complain?\n    }\n\n    DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f);\n    BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec());\n\n    return new DictionaryPage(\n        decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()),\n        compressedPage.getDictionarySize(),\n        compressedPage.getEncoding());\n  }", "code_tokens": ["DictionaryPage", "readDictionary", "(", "ColumnChunkMetaData", "meta", ")", "throws", "IOException", "{", "if", "(", "!", "meta", ".", "getEncodings", "(", ")", ".", "contains", "(", "Encoding", ".", "PLAIN_DICTIONARY", ")", "&&", "!", "meta", ".", "getEncodings", "(", ")", ".", "contains", "(", "Encoding", ".", "RLE_DICTIONARY", ")", ")", "{", "return", "null", ";", "}", "// TODO: this should use getDictionaryPageOffset() but it isn't reliable.", "if", "(", "f", ".", "getPos", "(", ")", "!=", "meta", ".", "getStartingPos", "(", ")", ")", "{", "f", ".", "seek", "(", "meta", ".", "getStartingPos", "(", ")", ")", ";", "}", "PageHeader", "pageHeader", "=", "Util", ".", "readPageHeader", "(", "f", ")", ";", "if", "(", "!", "pageHeader", ".", "isSetDictionary_page_header", "(", ")", ")", "{", "return", "null", ";", "// TODO: should this complain?", "}", "DictionaryPage", "compressedPage", "=", "readCompressedDictionary", "(", "pageHeader", ",", "f", ")", ";", "BytesInputDecompressor", "decompressor", "=", "options", ".", "getCodecFactory", "(", ")", ".", "getDecompressor", "(", "meta", ".", "getCodec", "(", ")", ")", ";", "return", "new", "DictionaryPage", "(", "decompressor", ".", "decompress", "(", "compressedPage", ".", "getBytes", "(", ")", ",", "compressedPage", ".", "getUncompressedSize", "(", ")", ")", ",", "compressedPage", ".", "getDictionarySize", "(", ")", ",", "compressedPage", ".", "getEncoding", "(", ")", ")", ";", "}"], "docstring": "Reads and decompresses a dictionary page for the given column chunk.\n\nReturns null if the given column chunk has no dictionary page.\n\n@param meta a column's ColumnChunkMetaData to read the dictionary from\n@return an uncompressed DictionaryPage or null\n@throws IOException if there is an error while reading the dictionary", "docstring_tokens": ["Reads", "and", "decompresses", "a", "dictionary", "page", "for", "the", "given", "column", "chunk", "."]}
{"code": "int compressedPageSize = (int)dictionaryPage.getBytes().size();", "comments": "TODO: fix casts", "lines": 6, "repo": "apache/parquet-mr", "path": "parquet-hadoop/src/main/java/org/apache/parquet/hadoop/ParquetFileWriter.java", "func_name": "ParquetFileWriter.writeDictionaryPage", "original_string": "public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException {\n    state = state.write();\n    LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize());\n    currentChunkDictionaryPageOffset = out.getPos();\n    int uncompressedSize = dictionaryPage.getUncompressedSize();\n    int compressedPageSize = (int)dictionaryPage.getBytes().size(); // TODO: fix casts\n    metadataConverter.writeDictionaryPageHeader(\n        uncompressedSize,\n        compressedPageSize,\n        dictionaryPage.getDictionarySize(),\n        dictionaryPage.getEncoding(),\n        out);\n    long headerSize = out.getPos() - currentChunkDictionaryPageOffset;\n    this.uncompressedLength += uncompressedSize + headerSize;\n    this.compressedLength += compressedPageSize + headerSize;\n    LOG.debug(\"{}: write dictionary page content {}\", out.getPos(), compressedPageSize);\n    dictionaryPage.getBytes().writeAllTo(out);\n    encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding());\n    currentEncodings.add(dictionaryPage.getEncoding());\n  }", "language": "java", "Allcodes": "public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException {\n    state = state.write();\n    LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize());\n    currentChunkDictionaryPageOffset = out.getPos();\n    int uncompressedSize = dictionaryPage.getUncompressedSize();\n    int compressedPageSize = (int)dictionaryPage.getBytes().size(); // TODO: fix casts\n    metadataConverter.writeDictionaryPageHeader(\n        uncompressedSize,\n        compressedPageSize,\n        dictionaryPage.getDictionarySize(),\n        dictionaryPage.getEncoding(),\n        out);\n    long headerSize = out.getPos() - currentChunkDictionaryPageOffset;\n    this.uncompressedLength += uncompressedSize + headerSize;\n    this.compressedLength += compressedPageSize + headerSize;\n    LOG.debug(\"{}: write dictionary page content {}\", out.getPos(), compressedPageSize);\n    dictionaryPage.getBytes().writeAllTo(out);\n    encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding());\n    currentEncodings.add(dictionaryPage.getEncoding());\n  }", "code_tokens": ["public", "void", "writeDictionaryPage", "(", "DictionaryPage", "dictionaryPage", ")", "throws", "IOException", "{", "state", "=", "state", ".", "write", "(", ")", ";", "LOG", ".", "debug", "(", "\"{}: write dictionary page: {} values\"", ",", "out", ".", "getPos", "(", ")", ",", "dictionaryPage", ".", "getDictionarySize", "(", ")", ")", ";", "currentChunkDictionaryPageOffset", "=", "out", ".", "getPos", "(", ")", ";", "int", "uncompressedSize", "=", "dictionaryPage", ".", "getUncompressedSize", "(", ")", ";", "int", "compressedPageSize", "=", "(", "int", ")", "dictionaryPage", ".", "getBytes", "(", ")", ".", "size", "(", ")", ";", "// TODO: fix casts", "metadataConverter", ".", "writeDictionaryPageHeader", "(", "uncompressedSize", ",", "compressedPageSize", ",", "dictionaryPage", ".", "getDictionarySize", "(", ")", ",", "dictionaryPage", ".", "getEncoding", "(", ")", ",", "out", ")", ";", "long", "headerSize", "=", "out", ".", "getPos", "(", ")", "-", "currentChunkDictionaryPageOffset", ";", "this", ".", "uncompressedLength", "+=", "uncompressedSize", "+", "headerSize", ";", "this", ".", "compressedLength", "+=", "compressedPageSize", "+", "headerSize", ";", "LOG", ".", "debug", "(", "\"{}: write dictionary page content {}\"", ",", "out", ".", "getPos", "(", ")", ",", "compressedPageSize", ")", ";", "dictionaryPage", ".", "getBytes", "(", ")", ".", "writeAllTo", "(", "out", ")", ";", "encodingStatsBuilder", ".", "addDictEncoding", "(", "dictionaryPage", ".", "getEncoding", "(", ")", ")", ";", "currentEncodings", ".", "add", "(", "dictionaryPage", ".", "getEncoding", "(", ")", ")", ";", "}"], "docstring": "writes a dictionary page page\n@param dictionaryPage the dictionary page\n@throws IOException if there is an error while writing", "docstring_tokens": ["writes", "a", "dictionary", "page", "page"]}
{"code": "regex.append(\"(?:\");", "comments": "non-capturing", "lines": 41, "repo": "apache/parquet-mr", "path": "parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/deprecated/PathGlobPattern.java", "func_name": "PathGlobPattern.set", "original_string": "public void set(String glob) {\n    StringBuilder regex = new StringBuilder();\n    int setOpen = 0;\n    int curlyOpen = 0;\n    int len = glob.length();\n    hasWildcard = false;\n\n    for (int i = 0; i < len; i++) {\n      char c = glob.charAt(i);\n\n      switch (c) {\n        case BACKSLASH:\n          if (++i >= len) {\n            error(\"Missing escaped character\", glob, i);\n          }\n          regex.append(c).append(glob.charAt(i));\n          continue;\n        case '.':\n        case '$':\n        case '(':\n        case ')':\n        case '|':\n        case '+':\n          // escape regex special chars that are not glob special chars\n          regex.append(BACKSLASH);\n          break;\n        case '*':\n          if (i + 1 < len && glob.charAt(i + 1) == '*') {\n            regex.append('.');\n            i++;\n            break;\n          }\n          regex.append(\"[^\" + PATH_SEPARATOR + \"]\");\n          hasWildcard = true;\n          break;\n        case '?':\n          regex.append('.');\n          hasWildcard = true;\n          continue;\n        case '{': // start of a group\n          regex.append(\"(?:\"); // non-capturing\n          curlyOpen++;\n          hasWildcard = true;\n          continue;\n        case ',':\n          regex.append(curlyOpen > 0 ? '|' : c);\n          continue;\n        case '}':\n          if (curlyOpen > 0) {\n            // end of a group\n            curlyOpen--;\n            regex.append(\")\");\n            continue;\n          }\n          break;\n        case '[':\n          if (setOpen > 0) {\n            error(\"Unclosed character class\", glob, i);\n          }\n          setOpen++;\n          hasWildcard = true;\n          break;\n        case '^': // ^ inside [...] can be unescaped\n          if (setOpen == 0) {\n            regex.append(BACKSLASH);\n          }\n          break;\n        case '!': // [! needs to be translated to [^\n          regex.append(setOpen > 0 && '[' == glob.charAt(i - 1) ? '^' : '!');\n          continue;\n        case ']':\n          // Many set errors like [][] could not be easily detected here,\n          // as []], []-] and [-] are all valid POSIX glob and java regex.\n          // We'll just let the regex compiler do the real work.\n          setOpen = 0;\n          break;\n        default:\n      }\n      regex.append(c);\n    }\n\n    if (setOpen > 0) {\n      error(\"Unclosed character class\", glob, len);\n    }\n    if (curlyOpen > 0) {\n      error(\"Unclosed group\", glob, len);\n    }\n    compiled = Pattern.compile(regex.toString());\n  }", "language": "java", "Allcodes": "public void set(String glob) {\n    StringBuilder regex = new StringBuilder();\n    int setOpen = 0;\n    int curlyOpen = 0;\n    int len = glob.length();\n    hasWildcard = false;\n\n    for (int i = 0; i < len; i++) {\n      char c = glob.charAt(i);\n\n      switch (c) {\n        case BACKSLASH:\n          if (++i >= len) {\n            error(\"Missing escaped character\", glob, i);\n          }\n          regex.append(c).append(glob.charAt(i));\n          continue;\n        case '.':\n        case '$':\n        case '(':\n        case ')':\n        case '|':\n        case '+':\n          // escape regex special chars that are not glob special chars\n          regex.append(BACKSLASH);\n          break;\n        case '*':\n          if (i + 1 < len && glob.charAt(i + 1) == '*') {\n            regex.append('.');\n            i++;\n            break;\n          }\n          regex.append(\"[^\" + PATH_SEPARATOR + \"]\");\n          hasWildcard = true;\n          break;\n        case '?':\n          regex.append('.');\n          hasWildcard = true;\n          continue;\n        case '{': // start of a group\n          regex.append(\"(?:\"); // non-capturing\n          curlyOpen++;\n          hasWildcard = true;\n          continue;\n        case ',':\n          regex.append(curlyOpen > 0 ? '|' : c);\n          continue;\n        case '}':\n          if (curlyOpen > 0) {\n            // end of a group\n            curlyOpen--;\n            regex.append(\")\");\n            continue;\n          }\n          break;\n        case '[':\n          if (setOpen > 0) {\n            error(\"Unclosed character class\", glob, i);\n          }\n          setOpen++;\n          hasWildcard = true;\n          break;\n        case '^': // ^ inside [...] can be unescaped\n          if (setOpen == 0) {\n            regex.append(BACKSLASH);\n          }\n          break;\n        case '!': // [! needs to be translated to [^\n          regex.append(setOpen > 0 && '[' == glob.charAt(i - 1) ? '^' : '!');\n          continue;\n        case ']':\n          // Many set errors like [][] could not be easily detected here,\n          // as []], []-] and [-] are all valid POSIX glob and java regex.\n          // We'll just let the regex compiler do the real work.\n          setOpen = 0;\n          break;\n        default:\n      }\n      regex.append(c);\n    }\n\n    if (setOpen > 0) {\n      error(\"Unclosed character class\", glob, len);\n    }\n    if (curlyOpen > 0) {\n      error(\"Unclosed group\", glob, len);\n    }\n    compiled = Pattern.compile(regex.toString());\n  }", "code_tokens": ["public", "void", "set", "(", "String", "glob", ")", "{", "StringBuilder", "regex", "=", "new", "StringBuilder", "(", ")", ";", "int", "setOpen", "=", "0", ";", "int", "curlyOpen", "=", "0", ";", "int", "len", "=", "glob", ".", "length", "(", ")", ";", "hasWildcard", "=", "false", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "c", "=", "glob", ".", "charAt", "(", "i", ")", ";", "switch", "(", "c", ")", "{", "case", "BACKSLASH", ":", "if", "(", "++", "i", ">=", "len", ")", "{", "error", "(", "\"Missing escaped character\"", ",", "glob", ",", "i", ")", ";", "}", "regex", ".", "append", "(", "c", ")", ".", "append", "(", "glob", ".", "charAt", "(", "i", ")", ")", ";", "continue", ";", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "// escape regex special chars that are not glob special chars", "regex", ".", "append", "(", "BACKSLASH", ")", ";", "break", ";", "case", "'", "'", ":", "if", "(", "i", "+", "1", "<", "len", "&&", "glob", ".", "charAt", "(", "i", "+", "1", ")", "==", "'", "'", ")", "{", "regex", ".", "append", "(", "'", "'", ")", ";", "i", "++", ";", "break", ";", "}", "regex", ".", "append", "(", "\"[^\"", "+", "PATH_SEPARATOR", "+", "\"]\"", ")", ";", "hasWildcard", "=", "true", ";", "break", ";", "case", "'", "'", ":", "regex", ".", "append", "(", "'", "'", ")", ";", "hasWildcard", "=", "true", ";", "continue", ";", "case", "'", "'", ":", "// start of a group", "regex", ".", "append", "(", "\"(?:\"", ")", ";", "// non-capturing", "curlyOpen", "++", ";", "hasWildcard", "=", "true", ";", "continue", ";", "case", "'", "'", ":", "regex", ".", "append", "(", "curlyOpen", ">", "0", "?", "'", "'", ":", "c", ")", ";", "continue", ";", "case", "'", "'", ":", "if", "(", "curlyOpen", ">", "0", ")", "{", "// end of a group", "curlyOpen", "--", ";", "regex", ".", "append", "(", "\")\"", ")", ";", "continue", ";", "}", "break", ";", "case", "'", "'", ":", "if", "(", "setOpen", ">", "0", ")", "{", "error", "(", "\"Unclosed character class\"", ",", "glob", ",", "i", ")", ";", "}", "setOpen", "++", ";", "hasWildcard", "=", "true", ";", "break", ";", "case", "'", "'", ":", "// ^ inside [...] can be unescaped", "if", "(", "setOpen", "==", "0", ")", "{", "regex", ".", "append", "(", "BACKSLASH", ")", ";", "}", "break", ";", "case", "'", "'", ":", "// [! needs to be translated to [^", "regex", ".", "append", "(", "setOpen", ">", "0", "&&", "'", "'", "==", "glob", ".", "charAt", "(", "i", "-", "1", ")", "?", "'", "'", ":", "'", "'", ")", ";", "continue", ";", "case", "'", "'", ":", "// Many set errors like [][] could not be easily detected here,", "// as []], []-] and [-] are all valid POSIX glob and java regex.", "// We'll just let the regex compiler do the real work.", "setOpen", "=", "0", ";", "break", ";", "default", ":", "}", "regex", ".", "append", "(", "c", ")", ";", "}", "if", "(", "setOpen", ">", "0", ")", "{", "error", "(", "\"Unclosed character class\"", ",", "glob", ",", "len", ")", ";", "}", "if", "(", "curlyOpen", ">", "0", ")", "{", "error", "(", "\"Unclosed group\"", ",", "glob", ",", "len", ")", ";", "}", "compiled", "=", "Pattern", ".", "compile", "(", "regex", ".", "toString", "(", ")", ")", ";", "}"], "docstring": "Set and compile a glob pattern\n\n@param glob the glob pattern string", "docstring_tokens": ["Set", "and", "compile", "a", "glob", "pattern"]}
{"code": "break;", "comments": "skip java built-in classes", "lines": 10, "repo": "apache/parquet-mr", "path": "parquet-avro/src/main/java/org/apache/parquet/avro/AvroRecordConverter.java", "func_name": "AvroRecordConverter.getFieldsByName", "original_string": "private static Map<String, Class<?>> getFieldsByName(Class<?> recordClass,\n                                                       boolean excludeJava) {\n    Map<String, Class<?>> fields = new LinkedHashMap<String, Class<?>>();\n\n    if (recordClass != null) {\n      Class<?> current = recordClass;\n      do {\n        if (excludeJava && current.getPackage() != null\n            && current.getPackage().getName().startsWith(\"java.\")) {\n          break; // skip java built-in classes\n        }\n        for (Field field : current.getDeclaredFields()) {\n          if (field.isAnnotationPresent(AvroIgnore.class) ||\n              isTransientOrStatic(field)) {\n            continue;\n          }\n          AvroName altName = field.getAnnotation(AvroName.class);\n          Class<?> existing = fields.put(\n              altName != null ? altName.value() : field.getName(),\n              field.getType());\n          if (existing != null) {\n            throw new AvroTypeException(\n                current + \" contains two fields named: \" + field.getName());\n          }\n        }\n        current = current.getSuperclass();\n      } while (current != null);\n    }\n\n    return fields;\n  }", "language": "java", "Allcodes": "private static Map<String, Class<?>> getFieldsByName(Class<?> recordClass,\n                                                       boolean excludeJava) {\n    Map<String, Class<?>> fields = new LinkedHashMap<String, Class<?>>();\n\n    if (recordClass != null) {\n      Class<?> current = recordClass;\n      do {\n        if (excludeJava && current.getPackage() != null\n            && current.getPackage().getName().startsWith(\"java.\")) {\n          break; // skip java built-in classes\n        }\n        for (Field field : current.getDeclaredFields()) {\n          if (field.isAnnotationPresent(AvroIgnore.class) ||\n              isTransientOrStatic(field)) {\n            continue;\n          }\n          AvroName altName = field.getAnnotation(AvroName.class);\n          Class<?> existing = fields.put(\n              altName != null ? altName.value() : field.getName(),\n              field.getType());\n          if (existing != null) {\n            throw new AvroTypeException(\n                current + \" contains two fields named: \" + field.getName());\n          }\n        }\n        current = current.getSuperclass();\n      } while (current != null);\n    }\n\n    return fields;\n  }", "code_tokens": ["private", "static", "Map", "<", "String", ",", "Class", "<", "?", ">", ">", "getFieldsByName", "(", "Class", "<", "?", ">", "recordClass", ",", "boolean", "excludeJava", ")", "{", "Map", "<", "String", ",", "Class", "<", "?", ">", ">", "fields", "=", "new", "LinkedHashMap", "<", "String", ",", "Class", "<", "?", ">", ">", "(", ")", ";", "if", "(", "recordClass", "!=", "null", ")", "{", "Class", "<", "?", ">", "current", "=", "recordClass", ";", "do", "{", "if", "(", "excludeJava", "&&", "current", ".", "getPackage", "(", ")", "!=", "null", "&&", "current", ".", "getPackage", "(", ")", ".", "getName", "(", ")", ".", "startsWith", "(", "\"java.\"", ")", ")", "{", "break", ";", "// skip java built-in classes", "}", "for", "(", "Field", "field", ":", "current", ".", "getDeclaredFields", "(", ")", ")", "{", "if", "(", "field", ".", "isAnnotationPresent", "(", "AvroIgnore", ".", "class", ")", "||", "isTransientOrStatic", "(", "field", ")", ")", "{", "continue", ";", "}", "AvroName", "altName", "=", "field", ".", "getAnnotation", "(", "AvroName", ".", "class", ")", ";", "Class", "<", "?", ">", "existing", "=", "fields", ".", "put", "(", "altName", "!=", "null", "?", "altName", ".", "value", "(", ")", ":", "field", ".", "getName", "(", ")", ",", "field", ".", "getType", "(", ")", ")", ";", "if", "(", "existing", "!=", "null", ")", "{", "throw", "new", "AvroTypeException", "(", "current", "+", "\" contains two fields named: \"", "+", "field", ".", "getName", "(", ")", ")", ";", "}", "}", "current", "=", "current", ".", "getSuperclass", "(", ")", ";", "}", "while", "(", "current", "!=", "null", ")", ";", "}", "return", "fields", ";", "}"], "docstring": "this was taken from Avro's ReflectData", "docstring_tokens": ["this", "was", "taken", "from", "Avro", "s", "ReflectData"]}
{"code": "checkNotNull(e);", "comments": "check before removing", "lines": 2, "repo": "streamsets/datacollector", "path": "common/src/main/java/com/streamsets/pipeline/lib/queue/XEvictingQueue.java", "func_name": "XEvictingQueue.add", "original_string": "@Override public boolean add(E e) {\n    checkNotNull(e);  // check before removing\n    if (maxSize == 0) {\n      return true;\n    }\n    if (size() == maxSize) {\n      delegate.remove();\n    }\n    delegate.add(e);\n    return true;\n  }", "language": "java", "Allcodes": "@Override public boolean add(E e) {\n    checkNotNull(e);  // check before removing\n    if (maxSize == 0) {\n      return true;\n    }\n    if (size() == maxSize) {\n      delegate.remove();\n    }\n    delegate.add(e);\n    return true;\n  }", "code_tokens": ["@", "Override", "public", "boolean", "add", "(", "E", "e", ")", "{", "checkNotNull", "(", "e", ")", ";", "// check before removing", "if", "(", "maxSize", "==", "0", ")", "{", "return", "true", ";", "}", "if", "(", "size", "(", ")", "==", "maxSize", ")", "{", "delegate", ".", "remove", "(", ")", ";", "}", "delegate", ".", "add", "(", "e", ")", ";", "return", "true", ";", "}"], "docstring": "Adds the given element to this queue. If the queue is currently full, the element at the head\nof the queue is evicted to make room.\n\n@return {@code true} always", "docstring_tokens": ["Adds", "the", "given", "element", "to", "this", "queue", ".", "If", "the", "queue", "is", "currently", "full", "the", "element", "at", "the", "head", "of", "the", "queue", "is", "evicted", "to", "make", "room", "."]}
{"code": "expectedOffset = batch.getResult().get(batch.getResult().size() - 1).getKey();", "comments": "get the last one", "lines": 11, "repo": "streamsets/datacollector", "path": "cluster-common/src/main/java/com/streamsets/pipeline/cluster/Producer.java", "func_name": "Producer.put", "original_string": "public Object put(OffsetAndResult<Map.Entry> batch) {\n    if (consumerError != null) {\n      throw new RuntimeException(Utils.format(\"Consumer encountered error: {}\", consumerError), consumerError);\n    }\n    if (producerError != null) {\n      throw new RuntimeException(Utils.format(\"Producer encountered error: {}\", producerError), producerError);\n    }\n    try {\n      Object expectedOffset = \"EMPTY_BATCH\";\n      if (!batch.getResult().isEmpty()) {\n        expectedOffset = batch.getResult().get(batch.getResult().size() - 1).getKey(); // get the last one\n      }\n      while (!dataChannel.offer(batch, 10, TimeUnit.MILLISECONDS)) {\n        for (ControlChannel.Message controlMessage : controlChannel.getProducerMessages()) {\n          switch (controlMessage.getType()) {\n            case CONSUMER_ERROR:\n              Throwable throwable = (Throwable) controlMessage.getPayload();\n              consumerError = throwable;\n              throw new ConsumerRuntimeException(Utils.format(\"Consumer encountered error: {}\", throwable), throwable);\n            default:\n              String msg = Utils.format(\"Illegal control message type: '{}'\", controlMessage.getType());\n              throw new IllegalStateException(msg);\n          }\n        }\n      }\n      return expectedOffset;\n    } catch (Throwable throwable) {\n      controlChannel.producerComplete();\n      if (!(throwable instanceof ConsumerRuntimeException)) {\n        String msg = \"Error caught in producer: \" + throwable;\n        LOG.error(msg, throwable);\n        controlChannel.producerError(throwable);\n        if (producerError == null) {\n          producerError = throwable;\n        }\n      }\n      throw Throwables.propagate(throwable);\n    }\n  }", "language": "java", "Allcodes": "public Object put(OffsetAndResult<Map.Entry> batch) {\n    if (consumerError != null) {\n      throw new RuntimeException(Utils.format(\"Consumer encountered error: {}\", consumerError), consumerError);\n    }\n    if (producerError != null) {\n      throw new RuntimeException(Utils.format(\"Producer encountered error: {}\", producerError), producerError);\n    }\n    try {\n      Object expectedOffset = \"EMPTY_BATCH\";\n      if (!batch.getResult().isEmpty()) {\n        expectedOffset = batch.getResult().get(batch.getResult().size() - 1).getKey(); // get the last one\n      }\n      while (!dataChannel.offer(batch, 10, TimeUnit.MILLISECONDS)) {\n        for (ControlChannel.Message controlMessage : controlChannel.getProducerMessages()) {\n          switch (controlMessage.getType()) {\n            case CONSUMER_ERROR:\n              Throwable throwable = (Throwable) controlMessage.getPayload();\n              consumerError = throwable;\n              throw new ConsumerRuntimeException(Utils.format(\"Consumer encountered error: {}\", throwable), throwable);\n            default:\n              String msg = Utils.format(\"Illegal control message type: '{}'\", controlMessage.getType());\n              throw new IllegalStateException(msg);\n          }\n        }\n      }\n      return expectedOffset;\n    } catch (Throwable throwable) {\n      controlChannel.producerComplete();\n      if (!(throwable instanceof ConsumerRuntimeException)) {\n        String msg = \"Error caught in producer: \" + throwable;\n        LOG.error(msg, throwable);\n        controlChannel.producerError(throwable);\n        if (producerError == null) {\n          producerError = throwable;\n        }\n      }\n      throw Throwables.propagate(throwable);\n    }\n  }", "code_tokens": ["public", "Object", "put", "(", "OffsetAndResult", "<", "Map", ".", "Entry", ">", "batch", ")", "{", "if", "(", "consumerError", "!=", "null", ")", "{", "throw", "new", "RuntimeException", "(", "Utils", ".", "format", "(", "\"Consumer encountered error: {}\"", ",", "consumerError", ")", ",", "consumerError", ")", ";", "}", "if", "(", "producerError", "!=", "null", ")", "{", "throw", "new", "RuntimeException", "(", "Utils", ".", "format", "(", "\"Producer encountered error: {}\"", ",", "producerError", ")", ",", "producerError", ")", ";", "}", "try", "{", "Object", "expectedOffset", "=", "\"EMPTY_BATCH\"", ";", "if", "(", "!", "batch", ".", "getResult", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "expectedOffset", "=", "batch", ".", "getResult", "(", ")", ".", "get", "(", "batch", ".", "getResult", "(", ")", ".", "size", "(", ")", "-", "1", ")", ".", "getKey", "(", ")", ";", "// get the last one", "}", "while", "(", "!", "dataChannel", ".", "offer", "(", "batch", ",", "10", ",", "TimeUnit", ".", "MILLISECONDS", ")", ")", "{", "for", "(", "ControlChannel", ".", "Message", "controlMessage", ":", "controlChannel", ".", "getProducerMessages", "(", ")", ")", "{", "switch", "(", "controlMessage", ".", "getType", "(", ")", ")", "{", "case", "CONSUMER_ERROR", ":", "Throwable", "throwable", "=", "(", "Throwable", ")", "controlMessage", ".", "getPayload", "(", ")", ";", "consumerError", "=", "throwable", ";", "throw", "new", "ConsumerRuntimeException", "(", "Utils", ".", "format", "(", "\"Consumer encountered error: {}\"", ",", "throwable", ")", ",", "throwable", ")", ";", "default", ":", "String", "msg", "=", "Utils", ".", "format", "(", "\"Illegal control message type: '{}'\"", ",", "controlMessage", ".", "getType", "(", ")", ")", ";", "throw", "new", "IllegalStateException", "(", "msg", ")", ";", "}", "}", "}", "return", "expectedOffset", ";", "}", "catch", "(", "Throwable", "throwable", ")", "{", "controlChannel", ".", "producerComplete", "(", ")", ";", "if", "(", "!", "(", "throwable", "instanceof", "ConsumerRuntimeException", ")", ")", "{", "String", "msg", "=", "\"Error caught in producer: \"", "+", "throwable", ";", "LOG", ".", "error", "(", "msg", ",", "throwable", ")", ";", "controlChannel", ".", "producerError", "(", "throwable", ")", ";", "if", "(", "producerError", "==", "null", ")", "{", "producerError", "=", "throwable", ";", "}", "}", "throw", "Throwables", ".", "propagate", "(", "throwable", ")", ";", "}", "}"], "docstring": "Queues the batch for the consumer and waits until the consumer\nsuccessfully commits the batch. While waiting processes any\ncontrol messages from the consumer. Throws an exception\nwhen the consumer has indicated it encountered an error.", "docstring_tokens": ["Queues", "the", "batch", "for", "the", "consumer", "and", "waits", "until", "the", "consumer", "successfully", "commits", "the", "batch", ".", "While", "waiting", "processes", "any", "control", "messages", "from", "the", "consumer", ".", "Throws", "an", "exception", "when", "the", "consumer", "has", "indicated", "it", "encountered", "an", "error", "."]}
{"code": "entry.put(innerPairSecondFieldName, Field.create(pair.getValue().toString()));", "comments": "stored value is \"INT\". need to fix this", "lines": 18, "repo": "streamsets/datacollector", "path": "hive-protolib/src/main/java/com/streamsets/pipeline/stage/lib/hive/HiveMetastoreUtil.java", "func_name": "HiveMetastoreUtil.generateInnerFieldFromTheList", "original_string": "private static <T> Field generateInnerFieldFromTheList(\n      LinkedHashMap<String, T> original,\n      String innerPairFirstFieldName,\n      String innerPairSecondFieldName,\n      boolean isSecondFieldHiveType\n  ) throws HiveStageCheckedException {\n    List<Field> columnList = new LinkedList<>();\n    for(Map.Entry<String,T> pair:  original.entrySet()) {\n      LinkedHashMap<String, Field> entry = new LinkedHashMap<>();\n      entry.put(innerPairFirstFieldName, Field.create(pair.getKey()));\n      if (isSecondFieldHiveType){\n        HiveTypeInfo hiveTypeInfo = (HiveTypeInfo) pair.getValue();\n        entry.put(\n            innerPairSecondFieldName,\n            hiveTypeInfo.getHiveType().getSupport().generateHiveTypeInfoFieldForMetadataRecord(hiveTypeInfo)\n        );\n      } else {\n        entry.put(innerPairSecondFieldName, Field.create(pair.getValue().toString())); //stored value is \"INT\". need to fix this\n      }\n      columnList.add(Field.createListMap(entry));\n    }\n    return !columnList.isEmpty() ? Field.create(columnList) : null;\n  }", "language": "java", "Allcodes": "private static <T> Field generateInnerFieldFromTheList(\n      LinkedHashMap<String, T> original,\n      String innerPairFirstFieldName,\n      String innerPairSecondFieldName,\n      boolean isSecondFieldHiveType\n  ) throws HiveStageCheckedException {\n    List<Field> columnList = new LinkedList<>();\n    for(Map.Entry<String,T> pair:  original.entrySet()) {\n      LinkedHashMap<String, Field> entry = new LinkedHashMap<>();\n      entry.put(innerPairFirstFieldName, Field.create(pair.getKey()));\n      if (isSecondFieldHiveType){\n        HiveTypeInfo hiveTypeInfo = (HiveTypeInfo) pair.getValue();\n        entry.put(\n            innerPairSecondFieldName,\n            hiveTypeInfo.getHiveType().getSupport().generateHiveTypeInfoFieldForMetadataRecord(hiveTypeInfo)\n        );\n      } else {\n        entry.put(innerPairSecondFieldName, Field.create(pair.getValue().toString())); //stored value is \"INT\". need to fix this\n      }\n      columnList.add(Field.createListMap(entry));\n    }\n    return !columnList.isEmpty() ? Field.create(columnList) : null;\n  }", "code_tokens": ["private", "static", "<", "T", ">", "Field", "generateInnerFieldFromTheList", "(", "LinkedHashMap", "<", "String", ",", "T", ">", "original", ",", "String", "innerPairFirstFieldName", ",", "String", "innerPairSecondFieldName", ",", "boolean", "isSecondFieldHiveType", ")", "throws", "HiveStageCheckedException", "{", "List", "<", "Field", ">", "columnList", "=", "new", "LinkedList", "<>", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "T", ">", "pair", ":", "original", ".", "entrySet", "(", ")", ")", "{", "LinkedHashMap", "<", "String", ",", "Field", ">", "entry", "=", "new", "LinkedHashMap", "<>", "(", ")", ";", "entry", ".", "put", "(", "innerPairFirstFieldName", ",", "Field", ".", "create", "(", "pair", ".", "getKey", "(", ")", ")", ")", ";", "if", "(", "isSecondFieldHiveType", ")", "{", "HiveTypeInfo", "hiveTypeInfo", "=", "(", "HiveTypeInfo", ")", "pair", ".", "getValue", "(", ")", ";", "entry", ".", "put", "(", "innerPairSecondFieldName", ",", "hiveTypeInfo", ".", "getHiveType", "(", ")", ".", "getSupport", "(", ")", ".", "generateHiveTypeInfoFieldForMetadataRecord", "(", "hiveTypeInfo", ")", ")", ";", "}", "else", "{", "entry", ".", "put", "(", "innerPairSecondFieldName", ",", "Field", ".", "create", "(", "pair", ".", "getValue", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "//stored value is \"INT\". need to fix this", "}", "columnList", ".", "add", "(", "Field", ".", "createListMap", "(", "entry", ")", ")", ";", "}", "return", "!", "columnList", ".", "isEmpty", "(", ")", "?", "Field", ".", "create", "(", "columnList", ")", ":", "null", ";", "}"], "docstring": "Opposite operation of extractInnerMapFromTheList.\nIt takes LinkedHashMap and generate a Field that contains the list.\nThis is to send metadata record to HMS target.\nThis function is called to for partition type list and partition value list.", "docstring_tokens": ["Opposite", "operation", "of", "extractInnerMapFromTheList", ".", "It", "takes", "LinkedHashMap", "and", "generate", "a", "Field", "that", "contains", "the", "list", ".", "This", "is", "to", "send", "metadata", "record", "to", "HMS", "target", ".", "This", "function", "is", "called", "to", "for", "partition", "type", "list", "and", "partition", "value", "list", "."]}
{"code": "batchCommitted = false;", "comments": "got a new batch", "lines": 30, "repo": "streamsets/datacollector", "path": "cluster-common/src/main/java/com/streamsets/pipeline/cluster/Consumer.java", "func_name": "Consumer.take", "original_string": "public OffsetAndResult<Map.Entry> take() {\n    if (producerError != null) {\n      throw new RuntimeException(Utils.format(\"Producer encountered error: {}\", producerError), producerError);\n    }\n    if (consumerError != null) {\n      throw new RuntimeException(Utils.format(\"Consumer encountered error: {}\", consumerError), consumerError);\n    }\n    try {\n      Utils.checkState(batchCommitted, \"Cannot take messages when last batch is uncommitted\");\n      while (running) {\n        for (ControlChannel.Message controlMessage : controlChannel.getConsumerMessages()) {\n          switch (controlMessage.getType()) {\n            case PRODUCER_COMPLETE:\n              // producer is complete, empty channel and afterwards return null\n              running = false;\n              break;\n            case PRODUCER_ERROR:\n              running = false;\n              Throwable throwable = (Throwable) controlMessage.getPayload();\n              producerError = throwable;\n              throw new ProducerRuntimeException(Utils.format(\"Producer encountered error: {}\", throwable), throwable);\n            default:\n              String msg = Utils.format(\"Illegal control message type: '{}'\", controlMessage.getType());\n              throw new IllegalStateException(msg);\n          }\n        }\n        OffsetAndResult<Map.Entry> batch = dataChannel.take(10, TimeUnit.MILLISECONDS);\n        LOG.trace(\"Received batch: {}\", batch);\n        if (batch != null) {\n          batchCommitted = false; // got a new batch\n          return batch;\n        }\n      }\n      LOG.trace(\"Returning null\");\n      return null;\n    } catch (Throwable throwable) {\n      if (!(throwable instanceof ProducerRuntimeException)) {\n        String msg = \"Error caught in consumer: \" + throwable;\n        LOG.error(msg, throwable);\n        error(throwable);\n      }\n      throw Throwables.propagate(throwable);\n    }\n  }", "language": "java", "Allcodes": "public OffsetAndResult<Map.Entry> take() {\n    if (producerError != null) {\n      throw new RuntimeException(Utils.format(\"Producer encountered error: {}\", producerError), producerError);\n    }\n    if (consumerError != null) {\n      throw new RuntimeException(Utils.format(\"Consumer encountered error: {}\", consumerError), consumerError);\n    }\n    try {\n      Utils.checkState(batchCommitted, \"Cannot take messages when last batch is uncommitted\");\n      while (running) {\n        for (ControlChannel.Message controlMessage : controlChannel.getConsumerMessages()) {\n          switch (controlMessage.getType()) {\n            case PRODUCER_COMPLETE:\n              // producer is complete, empty channel and afterwards return null\n              running = false;\n              break;\n            case PRODUCER_ERROR:\n              running = false;\n              Throwable throwable = (Throwable) controlMessage.getPayload();\n              producerError = throwable;\n              throw new ProducerRuntimeException(Utils.format(\"Producer encountered error: {}\", throwable), throwable);\n            default:\n              String msg = Utils.format(\"Illegal control message type: '{}'\", controlMessage.getType());\n              throw new IllegalStateException(msg);\n          }\n        }\n        OffsetAndResult<Map.Entry> batch = dataChannel.take(10, TimeUnit.MILLISECONDS);\n        LOG.trace(\"Received batch: {}\", batch);\n        if (batch != null) {\n          batchCommitted = false; // got a new batch\n          return batch;\n        }\n      }\n      LOG.trace(\"Returning null\");\n      return null;\n    } catch (Throwable throwable) {\n      if (!(throwable instanceof ProducerRuntimeException)) {\n        String msg = \"Error caught in consumer: \" + throwable;\n        LOG.error(msg, throwable);\n        error(throwable);\n      }\n      throw Throwables.propagate(throwable);\n    }\n  }", "code_tokens": ["public", "OffsetAndResult", "<", "Map", ".", "Entry", ">", "take", "(", ")", "{", "if", "(", "producerError", "!=", "null", ")", "{", "throw", "new", "RuntimeException", "(", "Utils", ".", "format", "(", "\"Producer encountered error: {}\"", ",", "producerError", ")", ",", "producerError", ")", ";", "}", "if", "(", "consumerError", "!=", "null", ")", "{", "throw", "new", "RuntimeException", "(", "Utils", ".", "format", "(", "\"Consumer encountered error: {}\"", ",", "consumerError", ")", ",", "consumerError", ")", ";", "}", "try", "{", "Utils", ".", "checkState", "(", "batchCommitted", ",", "\"Cannot take messages when last batch is uncommitted\"", ")", ";", "while", "(", "running", ")", "{", "for", "(", "ControlChannel", ".", "Message", "controlMessage", ":", "controlChannel", ".", "getConsumerMessages", "(", ")", ")", "{", "switch", "(", "controlMessage", ".", "getType", "(", ")", ")", "{", "case", "PRODUCER_COMPLETE", ":", "// producer is complete, empty channel and afterwards return null", "running", "=", "false", ";", "break", ";", "case", "PRODUCER_ERROR", ":", "running", "=", "false", ";", "Throwable", "throwable", "=", "(", "Throwable", ")", "controlMessage", ".", "getPayload", "(", ")", ";", "producerError", "=", "throwable", ";", "throw", "new", "ProducerRuntimeException", "(", "Utils", ".", "format", "(", "\"Producer encountered error: {}\"", ",", "throwable", ")", ",", "throwable", ")", ";", "default", ":", "String", "msg", "=", "Utils", ".", "format", "(", "\"Illegal control message type: '{}'\"", ",", "controlMessage", ".", "getType", "(", ")", ")", ";", "throw", "new", "IllegalStateException", "(", "msg", ")", ";", "}", "}", "OffsetAndResult", "<", "Map", ".", "Entry", ">", "batch", "=", "dataChannel", ".", "take", "(", "10", ",", "TimeUnit", ".", "MILLISECONDS", ")", ";", "LOG", ".", "trace", "(", "\"Received batch: {}\"", ",", "batch", ")", ";", "if", "(", "batch", "!=", "null", ")", "{", "batchCommitted", "=", "false", ";", "// got a new batch", "return", "batch", ";", "}", "}", "LOG", ".", "trace", "(", "\"Returning null\"", ")", ";", "return", "null", ";", "}", "catch", "(", "Throwable", "throwable", ")", "{", "if", "(", "!", "(", "throwable", "instanceof", "ProducerRuntimeException", ")", ")", "{", "String", "msg", "=", "\"Error caught in consumer: \"", "+", "throwable", ";", "LOG", ".", "error", "(", "msg", ",", "throwable", ")", ";", "error", "(", "throwable", ")", ";", "}", "throw", "Throwables", ".", "propagate", "(", "throwable", ")", ";", "}", "}"], "docstring": "Consumes messages off the queue. Returns null when the producer\nhas indicated it is complete and throws an exception\nwhen the consumer producer has indicated it is in error.", "docstring_tokens": ["Consumes", "messages", "off", "the", "queue", ".", "Returns", "null", "when", "the", "producer", "has", "indicated", "it", "is", "complete", "and", "throws", "an", "exception", "when", "the", "consumer", "producer", "has", "indicated", "it", "is", "in", "error", "."]}
{"code": "int opCode = -1;", "comments": "unsupported", "lines": 8, "repo": "streamsets/datacollector", "path": "jdbc-protolib/src/main/java/com/streamsets/pipeline/lib/jdbc/JdbcRecordReader.java", "func_name": "JdbcRecordReader.getOperationFromRecord", "original_string": "int getOperationFromRecord(\n      Record record,\n      int defaultOpCode,\n      UnsupportedOperationAction unsupportedAction,\n      List<OnRecordErrorException> errorRecords\n  ) {\n    String op = record.getHeader().getAttribute(OperationType.SDC_OPERATION_TYPE);\n    int opCode = -1; // unsupported\n\n    if (Strings.isNullOrEmpty(op)) {\n      return defaultOpCode;\n    }\n\n    // Check if the operation code from header attribute is valid\n    try {\n      opCode = JDBCOperationType.convertToIntCode(op);\n    } catch (NumberFormatException | UnsupportedOperationException ex) {\n      LOG.debug(\n          \"Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}\",\n          unsupportedAction.getLabel(),\n          ex\n      );\n      switch (unsupportedAction) {\n        case SEND_TO_ERROR:\n          LOG.debug(\"Sending record to error due to unsupported operation {}\", op);\n          errorRecords.add(new OnRecordErrorException(record, JdbcErrors.JDBC_70, op));\n          break;\n        case USE_DEFAULT:\n          opCode = defaultOpCode;\n          break;\n        case DISCARD:\n        default: // unknown action\n          LOG.debug(\"Discarding record with unsupported operation {}\", op);\n      }\n    }\n    return opCode;\n  }", "language": "java", "Allcodes": "int getOperationFromRecord(\n      Record record,\n      int defaultOpCode,\n      UnsupportedOperationAction unsupportedAction,\n      List<OnRecordErrorException> errorRecords\n  ) {\n    String op = record.getHeader().getAttribute(OperationType.SDC_OPERATION_TYPE);\n    int opCode = -1; // unsupported\n\n    if (Strings.isNullOrEmpty(op)) {\n      return defaultOpCode;\n    }\n\n    // Check if the operation code from header attribute is valid\n    try {\n      opCode = JDBCOperationType.convertToIntCode(op);\n    } catch (NumberFormatException | UnsupportedOperationException ex) {\n      LOG.debug(\n          \"Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}\",\n          unsupportedAction.getLabel(),\n          ex\n      );\n      switch (unsupportedAction) {\n        case SEND_TO_ERROR:\n          LOG.debug(\"Sending record to error due to unsupported operation {}\", op);\n          errorRecords.add(new OnRecordErrorException(record, JdbcErrors.JDBC_70, op));\n          break;\n        case USE_DEFAULT:\n          opCode = defaultOpCode;\n          break;\n        case DISCARD:\n        default: // unknown action\n          LOG.debug(\"Discarding record with unsupported operation {}\", op);\n      }\n    }\n    return opCode;\n  }", "code_tokens": ["int", "getOperationFromRecord", "(", "Record", "record", ",", "int", "defaultOpCode", ",", "UnsupportedOperationAction", "unsupportedAction", ",", "List", "<", "OnRecordErrorException", ">", "errorRecords", ")", "{", "String", "op", "=", "record", ".", "getHeader", "(", ")", ".", "getAttribute", "(", "OperationType", ".", "SDC_OPERATION_TYPE", ")", ";", "int", "opCode", "=", "-", "1", ";", "// unsupported", "if", "(", "Strings", ".", "isNullOrEmpty", "(", "op", ")", ")", "{", "return", "defaultOpCode", ";", "}", "// Check if the operation code from header attribute is valid", "try", "{", "opCode", "=", "JDBCOperationType", ".", "convertToIntCode", "(", "op", ")", ";", "}", "catch", "(", "NumberFormatException", "|", "UnsupportedOperationException", "ex", ")", "{", "LOG", ".", "debug", "(", "\"Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}\"", ",", "unsupportedAction", ".", "getLabel", "(", ")", ",", "ex", ")", ";", "switch", "(", "unsupportedAction", ")", "{", "case", "SEND_TO_ERROR", ":", "LOG", ".", "debug", "(", "\"Sending record to error due to unsupported operation {}\"", ",", "op", ")", ";", "errorRecords", ".", "add", "(", "new", "OnRecordErrorException", "(", "record", ",", "JdbcErrors", ".", "JDBC_70", ",", "op", ")", ")", ";", "break", ";", "case", "USE_DEFAULT", ":", "opCode", "=", "defaultOpCode", ";", "break", ";", "case", "DISCARD", ":", "default", ":", "// unknown action", "LOG", ".", "debug", "(", "\"Discarding record with unsupported operation {}\"", ",", "op", ")", ";", "}", "}", "return", "opCode", ";", "}"], "docstring": "Get the numeric operation code from record header. The default code is\nused if the operation code is not found in the header. This can be\noverwritten in inherited classes.\n\n@param record the record to find the operation code\n@param defaultOpCode the default operation code\n@param unsupportedAction the action to take for unsupported code\n@param errorRecords the list to take error records\n@return the numeric operation code or -1 for unsupported operation", "docstring_tokens": ["Get", "the", "numeric", "operation", "code", "from", "record", "header", ".", "The", "default", "code", "is", "used", "if", "the", "operation", "code", "is", "not", "found", "in", "the", "header", ".", "This", "can", "be", "overwritten", "in", "inherited", "classes", "."]}
{"code": "changeMultiplier(-multiplier);", "comments": "stopAll;", "lines": 5, "repo": "streamsets/datacollector", "path": "container/src/main/java/com/streamsets/datacollector/usagestats/UsageTimer.java", "func_name": "UsageTimer.roll", "original_string": "public UsageTimer roll() {\n    int multiplier;\n    synchronized (this) {\n      multiplier = getMultiplier();\n      changeMultiplier(-multiplier); //stopAll;\n    }\n    return new UsageTimer().setName(getName()).changeMultiplier(multiplier);\n  }", "language": "java", "Allcodes": "public UsageTimer roll() {\n    int multiplier;\n    synchronized (this) {\n      multiplier = getMultiplier();\n      changeMultiplier(-multiplier); //stopAll;\n    }\n    return new UsageTimer().setName(getName()).changeMultiplier(multiplier);\n  }", "code_tokens": ["public", "UsageTimer", "roll", "(", ")", "{", "int", "multiplier", ";", "synchronized", "(", "this", ")", "{", "multiplier", "=", "getMultiplier", "(", ")", ";", "changeMultiplier", "(", "-", "multiplier", ")", ";", "//stopAll;", "}", "return", "new", "UsageTimer", "(", ")", ".", "setName", "(", "getName", "(", ")", ")", ".", "changeMultiplier", "(", "multiplier", ")", ";", "}"], "docstring": "returns fresh UsageTimer just reset to zero accumulated time", "docstring_tokens": ["returns", "fresh", "UsageTimer", "just", "reset", "to", "zero", "accumulated", "time"]}
{"code": "int finalValue = -1;", "comments": "Invalid value", "lines": 8, "repo": "streamsets/datacollector", "path": "basic-lib/src/main/java/com/streamsets/pipeline/stage/processor/schemagen/generators/AvroSchemaGenerator.java", "func_name": "AvroSchemaGenerator.getDecimalScaleOrPrecision", "original_string": "private int getDecimalScaleOrPrecision(\n      Record record,\n      Field field,\n      String attributeName,\n      int defaultValue,\n      int minAllowed\n  ) throws OnRecordErrorException {\n    int finalValue = -1; // Invalid value\n\n    // Firstly try the field attribute\n    String stringValue = field.getAttribute(attributeName);\n    if(!StringUtils.isEmpty(stringValue)) {\n      finalValue = Integer.valueOf(stringValue);\n    }\n\n    // If it's invalid, then use the default value\n    if(finalValue < minAllowed) {\n      finalValue = defaultValue;\n    }\n\n    // If even the default value is invalid, then send the record to error\n    if(finalValue < minAllowed) {\n      throw new OnRecordErrorException(record, Errors.SCHEMA_GEN_0004, finalValue, field);\n    }\n\n    return finalValue;\n  }", "language": "java", "Allcodes": "private int getDecimalScaleOrPrecision(\n      Record record,\n      Field field,\n      String attributeName,\n      int defaultValue,\n      int minAllowed\n  ) throws OnRecordErrorException {\n    int finalValue = -1; // Invalid value\n\n    // Firstly try the field attribute\n    String stringValue = field.getAttribute(attributeName);\n    if(!StringUtils.isEmpty(stringValue)) {\n      finalValue = Integer.valueOf(stringValue);\n    }\n\n    // If it's invalid, then use the default value\n    if(finalValue < minAllowed) {\n      finalValue = defaultValue;\n    }\n\n    // If even the default value is invalid, then send the record to error\n    if(finalValue < minAllowed) {\n      throw new OnRecordErrorException(record, Errors.SCHEMA_GEN_0004, finalValue, field);\n    }\n\n    return finalValue;\n  }", "code_tokens": ["private", "int", "getDecimalScaleOrPrecision", "(", "Record", "record", ",", "Field", "field", ",", "String", "attributeName", ",", "int", "defaultValue", ",", "int", "minAllowed", ")", "throws", "OnRecordErrorException", "{", "int", "finalValue", "=", "-", "1", ";", "// Invalid value", "// Firstly try the field attribute", "String", "stringValue", "=", "field", ".", "getAttribute", "(", "attributeName", ")", ";", "if", "(", "!", "StringUtils", ".", "isEmpty", "(", "stringValue", ")", ")", "{", "finalValue", "=", "Integer", ".", "valueOf", "(", "stringValue", ")", ";", "}", "// If it's invalid, then use the default value", "if", "(", "finalValue", "<", "minAllowed", ")", "{", "finalValue", "=", "defaultValue", ";", "}", "// If even the default value is invalid, then send the record to error", "if", "(", "finalValue", "<", "minAllowed", ")", "{", "throw", "new", "OnRecordErrorException", "(", "record", ",", "Errors", ".", "SCHEMA_GEN_0004", ",", "finalValue", ",", "field", ")", ";", "}", "return", "finalValue", ";", "}"], "docstring": "Resolve parameters of decimal type.", "docstring_tokens": ["Resolve", "parameters", "of", "decimal", "type", "."]}
{"code": "int type = buf.getUnsignedShort(offset);", "comments": "0-1", "lines": 3, "repo": "streamsets/datacollector", "path": "commonlib/src/main/java/com/streamsets/pipeline/lib/parser/udp/collectd/CollectdParser.java", "func_name": "CollectdParser.parsePart", "original_string": "private int parsePart(int startOffset, ByteBuf buf, Map<String, Field> fields) throws OnRecordErrorException {\n    int offset = startOffset;\n    int type = buf.getUnsignedShort(offset); // 0-1\n    offset += 2;\n    final int length = buf.getUnsignedShort(offset); // 2-3\n    offset += 2;\n\n    switch (type) {\n      case HOST:\n      case PLUGIN:\n      case PLUGIN_INSTANCE:\n      case TYPE:\n      case TYPE_INSTANCE:\n      case MESSAGE:\n        pruneFields(type);\n        fields.put(PART_TYPES.get(type), Field.create(parseString(offset, length, buf)));\n        offset += length - 4;\n        break;\n      case TIME_HIRES:\n      case INTERVAL_HIRES:\n        if (type != INTERVAL_HIRES || !excludeInterval) {\n          long value = parseNumeric(offset, buf);\n          if (convertTime) {\n            value *= (Math.pow(2, -30) * 1000);\n            type = type == TIME_HIRES ? TIME : INTERVAL;\n          }\n          fields.put(PART_TYPES.get(type), Field.create(value));\n        }\n        offset += 8;\n        break;\n      case TIME:\n      case INTERVAL:\n      case SEVERITY:\n        if (type != INTERVAL || !excludeInterval) {\n          fields.put(PART_TYPES.get(type), Field.create(parseNumeric(offset, buf)));\n        }\n        offset += 8;\n        break;\n      case VALUES:\n        offset = parseValues(offset, buf);\n        startNewRecord();\n        break;\n      case SIGNATURE:\n        if (!verifySignature(offset, length, buf)) {\n          throw new OnRecordErrorException(Errors.COLLECTD_02);\n        }\n        offset += length - 4;\n        break;\n      case ENCRYPTION:\n        String user = parseUser(offset, buf);\n        offset += (2 + user.length());\n        byte[] iv = parseIv(offset, buf);\n        offset += 16;\n        decrypt(offset, length, buf, user, iv);\n        // Skip the checksum and continue processing.\n        offset += 20;\n        break;\n      default:\n        // Don't recognize this part type, so skip it\n        LOG.warn(\"Unrecognized part type: {}\", type);\n        offset += length - 4;\n        break;\n    }\n\n    return offset;\n  }", "language": "java", "Allcodes": "private int parsePart(int startOffset, ByteBuf buf, Map<String, Field> fields) throws OnRecordErrorException {\n    int offset = startOffset;\n    int type = buf.getUnsignedShort(offset); // 0-1\n    offset += 2;\n    final int length = buf.getUnsignedShort(offset); // 2-3\n    offset += 2;\n\n    switch (type) {\n      case HOST:\n      case PLUGIN:\n      case PLUGIN_INSTANCE:\n      case TYPE:\n      case TYPE_INSTANCE:\n      case MESSAGE:\n        pruneFields(type);\n        fields.put(PART_TYPES.get(type), Field.create(parseString(offset, length, buf)));\n        offset += length - 4;\n        break;\n      case TIME_HIRES:\n      case INTERVAL_HIRES:\n        if (type != INTERVAL_HIRES || !excludeInterval) {\n          long value = parseNumeric(offset, buf);\n          if (convertTime) {\n            value *= (Math.pow(2, -30) * 1000);\n            type = type == TIME_HIRES ? TIME : INTERVAL;\n          }\n          fields.put(PART_TYPES.get(type), Field.create(value));\n        }\n        offset += 8;\n        break;\n      case TIME:\n      case INTERVAL:\n      case SEVERITY:\n        if (type != INTERVAL || !excludeInterval) {\n          fields.put(PART_TYPES.get(type), Field.create(parseNumeric(offset, buf)));\n        }\n        offset += 8;\n        break;\n      case VALUES:\n        offset = parseValues(offset, buf);\n        startNewRecord();\n        break;\n      case SIGNATURE:\n        if (!verifySignature(offset, length, buf)) {\n          throw new OnRecordErrorException(Errors.COLLECTD_02);\n        }\n        offset += length - 4;\n        break;\n      case ENCRYPTION:\n        String user = parseUser(offset, buf);\n        offset += (2 + user.length());\n        byte[] iv = parseIv(offset, buf);\n        offset += 16;\n        decrypt(offset, length, buf, user, iv);\n        // Skip the checksum and continue processing.\n        offset += 20;\n        break;\n      default:\n        // Don't recognize this part type, so skip it\n        LOG.warn(\"Unrecognized part type: {}\", type);\n        offset += length - 4;\n        break;\n    }\n\n    return offset;\n  }", "code_tokens": ["private", "int", "parsePart", "(", "int", "startOffset", ",", "ByteBuf", "buf", ",", "Map", "<", "String", ",", "Field", ">", "fields", ")", "throws", "OnRecordErrorException", "{", "int", "offset", "=", "startOffset", ";", "int", "type", "=", "buf", ".", "getUnsignedShort", "(", "offset", ")", ";", "// 0-1", "offset", "+=", "2", ";", "final", "int", "length", "=", "buf", ".", "getUnsignedShort", "(", "offset", ")", ";", "// 2-3", "offset", "+=", "2", ";", "switch", "(", "type", ")", "{", "case", "HOST", ":", "case", "PLUGIN", ":", "case", "PLUGIN_INSTANCE", ":", "case", "TYPE", ":", "case", "TYPE_INSTANCE", ":", "case", "MESSAGE", ":", "pruneFields", "(", "type", ")", ";", "fields", ".", "put", "(", "PART_TYPES", ".", "get", "(", "type", ")", ",", "Field", ".", "create", "(", "parseString", "(", "offset", ",", "length", ",", "buf", ")", ")", ")", ";", "offset", "+=", "length", "-", "4", ";", "break", ";", "case", "TIME_HIRES", ":", "case", "INTERVAL_HIRES", ":", "if", "(", "type", "!=", "INTERVAL_HIRES", "||", "!", "excludeInterval", ")", "{", "long", "value", "=", "parseNumeric", "(", "offset", ",", "buf", ")", ";", "if", "(", "convertTime", ")", "{", "value", "*=", "(", "Math", ".", "pow", "(", "2", ",", "-", "30", ")", "*", "1000", ")", ";", "type", "=", "type", "==", "TIME_HIRES", "?", "TIME", ":", "INTERVAL", ";", "}", "fields", ".", "put", "(", "PART_TYPES", ".", "get", "(", "type", ")", ",", "Field", ".", "create", "(", "value", ")", ")", ";", "}", "offset", "+=", "8", ";", "break", ";", "case", "TIME", ":", "case", "INTERVAL", ":", "case", "SEVERITY", ":", "if", "(", "type", "!=", "INTERVAL", "||", "!", "excludeInterval", ")", "{", "fields", ".", "put", "(", "PART_TYPES", ".", "get", "(", "type", ")", ",", "Field", ".", "create", "(", "parseNumeric", "(", "offset", ",", "buf", ")", ")", ")", ";", "}", "offset", "+=", "8", ";", "break", ";", "case", "VALUES", ":", "offset", "=", "parseValues", "(", "offset", ",", "buf", ")", ";", "startNewRecord", "(", ")", ";", "break", ";", "case", "SIGNATURE", ":", "if", "(", "!", "verifySignature", "(", "offset", ",", "length", ",", "buf", ")", ")", "{", "throw", "new", "OnRecordErrorException", "(", "Errors", ".", "COLLECTD_02", ")", ";", "}", "offset", "+=", "length", "-", "4", ";", "break", ";", "case", "ENCRYPTION", ":", "String", "user", "=", "parseUser", "(", "offset", ",", "buf", ")", ";", "offset", "+=", "(", "2", "+", "user", ".", "length", "(", ")", ")", ";", "byte", "[", "]", "iv", "=", "parseIv", "(", "offset", ",", "buf", ")", ";", "offset", "+=", "16", ";", "decrypt", "(", "offset", ",", "length", ",", "buf", ",", "user", ",", "iv", ")", ";", "// Skip the checksum and continue processing.", "offset", "+=", "20", ";", "break", ";", "default", ":", "// Don't recognize this part type, so skip it", "LOG", ".", "warn", "(", "\"Unrecognized part type: {}\"", ",", "type", ")", ";", "offset", "+=", "length", "-", "4", ";", "break", ";", "}", "return", "offset", ";", "}"], "docstring": "Parses a collectd packet \"part\".\n\n@param startOffset beginning offset for this part\n@param buf         buffered packet\n@param fields      field map for the output record\n@return offset after consuming part", "docstring_tokens": ["Parses", "a", "collectd", "packet", "part", "."]}
{"code": "final int length = buf.getUnsignedShort(offset);", "comments": "2-3", "lines": 5, "repo": "streamsets/datacollector", "path": "commonlib/src/main/java/com/streamsets/pipeline/lib/parser/udp/collectd/CollectdParser.java", "func_name": "CollectdParser.parsePart", "original_string": "private int parsePart(int startOffset, ByteBuf buf, Map<String, Field> fields) throws OnRecordErrorException {\n    int offset = startOffset;\n    int type = buf.getUnsignedShort(offset); // 0-1\n    offset += 2;\n    final int length = buf.getUnsignedShort(offset); // 2-3\n    offset += 2;\n\n    switch (type) {\n      case HOST:\n      case PLUGIN:\n      case PLUGIN_INSTANCE:\n      case TYPE:\n      case TYPE_INSTANCE:\n      case MESSAGE:\n        pruneFields(type);\n        fields.put(PART_TYPES.get(type), Field.create(parseString(offset, length, buf)));\n        offset += length - 4;\n        break;\n      case TIME_HIRES:\n      case INTERVAL_HIRES:\n        if (type != INTERVAL_HIRES || !excludeInterval) {\n          long value = parseNumeric(offset, buf);\n          if (convertTime) {\n            value *= (Math.pow(2, -30) * 1000);\n            type = type == TIME_HIRES ? TIME : INTERVAL;\n          }\n          fields.put(PART_TYPES.get(type), Field.create(value));\n        }\n        offset += 8;\n        break;\n      case TIME:\n      case INTERVAL:\n      case SEVERITY:\n        if (type != INTERVAL || !excludeInterval) {\n          fields.put(PART_TYPES.get(type), Field.create(parseNumeric(offset, buf)));\n        }\n        offset += 8;\n        break;\n      case VALUES:\n        offset = parseValues(offset, buf);\n        startNewRecord();\n        break;\n      case SIGNATURE:\n        if (!verifySignature(offset, length, buf)) {\n          throw new OnRecordErrorException(Errors.COLLECTD_02);\n        }\n        offset += length - 4;\n        break;\n      case ENCRYPTION:\n        String user = parseUser(offset, buf);\n        offset += (2 + user.length());\n        byte[] iv = parseIv(offset, buf);\n        offset += 16;\n        decrypt(offset, length, buf, user, iv);\n        // Skip the checksum and continue processing.\n        offset += 20;\n        break;\n      default:\n        // Don't recognize this part type, so skip it\n        LOG.warn(\"Unrecognized part type: {}\", type);\n        offset += length - 4;\n        break;\n    }\n\n    return offset;\n  }", "language": "java", "Allcodes": "private int parsePart(int startOffset, ByteBuf buf, Map<String, Field> fields) throws OnRecordErrorException {\n    int offset = startOffset;\n    int type = buf.getUnsignedShort(offset); // 0-1\n    offset += 2;\n    final int length = buf.getUnsignedShort(offset); // 2-3\n    offset += 2;\n\n    switch (type) {\n      case HOST:\n      case PLUGIN:\n      case PLUGIN_INSTANCE:\n      case TYPE:\n      case TYPE_INSTANCE:\n      case MESSAGE:\n        pruneFields(type);\n        fields.put(PART_TYPES.get(type), Field.create(parseString(offset, length, buf)));\n        offset += length - 4;\n        break;\n      case TIME_HIRES:\n      case INTERVAL_HIRES:\n        if (type != INTERVAL_HIRES || !excludeInterval) {\n          long value = parseNumeric(offset, buf);\n          if (convertTime) {\n            value *= (Math.pow(2, -30) * 1000);\n            type = type == TIME_HIRES ? TIME : INTERVAL;\n          }\n          fields.put(PART_TYPES.get(type), Field.create(value));\n        }\n        offset += 8;\n        break;\n      case TIME:\n      case INTERVAL:\n      case SEVERITY:\n        if (type != INTERVAL || !excludeInterval) {\n          fields.put(PART_TYPES.get(type), Field.create(parseNumeric(offset, buf)));\n        }\n        offset += 8;\n        break;\n      case VALUES:\n        offset = parseValues(offset, buf);\n        startNewRecord();\n        break;\n      case SIGNATURE:\n        if (!verifySignature(offset, length, buf)) {\n          throw new OnRecordErrorException(Errors.COLLECTD_02);\n        }\n        offset += length - 4;\n        break;\n      case ENCRYPTION:\n        String user = parseUser(offset, buf);\n        offset += (2 + user.length());\n        byte[] iv = parseIv(offset, buf);\n        offset += 16;\n        decrypt(offset, length, buf, user, iv);\n        // Skip the checksum and continue processing.\n        offset += 20;\n        break;\n      default:\n        // Don't recognize this part type, so skip it\n        LOG.warn(\"Unrecognized part type: {}\", type);\n        offset += length - 4;\n        break;\n    }\n\n    return offset;\n  }", "code_tokens": ["private", "int", "parsePart", "(", "int", "startOffset", ",", "ByteBuf", "buf", ",", "Map", "<", "String", ",", "Field", ">", "fields", ")", "throws", "OnRecordErrorException", "{", "int", "offset", "=", "startOffset", ";", "int", "type", "=", "buf", ".", "getUnsignedShort", "(", "offset", ")", ";", "// 0-1", "offset", "+=", "2", ";", "final", "int", "length", "=", "buf", ".", "getUnsignedShort", "(", "offset", ")", ";", "// 2-3", "offset", "+=", "2", ";", "switch", "(", "type", ")", "{", "case", "HOST", ":", "case", "PLUGIN", ":", "case", "PLUGIN_INSTANCE", ":", "case", "TYPE", ":", "case", "TYPE_INSTANCE", ":", "case", "MESSAGE", ":", "pruneFields", "(", "type", ")", ";", "fields", ".", "put", "(", "PART_TYPES", ".", "get", "(", "type", ")", ",", "Field", ".", "create", "(", "parseString", "(", "offset", ",", "length", ",", "buf", ")", ")", ")", ";", "offset", "+=", "length", "-", "4", ";", "break", ";", "case", "TIME_HIRES", ":", "case", "INTERVAL_HIRES", ":", "if", "(", "type", "!=", "INTERVAL_HIRES", "||", "!", "excludeInterval", ")", "{", "long", "value", "=", "parseNumeric", "(", "offset", ",", "buf", ")", ";", "if", "(", "convertTime", ")", "{", "value", "*=", "(", "Math", ".", "pow", "(", "2", ",", "-", "30", ")", "*", "1000", ")", ";", "type", "=", "type", "==", "TIME_HIRES", "?", "TIME", ":", "INTERVAL", ";", "}", "fields", ".", "put", "(", "PART_TYPES", ".", "get", "(", "type", ")", ",", "Field", ".", "create", "(", "value", ")", ")", ";", "}", "offset", "+=", "8", ";", "break", ";", "case", "TIME", ":", "case", "INTERVAL", ":", "case", "SEVERITY", ":", "if", "(", "type", "!=", "INTERVAL", "||", "!", "excludeInterval", ")", "{", "fields", ".", "put", "(", "PART_TYPES", ".", "get", "(", "type", ")", ",", "Field", ".", "create", "(", "parseNumeric", "(", "offset", ",", "buf", ")", ")", ")", ";", "}", "offset", "+=", "8", ";", "break", ";", "case", "VALUES", ":", "offset", "=", "parseValues", "(", "offset", ",", "buf", ")", ";", "startNewRecord", "(", ")", ";", "break", ";", "case", "SIGNATURE", ":", "if", "(", "!", "verifySignature", "(", "offset", ",", "length", ",", "buf", ")", ")", "{", "throw", "new", "OnRecordErrorException", "(", "Errors", ".", "COLLECTD_02", ")", ";", "}", "offset", "+=", "length", "-", "4", ";", "break", ";", "case", "ENCRYPTION", ":", "String", "user", "=", "parseUser", "(", "offset", ",", "buf", ")", ";", "offset", "+=", "(", "2", "+", "user", ".", "length", "(", ")", ")", ";", "byte", "[", "]", "iv", "=", "parseIv", "(", "offset", ",", "buf", ")", ";", "offset", "+=", "16", ";", "decrypt", "(", "offset", ",", "length", ",", "buf", ",", "user", ",", "iv", ")", ";", "// Skip the checksum and continue processing.", "offset", "+=", "20", ";", "break", ";", "default", ":", "// Don't recognize this part type, so skip it", "LOG", ".", "warn", "(", "\"Unrecognized part type: {}\"", ",", "type", ")", ";", "offset", "+=", "length", "-", "4", ";", "break", ";", "}", "return", "offset", ";", "}"], "docstring": "Parses a collectd packet \"part\".\n\n@param startOffset beginning offset for this part\n@param buf         buffered packet\n@param fields      field map for the output record\n@return offset after consuming part", "docstring_tokens": ["Parses", "a", "collectd", "packet", "part", "."]}
{"code": "int numValues = buf.getUnsignedShort(offset);", "comments": "4-5", "lines": 6, "repo": "streamsets/datacollector", "path": "commonlib/src/main/java/com/streamsets/pipeline/lib/parser/udp/collectd/CollectdParser.java", "func_name": "CollectdParser.parseValues", "original_string": "private int parseValues(int startOffset, ByteBuf buf) throws OnRecordErrorException {\n    int offset = startOffset;\n    // N Values\n    // For each Value:\n    // 1 byte data type code\n    int numValues = buf.getUnsignedShort(offset); // 4-5\n    offset += 2;\n\n    List<Byte> types = new ArrayList<>(numValues);\n\n    while (numValues-- > 0) {\n      types.add(buf.getByte(offset));\n      offset += 1;\n    }\n\n    for (int i = 0; i < types.size(); i++) {\n      Byte type = types.get(i);\n      String label = getValueLabel(i, type);\n      switch (type) {\n        case COUNTER:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        case GAUGE:\n          fields.put(\n              label,\n              Field.create(buf.order(ByteOrder.LITTLE_ENDIAN).getDouble(offset))\n          );\n          offset += 8;\n          break;\n        case DERIVE:\n          fields.put(label, Field.create(buf.getLong(offset)));\n          offset += 8;\n          break;\n        case ABSOLUTE:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        default:\n          // error\n          throw new OnRecordErrorException(Errors.COLLECTD_01, type);\n      }\n    }\n    return offset;\n  }", "language": "java", "Allcodes": "private int parseValues(int startOffset, ByteBuf buf) throws OnRecordErrorException {\n    int offset = startOffset;\n    // N Values\n    // For each Value:\n    // 1 byte data type code\n    int numValues = buf.getUnsignedShort(offset); // 4-5\n    offset += 2;\n\n    List<Byte> types = new ArrayList<>(numValues);\n\n    while (numValues-- > 0) {\n      types.add(buf.getByte(offset));\n      offset += 1;\n    }\n\n    for (int i = 0; i < types.size(); i++) {\n      Byte type = types.get(i);\n      String label = getValueLabel(i, type);\n      switch (type) {\n        case COUNTER:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        case GAUGE:\n          fields.put(\n              label,\n              Field.create(buf.order(ByteOrder.LITTLE_ENDIAN).getDouble(offset))\n          );\n          offset += 8;\n          break;\n        case DERIVE:\n          fields.put(label, Field.create(buf.getLong(offset)));\n          offset += 8;\n          break;\n        case ABSOLUTE:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        default:\n          // error\n          throw new OnRecordErrorException(Errors.COLLECTD_01, type);\n      }\n    }\n    return offset;\n  }", "code_tokens": ["private", "int", "parseValues", "(", "int", "startOffset", ",", "ByteBuf", "buf", ")", "throws", "OnRecordErrorException", "{", "int", "offset", "=", "startOffset", ";", "// N Values", "// For each Value:", "// 1 byte data type code", "int", "numValues", "=", "buf", ".", "getUnsignedShort", "(", "offset", ")", ";", "// 4-5", "offset", "+=", "2", ";", "List", "<", "Byte", ">", "types", "=", "new", "ArrayList", "<>", "(", "numValues", ")", ";", "while", "(", "numValues", "--", ">", "0", ")", "{", "types", ".", "add", "(", "buf", ".", "getByte", "(", "offset", ")", ")", ";", "offset", "+=", "1", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "types", ".", "size", "(", ")", ";", "i", "++", ")", "{", "Byte", "type", "=", "types", ".", "get", "(", "i", ")", ";", "String", "label", "=", "getValueLabel", "(", "i", ",", "type", ")", ";", "switch", "(", "type", ")", "{", "case", "COUNTER", ":", "fields", ".", "put", "(", "label", ",", "Field", ".", "create", "(", "buf", ".", "getUnsignedInt", "(", "offset", ")", ")", ")", ";", "offset", "+=", "8", ";", "break", ";", "case", "GAUGE", ":", "fields", ".", "put", "(", "label", ",", "Field", ".", "create", "(", "buf", ".", "order", "(", "ByteOrder", ".", "LITTLE_ENDIAN", ")", ".", "getDouble", "(", "offset", ")", ")", ")", ";", "offset", "+=", "8", ";", "break", ";", "case", "DERIVE", ":", "fields", ".", "put", "(", "label", ",", "Field", ".", "create", "(", "buf", ".", "getLong", "(", "offset", ")", ")", ")", ";", "offset", "+=", "8", ";", "break", ";", "case", "ABSOLUTE", ":", "fields", ".", "put", "(", "label", ",", "Field", ".", "create", "(", "buf", ".", "getUnsignedInt", "(", "offset", ")", ")", ")", ";", "offset", "+=", "8", ";", "break", ";", "default", ":", "// error", "throw", "new", "OnRecordErrorException", "(", "Errors", ".", "COLLECTD_01", ",", "type", ")", ";", "}", "}", "return", "offset", ";", "}"], "docstring": "Parses the value part of the packet where metrics are located\n\n@param startOffset beginning offset for this part\n@param buf         buffered packet\n@return offset after consuming part", "docstring_tokens": ["Parses", "the", "value", "part", "of", "the", "packet", "where", "metrics", "are", "located"]}
{"code": "error.printStackTrace(System.err);", "comments": "required as in local mode the following seems to be lost", "lines": 12, "repo": "streamsets/datacollector", "path": "cluster-bootstrap-api/src/main/java/com/streamsets/pipeline/BootstrapClusterStreaming.java", "func_name": "BootstrapClusterStreaming.main", "original_string": "public static void main(String[] args) throws Exception {\n    SparkStreamingBinding binding = null;\n    try {\n      binding = SparkStreamingBindingFactory.build(BootstrapCluster.getProperties());\n      binding.init();\n      BootstrapCluster.createTransformers(binding.getStreamingContext().sparkContext(), binding.getSparkSession());\n      binding.startContext();\n      binding.awaitTermination();\n    } catch (Throwable error) {\n      String msg = \"Error trying to invoke BootstrapClusterStreaming.main: \" + error;\n      System.err.println(new Date()+ \": \" + msg);\n      error.printStackTrace(System.err); // required as in local mode the following seems to be lost\n      LOG.error(msg, error);\n      throw new IllegalStateException(msg, error);\n    } finally {\n      try {\n        if (binding != null) {\n          binding.close();\n        }\n      } catch (Exception ex) {\n        LOG.warn(\"Error on binding close: \" + ex, ex);\n      }\n    }\n  }", "language": "java", "Allcodes": "public static void main(String[] args) throws Exception {\n    SparkStreamingBinding binding = null;\n    try {\n      binding = SparkStreamingBindingFactory.build(BootstrapCluster.getProperties());\n      binding.init();\n      BootstrapCluster.createTransformers(binding.getStreamingContext().sparkContext(), binding.getSparkSession());\n      binding.startContext();\n      binding.awaitTermination();\n    } catch (Throwable error) {\n      String msg = \"Error trying to invoke BootstrapClusterStreaming.main: \" + error;\n      System.err.println(new Date()+ \": \" + msg);\n      error.printStackTrace(System.err); // required as in local mode the following seems to be lost\n      LOG.error(msg, error);\n      throw new IllegalStateException(msg, error);\n    } finally {\n      try {\n        if (binding != null) {\n          binding.close();\n        }\n      } catch (Exception ex) {\n        LOG.warn(\"Error on binding close: \" + ex, ex);\n      }\n    }\n  }", "code_tokens": ["public", "static", "void", "main", "(", "String", "[", "]", "args", ")", "throws", "Exception", "{", "SparkStreamingBinding", "binding", "=", "null", ";", "try", "{", "binding", "=", "SparkStreamingBindingFactory", ".", "build", "(", "BootstrapCluster", ".", "getProperties", "(", ")", ")", ";", "binding", ".", "init", "(", ")", ";", "BootstrapCluster", ".", "createTransformers", "(", "binding", ".", "getStreamingContext", "(", ")", ".", "sparkContext", "(", ")", ",", "binding", ".", "getSparkSession", "(", ")", ")", ";", "binding", ".", "startContext", "(", ")", ";", "binding", ".", "awaitTermination", "(", ")", ";", "}", "catch", "(", "Throwable", "error", ")", "{", "String", "msg", "=", "\"Error trying to invoke BootstrapClusterStreaming.main: \"", "+", "error", ";", "System", ".", "err", ".", "println", "(", "new", "Date", "(", ")", "+", "\": \"", "+", "msg", ")", ";", "error", ".", "printStackTrace", "(", "System", ".", "err", ")", ";", "// required as in local mode the following seems to be lost", "LOG", ".", "error", "(", "msg", ",", "error", ")", ";", "throw", "new", "IllegalStateException", "(", "msg", ",", "error", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "binding", "!=", "null", ")", "{", "binding", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "LOG", ".", "warn", "(", "\"Error on binding close: \"", "+", "ex", ",", "ex", ")", ";", "}", "}", "}"], "docstring": "Bootstrapping the Driver which starts a Spark job on cluster", "docstring_tokens": ["Bootstrapping", "the", "Driver", "which", "starts", "a", "Spark", "job", "on", "cluster"]}
{"code": "binding.awaitTermination();", "comments": "killed by ClusterProviderImpl before returning", "lines": 6, "repo": "streamsets/datacollector", "path": "cluster-bootstrap-api/src/main/java/com/streamsets/pipeline/BootstrapEmrBatch.java", "func_name": "BootstrapEmrBatch.main", "original_string": "public static void main(String[] args) throws Exception {\n    EmrBinding binding = null;\n    try {\n      binding = new EmrBinding(args);\n      binding.init();\n      binding.awaitTermination(); // killed by ClusterProviderImpl before returning\n    } catch (Exception ex) {\n      String msg = \"Error trying to invoke BootstrapEmrBatch.main: \" + ex;\n      throw new IllegalStateException(msg, ex);\n    } finally {\n      try {\n        if (binding != null) {\n          binding.close();\n        }\n      } catch (Exception ex) {\n        LOG.warn(\"Error on binding close: \" + ex, ex);\n      }\n    }\n  }", "language": "java", "Allcodes": "public static void main(String[] args) throws Exception {\n    EmrBinding binding = null;\n    try {\n      binding = new EmrBinding(args);\n      binding.init();\n      binding.awaitTermination(); // killed by ClusterProviderImpl before returning\n    } catch (Exception ex) {\n      String msg = \"Error trying to invoke BootstrapEmrBatch.main: \" + ex;\n      throw new IllegalStateException(msg, ex);\n    } finally {\n      try {\n        if (binding != null) {\n          binding.close();\n        }\n      } catch (Exception ex) {\n        LOG.warn(\"Error on binding close: \" + ex, ex);\n      }\n    }\n  }", "code_tokens": ["public", "static", "void", "main", "(", "String", "[", "]", "args", ")", "throws", "Exception", "{", "EmrBinding", "binding", "=", "null", ";", "try", "{", "binding", "=", "new", "EmrBinding", "(", "args", ")", ";", "binding", ".", "init", "(", ")", ";", "binding", ".", "awaitTermination", "(", ")", ";", "// killed by ClusterProviderImpl before returning", "}", "catch", "(", "Exception", "ex", ")", "{", "String", "msg", "=", "\"Error trying to invoke BootstrapEmrBatch.main: \"", "+", "ex", ";", "throw", "new", "IllegalStateException", "(", "msg", ",", "ex", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "binding", "!=", "null", ")", "{", "binding", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "LOG", ".", "warn", "(", "\"Error on binding close: \"", "+", "ex", ",", "ex", ")", ";", "}", "}", "}"], "docstring": "Bootstrapping the Driver which starts a EMR job on cluster", "docstring_tokens": ["Bootstrapping", "the", "Driver", "which", "starts", "a", "EMR", "job", "on", "cluster"]}
{"code": "throw new Error(e);", "comments": "we won't recover, so throw an error", "lines": 14, "repo": "NanoHttpd/nanohttpd", "path": "core/src/main/java/org/nanohttpd/protocols/http/HTTPSession.java", "func_name": "HTTPSession.saveTmpFile", "original_string": "private String saveTmpFile(ByteBuffer b, int offset, int len, String filename_hint) {\n        String path = \"\";\n        if (len > 0) {\n            FileOutputStream fileOutputStream = null;\n            try {\n                ITempFile tempFile = this.tempFileManager.createTempFile(filename_hint);\n                ByteBuffer src = b.duplicate();\n                fileOutputStream = new FileOutputStream(tempFile.getName());\n                FileChannel dest = fileOutputStream.getChannel();\n                src.position(offset).limit(offset + len);\n                dest.write(src.slice());\n                path = tempFile.getName();\n            } catch (Exception e) { // Catch exception if any\n                throw new Error(e); // we won't recover, so throw an error\n            } finally {\n                NanoHTTPD.safeClose(fileOutputStream);\n            }\n        }\n        return path;\n    }", "language": "java", "Allcodes": "private String saveTmpFile(ByteBuffer b, int offset, int len, String filename_hint) {\n        String path = \"\";\n        if (len > 0) {\n            FileOutputStream fileOutputStream = null;\n            try {\n                ITempFile tempFile = this.tempFileManager.createTempFile(filename_hint);\n                ByteBuffer src = b.duplicate();\n                fileOutputStream = new FileOutputStream(tempFile.getName());\n                FileChannel dest = fileOutputStream.getChannel();\n                src.position(offset).limit(offset + len);\n                dest.write(src.slice());\n                path = tempFile.getName();\n            } catch (Exception e) { // Catch exception if any\n                throw new Error(e); // we won't recover, so throw an error\n            } finally {\n                NanoHTTPD.safeClose(fileOutputStream);\n            }\n        }\n        return path;\n    }", "code_tokens": ["private", "String", "saveTmpFile", "(", "ByteBuffer", "b", ",", "int", "offset", ",", "int", "len", ",", "String", "filename_hint", ")", "{", "String", "path", "=", "\"\"", ";", "if", "(", "len", ">", "0", ")", "{", "FileOutputStream", "fileOutputStream", "=", "null", ";", "try", "{", "ITempFile", "tempFile", "=", "this", ".", "tempFileManager", ".", "createTempFile", "(", "filename_hint", ")", ";", "ByteBuffer", "src", "=", "b", ".", "duplicate", "(", ")", ";", "fileOutputStream", "=", "new", "FileOutputStream", "(", "tempFile", ".", "getName", "(", ")", ")", ";", "FileChannel", "dest", "=", "fileOutputStream", ".", "getChannel", "(", ")", ";", "src", ".", "position", "(", "offset", ")", ".", "limit", "(", "offset", "+", "len", ")", ";", "dest", ".", "write", "(", "src", ".", "slice", "(", ")", ")", ";", "path", "=", "tempFile", ".", "getName", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "// Catch exception if any", "throw", "new", "Error", "(", "e", ")", ";", "// we won't recover, so throw an error", "}", "finally", "{", "NanoHTTPD", ".", "safeClose", "(", "fileOutputStream", ")", ";", "}", "}", "return", "path", ";", "}"], "docstring": "Retrieves the content of a sent file and saves it to a temporary file.\nThe full path to the saved file is returned.", "docstring_tokens": ["Retrieves", "the", "content", "of", "a", "sent", "file", "and", "saves", "it", "to", "a", "temporary", "file", ".", "The", "full", "path", "to", "the", "saved", "file", "is", "returned", "."]}
{"code": "ModelVersion MODEL_VERSION_EAP63 = ModelVersion.create(1, 3, 0);", "comments": "also EAP6.2", "lines": 4, "repo": "wildfly/wildfly", "path": "legacy/jacorb/src/main/java/org/jboss/as/jacorb/JacORBExtension.java", "func_name": "JacORBExtension.registerTransformers", "original_string": "protected static void registerTransformers(final SubsystemRegistration subsystem) {\n        ChainedTransformationDescriptionBuilder chained = ResourceTransformationDescriptionBuilder.Factory.createChainedSubystemInstance(CURRENT_MODEL_VERSION);\n        ModelVersion MODEL_VERSION_EAP64 = ModelVersion.create(1, 4, 0);\n        ModelVersion MODEL_VERSION_EAP63 = ModelVersion.create(1, 3, 0);//also EAP6.2\n\n        ResourceTransformationDescriptionBuilder builder64 = chained.createBuilder(CURRENT_MODEL_VERSION, MODEL_VERSION_EAP64);\n        builder64.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID.getDefaultValue()), JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID)\n                .setValueConverter(new AttributeConverter.DefaultValueAttributeConverter(JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES),JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES);\n\n\n        ResourceTransformationDescriptionBuilder builder63 = chained.createBuilder(MODEL_VERSION_EAP64, MODEL_VERSION_EAP63);\n        builder63.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORTransportConfigDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORASContextDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORSASContextDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .end()\n                .rejectChildResource(IORSettingsDefinition.INSTANCE.getPathElement());\n\n\n        chained.buildAndRegister(subsystem, new ModelVersion[]{\n                MODEL_VERSION_EAP64,\n                MODEL_VERSION_EAP63\n        });\n    }", "language": "java", "Allcodes": "protected static void registerTransformers(final SubsystemRegistration subsystem) {\n        ChainedTransformationDescriptionBuilder chained = ResourceTransformationDescriptionBuilder.Factory.createChainedSubystemInstance(CURRENT_MODEL_VERSION);\n        ModelVersion MODEL_VERSION_EAP64 = ModelVersion.create(1, 4, 0);\n        ModelVersion MODEL_VERSION_EAP63 = ModelVersion.create(1, 3, 0);//also EAP6.2\n\n        ResourceTransformationDescriptionBuilder builder64 = chained.createBuilder(CURRENT_MODEL_VERSION, MODEL_VERSION_EAP64);\n        builder64.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID)\n                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID.getDefaultValue()), JacORBSubsystemDefinitions.PERSISTENT_SERVER_ID)\n                .setValueConverter(new AttributeConverter.DefaultValueAttributeConverter(JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES),JacORBSubsystemDefinitions.INTEROP_CHUNK_RMI_VALUETYPES);\n\n\n        ResourceTransformationDescriptionBuilder builder63 = chained.createBuilder(MODEL_VERSION_EAP64, MODEL_VERSION_EAP63);\n        builder63.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORTransportConfigDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORASContextDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .addRejectCheck(RejectAttributeChecker.DEFINED, IORSASContextDefinition.ATTRIBUTES.toArray(new AttributeDefinition[0]))\n                .end()\n                .rejectChildResource(IORSettingsDefinition.INSTANCE.getPathElement());\n\n\n        chained.buildAndRegister(subsystem, new ModelVersion[]{\n                MODEL_VERSION_EAP64,\n                MODEL_VERSION_EAP63\n        });\n    }", "code_tokens": ["protected", "static", "void", "registerTransformers", "(", "final", "SubsystemRegistration", "subsystem", ")", "{", "ChainedTransformationDescriptionBuilder", "chained", "=", "ResourceTransformationDescriptionBuilder", ".", "Factory", ".", "createChainedSubystemInstance", "(", "CURRENT_MODEL_VERSION", ")", ";", "ModelVersion", "MODEL_VERSION_EAP64", "=", "ModelVersion", ".", "create", "(", "1", ",", "4", ",", "0", ")", ";", "ModelVersion", "MODEL_VERSION_EAP63", "=", "ModelVersion", ".", "create", "(", "1", ",", "3", ",", "0", ")", ";", "//also EAP6.2", "ResourceTransformationDescriptionBuilder", "builder64", "=", "chained", ".", "createBuilder", "(", "CURRENT_MODEL_VERSION", ",", "MODEL_VERSION_EAP64", ")", ";", "builder64", ".", "getAttributeBuilder", "(", ")", ".", "addRejectCheck", "(", "RejectAttributeChecker", ".", "DEFINED", ",", "JacORBSubsystemDefinitions", ".", "PERSISTENT_SERVER_ID", ")", ".", "setDiscard", "(", "new", "DiscardAttributeChecker", ".", "DiscardAttributeValueChecker", "(", "JacORBSubsystemDefinitions", ".", "PERSISTENT_SERVER_ID", ".", "getDefaultValue", "(", ")", ")", ",", "JacORBSubsystemDefinitions", ".", "PERSISTENT_SERVER_ID", ")", ".", "setValueConverter", "(", "new", "AttributeConverter", ".", "DefaultValueAttributeConverter", "(", "JacORBSubsystemDefinitions", ".", "INTEROP_CHUNK_RMI_VALUETYPES", ")", ",", "JacORBSubsystemDefinitions", ".", "INTEROP_CHUNK_RMI_VALUETYPES", ")", ";", "ResourceTransformationDescriptionBuilder", "builder63", "=", "chained", ".", "createBuilder", "(", "MODEL_VERSION_EAP64", ",", "MODEL_VERSION_EAP63", ")", ";", "builder63", ".", "getAttributeBuilder", "(", ")", ".", "addRejectCheck", "(", "RejectAttributeChecker", ".", "DEFINED", ",", "IORTransportConfigDefinition", ".", "ATTRIBUTES", ".", "toArray", "(", "new", "AttributeDefinition", "[", "0", "]", ")", ")", ".", "addRejectCheck", "(", "RejectAttributeChecker", ".", "DEFINED", ",", "IORASContextDefinition", ".", "ATTRIBUTES", ".", "toArray", "(", "new", "AttributeDefinition", "[", "0", "]", ")", ")", ".", "addRejectCheck", "(", "RejectAttributeChecker", ".", "DEFINED", ",", "IORSASContextDefinition", ".", "ATTRIBUTES", ".", "toArray", "(", "new", "AttributeDefinition", "[", "0", "]", ")", ")", ".", "end", "(", ")", ".", "rejectChildResource", "(", "IORSettingsDefinition", ".", "INSTANCE", ".", "getPathElement", "(", ")", ")", ";", "chained", ".", "buildAndRegister", "(", "subsystem", ",", "new", "ModelVersion", "[", "]", "{", "MODEL_VERSION_EAP64", ",", "MODEL_VERSION_EAP63", "}", ")", ";", "}"], "docstring": "Register the transformers for the 1.3.0 version.\n\n@param subsystem the subsystems registration", "docstring_tokens": ["Register", "the", "transformers", "for", "the", "1", ".", "3", ".", "0", "version", "."]}
{"code": "return;", "comments": "component has been restarted", "lines": 24, "repo": "wildfly/wildfly", "path": "ejb3/src/main/java/org/jboss/as/ejb3/component/interceptors/ShutDownInterceptorFactory.java", "func_name": "ShutDownInterceptorFactory.shutdown", "original_string": "public void shutdown() {\n        int value;\n        int oldValue;\n        //set the shutdown bit\n        do {\n            oldValue = invocationCount;\n            value = SHUTDOWN_FLAG | oldValue;\n            //the component has already been shutdown\n            if (oldValue == value) {\n                return;\n            }\n        } while (!updater.compareAndSet(this, oldValue, value));\n\n        synchronized (lock) {\n            value = invocationCount;\n            while (value != SHUTDOWN_FLAG) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                value = invocationCount;\n                if((value & SHUTDOWN_FLAG) == 0) {\n                    return; //component has been restarted\n                }\n            }\n        }\n    }", "language": "java", "Allcodes": "public void shutdown() {\n        int value;\n        int oldValue;\n        //set the shutdown bit\n        do {\n            oldValue = invocationCount;\n            value = SHUTDOWN_FLAG | oldValue;\n            //the component has already been shutdown\n            if (oldValue == value) {\n                return;\n            }\n        } while (!updater.compareAndSet(this, oldValue, value));\n\n        synchronized (lock) {\n            value = invocationCount;\n            while (value != SHUTDOWN_FLAG) {\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                value = invocationCount;\n                if((value & SHUTDOWN_FLAG) == 0) {\n                    return; //component has been restarted\n                }\n            }\n        }\n    }", "code_tokens": ["public", "void", "shutdown", "(", ")", "{", "int", "value", ";", "int", "oldValue", ";", "//set the shutdown bit", "do", "{", "oldValue", "=", "invocationCount", ";", "value", "=", "SHUTDOWN_FLAG", "|", "oldValue", ";", "//the component has already been shutdown", "if", "(", "oldValue", "==", "value", ")", "{", "return", ";", "}", "}", "while", "(", "!", "updater", ".", "compareAndSet", "(", "this", ",", "oldValue", ",", "value", ")", ")", ";", "synchronized", "(", "lock", ")", "{", "value", "=", "invocationCount", ";", "while", "(", "value", "!=", "SHUTDOWN_FLAG", ")", "{", "try", "{", "lock", ".", "wait", "(", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "value", "=", "invocationCount", ";", "if", "(", "(", "value", "&", "SHUTDOWN_FLAG", ")", "==", "0", ")", "{", "return", ";", "//component has been restarted", "}", "}", "}", "}"], "docstring": "Upon calling this method the EJB will be set to a shutdown state, and no further invocations will be allowed.\nIt will then wait for all active invocation to finish and then return.", "docstring_tokens": ["Upon", "calling", "this", "method", "the", "EJB", "will", "be", "set", "to", "a", "shutdown", "state", "and", "no", "further", "invocations", "will", "be", "allowed", ".", "It", "will", "then", "wait", "for", "all", "active", "invocation", "to", "finish", "and", "then", "return", "."]}
{"code": "continue;", "comments": "success move to next detail", "lines": 45, "repo": "wildfly/wildfly", "path": "jaxrs/src/main/java/org/jboss/as/jaxrs/deployment/JaxrsMethodParameterProcessor.java", "func_name": "JaxrsMethodParameterProcessor.validateDefaultValues", "original_string": "private void validateDefaultValues(List<ParamDetail> detailList,\n                                       HashMap<String, List<Validator>> paramConverterMap)\n            throws DeploymentUnitProcessingException {\n\n        for(ParamDetail detail : detailList) {\n\n            // check param converter for specific return type\n            List<Validator> validators = paramConverterMap.get(\n                    detail.parameter.getName());\n\n            if (validators == null) {\n                // check for paramConverterProvider\n                validators = paramConverterMap.get(Object.class.getName());\n            }\n\n            boolean isCheckClazzMethods = true;\n            if (validators != null) {\n                for (Validator v : validators) {\n                    if (!v.isLazyLoad()) {\n                        try {\n                            Object obj = v.verify(detail);\n                            if (obj != null) {\n                                isCheckClazzMethods = false;\n                                break;\n                            }\n                        } catch (Exception e) {\n                            JAXRS_LOGGER.paramConverterFailed(detail.defaultValue.value(),\n                                    detail.parameter.getSimpleName(),\n                                    detail.method.toString(),\n                                    v.toString(), e.getClass().getName(),\n                                    e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            if (isCheckClazzMethods) {\n                Class baseType = detail.parameter;\n                Method valueOf = null;\n\n                // constructor rule\n                try {\n                    Constructor<?> ctor = baseType.getConstructor(String.class);\n                    if (Modifier.isPublic(ctor.getModifiers())) {\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignored) { }\n\n                // method fromValue(String.class) rule\n                try {\n                    Method fromValue = baseType.getDeclaredMethod(\"fromValue\", String.class);\n                    if (Modifier.isPublic(fromValue.getModifiers())) {\n                        for (Annotation ann : baseType.getAnnotations()) {\n                            if (ann.annotationType().getName()\n                                    .equals(\"javax.xml.bind.annotation.XmlEnum\")) {\n                                valueOf = fromValue;\n                            }\n                        }\n                        validateBaseType(fromValue, detail.defaultValue.value(), detail);\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignoredA) { }\n\n                // method fromString(String.class) rule\n                Method fromString = null;\n                try {\n                    fromString = baseType.getDeclaredMethod(\"fromString\", String.class);\n                    if (Modifier.isStatic(fromString.getModifiers())) {\n                        validateBaseType(fromString, detail.defaultValue.value(), detail);\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignoredB) {\n                }\n\n                // method valueof(String.class) rule\n                try {\n                    valueOf = baseType.getDeclaredMethod(\"valueOf\", String.class);\n                    if (Modifier.isStatic(valueOf.getModifiers())) {\n                        validateBaseType(valueOf, detail.defaultValue.value(), detail);\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignored) {\n                }\n\n            }\n        }\n\n    }", "language": "java", "Allcodes": "private void validateDefaultValues(List<ParamDetail> detailList,\n                                       HashMap<String, List<Validator>> paramConverterMap)\n            throws DeploymentUnitProcessingException {\n\n        for(ParamDetail detail : detailList) {\n\n            // check param converter for specific return type\n            List<Validator> validators = paramConverterMap.get(\n                    detail.parameter.getName());\n\n            if (validators == null) {\n                // check for paramConverterProvider\n                validators = paramConverterMap.get(Object.class.getName());\n            }\n\n            boolean isCheckClazzMethods = true;\n            if (validators != null) {\n                for (Validator v : validators) {\n                    if (!v.isLazyLoad()) {\n                        try {\n                            Object obj = v.verify(detail);\n                            if (obj != null) {\n                                isCheckClazzMethods = false;\n                                break;\n                            }\n                        } catch (Exception e) {\n                            JAXRS_LOGGER.paramConverterFailed(detail.defaultValue.value(),\n                                    detail.parameter.getSimpleName(),\n                                    detail.method.toString(),\n                                    v.toString(), e.getClass().getName(),\n                                    e.getMessage());\n                        }\n                    }\n                }\n            }\n\n            if (isCheckClazzMethods) {\n                Class baseType = detail.parameter;\n                Method valueOf = null;\n\n                // constructor rule\n                try {\n                    Constructor<?> ctor = baseType.getConstructor(String.class);\n                    if (Modifier.isPublic(ctor.getModifiers())) {\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignored) { }\n\n                // method fromValue(String.class) rule\n                try {\n                    Method fromValue = baseType.getDeclaredMethod(\"fromValue\", String.class);\n                    if (Modifier.isPublic(fromValue.getModifiers())) {\n                        for (Annotation ann : baseType.getAnnotations()) {\n                            if (ann.annotationType().getName()\n                                    .equals(\"javax.xml.bind.annotation.XmlEnum\")) {\n                                valueOf = fromValue;\n                            }\n                        }\n                        validateBaseType(fromValue, detail.defaultValue.value(), detail);\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignoredA) { }\n\n                // method fromString(String.class) rule\n                Method fromString = null;\n                try {\n                    fromString = baseType.getDeclaredMethod(\"fromString\", String.class);\n                    if (Modifier.isStatic(fromString.getModifiers())) {\n                        validateBaseType(fromString, detail.defaultValue.value(), detail);\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignoredB) {\n                }\n\n                // method valueof(String.class) rule\n                try {\n                    valueOf = baseType.getDeclaredMethod(\"valueOf\", String.class);\n                    if (Modifier.isStatic(valueOf.getModifiers())) {\n                        validateBaseType(valueOf, detail.defaultValue.value(), detail);\n                        continue; // success move to next detail\n                    }\n                } catch (NoSuchMethodException ignored) {\n                }\n\n            }\n        }\n\n    }", "code_tokens": ["private", "void", "validateDefaultValues", "(", "List", "<", "ParamDetail", ">", "detailList", ",", "HashMap", "<", "String", ",", "List", "<", "Validator", ">", ">", "paramConverterMap", ")", "throws", "DeploymentUnitProcessingException", "{", "for", "(", "ParamDetail", "detail", ":", "detailList", ")", "{", "// check param converter for specific return type", "List", "<", "Validator", ">", "validators", "=", "paramConverterMap", ".", "get", "(", "detail", ".", "parameter", ".", "getName", "(", ")", ")", ";", "if", "(", "validators", "==", "null", ")", "{", "// check for paramConverterProvider", "validators", "=", "paramConverterMap", ".", "get", "(", "Object", ".", "class", ".", "getName", "(", ")", ")", ";", "}", "boolean", "isCheckClazzMethods", "=", "true", ";", "if", "(", "validators", "!=", "null", ")", "{", "for", "(", "Validator", "v", ":", "validators", ")", "{", "if", "(", "!", "v", ".", "isLazyLoad", "(", ")", ")", "{", "try", "{", "Object", "obj", "=", "v", ".", "verify", "(", "detail", ")", ";", "if", "(", "obj", "!=", "null", ")", "{", "isCheckClazzMethods", "=", "false", ";", "break", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "JAXRS_LOGGER", ".", "paramConverterFailed", "(", "detail", ".", "defaultValue", ".", "value", "(", ")", ",", "detail", ".", "parameter", ".", "getSimpleName", "(", ")", ",", "detail", ".", "method", ".", "toString", "(", ")", ",", "v", ".", "toString", "(", ")", ",", "e", ".", "getClass", "(", ")", ".", "getName", "(", ")", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "}", "if", "(", "isCheckClazzMethods", ")", "{", "Class", "baseType", "=", "detail", ".", "parameter", ";", "Method", "valueOf", "=", "null", ";", "// constructor rule", "try", "{", "Constructor", "<", "?", ">", "ctor", "=", "baseType", ".", "getConstructor", "(", "String", ".", "class", ")", ";", "if", "(", "Modifier", ".", "isPublic", "(", "ctor", ".", "getModifiers", "(", ")", ")", ")", "{", "continue", ";", "// success move to next detail", "}", "}", "catch", "(", "NoSuchMethodException", "ignored", ")", "{", "}", "// method fromValue(String.class) rule", "try", "{", "Method", "fromValue", "=", "baseType", ".", "getDeclaredMethod", "(", "\"fromValue\"", ",", "String", ".", "class", ")", ";", "if", "(", "Modifier", ".", "isPublic", "(", "fromValue", ".", "getModifiers", "(", ")", ")", ")", "{", "for", "(", "Annotation", "ann", ":", "baseType", ".", "getAnnotations", "(", ")", ")", "{", "if", "(", "ann", ".", "annotationType", "(", ")", ".", "getName", "(", ")", ".", "equals", "(", "\"javax.xml.bind.annotation.XmlEnum\"", ")", ")", "{", "valueOf", "=", "fromValue", ";", "}", "}", "validateBaseType", "(", "fromValue", ",", "detail", ".", "defaultValue", ".", "value", "(", ")", ",", "detail", ")", ";", "continue", ";", "// success move to next detail", "}", "}", "catch", "(", "NoSuchMethodException", "ignoredA", ")", "{", "}", "// method fromString(String.class) rule", "Method", "fromString", "=", "null", ";", "try", "{", "fromString", "=", "baseType", ".", "getDeclaredMethod", "(", "\"fromString\"", ",", "String", ".", "class", ")", ";", "if", "(", "Modifier", ".", "isStatic", "(", "fromString", ".", "getModifiers", "(", ")", ")", ")", "{", "validateBaseType", "(", "fromString", ",", "detail", ".", "defaultValue", ".", "value", "(", ")", ",", "detail", ")", ";", "continue", ";", "// success move to next detail", "}", "}", "catch", "(", "NoSuchMethodException", "ignoredB", ")", "{", "}", "// method valueof(String.class) rule", "try", "{", "valueOf", "=", "baseType", ".", "getDeclaredMethod", "(", "\"valueOf\"", ",", "String", ".", "class", ")", ";", "if", "(", "Modifier", ".", "isStatic", "(", "valueOf", ".", "getModifiers", "(", ")", ")", ")", "{", "validateBaseType", "(", "valueOf", ",", "detail", ".", "defaultValue", ".", "value", "(", ")", ",", "detail", ")", ";", "continue", ";", "// success move to next detail", "}", "}", "catch", "(", "NoSuchMethodException", "ignored", ")", "{", "}", "}", "}", "}"], "docstring": "Process all parameter DefaulValue objects.  Flag all parameters with\nmissing and invalid converters.\n\n@param detailList\n@param paramConverterMap", "docstring_tokens": ["Process", "all", "parameter", "DefaulValue", "objects", ".", "Flag", "all", "parameters", "with", "missing", "and", "invalid", "converters", "."]}
{"code": "return;", "comments": "Skip if there are no beans.xml files in the deployment", "lines": 10, "repo": "wildfly/wildfly", "path": "weld/subsystem/src/main/java/org/jboss/as/weld/deployment/processors/WeldDependencyProcessor.java", "func_name": "WeldDependencyProcessor.deploy", "original_string": "public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAVAX_ENTERPRISE_API);\n        addDependency(moduleSpecification, moduleLoader, JAVAX_INJECT_API);\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return; // Skip if there are no beans.xml files in the deployment\n        }\n        addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_CORE_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_PROBE_ID, true);\n        addDependency(moduleSpecification, moduleLoader, WELD_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_SPI_ID);\n\n        ModuleDependency weldSubsystemDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_ID, false, false, false, false);\n        weldSubsystemDependency.addImportFilter(PathFilters.getMetaInfFilter(), true);\n        weldSubsystemDependency.addImportFilter(PathFilters.is(\"org/jboss/as/weld/injection\"), true);\n        weldSubsystemDependency.addImportFilter(PathFilters.acceptAll(), false);\n        weldSubsystemDependency.addExportFilter(PathFilters.getMetaInfFilter(), true);\n        moduleSpecification.addSystemDependency(weldSubsystemDependency);\n\n        // Due to serialization of EJBs\n        ModuleDependency weldEjbDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_EJB_ID, true, false, false, false);\n        weldEjbDependency.addImportFilter(PathFilters.is(\"org/jboss/as/weld/ejb\"), true);\n        weldEjbDependency.addImportFilter(PathFilters.acceptAll(), false);\n        moduleSpecification.addSystemDependency(weldEjbDependency);\n    }", "language": "java", "Allcodes": "public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        addDependency(moduleSpecification, moduleLoader, JAVAX_ENTERPRISE_API);\n        addDependency(moduleSpecification, moduleLoader, JAVAX_INJECT_API);\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return; // Skip if there are no beans.xml files in the deployment\n        }\n        addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_CORE_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_PROBE_ID, true);\n        addDependency(moduleSpecification, moduleLoader, WELD_API_ID);\n        addDependency(moduleSpecification, moduleLoader, WELD_SPI_ID);\n\n        ModuleDependency weldSubsystemDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_ID, false, false, false, false);\n        weldSubsystemDependency.addImportFilter(PathFilters.getMetaInfFilter(), true);\n        weldSubsystemDependency.addImportFilter(PathFilters.is(\"org/jboss/as/weld/injection\"), true);\n        weldSubsystemDependency.addImportFilter(PathFilters.acceptAll(), false);\n        weldSubsystemDependency.addExportFilter(PathFilters.getMetaInfFilter(), true);\n        moduleSpecification.addSystemDependency(weldSubsystemDependency);\n\n        // Due to serialization of EJBs\n        ModuleDependency weldEjbDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_EJB_ID, true, false, false, false);\n        weldEjbDependency.addImportFilter(PathFilters.is(\"org/jboss/as/weld/ejb\"), true);\n        weldEjbDependency.addImportFilter(PathFilters.acceptAll(), false);\n        moduleSpecification.addSystemDependency(weldEjbDependency);\n    }", "code_tokens": ["public", "void", "deploy", "(", "DeploymentPhaseContext", "phaseContext", ")", "throws", "DeploymentUnitProcessingException", "{", "final", "DeploymentUnit", "deploymentUnit", "=", "phaseContext", ".", "getDeploymentUnit", "(", ")", ";", "final", "ModuleSpecification", "moduleSpecification", "=", "deploymentUnit", ".", "getAttachment", "(", "Attachments", ".", "MODULE_SPECIFICATION", ")", ";", "final", "ModuleLoader", "moduleLoader", "=", "Module", ".", "getBootModuleLoader", "(", ")", ";", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "JAVAX_ENTERPRISE_API", ")", ";", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "JAVAX_INJECT_API", ")", ";", "if", "(", "!", "WeldDeploymentMarker", ".", "isPartOfWeldDeployment", "(", "deploymentUnit", ")", ")", "{", "return", ";", "// Skip if there are no beans.xml files in the deployment", "}", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "JAVAX_PERSISTENCE_API_ID", ")", ";", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "WELD_CORE_ID", ")", ";", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "WELD_PROBE_ID", ",", "true", ")", ";", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "WELD_API_ID", ")", ";", "addDependency", "(", "moduleSpecification", ",", "moduleLoader", ",", "WELD_SPI_ID", ")", ";", "ModuleDependency", "weldSubsystemDependency", "=", "new", "ModuleDependency", "(", "moduleLoader", ",", "JBOSS_AS_WELD_ID", ",", "false", ",", "false", ",", "false", ",", "false", ")", ";", "weldSubsystemDependency", ".", "addImportFilter", "(", "PathFilters", ".", "getMetaInfFilter", "(", ")", ",", "true", ")", ";", "weldSubsystemDependency", ".", "addImportFilter", "(", "PathFilters", ".", "is", "(", "\"org/jboss/as/weld/injection\"", ")", ",", "true", ")", ";", "weldSubsystemDependency", ".", "addImportFilter", "(", "PathFilters", ".", "acceptAll", "(", ")", ",", "false", ")", ";", "weldSubsystemDependency", ".", "addExportFilter", "(", "PathFilters", ".", "getMetaInfFilter", "(", ")", ",", "true", ")", ";", "moduleSpecification", ".", "addSystemDependency", "(", "weldSubsystemDependency", ")", ";", "// Due to serialization of EJBs", "ModuleDependency", "weldEjbDependency", "=", "new", "ModuleDependency", "(", "moduleLoader", ",", "JBOSS_AS_WELD_EJB_ID", ",", "true", ",", "false", ",", "false", ",", "false", ")", ";", "weldEjbDependency", ".", "addImportFilter", "(", "PathFilters", ".", "is", "(", "\"org/jboss/as/weld/ejb\"", ")", ",", "true", ")", ";", "weldEjbDependency", ".", "addImportFilter", "(", "PathFilters", ".", "acceptAll", "(", ")", ",", "false", ")", ";", "moduleSpecification", ".", "addSystemDependency", "(", "weldEjbDependency", ")", ";", "}"], "docstring": "Add dependencies for modules required for weld deployments, if managed weld configurations are attached to the deployment", "docstring_tokens": ["Add", "dependencies", "for", "modules", "required", "for", "weld", "deployments", "if", "managed", "weld", "configurations", "are", "attached", "to", "the", "deployment"]}
{"code": "res.append('J');", "comments": "1.3.2.3", "lines": 8, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/Util.java", "func_name": "Util.javaToIDLName", "original_string": "public static String javaToIDLName(String name) {\n        if (name == null || \"\".equals(name) || name.indexOf('.') != -1)\n            throw IIOPLogger.ROOT_LOGGER.nameCannotBeNullEmptyOrQualified();\n\n        StringBuffer res = new StringBuffer(name.length());\n\n        if (name.charAt(0) == '_')\n            res.append('J'); // 1.3.2.3\n\n        for (int i = 0; i < name.length(); ++i) {\n            char c = name.charAt(i);\n\n            if (isLegalIDLIdentifierChar(c))\n                res.append(c);\n            else // 1.3.2.4\n                res.append('U').append(toHexString((int) c));\n        }\n\n        String s = res.toString();\n\n        if (isReservedIDLKeyword(s))\n            return \"_\" + s;\n        else\n            return s;\n    }", "language": "java", "Allcodes": "public static String javaToIDLName(String name) {\n        if (name == null || \"\".equals(name) || name.indexOf('.') != -1)\n            throw IIOPLogger.ROOT_LOGGER.nameCannotBeNullEmptyOrQualified();\n\n        StringBuffer res = new StringBuffer(name.length());\n\n        if (name.charAt(0) == '_')\n            res.append('J'); // 1.3.2.3\n\n        for (int i = 0; i < name.length(); ++i) {\n            char c = name.charAt(i);\n\n            if (isLegalIDLIdentifierChar(c))\n                res.append(c);\n            else // 1.3.2.4\n                res.append('U').append(toHexString((int) c));\n        }\n\n        String s = res.toString();\n\n        if (isReservedIDLKeyword(s))\n            return \"_\" + s;\n        else\n            return s;\n    }", "code_tokens": ["public", "static", "String", "javaToIDLName", "(", "String", "name", ")", "{", "if", "(", "name", "==", "null", "||", "\"\"", ".", "equals", "(", "name", ")", "||", "name", ".", "indexOf", "(", "'", "'", ")", "!=", "-", "1", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "nameCannotBeNullEmptyOrQualified", "(", ")", ";", "StringBuffer", "res", "=", "new", "StringBuffer", "(", "name", ".", "length", "(", ")", ")", ";", "if", "(", "name", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "res", ".", "append", "(", "'", "'", ")", ";", "// 1.3.2.3", "for", "(", "int", "i", "=", "0", ";", "i", "<", "name", ".", "length", "(", ")", ";", "++", "i", ")", "{", "char", "c", "=", "name", ".", "charAt", "(", "i", ")", ";", "if", "(", "isLegalIDLIdentifierChar", "(", "c", ")", ")", "res", ".", "append", "(", "c", ")", ";", "else", "// 1.3.2.4", "res", ".", "append", "(", "'", "'", ")", ".", "append", "(", "toHexString", "(", "(", "int", ")", "c", ")", ")", ";", "}", "String", "s", "=", "res", ".", "toString", "(", ")", ";", "if", "(", "isReservedIDLKeyword", "(", "s", ")", ")", "return", "\"_\"", "+", "s", ";", "else", "return", "s", ";", "}"], "docstring": "Map Java name to IDL name, as per sections 1.3.2.3, 1.3.2.4 and\n1.3.2.2.\nThis only works for a single name component, without a qualifying\ndot.", "docstring_tokens": ["Map", "Java", "name", "to", "IDL", "name", "as", "per", "sections", "1", ".", "3", ".", "2", ".", "3", "1", ".", "3", ".", "2", ".", "4", "and", "1", ".", "3", ".", "2", ".", "2", ".", "This", "only", "works", "for", "a", "single", "name", "component", "without", "a", "qualifying", "dot", "."]}
{"code": "throw new RuntimeException(e);", "comments": "this method really should have thrown IOException", "lines": 28, "repo": "wildfly/wildfly", "path": "undertow/src/main/java/org/wildfly/extension/undertow/deployment/ServletResourceManager.java", "func_name": "ServletResourceManager.list", "original_string": "public List<Resource> list(String path) {\n        try {\n            final List<Resource> ret = new ArrayList<>();\n\n            Resource res = deploymentResourceManager.getResource(path);\n            if (res != null) {\n                for (Resource child : res.list()) {\n                    ret.add(new ServletResource(this, child));\n                }\n            }\n            String p = path;\n            if (p.startsWith(\"/\")) {\n                p = p.substring(1);\n            }\n            if (overlays != null) {\n                for (VirtualFile overlay : overlays) {\n                    VirtualFile child = overlay.getChild(p);\n                    if (child.exists()) {\n                        VirtualFileResource vfsResource = new VirtualFileResource(overlay.getPhysicalFile(), child, path);\n                        for (Resource c : vfsResource.list()) {\n                            ret.add(new ServletResource(this, c));\n                        }\n                    }\n                }\n            }\n            return ret;\n        } catch (IOException e) {\n            throw new RuntimeException(e); //this method really should have thrown IOException\n        }\n    }", "language": "java", "Allcodes": "public List<Resource> list(String path) {\n        try {\n            final List<Resource> ret = new ArrayList<>();\n\n            Resource res = deploymentResourceManager.getResource(path);\n            if (res != null) {\n                for (Resource child : res.list()) {\n                    ret.add(new ServletResource(this, child));\n                }\n            }\n            String p = path;\n            if (p.startsWith(\"/\")) {\n                p = p.substring(1);\n            }\n            if (overlays != null) {\n                for (VirtualFile overlay : overlays) {\n                    VirtualFile child = overlay.getChild(p);\n                    if (child.exists()) {\n                        VirtualFileResource vfsResource = new VirtualFileResource(overlay.getPhysicalFile(), child, path);\n                        for (Resource c : vfsResource.list()) {\n                            ret.add(new ServletResource(this, c));\n                        }\n                    }\n                }\n            }\n            return ret;\n        } catch (IOException e) {\n            throw new RuntimeException(e); //this method really should have thrown IOException\n        }\n    }", "code_tokens": ["public", "List", "<", "Resource", ">", "list", "(", "String", "path", ")", "{", "try", "{", "final", "List", "<", "Resource", ">", "ret", "=", "new", "ArrayList", "<>", "(", ")", ";", "Resource", "res", "=", "deploymentResourceManager", ".", "getResource", "(", "path", ")", ";", "if", "(", "res", "!=", "null", ")", "{", "for", "(", "Resource", "child", ":", "res", ".", "list", "(", ")", ")", "{", "ret", ".", "add", "(", "new", "ServletResource", "(", "this", ",", "child", ")", ")", ";", "}", "}", "String", "p", "=", "path", ";", "if", "(", "p", ".", "startsWith", "(", "\"/\"", ")", ")", "{", "p", "=", "p", ".", "substring", "(", "1", ")", ";", "}", "if", "(", "overlays", "!=", "null", ")", "{", "for", "(", "VirtualFile", "overlay", ":", "overlays", ")", "{", "VirtualFile", "child", "=", "overlay", ".", "getChild", "(", "p", ")", ";", "if", "(", "child", ".", "exists", "(", ")", ")", "{", "VirtualFileResource", "vfsResource", "=", "new", "VirtualFileResource", "(", "overlay", ".", "getPhysicalFile", "(", ")", ",", "child", ",", "path", ")", ";", "for", "(", "Resource", "c", ":", "vfsResource", ".", "list", "(", ")", ")", "{", "ret", ".", "add", "(", "new", "ServletResource", "(", "this", ",", "c", ")", ")", ";", "}", "}", "}", "}", "return", "ret", ";", "}", "catch", "(", "IOException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "//this method really should have thrown IOException", "}", "}"], "docstring": "Lists all children of a particular path, taking overlays into account\n\n@param path The path\n@return The list of children", "docstring_tokens": ["Lists", "all", "children", "of", "a", "particular", "path", "taking", "overlays", "into", "account"]}
{"code": "return;", "comments": "Skip non web deployments", "lines": 4, "repo": "wildfly/wildfly", "path": "undertow/src/main/java/org/wildfly/extension/undertow/deployment/WarAnnotationDeploymentProcessor.java", "func_name": "WarAnnotationDeploymentProcessor.deploy", "original_string": "public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        Map<String, WebMetaData> annotationsMetaData = warMetaData.getAnnotationsMetaData();\n        if (annotationsMetaData == null) {\n            annotationsMetaData = new HashMap<String, WebMetaData>();\n            warMetaData.setAnnotationsMetaData(annotationsMetaData);\n        }\n        Map<ResourceRoot, Index> indexes = AnnotationIndexUtils.getAnnotationIndexes(deploymentUnit);\n\n        // Process lib/*.jar\n        for (final Entry<ResourceRoot, Index> entry : indexes.entrySet()) {\n            final Index jarIndex = entry.getValue();\n            annotationsMetaData.put(entry.getKey().getRootName(), processAnnotations(jarIndex));\n        }\n\n        Map<ModuleIdentifier, CompositeIndex> additionalModelAnnotations = deploymentUnit.getAttachment(Attachments.ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE);\n        if (additionalModelAnnotations != null) {\n            final List<WebMetaData> additional = new ArrayList<WebMetaData>();\n            for (Entry<ModuleIdentifier, CompositeIndex> entry : additionalModelAnnotations.entrySet()) {\n                for(Index index : entry.getValue().getIndexes()) {\n                    additional.add(processAnnotations(index));\n                }\n            }\n            warMetaData.setAdditionalModuleAnnotationsMetadata(additional);\n        }\n    }", "language": "java", "Allcodes": "public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        Map<String, WebMetaData> annotationsMetaData = warMetaData.getAnnotationsMetaData();\n        if (annotationsMetaData == null) {\n            annotationsMetaData = new HashMap<String, WebMetaData>();\n            warMetaData.setAnnotationsMetaData(annotationsMetaData);\n        }\n        Map<ResourceRoot, Index> indexes = AnnotationIndexUtils.getAnnotationIndexes(deploymentUnit);\n\n        // Process lib/*.jar\n        for (final Entry<ResourceRoot, Index> entry : indexes.entrySet()) {\n            final Index jarIndex = entry.getValue();\n            annotationsMetaData.put(entry.getKey().getRootName(), processAnnotations(jarIndex));\n        }\n\n        Map<ModuleIdentifier, CompositeIndex> additionalModelAnnotations = deploymentUnit.getAttachment(Attachments.ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE);\n        if (additionalModelAnnotations != null) {\n            final List<WebMetaData> additional = new ArrayList<WebMetaData>();\n            for (Entry<ModuleIdentifier, CompositeIndex> entry : additionalModelAnnotations.entrySet()) {\n                for(Index index : entry.getValue().getIndexes()) {\n                    additional.add(processAnnotations(index));\n                }\n            }\n            warMetaData.setAdditionalModuleAnnotationsMetadata(additional);\n        }\n    }", "code_tokens": ["public", "void", "deploy", "(", "final", "DeploymentPhaseContext", "phaseContext", ")", "throws", "DeploymentUnitProcessingException", "{", "final", "DeploymentUnit", "deploymentUnit", "=", "phaseContext", ".", "getDeploymentUnit", "(", ")", ";", "if", "(", "!", "DeploymentTypeMarker", ".", "isType", "(", "DeploymentType", ".", "WAR", ",", "deploymentUnit", ")", ")", "{", "return", ";", "// Skip non web deployments", "}", "WarMetaData", "warMetaData", "=", "deploymentUnit", ".", "getAttachment", "(", "WarMetaData", ".", "ATTACHMENT_KEY", ")", ";", "assert", "warMetaData", "!=", "null", ";", "Map", "<", "String", ",", "WebMetaData", ">", "annotationsMetaData", "=", "warMetaData", ".", "getAnnotationsMetaData", "(", ")", ";", "if", "(", "annotationsMetaData", "==", "null", ")", "{", "annotationsMetaData", "=", "new", "HashMap", "<", "String", ",", "WebMetaData", ">", "(", ")", ";", "warMetaData", ".", "setAnnotationsMetaData", "(", "annotationsMetaData", ")", ";", "}", "Map", "<", "ResourceRoot", ",", "Index", ">", "indexes", "=", "AnnotationIndexUtils", ".", "getAnnotationIndexes", "(", "deploymentUnit", ")", ";", "// Process lib/*.jar", "for", "(", "final", "Entry", "<", "ResourceRoot", ",", "Index", ">", "entry", ":", "indexes", ".", "entrySet", "(", ")", ")", "{", "final", "Index", "jarIndex", "=", "entry", ".", "getValue", "(", ")", ";", "annotationsMetaData", ".", "put", "(", "entry", ".", "getKey", "(", ")", ".", "getRootName", "(", ")", ",", "processAnnotations", "(", "jarIndex", ")", ")", ";", "}", "Map", "<", "ModuleIdentifier", ",", "CompositeIndex", ">", "additionalModelAnnotations", "=", "deploymentUnit", ".", "getAttachment", "(", "Attachments", ".", "ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE", ")", ";", "if", "(", "additionalModelAnnotations", "!=", "null", ")", "{", "final", "List", "<", "WebMetaData", ">", "additional", "=", "new", "ArrayList", "<", "WebMetaData", ">", "(", ")", ";", "for", "(", "Entry", "<", "ModuleIdentifier", ",", "CompositeIndex", ">", "entry", ":", "additionalModelAnnotations", ".", "entrySet", "(", ")", ")", "{", "for", "(", "Index", "index", ":", "entry", ".", "getValue", "(", ")", ".", "getIndexes", "(", ")", ")", "{", "additional", ".", "add", "(", "processAnnotations", "(", "index", ")", ")", ";", "}", "}", "warMetaData", ".", "setAdditionalModuleAnnotationsMetadata", "(", "additional", ")", ";", "}", "}"], "docstring": "Process web annotations.", "docstring_tokens": ["Process", "web", "annotations", "."]}
{"code": "idCount = kindCount = 0;", "comments": "reset for new component", "lines": 11, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNNameParser.java", "func_name": "CNNameParser.insStringToStringifiedComps", "original_string": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "language": "java", "Allcodes": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "code_tokens": ["private", "static", "Vector", "insStringToStringifiedComps", "(", "String", "str", ")", "throws", "InvalidNameException", "{", "int", "len", "=", "str", ".", "length", "(", ")", ";", "Vector", "components", "=", "new", "Vector", "(", "10", ")", ";", "char", "[", "]", "id", "=", "new", "char", "[", "len", "]", ";", "char", "[", "]", "kind", "=", "new", "char", "[", "len", "]", ";", "int", "idCount", ",", "kindCount", ";", "boolean", "idMode", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", ")", "{", "idCount", "=", "kindCount", "=", "0", ";", "// reset for new component", "idMode", "=", "true", ";", "// always start off parsing id", "while", "(", "i", "<", "len", ")", "{", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "compSeparator", ")", "{", "break", ";", "}", "else", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "str", ")", ";", "}", "else", "if", "(", "isMeta", "(", "str", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "// skip escape and let meta through", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "str", ")", ";", "}", "}", "else", "if", "(", "idMode", "&&", "str", ".", "charAt", "(", "i", ")", "==", "kindSeparator", ")", "{", "// just look for the first kindSeparator", "++", "i", ";", "// skip kind separator", "idMode", "=", "false", ";", "}", "else", "{", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "}", "components", ".", "addElement", "(", "stringifyComponent", "(", "new", "NameComponent", "(", "new", "String", "(", "id", ",", "0", ",", "idCount", ")", ",", "new", "String", "(", "kind", ",", "0", ",", "kindCount", ")", ")", ")", ")", ";", "if", "(", "i", "<", "len", ")", "{", "++", "i", ";", "// skip separator", "}", "}", "return", "components", ";", "}"], "docstring": "Converts an INS-syntax string name into a Vector in which\neach element of the vector contains a stringified form of\na NameComponent.", "docstring_tokens": ["Converts", "an", "INS", "-", "syntax", "string", "name", "into", "a", "Vector", "in", "which", "each", "element", "of", "the", "vector", "contains", "a", "stringified", "form", "of", "a", "NameComponent", "."]}
{"code": "idMode = true;", "comments": "always start off parsing id", "lines": 12, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNNameParser.java", "func_name": "CNNameParser.insStringToStringifiedComps", "original_string": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "language": "java", "Allcodes": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "code_tokens": ["private", "static", "Vector", "insStringToStringifiedComps", "(", "String", "str", ")", "throws", "InvalidNameException", "{", "int", "len", "=", "str", ".", "length", "(", ")", ";", "Vector", "components", "=", "new", "Vector", "(", "10", ")", ";", "char", "[", "]", "id", "=", "new", "char", "[", "len", "]", ";", "char", "[", "]", "kind", "=", "new", "char", "[", "len", "]", ";", "int", "idCount", ",", "kindCount", ";", "boolean", "idMode", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", ")", "{", "idCount", "=", "kindCount", "=", "0", ";", "// reset for new component", "idMode", "=", "true", ";", "// always start off parsing id", "while", "(", "i", "<", "len", ")", "{", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "compSeparator", ")", "{", "break", ";", "}", "else", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "str", ")", ";", "}", "else", "if", "(", "isMeta", "(", "str", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "// skip escape and let meta through", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "str", ")", ";", "}", "}", "else", "if", "(", "idMode", "&&", "str", ".", "charAt", "(", "i", ")", "==", "kindSeparator", ")", "{", "// just look for the first kindSeparator", "++", "i", ";", "// skip kind separator", "idMode", "=", "false", ";", "}", "else", "{", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "}", "components", ".", "addElement", "(", "stringifyComponent", "(", "new", "NameComponent", "(", "new", "String", "(", "id", ",", "0", ",", "idCount", ")", ",", "new", "String", "(", "kind", ",", "0", ",", "kindCount", ")", ")", ")", ")", ";", "if", "(", "i", "<", "len", ")", "{", "++", "i", ";", "// skip separator", "}", "}", "return", "components", ";", "}"], "docstring": "Converts an INS-syntax string name into a Vector in which\neach element of the vector contains a stringified form of\na NameComponent.", "docstring_tokens": ["Converts", "an", "INS", "-", "syntax", "string", "name", "into", "a", "Vector", "in", "which", "each", "element", "of", "the", "vector", "contains", "a", "stringified", "form", "of", "a", "NameComponent", "."]}
{"code": "++i;", "comments": "skip escape and let meta through", "lines": 21, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNNameParser.java", "func_name": "CNNameParser.insStringToStringifiedComps", "original_string": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "language": "java", "Allcodes": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "code_tokens": ["private", "static", "Vector", "insStringToStringifiedComps", "(", "String", "str", ")", "throws", "InvalidNameException", "{", "int", "len", "=", "str", ".", "length", "(", ")", ";", "Vector", "components", "=", "new", "Vector", "(", "10", ")", ";", "char", "[", "]", "id", "=", "new", "char", "[", "len", "]", ";", "char", "[", "]", "kind", "=", "new", "char", "[", "len", "]", ";", "int", "idCount", ",", "kindCount", ";", "boolean", "idMode", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", ")", "{", "idCount", "=", "kindCount", "=", "0", ";", "// reset for new component", "idMode", "=", "true", ";", "// always start off parsing id", "while", "(", "i", "<", "len", ")", "{", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "compSeparator", ")", "{", "break", ";", "}", "else", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "str", ")", ";", "}", "else", "if", "(", "isMeta", "(", "str", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "// skip escape and let meta through", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "str", ")", ";", "}", "}", "else", "if", "(", "idMode", "&&", "str", ".", "charAt", "(", "i", ")", "==", "kindSeparator", ")", "{", "// just look for the first kindSeparator", "++", "i", ";", "// skip kind separator", "idMode", "=", "false", ";", "}", "else", "{", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "}", "components", ".", "addElement", "(", "stringifyComponent", "(", "new", "NameComponent", "(", "new", "String", "(", "id", ",", "0", ",", "idCount", ")", ",", "new", "String", "(", "kind", ",", "0", ",", "kindCount", ")", ")", ")", ")", ";", "if", "(", "i", "<", "len", ")", "{", "++", "i", ";", "// skip separator", "}", "}", "return", "components", ";", "}"], "docstring": "Converts an INS-syntax string name into a Vector in which\neach element of the vector contains a stringified form of\na NameComponent.", "docstring_tokens": ["Converts", "an", "INS", "-", "syntax", "string", "name", "into", "a", "Vector", "in", "which", "each", "element", "of", "the", "vector", "contains", "a", "stringified", "form", "of", "a", "NameComponent", "."]}
{"code": "++i;", "comments": "skip kind separator", "lines": 33, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNNameParser.java", "func_name": "CNNameParser.insStringToStringifiedComps", "original_string": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "language": "java", "Allcodes": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "code_tokens": ["private", "static", "Vector", "insStringToStringifiedComps", "(", "String", "str", ")", "throws", "InvalidNameException", "{", "int", "len", "=", "str", ".", "length", "(", ")", ";", "Vector", "components", "=", "new", "Vector", "(", "10", ")", ";", "char", "[", "]", "id", "=", "new", "char", "[", "len", "]", ";", "char", "[", "]", "kind", "=", "new", "char", "[", "len", "]", ";", "int", "idCount", ",", "kindCount", ";", "boolean", "idMode", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", ")", "{", "idCount", "=", "kindCount", "=", "0", ";", "// reset for new component", "idMode", "=", "true", ";", "// always start off parsing id", "while", "(", "i", "<", "len", ")", "{", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "compSeparator", ")", "{", "break", ";", "}", "else", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "str", ")", ";", "}", "else", "if", "(", "isMeta", "(", "str", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "// skip escape and let meta through", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "str", ")", ";", "}", "}", "else", "if", "(", "idMode", "&&", "str", ".", "charAt", "(", "i", ")", "==", "kindSeparator", ")", "{", "// just look for the first kindSeparator", "++", "i", ";", "// skip kind separator", "idMode", "=", "false", ";", "}", "else", "{", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "}", "components", ".", "addElement", "(", "stringifyComponent", "(", "new", "NameComponent", "(", "new", "String", "(", "id", ",", "0", ",", "idCount", ")", ",", "new", "String", "(", "kind", ",", "0", ",", "kindCount", ")", ")", ")", ")", ";", "if", "(", "i", "<", "len", ")", "{", "++", "i", ";", "// skip separator", "}", "}", "return", "components", ";", "}"], "docstring": "Converts an INS-syntax string name into a Vector in which\neach element of the vector contains a stringified form of\na NameComponent.", "docstring_tokens": ["Converts", "an", "INS", "-", "syntax", "string", "name", "into", "a", "Vector", "in", "which", "each", "element", "of", "the", "vector", "contains", "a", "stringified", "form", "of", "a", "NameComponent", "."]}
{"code": "++i;", "comments": "skip separator", "lines": 49, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNNameParser.java", "func_name": "CNNameParser.insStringToStringifiedComps", "original_string": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "language": "java", "Allcodes": "private static Vector insStringToStringifiedComps(String str)\n            throws InvalidNameException {\n\n        int len = str.length();\n        Vector components = new Vector(10);\n        char[] id = new char[len];\n        char[] kind = new char[len];\n        int idCount, kindCount;\n        boolean idMode;\n        for (int i = 0; i < len; ) {\n            idCount = kindCount = 0; // reset for new component\n            idMode = true;           // always start off parsing id\n            while (i < len) {\n                if (str.charAt(i) == compSeparator) {\n                    break;\n\n                } else if (str.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);\n                    } else if (isMeta(str.charAt(i + 1))) {\n                        ++i; // skip escape and let meta through\n                        if (idMode) {\n                            id[idCount++] = str.charAt(i++);\n                        } else {\n                            kind[kindCount++] = str.charAt(i++);\n                        }\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);\n                    }\n\n                } else if (idMode && str.charAt(i) == kindSeparator) {\n                    // just look for the first kindSeparator\n                    ++i; // skip kind separator\n                    idMode = false;\n\n                } else {\n                    if (idMode) {\n                        id[idCount++] = str.charAt(i++);\n                    } else {\n                        kind[kindCount++] = str.charAt(i++);\n                    }\n                }\n            }\n            components.addElement(stringifyComponent(\n                    new NameComponent(new String(id, 0, idCount),\n                            new String(kind, 0, kindCount))));\n\n            if (i < len) {\n                ++i; // skip separator\n            }\n        }\n\n        return components;\n    }", "code_tokens": ["private", "static", "Vector", "insStringToStringifiedComps", "(", "String", "str", ")", "throws", "InvalidNameException", "{", "int", "len", "=", "str", ".", "length", "(", ")", ";", "Vector", "components", "=", "new", "Vector", "(", "10", ")", ";", "char", "[", "]", "id", "=", "new", "char", "[", "len", "]", ";", "char", "[", "]", "kind", "=", "new", "char", "[", "len", "]", ";", "int", "idCount", ",", "kindCount", ";", "boolean", "idMode", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", ")", "{", "idCount", "=", "kindCount", "=", "0", ";", "// reset for new component", "idMode", "=", "true", ";", "// always start off parsing id", "while", "(", "i", "<", "len", ")", "{", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "compSeparator", ")", "{", "break", ";", "}", "else", "if", "(", "str", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "str", ")", ";", "}", "else", "if", "(", "isMeta", "(", "str", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "++", "i", ";", "// skip escape and let meta through", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "str", ")", ";", "}", "}", "else", "if", "(", "idMode", "&&", "str", ".", "charAt", "(", "i", ")", "==", "kindSeparator", ")", "{", "// just look for the first kindSeparator", "++", "i", ";", "// skip kind separator", "idMode", "=", "false", ";", "}", "else", "{", "if", "(", "idMode", ")", "{", "id", "[", "idCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "else", "{", "kind", "[", "kindCount", "++", "]", "=", "str", ".", "charAt", "(", "i", "++", ")", ";", "}", "}", "}", "components", ".", "addElement", "(", "stringifyComponent", "(", "new", "NameComponent", "(", "new", "String", "(", "id", ",", "0", ",", "idCount", ")", ",", "new", "String", "(", "kind", ",", "0", ",", "kindCount", ")", ")", ")", ")", ";", "if", "(", "i", "<", "len", ")", "{", "++", "i", ";", "// skip separator", "}", "}", "return", "components", ";", "}"], "docstring": "Converts an INS-syntax string name into a Vector in which\neach element of the vector contains a stringified form of\na NameComponent.", "docstring_tokens": ["Converts", "an", "INS", "-", "syntax", "string", "name", "into", "a", "Vector", "in", "which", "each", "element", "of", "the", "vector", "contains", "a", "stringified", "form", "of", "a", "NameComponent", "."]}
{"code": "comp.kind = \"\";", "comments": "no kind separator", "lines": 36, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNNameParser.java", "func_name": "CNNameParser.parseComponent", "original_string": "private static NameComponent parseComponent(String compStr)\n            throws InvalidNameException {\n        NameComponent comp = new NameComponent();\n        int kindSep = -1;\n        int len = compStr.length();\n\n        int j = 0;\n        char[] newStr = new char[len];\n        boolean escaped = false;\n\n        // Find the kind separator\n        for (int i = 0; i < len && kindSep < 0; i++) {\n            if (escaped) {\n                newStr[j++] = compStr.charAt(i);\n                escaped = false;\n            } else if (compStr.charAt(i) == escapeChar) {\n                if (i + 1 >= len) {\n                    throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(compStr);\n                } else if (isMeta(compStr.charAt(i + 1))) {\n                    escaped = true;\n                } else {\n                    throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(compStr);\n                }\n            } else if (compStr.charAt(i) == kindSeparator) {\n                kindSep = i;\n            } else {\n                newStr[j++] = compStr.charAt(i);\n            }\n        }\n\n        // Set id\n        comp.id = new String(newStr, 0, j);\n\n        // Set kind\n        if (kindSep < 0) {\n            comp.kind = \"\";  // no kind separator\n        } else {\n            // unescape kind\n            j = 0;\n            escaped = false;\n            for (int i = kindSep + 1; i < len; i++) {\n                if (escaped) {\n                    newStr[j++] = compStr.charAt(i);\n                    escaped = false;\n                } else if (compStr.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(compStr);\n                    } else if (isMeta(compStr.charAt(i + 1))) {\n                        escaped = true;\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(compStr);\n                    }\n                } else {\n                    newStr[j++] = compStr.charAt(i);\n                }\n            }\n            comp.kind = new String(newStr, 0, j);\n        }\n        return comp;\n    }", "language": "java", "Allcodes": "private static NameComponent parseComponent(String compStr)\n            throws InvalidNameException {\n        NameComponent comp = new NameComponent();\n        int kindSep = -1;\n        int len = compStr.length();\n\n        int j = 0;\n        char[] newStr = new char[len];\n        boolean escaped = false;\n\n        // Find the kind separator\n        for (int i = 0; i < len && kindSep < 0; i++) {\n            if (escaped) {\n                newStr[j++] = compStr.charAt(i);\n                escaped = false;\n            } else if (compStr.charAt(i) == escapeChar) {\n                if (i + 1 >= len) {\n                    throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(compStr);\n                } else if (isMeta(compStr.charAt(i + 1))) {\n                    escaped = true;\n                } else {\n                    throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(compStr);\n                }\n            } else if (compStr.charAt(i) == kindSeparator) {\n                kindSep = i;\n            } else {\n                newStr[j++] = compStr.charAt(i);\n            }\n        }\n\n        // Set id\n        comp.id = new String(newStr, 0, j);\n\n        // Set kind\n        if (kindSep < 0) {\n            comp.kind = \"\";  // no kind separator\n        } else {\n            // unescape kind\n            j = 0;\n            escaped = false;\n            for (int i = kindSep + 1; i < len; i++) {\n                if (escaped) {\n                    newStr[j++] = compStr.charAt(i);\n                    escaped = false;\n                } else if (compStr.charAt(i) == escapeChar) {\n                    if (i + 1 >= len) {\n                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(compStr);\n                    } else if (isMeta(compStr.charAt(i + 1))) {\n                        escaped = true;\n                    } else {\n                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(compStr);\n                    }\n                } else {\n                    newStr[j++] = compStr.charAt(i);\n                }\n            }\n            comp.kind = new String(newStr, 0, j);\n        }\n        return comp;\n    }", "code_tokens": ["private", "static", "NameComponent", "parseComponent", "(", "String", "compStr", ")", "throws", "InvalidNameException", "{", "NameComponent", "comp", "=", "new", "NameComponent", "(", ")", ";", "int", "kindSep", "=", "-", "1", ";", "int", "len", "=", "compStr", ".", "length", "(", ")", ";", "int", "j", "=", "0", ";", "char", "[", "]", "newStr", "=", "new", "char", "[", "len", "]", ";", "boolean", "escaped", "=", "false", ";", "// Find the kind separator", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", "&&", "kindSep", "<", "0", ";", "i", "++", ")", "{", "if", "(", "escaped", ")", "{", "newStr", "[", "j", "++", "]", "=", "compStr", ".", "charAt", "(", "i", ")", ";", "escaped", "=", "false", ";", "}", "else", "if", "(", "compStr", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "compStr", ")", ";", "}", "else", "if", "(", "isMeta", "(", "compStr", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "escaped", "=", "true", ";", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "compStr", ")", ";", "}", "}", "else", "if", "(", "compStr", ".", "charAt", "(", "i", ")", "==", "kindSeparator", ")", "{", "kindSep", "=", "i", ";", "}", "else", "{", "newStr", "[", "j", "++", "]", "=", "compStr", ".", "charAt", "(", "i", ")", ";", "}", "}", "// Set id", "comp", ".", "id", "=", "new", "String", "(", "newStr", ",", "0", ",", "j", ")", ";", "// Set kind", "if", "(", "kindSep", "<", "0", ")", "{", "comp", ".", "kind", "=", "\"\"", ";", "// no kind separator", "}", "else", "{", "// unescape kind", "j", "=", "0", ";", "escaped", "=", "false", ";", "for", "(", "int", "i", "=", "kindSep", "+", "1", ";", "i", "<", "len", ";", "i", "++", ")", "{", "if", "(", "escaped", ")", "{", "newStr", "[", "j", "++", "]", "=", "compStr", ".", "charAt", "(", "i", ")", ";", "escaped", "=", "false", ";", "}", "else", "if", "(", "compStr", ".", "charAt", "(", "i", ")", "==", "escapeChar", ")", "{", "if", "(", "i", "+", "1", ">=", "len", ")", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unescapedCharacter", "(", "compStr", ")", ";", "}", "else", "if", "(", "isMeta", "(", "compStr", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "escaped", "=", "true", ";", "}", "else", "{", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "invalidEscapedCharacter", "(", "compStr", ")", ";", "}", "}", "else", "{", "newStr", "[", "j", "++", "]", "=", "compStr", ".", "charAt", "(", "i", ")", ";", "}", "}", "comp", ".", "kind", "=", "new", "String", "(", "newStr", ",", "0", ",", "j", ")", ";", "}", "return", "comp", ";", "}"], "docstring": "Return a NameComponent given its stringified form.", "docstring_tokens": ["Return", "a", "NameComponent", "given", "its", "stringified", "form", "."]}
{"code": "mj.setTarget(new ImmediateValue<Object>(null));", "comments": "null, since this is static call", "lines": 22, "repo": "wildfly/wildfly", "path": "pojo/src/main/java/org/jboss/as/pojo/service/BeanUtils.java", "func_name": "BeanUtils.instantiateBean", "original_string": "public static Object instantiateBean(BeanMetaDataConfig beanConfig, BeanInfo beanInfo, DeploymentReflectionIndex index, Module module) throws Throwable {\n        Joinpoint instantiateJoinpoint = null;\n        ValueConfig[] parameters = new ValueConfig[0];\n        String[] types = Configurator.NO_PARAMS_TYPES;\n        ConstructorConfig ctorConfig = beanConfig.getConstructor();\n        if (ctorConfig != null) {\n            parameters = ctorConfig.getParameters();\n            types = Configurator.getTypes(parameters);\n\n            String factoryClass = ctorConfig.getFactoryClass();\n            FactoryConfig factory = ctorConfig.getFactory();\n            if (factoryClass != null || factory != null) {\n                String factoryMethod = ctorConfig.getFactoryMethod();\n                if (factoryMethod == null)\n                    throw PojoLogger.ROOT_LOGGER.missingFactoryMethod(beanConfig);\n\n                if (factoryClass != null) {\n                    // static factory\n                    Class<?> factoryClazz = Class.forName(factoryClass, false, module.getClassLoader());\n                    Method method = Configurator.findMethod(index, factoryClazz, factoryMethod, types, true, true, true);\n                    MethodJoinpoint mj = new MethodJoinpoint(method);\n                    mj.setTarget(new ImmediateValue<Object>(null)); // null, since this is static call\n                    mj.setParameters(parameters);\n                    instantiateJoinpoint = mj;\n                } else if (factory != null) {\n                    ReflectionJoinpoint rj = new ReflectionJoinpoint(factory.getBeanInfo(), factoryMethod, types);\n                    // null type is ok, as this should be plain injection\n                    rj.setTarget(new ImmediateValue<Object>(factory.getValue(null)));\n                    rj.setParameters(parameters);\n                    instantiateJoinpoint = rj;\n                }\n            }\n        }\n        // plain bean's ctor\n        if (instantiateJoinpoint == null) {\n            if (beanInfo == null)\n                throw new StartException(PojoLogger.ROOT_LOGGER.missingBeanInfo(beanConfig));\n\n            Constructor ctor = (types.length == 0) ? beanInfo.getConstructor() : beanInfo.findConstructor(types);\n            ConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint(ctor);\n            constructorJoinpoint.setParameters(parameters);\n            instantiateJoinpoint = constructorJoinpoint;\n        }\n\n        return instantiateJoinpoint.dispatch();\n    }", "language": "java", "Allcodes": "public static Object instantiateBean(BeanMetaDataConfig beanConfig, BeanInfo beanInfo, DeploymentReflectionIndex index, Module module) throws Throwable {\n        Joinpoint instantiateJoinpoint = null;\n        ValueConfig[] parameters = new ValueConfig[0];\n        String[] types = Configurator.NO_PARAMS_TYPES;\n        ConstructorConfig ctorConfig = beanConfig.getConstructor();\n        if (ctorConfig != null) {\n            parameters = ctorConfig.getParameters();\n            types = Configurator.getTypes(parameters);\n\n            String factoryClass = ctorConfig.getFactoryClass();\n            FactoryConfig factory = ctorConfig.getFactory();\n            if (factoryClass != null || factory != null) {\n                String factoryMethod = ctorConfig.getFactoryMethod();\n                if (factoryMethod == null)\n                    throw PojoLogger.ROOT_LOGGER.missingFactoryMethod(beanConfig);\n\n                if (factoryClass != null) {\n                    // static factory\n                    Class<?> factoryClazz = Class.forName(factoryClass, false, module.getClassLoader());\n                    Method method = Configurator.findMethod(index, factoryClazz, factoryMethod, types, true, true, true);\n                    MethodJoinpoint mj = new MethodJoinpoint(method);\n                    mj.setTarget(new ImmediateValue<Object>(null)); // null, since this is static call\n                    mj.setParameters(parameters);\n                    instantiateJoinpoint = mj;\n                } else if (factory != null) {\n                    ReflectionJoinpoint rj = new ReflectionJoinpoint(factory.getBeanInfo(), factoryMethod, types);\n                    // null type is ok, as this should be plain injection\n                    rj.setTarget(new ImmediateValue<Object>(factory.getValue(null)));\n                    rj.setParameters(parameters);\n                    instantiateJoinpoint = rj;\n                }\n            }\n        }\n        // plain bean's ctor\n        if (instantiateJoinpoint == null) {\n            if (beanInfo == null)\n                throw new StartException(PojoLogger.ROOT_LOGGER.missingBeanInfo(beanConfig));\n\n            Constructor ctor = (types.length == 0) ? beanInfo.getConstructor() : beanInfo.findConstructor(types);\n            ConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint(ctor);\n            constructorJoinpoint.setParameters(parameters);\n            instantiateJoinpoint = constructorJoinpoint;\n        }\n\n        return instantiateJoinpoint.dispatch();\n    }", "code_tokens": ["public", "static", "Object", "instantiateBean", "(", "BeanMetaDataConfig", "beanConfig", ",", "BeanInfo", "beanInfo", ",", "DeploymentReflectionIndex", "index", ",", "Module", "module", ")", "throws", "Throwable", "{", "Joinpoint", "instantiateJoinpoint", "=", "null", ";", "ValueConfig", "[", "]", "parameters", "=", "new", "ValueConfig", "[", "0", "]", ";", "String", "[", "]", "types", "=", "Configurator", ".", "NO_PARAMS_TYPES", ";", "ConstructorConfig", "ctorConfig", "=", "beanConfig", ".", "getConstructor", "(", ")", ";", "if", "(", "ctorConfig", "!=", "null", ")", "{", "parameters", "=", "ctorConfig", ".", "getParameters", "(", ")", ";", "types", "=", "Configurator", ".", "getTypes", "(", "parameters", ")", ";", "String", "factoryClass", "=", "ctorConfig", ".", "getFactoryClass", "(", ")", ";", "FactoryConfig", "factory", "=", "ctorConfig", ".", "getFactory", "(", ")", ";", "if", "(", "factoryClass", "!=", "null", "||", "factory", "!=", "null", ")", "{", "String", "factoryMethod", "=", "ctorConfig", ".", "getFactoryMethod", "(", ")", ";", "if", "(", "factoryMethod", "==", "null", ")", "throw", "PojoLogger", ".", "ROOT_LOGGER", ".", "missingFactoryMethod", "(", "beanConfig", ")", ";", "if", "(", "factoryClass", "!=", "null", ")", "{", "// static factory", "Class", "<", "?", ">", "factoryClazz", "=", "Class", ".", "forName", "(", "factoryClass", ",", "false", ",", "module", ".", "getClassLoader", "(", ")", ")", ";", "Method", "method", "=", "Configurator", ".", "findMethod", "(", "index", ",", "factoryClazz", ",", "factoryMethod", ",", "types", ",", "true", ",", "true", ",", "true", ")", ";", "MethodJoinpoint", "mj", "=", "new", "MethodJoinpoint", "(", "method", ")", ";", "mj", ".", "setTarget", "(", "new", "ImmediateValue", "<", "Object", ">", "(", "null", ")", ")", ";", "// null, since this is static call", "mj", ".", "setParameters", "(", "parameters", ")", ";", "instantiateJoinpoint", "=", "mj", ";", "}", "else", "if", "(", "factory", "!=", "null", ")", "{", "ReflectionJoinpoint", "rj", "=", "new", "ReflectionJoinpoint", "(", "factory", ".", "getBeanInfo", "(", ")", ",", "factoryMethod", ",", "types", ")", ";", "// null type is ok, as this should be plain injection", "rj", ".", "setTarget", "(", "new", "ImmediateValue", "<", "Object", ">", "(", "factory", ".", "getValue", "(", "null", ")", ")", ")", ";", "rj", ".", "setParameters", "(", "parameters", ")", ";", "instantiateJoinpoint", "=", "rj", ";", "}", "}", "}", "// plain bean's ctor", "if", "(", "instantiateJoinpoint", "==", "null", ")", "{", "if", "(", "beanInfo", "==", "null", ")", "throw", "new", "StartException", "(", "PojoLogger", ".", "ROOT_LOGGER", ".", "missingBeanInfo", "(", "beanConfig", ")", ")", ";", "Constructor", "ctor", "=", "(", "types", ".", "length", "==", "0", ")", "?", "beanInfo", ".", "getConstructor", "(", ")", ":", "beanInfo", ".", "findConstructor", "(", "types", ")", ";", "ConstructorJoinpoint", "constructorJoinpoint", "=", "new", "ConstructorJoinpoint", "(", "ctor", ")", ";", "constructorJoinpoint", ".", "setParameters", "(", "parameters", ")", ";", "instantiateJoinpoint", "=", "constructorJoinpoint", ";", "}", "return", "instantiateJoinpoint", ".", "dispatch", "(", ")", ";", "}"], "docstring": "Instantiate bean.\n\n@param beanConfig the bean metadata config, must not be null\n@param beanInfo the bean info, can be null if enough info\n@param index the reflection index, must not be null\n@param module the current CL module, must not be null\n@return new bean instance\n@throws Throwable for any error", "docstring_tokens": ["Instantiate", "bean", "."]}
{"code": "return;", "comments": "Skip deployments with out a service xml descriptor", "lines": 6, "repo": "wildfly/wildfly", "path": "sar/src/main/java/org/jboss/as/service/SarModuleDependencyProcessor.java", "func_name": "SarModuleDependencyProcessor.deploy", "original_string": "public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit.getAttachment(JBossServiceXmlDescriptor.ATTACHMENT_KEY);\n        if(serviceXmlDescriptor == null) {\n            return; // Skip deployments with out a service xml descriptor\n        }\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), JBOSS_MODULES_ID, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), JBOSS_AS_SYSTEM_JMX_ID, true, false, false, false));\n        // depend on Properties editor module which uses ServiceLoader approach to load the appropriate org.jboss.common.beans.property.finder.PropertyEditorFinder\n        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), PROPERTIES_EDITOR_MODULE_ID, false, false, true, false));\n\n        // All SARs require the ability to register MBeans.\n        moduleSpecification.addPermissionFactory(REGISTER_PERMISSION_FACTORY);\n    }", "language": "java", "Allcodes": "public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit.getAttachment(JBossServiceXmlDescriptor.ATTACHMENT_KEY);\n        if(serviceXmlDescriptor == null) {\n            return; // Skip deployments with out a service xml descriptor\n        }\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), JBOSS_MODULES_ID, false, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), JBOSS_AS_SYSTEM_JMX_ID, true, false, false, false));\n        // depend on Properties editor module which uses ServiceLoader approach to load the appropriate org.jboss.common.beans.property.finder.PropertyEditorFinder\n        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), PROPERTIES_EDITOR_MODULE_ID, false, false, true, false));\n\n        // All SARs require the ability to register MBeans.\n        moduleSpecification.addPermissionFactory(REGISTER_PERMISSION_FACTORY);\n    }", "code_tokens": ["public", "void", "deploy", "(", "DeploymentPhaseContext", "phaseContext", ")", "throws", "DeploymentUnitProcessingException", "{", "final", "DeploymentUnit", "deploymentUnit", "=", "phaseContext", ".", "getDeploymentUnit", "(", ")", ";", "final", "ModuleSpecification", "moduleSpecification", "=", "deploymentUnit", ".", "getAttachment", "(", "Attachments", ".", "MODULE_SPECIFICATION", ")", ";", "final", "JBossServiceXmlDescriptor", "serviceXmlDescriptor", "=", "deploymentUnit", ".", "getAttachment", "(", "JBossServiceXmlDescriptor", ".", "ATTACHMENT_KEY", ")", ";", "if", "(", "serviceXmlDescriptor", "==", "null", ")", "{", "return", ";", "// Skip deployments with out a service xml descriptor", "}", "moduleSpecification", ".", "addSystemDependency", "(", "new", "ModuleDependency", "(", "Module", ".", "getBootModuleLoader", "(", ")", ",", "JBOSS_MODULES_ID", ",", "false", ",", "false", ",", "false", ",", "false", ")", ")", ";", "moduleSpecification", ".", "addSystemDependency", "(", "new", "ModuleDependency", "(", "Module", ".", "getBootModuleLoader", "(", ")", ",", "JBOSS_AS_SYSTEM_JMX_ID", ",", "true", ",", "false", ",", "false", ",", "false", ")", ")", ";", "// depend on Properties editor module which uses ServiceLoader approach to load the appropriate org.jboss.common.beans.property.finder.PropertyEditorFinder", "moduleSpecification", ".", "addSystemDependency", "(", "new", "ModuleDependency", "(", "Module", ".", "getBootModuleLoader", "(", ")", ",", "PROPERTIES_EDITOR_MODULE_ID", ",", "false", ",", "false", ",", "true", ",", "false", ")", ")", ";", "// All SARs require the ability to register MBeans.", "moduleSpecification", ".", "addPermissionFactory", "(", "REGISTER_PERMISSION_FACTORY", ")", ";", "}"], "docstring": "Add dependencies for modules required for manged bean deployments, if managed bean configurations are attached\nto the deployment.\n\n@param phaseContext the deployment unit context\n@throws DeploymentUnitProcessingException", "docstring_tokens": ["Add", "dependencies", "for", "modules", "required", "for", "manged", "bean", "deployments", "if", "managed", "bean", "configurations", "are", "attached", "to", "the", "deployment", "."]}
{"code": "deploymentUnit = deploymentUnit.getParent();", "comments": "get annotation indexes for top level also", "lines": 19, "repo": "wildfly/wildfly", "path": "jpa/subsystem/src/main/java/org/jboss/as/jpa/processor/PersistenceUnitServiceHandler.java", "func_name": "PersistenceUnitServiceHandler.setAnnotationIndexes", "original_string": "private static void setAnnotationIndexes(\n            final PersistenceUnitMetadataHolder puHolder,\n            DeploymentUnit deploymentUnit ) {\n\n        final Map<URL, Index> annotationIndexes = new HashMap<>();\n\n        do {\n            for (ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {\n                final Index index = root.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    try {\n                        ROOT_LOGGER.tracef(\"adding '%s' to annotation index map\", root.getRoot().toURL());\n                        annotationIndexes.put(root.getRoot().toURL(), index);\n                    } catch (MalformedURLException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            deploymentUnit = deploymentUnit.getParent(); // get annotation indexes for top level also\n        }\n        while (deploymentUnit != null);\n\n        for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {\n            pu.setAnnotationIndex(annotationIndexes);   // hold onto the annotation index for Persistence Provider use during deployment\n        }\n    }", "language": "java", "Allcodes": "private static void setAnnotationIndexes(\n            final PersistenceUnitMetadataHolder puHolder,\n            DeploymentUnit deploymentUnit ) {\n\n        final Map<URL, Index> annotationIndexes = new HashMap<>();\n\n        do {\n            for (ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {\n                final Index index = root.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    try {\n                        ROOT_LOGGER.tracef(\"adding '%s' to annotation index map\", root.getRoot().toURL());\n                        annotationIndexes.put(root.getRoot().toURL(), index);\n                    } catch (MalformedURLException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            deploymentUnit = deploymentUnit.getParent(); // get annotation indexes for top level also\n        }\n        while (deploymentUnit != null);\n\n        for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {\n            pu.setAnnotationIndex(annotationIndexes);   // hold onto the annotation index for Persistence Provider use during deployment\n        }\n    }", "code_tokens": ["private", "static", "void", "setAnnotationIndexes", "(", "final", "PersistenceUnitMetadataHolder", "puHolder", ",", "DeploymentUnit", "deploymentUnit", ")", "{", "final", "Map", "<", "URL", ",", "Index", ">", "annotationIndexes", "=", "new", "HashMap", "<>", "(", ")", ";", "do", "{", "for", "(", "ResourceRoot", "root", ":", "DeploymentUtils", ".", "allResourceRoots", "(", "deploymentUnit", ")", ")", "{", "final", "Index", "index", "=", "root", ".", "getAttachment", "(", "Attachments", ".", "ANNOTATION_INDEX", ")", ";", "if", "(", "index", "!=", "null", ")", "{", "try", "{", "ROOT_LOGGER", ".", "tracef", "(", "\"adding '%s' to annotation index map\"", ",", "root", ".", "getRoot", "(", ")", ".", "toURL", "(", ")", ")", ";", "annotationIndexes", ".", "put", "(", "root", ".", "getRoot", "(", ")", ".", "toURL", "(", ")", ",", "index", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "}", "deploymentUnit", "=", "deploymentUnit", ".", "getParent", "(", ")", ";", "// get annotation indexes for top level also", "}", "while", "(", "deploymentUnit", "!=", "null", ")", ";", "for", "(", "PersistenceUnitMetadata", "pu", ":", "puHolder", ".", "getPersistenceUnits", "(", ")", ")", "{", "pu", ".", "setAnnotationIndex", "(", "annotationIndexes", ")", ";", "// hold onto the annotation index for Persistence Provider use during deployment", "}", "}"], "docstring": "Setup the annotation index map\n\n@param puHolder\n@param deploymentUnit", "docstring_tokens": ["Setup", "the", "annotation", "index", "map"]}
{"code": "pu.setAnnotationIndex(annotationIndexes);", "comments": "hold onto the annotation index for Persistence Provider use during deployment", "lines": 24, "repo": "wildfly/wildfly", "path": "jpa/subsystem/src/main/java/org/jboss/as/jpa/processor/PersistenceUnitServiceHandler.java", "func_name": "PersistenceUnitServiceHandler.setAnnotationIndexes", "original_string": "private static void setAnnotationIndexes(\n            final PersistenceUnitMetadataHolder puHolder,\n            DeploymentUnit deploymentUnit ) {\n\n        final Map<URL, Index> annotationIndexes = new HashMap<>();\n\n        do {\n            for (ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {\n                final Index index = root.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    try {\n                        ROOT_LOGGER.tracef(\"adding '%s' to annotation index map\", root.getRoot().toURL());\n                        annotationIndexes.put(root.getRoot().toURL(), index);\n                    } catch (MalformedURLException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            deploymentUnit = deploymentUnit.getParent(); // get annotation indexes for top level also\n        }\n        while (deploymentUnit != null);\n\n        for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {\n            pu.setAnnotationIndex(annotationIndexes);   // hold onto the annotation index for Persistence Provider use during deployment\n        }\n    }", "language": "java", "Allcodes": "private static void setAnnotationIndexes(\n            final PersistenceUnitMetadataHolder puHolder,\n            DeploymentUnit deploymentUnit ) {\n\n        final Map<URL, Index> annotationIndexes = new HashMap<>();\n\n        do {\n            for (ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {\n                final Index index = root.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    try {\n                        ROOT_LOGGER.tracef(\"adding '%s' to annotation index map\", root.getRoot().toURL());\n                        annotationIndexes.put(root.getRoot().toURL(), index);\n                    } catch (MalformedURLException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            deploymentUnit = deploymentUnit.getParent(); // get annotation indexes for top level also\n        }\n        while (deploymentUnit != null);\n\n        for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {\n            pu.setAnnotationIndex(annotationIndexes);   // hold onto the annotation index for Persistence Provider use during deployment\n        }\n    }", "code_tokens": ["private", "static", "void", "setAnnotationIndexes", "(", "final", "PersistenceUnitMetadataHolder", "puHolder", ",", "DeploymentUnit", "deploymentUnit", ")", "{", "final", "Map", "<", "URL", ",", "Index", ">", "annotationIndexes", "=", "new", "HashMap", "<>", "(", ")", ";", "do", "{", "for", "(", "ResourceRoot", "root", ":", "DeploymentUtils", ".", "allResourceRoots", "(", "deploymentUnit", ")", ")", "{", "final", "Index", "index", "=", "root", ".", "getAttachment", "(", "Attachments", ".", "ANNOTATION_INDEX", ")", ";", "if", "(", "index", "!=", "null", ")", "{", "try", "{", "ROOT_LOGGER", ".", "tracef", "(", "\"adding '%s' to annotation index map\"", ",", "root", ".", "getRoot", "(", ")", ".", "toURL", "(", ")", ")", ";", "annotationIndexes", ".", "put", "(", "root", ".", "getRoot", "(", ")", ".", "toURL", "(", ")", ",", "index", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "}", "deploymentUnit", "=", "deploymentUnit", ".", "getParent", "(", ")", ";", "// get annotation indexes for top level also", "}", "while", "(", "deploymentUnit", "!=", "null", ")", ";", "for", "(", "PersistenceUnitMetadata", "pu", ":", "puHolder", ".", "getPersistenceUnits", "(", ")", ")", "{", "pu", ".", "setAnnotationIndex", "(", "annotationIndexes", ")", ";", "// hold onto the annotation index for Persistence Provider use during deployment", "}", "}"], "docstring": "Setup the annotation index map\n\n@param puHolder\n@param deploymentUnit", "docstring_tokens": ["Setup", "the", "annotation", "index", "map"]}
{"code": "key = adaptorModule;", "comments": "handle legacy adapter module", "lines": 10, "repo": "wildfly/wildfly", "path": "jpa/subsystem/src/main/java/org/jboss/as/jpa/processor/PersistenceUnitServiceHandler.java", "func_name": "PersistenceUnitServiceHandler.savePerDeploymentSharedPersistenceProviderAdaptor", "original_string": "private static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor(DeploymentUnit deploymentUnit, String adaptorModule, PersistenceProviderAdaptor adaptor, PersistenceProvider provider) {\n        if (deploymentUnit.getParent() != null) {\n            deploymentUnit = deploymentUnit.getParent();\n        }\n        synchronized (deploymentUnit) {\n            Map<String,PersistenceProviderAdaptor> map = deploymentUnit.getAttachment(providerAdaptorMapKey);\n            String key;\n\n            if (adaptorModule != null) {\n                key = adaptorModule;  // handle legacy adapter module\n            }\n            else {\n                key = provider.getClass().getName();\n            }\n            PersistenceProviderAdaptor current = map.get(key);\n\n            // saved if not already set by another thread\n            if (current == null) {\n                map.put(key, adaptor);\n                current = adaptor;\n            }\n            return current;\n        }\n    }", "language": "java", "Allcodes": "private static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor(DeploymentUnit deploymentUnit, String adaptorModule, PersistenceProviderAdaptor adaptor, PersistenceProvider provider) {\n        if (deploymentUnit.getParent() != null) {\n            deploymentUnit = deploymentUnit.getParent();\n        }\n        synchronized (deploymentUnit) {\n            Map<String,PersistenceProviderAdaptor> map = deploymentUnit.getAttachment(providerAdaptorMapKey);\n            String key;\n\n            if (adaptorModule != null) {\n                key = adaptorModule;  // handle legacy adapter module\n            }\n            else {\n                key = provider.getClass().getName();\n            }\n            PersistenceProviderAdaptor current = map.get(key);\n\n            // saved if not already set by another thread\n            if (current == null) {\n                map.put(key, adaptor);\n                current = adaptor;\n            }\n            return current;\n        }\n    }", "code_tokens": ["private", "static", "PersistenceProviderAdaptor", "savePerDeploymentSharedPersistenceProviderAdaptor", "(", "DeploymentUnit", "deploymentUnit", ",", "String", "adaptorModule", ",", "PersistenceProviderAdaptor", "adaptor", ",", "PersistenceProvider", "provider", ")", "{", "if", "(", "deploymentUnit", ".", "getParent", "(", ")", "!=", "null", ")", "{", "deploymentUnit", "=", "deploymentUnit", ".", "getParent", "(", ")", ";", "}", "synchronized", "(", "deploymentUnit", ")", "{", "Map", "<", "String", ",", "PersistenceProviderAdaptor", ">", "map", "=", "deploymentUnit", ".", "getAttachment", "(", "providerAdaptorMapKey", ")", ";", "String", "key", ";", "if", "(", "adaptorModule", "!=", "null", ")", "{", "key", "=", "adaptorModule", ";", "// handle legacy adapter module", "}", "else", "{", "key", "=", "provider", ".", "getClass", "(", ")", ".", "getName", "(", ")", ";", "}", "PersistenceProviderAdaptor", "current", "=", "map", ".", "get", "(", "key", ")", ";", "// saved if not already set by another thread", "if", "(", "current", "==", "null", ")", "{", "map", ".", "put", "(", "key", ",", "adaptor", ")", ";", "current", "=", "adaptor", ";", "}", "return", "current", ";", "}", "}"], "docstring": "Will save the PersistenceProviderAdaptor at the top level application deployment unit level for sharing with other persistence units\n\n@param deploymentUnit\n@param adaptorModule\n@param adaptor\n@param provider\n@return the application level shared PersistenceProviderAdaptor (which may of been set by a different thread)", "docstring_tokens": ["Will", "save", "the", "PersistenceProviderAdaptor", "at", "the", "top", "level", "application", "deployment", "unit", "level", "for", "sharing", "with", "other", "persistence", "units"]}
{"code": "return annotations;", "comments": "TODO:  Should this be limited by URI", "lines": 3, "repo": "wildfly/wildfly", "path": "jsf/injection/src/main/java/org/jboss/as/jsf/injection/JandexAnnotationProvider.java", "func_name": "JandexAnnotationProvider.getAnnotatedClasses", "original_string": "@Override\n    public Map<Class<? extends Annotation>, Set<Class<?>>> getAnnotatedClasses(final Set uris) {\n        return annotations; // TODO:  Should this be limited by URI\n    }", "language": "java", "Allcodes": "@Override\n    public Map<Class<? extends Annotation>, Set<Class<?>>> getAnnotatedClasses(final Set uris) {\n        return annotations; // TODO:  Should this be limited by URI\n    }", "code_tokens": ["@", "Override", "public", "Map", "<", "Class", "<", "?", "extends", "Annotation", ">", ",", "Set", "<", "Class", "<", "?", ">", ">", ">", "getAnnotatedClasses", "(", "final", "Set", "uris", ")", "{", "return", "annotations", ";", "// TODO:  Should this be limited by URI", "}"], "docstring": "use a plain Set and it should work for both versions.", "docstring_tokens": ["use", "a", "plain", "Set", "and", "it", "should", "work", "for", "both", "versions", "."]}
{"code": "return inProgress;", "comments": "return unfinished", "lines": 14, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/WorkCacheManager.java", "func_name": "WorkCacheManager.getAnalysis", "original_string": "ContainerAnalysis getAnalysis(final Class cls) throws RMIIIOPViolationException {\n        ContainerAnalysis ret = null;\n        boolean created = false;\n        try {\n            synchronized (this) {\n                ret = lookupDone(cls);\n                if (ret != null) {\n                    return ret;\n                }\n\n                // is it work-in-progress?\n                final ContainerAnalysis inProgress = workInProgress.get(new InProgressKey(cls, Thread.currentThread()));\n                if (inProgress != null) {\n                        return inProgress; // return unfinished\n\n                    // Do not wait for the other thread: We may deadlock\n                    // Double work is better that deadlock...\n                }\n\n                ret = createWorkInProgress(cls);\n            }\n            created = true;\n            // Do the work\n            doTheWork(cls, ret);\n        } finally {\n            // We did it\n            synchronized (this) {\n                if(created) {\n                    workInProgress.remove(new InProgressKey(cls, Thread.currentThread()));\n                    workDone.put(cls, new SoftReference<ContainerAnalysis>(ret));\n                    ClassLoader classLoader = cls.getClassLoader();\n                    if (classLoader != null) {\n                        Set<Class<?>> classes = classesByLoader.get(classLoader);\n                        if (classes == null) {\n                            classesByLoader.put(classLoader, classes = new HashSet<Class<?>>());\n                        }\n                        classes.add(cls);\n                    }\n                }\n                notifyAll();\n            }\n        }\n        return ret;\n    }", "language": "java", "Allcodes": "ContainerAnalysis getAnalysis(final Class cls) throws RMIIIOPViolationException {\n        ContainerAnalysis ret = null;\n        boolean created = false;\n        try {\n            synchronized (this) {\n                ret = lookupDone(cls);\n                if (ret != null) {\n                    return ret;\n                }\n\n                // is it work-in-progress?\n                final ContainerAnalysis inProgress = workInProgress.get(new InProgressKey(cls, Thread.currentThread()));\n                if (inProgress != null) {\n                        return inProgress; // return unfinished\n\n                    // Do not wait for the other thread: We may deadlock\n                    // Double work is better that deadlock...\n                }\n\n                ret = createWorkInProgress(cls);\n            }\n            created = true;\n            // Do the work\n            doTheWork(cls, ret);\n        } finally {\n            // We did it\n            synchronized (this) {\n                if(created) {\n                    workInProgress.remove(new InProgressKey(cls, Thread.currentThread()));\n                    workDone.put(cls, new SoftReference<ContainerAnalysis>(ret));\n                    ClassLoader classLoader = cls.getClassLoader();\n                    if (classLoader != null) {\n                        Set<Class<?>> classes = classesByLoader.get(classLoader);\n                        if (classes == null) {\n                            classesByLoader.put(classLoader, classes = new HashSet<Class<?>>());\n                        }\n                        classes.add(cls);\n                    }\n                }\n                notifyAll();\n            }\n        }\n        return ret;\n    }", "code_tokens": ["ContainerAnalysis", "getAnalysis", "(", "final", "Class", "cls", ")", "throws", "RMIIIOPViolationException", "{", "ContainerAnalysis", "ret", "=", "null", ";", "boolean", "created", "=", "false", ";", "try", "{", "synchronized", "(", "this", ")", "{", "ret", "=", "lookupDone", "(", "cls", ")", ";", "if", "(", "ret", "!=", "null", ")", "{", "return", "ret", ";", "}", "// is it work-in-progress?", "final", "ContainerAnalysis", "inProgress", "=", "workInProgress", ".", "get", "(", "new", "InProgressKey", "(", "cls", ",", "Thread", ".", "currentThread", "(", ")", ")", ")", ";", "if", "(", "inProgress", "!=", "null", ")", "{", "return", "inProgress", ";", "// return unfinished", "// Do not wait for the other thread: We may deadlock", "// Double work is better that deadlock...", "}", "ret", "=", "createWorkInProgress", "(", "cls", ")", ";", "}", "created", "=", "true", ";", "// Do the work", "doTheWork", "(", "cls", ",", "ret", ")", ";", "}", "finally", "{", "// We did it", "synchronized", "(", "this", ")", "{", "if", "(", "created", ")", "{", "workInProgress", ".", "remove", "(", "new", "InProgressKey", "(", "cls", ",", "Thread", ".", "currentThread", "(", ")", ")", ")", ";", "workDone", ".", "put", "(", "cls", ",", "new", "SoftReference", "<", "ContainerAnalysis", ">", "(", "ret", ")", ")", ";", "ClassLoader", "classLoader", "=", "cls", ".", "getClassLoader", "(", ")", ";", "if", "(", "classLoader", "!=", "null", ")", "{", "Set", "<", "Class", "<", "?", ">", ">", "classes", "=", "classesByLoader", ".", "get", "(", "classLoader", ")", ";", "if", "(", "classes", "==", "null", ")", "{", "classesByLoader", ".", "put", "(", "classLoader", ",", "classes", "=", "new", "HashSet", "<", "Class", "<", "?", ">", ">", "(", ")", ")", ";", "}", "classes", ".", "add", "(", "cls", ")", ";", "}", "}", "notifyAll", "(", ")", ";", "}", "}", "return", "ret", ";", "}"], "docstring": "Returns an analysis.\nIf the calling thread is currently doing an analysis of this\nclass, an unfinished analysis is returned.", "docstring_tokens": ["Returns", "an", "analysis", ".", "If", "the", "calling", "thread", "is", "currently", "doing", "an", "analysis", "of", "this", "class", "an", "unfinished", "analysis", "is", "returned", "."]}
{"code": "workDone.remove(cls);", "comments": "clear map entry if soft ref. was cleared.", "lines": 7, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/WorkCacheManager.java", "func_name": "WorkCacheManager.lookupDone", "original_string": "private ContainerAnalysis lookupDone(Class cls) {\n        SoftReference ref = (SoftReference) workDone.get(cls);\n        if (ref == null)\n            return null;\n        ContainerAnalysis ret = (ContainerAnalysis) ref.get();\n        if (ret == null)\n            workDone.remove(cls); // clear map entry if soft ref. was cleared.\n        return ret;\n    }", "language": "java", "Allcodes": "private ContainerAnalysis lookupDone(Class cls) {\n        SoftReference ref = (SoftReference) workDone.get(cls);\n        if (ref == null)\n            return null;\n        ContainerAnalysis ret = (ContainerAnalysis) ref.get();\n        if (ret == null)\n            workDone.remove(cls); // clear map entry if soft ref. was cleared.\n        return ret;\n    }", "code_tokens": ["private", "ContainerAnalysis", "lookupDone", "(", "Class", "cls", ")", "{", "SoftReference", "ref", "=", "(", "SoftReference", ")", "workDone", ".", "get", "(", "cls", ")", ";", "if", "(", "ref", "==", "null", ")", "return", "null", ";", "ContainerAnalysis", "ret", "=", "(", "ContainerAnalysis", ")", "ref", ".", "get", "(", ")", ";", "if", "(", "ret", "==", "null", ")", "workDone", ".", "remove", "(", "cls", ")", ";", "// clear map entry if soft ref. was cleared.", "return", "ret", ";", "}"], "docstring": "Lookup an analysis in the fully done map.", "docstring_tokens": ["Lookup", "an", "analysis", "in", "the", "fully", "done", "map", "."]}
{"code": "continue;", "comments": "This method is not mapped.", "lines": 15, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ContainerAnalysis.java", "func_name": "ContainerAnalysis.fixupOverloadedOperationNames", "original_string": "protected void fixupOverloadedOperationNames()\n            throws RMIIIOPViolationException {\n        for (int i = 0; i < methods.length; ++i) {\n            if ((m_flags[i] & M_OVERLOADED) == 0)\n                continue;\n\n            // Find the operation\n            OperationAnalysis oa = null;\n            String javaName = methods[i].getName();\n            for (int opIdx = 0; oa == null && opIdx < operations.length; ++opIdx)\n                if (operations[opIdx].getMethod().equals(methods[i]))\n                    oa = operations[opIdx];\n\n            if (oa == null)\n                continue; // This method is not mapped.\n\n            // Calculate new IDL name\n            ParameterAnalysis[] params = oa.getParameters();\n            StringBuffer b = new StringBuffer(oa.getIDLName());\n            if (params.length == 0)\n                b.append(\"__\");\n            for (int j = 0; j < params.length; ++j) {\n                String s = params[j].getTypeIDLName();\n\n                if (s.startsWith(\"::\"))\n                    s = s.substring(2);\n\n                if (s.startsWith(\"_\")) {\n                    // remove leading underscore in IDL escaped identifier\n                    s = s.substring(1);\n                }\n\n                b.append('_');\n\n                while (!\"\".equals(s)) {\n                    int idx = s.indexOf(\"::\");\n\n                    b.append('_');\n\n                    if (idx == -1) {\n                        b.append(s);\n                        s = \"\";\n                    } else {\n                        b.append(s.substring(0, idx));\n                        if (s.length() > idx + 2 && s.charAt(idx + 2) == '_') {\n                            // remove leading underscore in IDL escaped identifier\n                            s = s.substring(idx + 3);\n                        } else {\n                            s = s.substring(idx + 2);\n                        }\n                    }\n                }\n            }\n\n            // Set new IDL name\n            oa.setIDLName(b.toString());\n        }\n    }", "language": "java", "Allcodes": "protected void fixupOverloadedOperationNames()\n            throws RMIIIOPViolationException {\n        for (int i = 0; i < methods.length; ++i) {\n            if ((m_flags[i] & M_OVERLOADED) == 0)\n                continue;\n\n            // Find the operation\n            OperationAnalysis oa = null;\n            String javaName = methods[i].getName();\n            for (int opIdx = 0; oa == null && opIdx < operations.length; ++opIdx)\n                if (operations[opIdx].getMethod().equals(methods[i]))\n                    oa = operations[opIdx];\n\n            if (oa == null)\n                continue; // This method is not mapped.\n\n            // Calculate new IDL name\n            ParameterAnalysis[] params = oa.getParameters();\n            StringBuffer b = new StringBuffer(oa.getIDLName());\n            if (params.length == 0)\n                b.append(\"__\");\n            for (int j = 0; j < params.length; ++j) {\n                String s = params[j].getTypeIDLName();\n\n                if (s.startsWith(\"::\"))\n                    s = s.substring(2);\n\n                if (s.startsWith(\"_\")) {\n                    // remove leading underscore in IDL escaped identifier\n                    s = s.substring(1);\n                }\n\n                b.append('_');\n\n                while (!\"\".equals(s)) {\n                    int idx = s.indexOf(\"::\");\n\n                    b.append('_');\n\n                    if (idx == -1) {\n                        b.append(s);\n                        s = \"\";\n                    } else {\n                        b.append(s.substring(0, idx));\n                        if (s.length() > idx + 2 && s.charAt(idx + 2) == '_') {\n                            // remove leading underscore in IDL escaped identifier\n                            s = s.substring(idx + 3);\n                        } else {\n                            s = s.substring(idx + 2);\n                        }\n                    }\n                }\n            }\n\n            // Set new IDL name\n            oa.setIDLName(b.toString());\n        }\n    }", "code_tokens": ["protected", "void", "fixupOverloadedOperationNames", "(", ")", "throws", "RMIIIOPViolationException", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "methods", ".", "length", ";", "++", "i", ")", "{", "if", "(", "(", "m_flags", "[", "i", "]", "&", "M_OVERLOADED", ")", "==", "0", ")", "continue", ";", "// Find the operation", "OperationAnalysis", "oa", "=", "null", ";", "String", "javaName", "=", "methods", "[", "i", "]", ".", "getName", "(", ")", ";", "for", "(", "int", "opIdx", "=", "0", ";", "oa", "==", "null", "&&", "opIdx", "<", "operations", ".", "length", ";", "++", "opIdx", ")", "if", "(", "operations", "[", "opIdx", "]", ".", "getMethod", "(", ")", ".", "equals", "(", "methods", "[", "i", "]", ")", ")", "oa", "=", "operations", "[", "opIdx", "]", ";", "if", "(", "oa", "==", "null", ")", "continue", ";", "// This method is not mapped.", "// Calculate new IDL name", "ParameterAnalysis", "[", "]", "params", "=", "oa", ".", "getParameters", "(", ")", ";", "StringBuffer", "b", "=", "new", "StringBuffer", "(", "oa", ".", "getIDLName", "(", ")", ")", ";", "if", "(", "params", ".", "length", "==", "0", ")", "b", ".", "append", "(", "\"__\"", ")", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "params", ".", "length", ";", "++", "j", ")", "{", "String", "s", "=", "params", "[", "j", "]", ".", "getTypeIDLName", "(", ")", ";", "if", "(", "s", ".", "startsWith", "(", "\"::\"", ")", ")", "s", "=", "s", ".", "substring", "(", "2", ")", ";", "if", "(", "s", ".", "startsWith", "(", "\"_\"", ")", ")", "{", "// remove leading underscore in IDL escaped identifier", "s", "=", "s", ".", "substring", "(", "1", ")", ";", "}", "b", ".", "append", "(", "'", "'", ")", ";", "while", "(", "!", "\"\"", ".", "equals", "(", "s", ")", ")", "{", "int", "idx", "=", "s", ".", "indexOf", "(", "\"::\"", ")", ";", "b", ".", "append", "(", "'", "'", ")", ";", "if", "(", "idx", "==", "-", "1", ")", "{", "b", ".", "append", "(", "s", ")", ";", "s", "=", "\"\"", ";", "}", "else", "{", "b", ".", "append", "(", "s", ".", "substring", "(", "0", ",", "idx", ")", ")", ";", "if", "(", "s", ".", "length", "(", ")", ">", "idx", "+", "2", "&&", "s", ".", "charAt", "(", "idx", "+", "2", ")", "==", "'", "'", ")", "{", "// remove leading underscore in IDL escaped identifier", "s", "=", "s", ".", "substring", "(", "idx", "+", "3", ")", ";", "}", "else", "{", "s", "=", "s", ".", "substring", "(", "idx", "+", "2", ")", ";", "}", "}", "}", "}", "// Set new IDL name", "oa", ".", "setIDLName", "(", "b", ".", "toString", "(", ")", ")", ";", "}", "}"], "docstring": "Fixup overloaded operation names.\nAs specified in section 1.3.2.6.", "docstring_tokens": ["Fixup", "overloaded", "operation", "names", ".", "As", "specified", "in", "section", "1", ".", "3", ".", "2", ".", "6", "."]}
{"code": "cnc.close();", "comments": "remove the reference to the context", "lines": 13, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNCtx.java", "func_name": "CNCtx.destroySubcontext", "original_string": "public void destroySubcontext(Name name)\n            throws NamingException {\n        if (_nc == null)\n            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());\n        NamingContext the_nc = _nc;\n        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);\n        if (name.size() > 0) {\n            try {\n                javax.naming.Context ctx =\n                        (javax.naming.Context) callResolve(path);\n                CNCtx cnc = (CNCtx) ctx;\n                the_nc = cnc._nc;\n                cnc.close(); //remove the reference to the context\n            } catch (ClassCastException e) {\n                throw new NotContextException(name.toString());\n            } catch (CannotProceedException e) {\n                javax.naming.Context cctx = getContinuationContext(e);\n                cctx.destroySubcontext(e.getRemainingName());\n                return;\n            } catch (NameNotFoundException e) {\n                // If leaf is the one missing, return success\n                // as per JNDI spec\n\n                if (e.getRootCause() instanceof NotFound &&\n                        leafNotFound((NotFound) e.getRootCause(),\n                                path[path.length - 1])) {\n                    return; // leaf missing OK\n                }\n                throw e;\n            } catch (NamingException e) {\n                throw e;\n            }\n        }\n        callDestroy(the_nc);\n        callUnbind(path);\n    }", "language": "java", "Allcodes": "public void destroySubcontext(Name name)\n            throws NamingException {\n        if (_nc == null)\n            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());\n        NamingContext the_nc = _nc;\n        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);\n        if (name.size() > 0) {\n            try {\n                javax.naming.Context ctx =\n                        (javax.naming.Context) callResolve(path);\n                CNCtx cnc = (CNCtx) ctx;\n                the_nc = cnc._nc;\n                cnc.close(); //remove the reference to the context\n            } catch (ClassCastException e) {\n                throw new NotContextException(name.toString());\n            } catch (CannotProceedException e) {\n                javax.naming.Context cctx = getContinuationContext(e);\n                cctx.destroySubcontext(e.getRemainingName());\n                return;\n            } catch (NameNotFoundException e) {\n                // If leaf is the one missing, return success\n                // as per JNDI spec\n\n                if (e.getRootCause() instanceof NotFound &&\n                        leafNotFound((NotFound) e.getRootCause(),\n                                path[path.length - 1])) {\n                    return; // leaf missing OK\n                }\n                throw e;\n            } catch (NamingException e) {\n                throw e;\n            }\n        }\n        callDestroy(the_nc);\n        callUnbind(path);\n    }", "code_tokens": ["public", "void", "destroySubcontext", "(", "Name", "name", ")", "throws", "NamingException", "{", "if", "(", "_nc", "==", "null", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "notANamingContext", "(", "name", ".", "toString", "(", ")", ")", ";", "NamingContext", "the_nc", "=", "_nc", ";", "NameComponent", "[", "]", "path", "=", "org", ".", "wildfly", ".", "iiop", ".", "openjdk", ".", "naming", ".", "jndi", ".", "CNNameParser", ".", "nameToCosName", "(", "name", ")", ";", "if", "(", "name", ".", "size", "(", ")", ">", "0", ")", "{", "try", "{", "javax", ".", "naming", ".", "Context", "ctx", "=", "(", "javax", ".", "naming", ".", "Context", ")", "callResolve", "(", "path", ")", ";", "CNCtx", "cnc", "=", "(", "CNCtx", ")", "ctx", ";", "the_nc", "=", "cnc", ".", "_nc", ";", "cnc", ".", "close", "(", ")", ";", "//remove the reference to the context", "}", "catch", "(", "ClassCastException", "e", ")", "{", "throw", "new", "NotContextException", "(", "name", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "CannotProceedException", "e", ")", "{", "javax", ".", "naming", ".", "Context", "cctx", "=", "getContinuationContext", "(", "e", ")", ";", "cctx", ".", "destroySubcontext", "(", "e", ".", "getRemainingName", "(", ")", ")", ";", "return", ";", "}", "catch", "(", "NameNotFoundException", "e", ")", "{", "// If leaf is the one missing, return success", "// as per JNDI spec", "if", "(", "e", ".", "getRootCause", "(", ")", "instanceof", "NotFound", "&&", "leafNotFound", "(", "(", "NotFound", ")", "e", ".", "getRootCause", "(", ")", ",", "path", "[", "path", ".", "length", "-", "1", "]", ")", ")", "{", "return", ";", "// leaf missing OK", "}", "throw", "e", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "throw", "e", ";", "}", "}", "callDestroy", "(", "the_nc", ")", ";", "callUnbind", "(", "path", ")", ";", "}"], "docstring": "Uses the callDestroy function to destroy the context. Destroys\nthe current context if name is empty.\n\n@param name JNDI Name\n@throws javax.naming.OperationNotSupportedException when list is invoked\nwith a non-null argument", "docstring_tokens": ["Uses", "the", "callDestroy", "function", "to", "destroy", "the", "context", ".", "Destroys", "the", "current", "context", "if", "name", "is", "empty", "."]}
{"code": "return;", "comments": "leaf missing OK", "lines": 27, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNCtx.java", "func_name": "CNCtx.destroySubcontext", "original_string": "public void destroySubcontext(Name name)\n            throws NamingException {\n        if (_nc == null)\n            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());\n        NamingContext the_nc = _nc;\n        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);\n        if (name.size() > 0) {\n            try {\n                javax.naming.Context ctx =\n                        (javax.naming.Context) callResolve(path);\n                CNCtx cnc = (CNCtx) ctx;\n                the_nc = cnc._nc;\n                cnc.close(); //remove the reference to the context\n            } catch (ClassCastException e) {\n                throw new NotContextException(name.toString());\n            } catch (CannotProceedException e) {\n                javax.naming.Context cctx = getContinuationContext(e);\n                cctx.destroySubcontext(e.getRemainingName());\n                return;\n            } catch (NameNotFoundException e) {\n                // If leaf is the one missing, return success\n                // as per JNDI spec\n\n                if (e.getRootCause() instanceof NotFound &&\n                        leafNotFound((NotFound) e.getRootCause(),\n                                path[path.length - 1])) {\n                    return; // leaf missing OK\n                }\n                throw e;\n            } catch (NamingException e) {\n                throw e;\n            }\n        }\n        callDestroy(the_nc);\n        callUnbind(path);\n    }", "language": "java", "Allcodes": "public void destroySubcontext(Name name)\n            throws NamingException {\n        if (_nc == null)\n            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());\n        NamingContext the_nc = _nc;\n        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);\n        if (name.size() > 0) {\n            try {\n                javax.naming.Context ctx =\n                        (javax.naming.Context) callResolve(path);\n                CNCtx cnc = (CNCtx) ctx;\n                the_nc = cnc._nc;\n                cnc.close(); //remove the reference to the context\n            } catch (ClassCastException e) {\n                throw new NotContextException(name.toString());\n            } catch (CannotProceedException e) {\n                javax.naming.Context cctx = getContinuationContext(e);\n                cctx.destroySubcontext(e.getRemainingName());\n                return;\n            } catch (NameNotFoundException e) {\n                // If leaf is the one missing, return success\n                // as per JNDI spec\n\n                if (e.getRootCause() instanceof NotFound &&\n                        leafNotFound((NotFound) e.getRootCause(),\n                                path[path.length - 1])) {\n                    return; // leaf missing OK\n                }\n                throw e;\n            } catch (NamingException e) {\n                throw e;\n            }\n        }\n        callDestroy(the_nc);\n        callUnbind(path);\n    }", "code_tokens": ["public", "void", "destroySubcontext", "(", "Name", "name", ")", "throws", "NamingException", "{", "if", "(", "_nc", "==", "null", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "notANamingContext", "(", "name", ".", "toString", "(", ")", ")", ";", "NamingContext", "the_nc", "=", "_nc", ";", "NameComponent", "[", "]", "path", "=", "org", ".", "wildfly", ".", "iiop", ".", "openjdk", ".", "naming", ".", "jndi", ".", "CNNameParser", ".", "nameToCosName", "(", "name", ")", ";", "if", "(", "name", ".", "size", "(", ")", ">", "0", ")", "{", "try", "{", "javax", ".", "naming", ".", "Context", "ctx", "=", "(", "javax", ".", "naming", ".", "Context", ")", "callResolve", "(", "path", ")", ";", "CNCtx", "cnc", "=", "(", "CNCtx", ")", "ctx", ";", "the_nc", "=", "cnc", ".", "_nc", ";", "cnc", ".", "close", "(", ")", ";", "//remove the reference to the context", "}", "catch", "(", "ClassCastException", "e", ")", "{", "throw", "new", "NotContextException", "(", "name", ".", "toString", "(", ")", ")", ";", "}", "catch", "(", "CannotProceedException", "e", ")", "{", "javax", ".", "naming", ".", "Context", "cctx", "=", "getContinuationContext", "(", "e", ")", ";", "cctx", ".", "destroySubcontext", "(", "e", ".", "getRemainingName", "(", ")", ")", ";", "return", ";", "}", "catch", "(", "NameNotFoundException", "e", ")", "{", "// If leaf is the one missing, return success", "// as per JNDI spec", "if", "(", "e", ".", "getRootCause", "(", ")", "instanceof", "NotFound", "&&", "leafNotFound", "(", "(", "NotFound", ")", "e", ".", "getRootCause", "(", ")", ",", "path", "[", "path", ".", "length", "-", "1", "]", ")", ")", "{", "return", ";", "// leaf missing OK", "}", "throw", "e", ";", "}", "catch", "(", "NamingException", "e", ")", "{", "throw", "e", ";", "}", "}", "callDestroy", "(", "the_nc", ")", ";", "callUnbind", "(", "path", ")", ";", "}"], "docstring": "Uses the callDestroy function to destroy the context. Destroys\nthe current context if name is empty.\n\n@param name JNDI Name\n@throws javax.naming.OperationNotSupportedException when list is invoked\nwith a non-null argument", "docstring_tokens": ["Uses", "the", "callDestroy", "function", "to", "destroy", "the", "context", ".", "Destroys", "the", "current", "context", "if", "name", "is", "empty", "."]}
{"code": "any.insert_wstring((String) value);", "comments": "1.3.5.10 Map to wstring", "lines": 3, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ConstantAnalysis.java", "func_name": "ConstantAnalysis.insertValue", "original_string": "public void insertValue(Any any) {\n        if (type == String.class)\n            any.insert_wstring((String) value); // 1.3.5.10 Map to wstring\n        else\n            Util.insertAnyPrimitive(any, value);\n    }", "language": "java", "Allcodes": "public void insertValue(Any any) {\n        if (type == String.class)\n            any.insert_wstring((String) value); // 1.3.5.10 Map to wstring\n        else\n            Util.insertAnyPrimitive(any, value);\n    }", "code_tokens": ["public", "void", "insertValue", "(", "Any", "any", ")", "{", "if", "(", "type", "==", "String", ".", "class", ")", "any", ".", "insert_wstring", "(", "(", "String", ")", "value", ")", ";", "// 1.3.5.10 Map to wstring", "else", "Util", ".", "insertAnyPrimitive", "(", "any", ",", "value", ")", ";", "}"], "docstring": "Insert the constant value into the argument Any.", "docstring_tokens": ["Insert", "the", "constant", "value", "into", "the", "argument", "Any", "."]}
{"code": "return null;", "comments": "pass and let next state factory try", "lines": 21, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/RemoteToCorba.java", "func_name": "RemoteToCorba.getStateToBind", "original_string": "public Object getStateToBind(Object orig, Name name, Context ctx,\n                                 Hashtable<?, ?> env) throws NamingException {\n        if (orig instanceof org.omg.CORBA.Object) {\n            // Already a CORBA object, just use it\n            return null;\n        }\n\n        if (orig instanceof Remote) {\n            // Turn remote object into org.omg.CORBA.Object\n            try {\n                // Returns null if JRMP; let next factory try\n                // CNCtx will eventually throw IllegalArgumentException if\n                // no CORBA object gotten\n                return\n                        CorbaUtils.remoteToCorba((Remote) orig, ((CNCtx) ctx)._orb);\n            } catch (ClassNotFoundException e) {\n                // RMI-IIOP library not available\n                throw IIOPLogger.ROOT_LOGGER.unavailableRMIPackages();\n            }\n        }\n        return null; // pass and let next state factory try\n    }", "language": "java", "Allcodes": "public Object getStateToBind(Object orig, Name name, Context ctx,\n                                 Hashtable<?, ?> env) throws NamingException {\n        if (orig instanceof org.omg.CORBA.Object) {\n            // Already a CORBA object, just use it\n            return null;\n        }\n\n        if (orig instanceof Remote) {\n            // Turn remote object into org.omg.CORBA.Object\n            try {\n                // Returns null if JRMP; let next factory try\n                // CNCtx will eventually throw IllegalArgumentException if\n                // no CORBA object gotten\n                return\n                        CorbaUtils.remoteToCorba((Remote) orig, ((CNCtx) ctx)._orb);\n            } catch (ClassNotFoundException e) {\n                // RMI-IIOP library not available\n                throw IIOPLogger.ROOT_LOGGER.unavailableRMIPackages();\n            }\n        }\n        return null; // pass and let next state factory try\n    }", "code_tokens": ["public", "Object", "getStateToBind", "(", "Object", "orig", ",", "Name", "name", ",", "Context", "ctx", ",", "Hashtable", "<", "?", ",", "?", ">", "env", ")", "throws", "NamingException", "{", "if", "(", "orig", "instanceof", "org", ".", "omg", ".", "CORBA", ".", "Object", ")", "{", "// Already a CORBA object, just use it", "return", "null", ";", "}", "if", "(", "orig", "instanceof", "Remote", ")", "{", "// Turn remote object into org.omg.CORBA.Object", "try", "{", "// Returns null if JRMP; let next factory try", "// CNCtx will eventually throw IllegalArgumentException if", "// no CORBA object gotten", "return", "CorbaUtils", ".", "remoteToCorba", "(", "(", "Remote", ")", "orig", ",", "(", "(", "CNCtx", ")", "ctx", ")", ".", "_orb", ")", ";", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "// RMI-IIOP library not available", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "unavailableRMIPackages", "(", ")", ";", "}", "}", "return", "null", ";", "// pass and let next state factory try", "}"], "docstring": "Returns the CORBA object for a Remote object.\nIf input is not a Remote object, or if Remote object uses JRMP, return null.\nIf the RMI-IIOP library is not available, throw ConfigurationException.\n\n@param orig The object to turn into a CORBA object. If not Remote,\nor if is a JRMP stub or impl, return null.\n@param name Ignored\n@param ctx  The non-null CNCtx whose ORB to use.\n@param env  Ignored\n@return The CORBA object for <tt>orig</tt> or null.\n@throws javax.naming.ConfigurationException If the CORBA object cannot be obtained\ndue to configuration problems, for instance, if RMI-IIOP not available.\n@throws NamingException        If some other problem prevented a CORBA\nobject from being obtained from the Remote object.", "docstring_tokens": ["Returns", "the", "CORBA", "object", "for", "a", "Remote", "object", ".", "If", "input", "is", "not", "a", "Remote", "object", "or", "if", "Remote", "object", "uses", "JRMP", "return", "null", ".", "If", "the", "RMI", "-", "IIOP", "library", "is", "not", "available", "throw", "ConfigurationException", "."]}
{"code": "return (ModuleDefImpl) c;", "comments": "done", "lines": 6, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ir/InterfaceRepository.java", "func_name": "InterfaceRepository.ensurePackageExists", "original_string": "private ModuleDefImpl ensurePackageExists(LocalContainer c,\n                                              String previous,\n                                              String remainder)\n            throws IRConstructionException {\n        if (\"\".equals(remainder))\n            return (ModuleDefImpl) c; // done\n\n        int idx = remainder.indexOf('.');\n        String base;\n\n        if (idx == -1)\n            base = remainder;\n        else\n            base = remainder.substring(0, idx);\n        base = Util.javaToIDLName(base);\n\n        if (previous.equals(\"\"))\n            previous = base;\n        else\n            previous = previous + \"/\" + base;\n        if (idx == -1)\n            remainder = \"\";\n        else\n            remainder = remainder.substring(idx + 1);\n\n        LocalContainer next = null;\n        LocalContained contained = (LocalContained) c._lookup(base);\n\n        if (contained instanceof LocalContainer)\n            next = (LocalContainer) contained;\n        else if (contained != null)\n            throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        if (next == null) {\n            String id = \"IDL:\" + previous + \":1.0\";\n\n            // Create module\n            ModuleDefImpl m = new ModuleDefImpl(id, base, \"1.0\", c, impl);\n\n            c.add(base, m);\n\n            if (idx == -1)\n                return m; // done\n\n            next = (LocalContainer) c._lookup(base); // Better be there now...\n        } else // Check that next _is_ a module\n            if (next.def_kind() != DefinitionKind.dk_Module)\n                throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        return ensurePackageExists(next, previous, remainder);\n    }", "language": "java", "Allcodes": "private ModuleDefImpl ensurePackageExists(LocalContainer c,\n                                              String previous,\n                                              String remainder)\n            throws IRConstructionException {\n        if (\"\".equals(remainder))\n            return (ModuleDefImpl) c; // done\n\n        int idx = remainder.indexOf('.');\n        String base;\n\n        if (idx == -1)\n            base = remainder;\n        else\n            base = remainder.substring(0, idx);\n        base = Util.javaToIDLName(base);\n\n        if (previous.equals(\"\"))\n            previous = base;\n        else\n            previous = previous + \"/\" + base;\n        if (idx == -1)\n            remainder = \"\";\n        else\n            remainder = remainder.substring(idx + 1);\n\n        LocalContainer next = null;\n        LocalContained contained = (LocalContained) c._lookup(base);\n\n        if (contained instanceof LocalContainer)\n            next = (LocalContainer) contained;\n        else if (contained != null)\n            throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        if (next == null) {\n            String id = \"IDL:\" + previous + \":1.0\";\n\n            // Create module\n            ModuleDefImpl m = new ModuleDefImpl(id, base, \"1.0\", c, impl);\n\n            c.add(base, m);\n\n            if (idx == -1)\n                return m; // done\n\n            next = (LocalContainer) c._lookup(base); // Better be there now...\n        } else // Check that next _is_ a module\n            if (next.def_kind() != DefinitionKind.dk_Module)\n                throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        return ensurePackageExists(next, previous, remainder);\n    }", "code_tokens": ["private", "ModuleDefImpl", "ensurePackageExists", "(", "LocalContainer", "c", ",", "String", "previous", ",", "String", "remainder", ")", "throws", "IRConstructionException", "{", "if", "(", "\"\"", ".", "equals", "(", "remainder", ")", ")", "return", "(", "ModuleDefImpl", ")", "c", ";", "// done", "int", "idx", "=", "remainder", ".", "indexOf", "(", "'", "'", ")", ";", "String", "base", ";", "if", "(", "idx", "==", "-", "1", ")", "base", "=", "remainder", ";", "else", "base", "=", "remainder", ".", "substring", "(", "0", ",", "idx", ")", ";", "base", "=", "Util", ".", "javaToIDLName", "(", "base", ")", ";", "if", "(", "previous", ".", "equals", "(", "\"\"", ")", ")", "previous", "=", "base", ";", "else", "previous", "=", "previous", "+", "\"/\"", "+", "base", ";", "if", "(", "idx", "==", "-", "1", ")", "remainder", "=", "\"\"", ";", "else", "remainder", "=", "remainder", ".", "substring", "(", "idx", "+", "1", ")", ";", "LocalContainer", "next", "=", "null", ";", "LocalContained", "contained", "=", "(", "LocalContained", ")", "c", ".", "_lookup", "(", "base", ")", ";", "if", "(", "contained", "instanceof", "LocalContainer", ")", "next", "=", "(", "LocalContainer", ")", "contained", ";", "else", "if", "(", "contained", "!=", "null", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "collisionWhileCreatingPackage", "(", ")", ";", "if", "(", "next", "==", "null", ")", "{", "String", "id", "=", "\"IDL:\"", "+", "previous", "+", "\":1.0\"", ";", "// Create module", "ModuleDefImpl", "m", "=", "new", "ModuleDefImpl", "(", "id", ",", "base", ",", "\"1.0\"", ",", "c", ",", "impl", ")", ";", "c", ".", "add", "(", "base", ",", "m", ")", ";", "if", "(", "idx", "==", "-", "1", ")", "return", "m", ";", "// done", "next", "=", "(", "LocalContainer", ")", "c", ".", "_lookup", "(", "base", ")", ";", "// Better be there now...", "}", "else", "// Check that next _is_ a module", "if", "(", "next", ".", "def_kind", "(", ")", "!=", "DefinitionKind", ".", "dk_Module", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "collisionWhileCreatingPackage", "(", ")", ";", "return", "ensurePackageExists", "(", "next", ",", "previous", ",", "remainder", ")", ";", "}"], "docstring": "Ensure that a package exists in the IR.\nThis will create modules in the IR as needed.\n\n@param c         The container that the remainder of modules should be defined in.\n@param previous  The IDL module name, from root to <code>c</code>.\n@param remainder The java package name, relative to <code>c</code>.\n@return A reference to the IR module that represents the package.", "docstring_tokens": ["Ensure", "that", "a", "package", "exists", "in", "the", "IR", ".", "This", "will", "create", "modules", "in", "the", "IR", "as", "needed", "."]}
{"code": "next = (LocalContainer) c._lookup(base);", "comments": "Better be there now...", "lines": 45, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ir/InterfaceRepository.java", "func_name": "InterfaceRepository.ensurePackageExists", "original_string": "private ModuleDefImpl ensurePackageExists(LocalContainer c,\n                                              String previous,\n                                              String remainder)\n            throws IRConstructionException {\n        if (\"\".equals(remainder))\n            return (ModuleDefImpl) c; // done\n\n        int idx = remainder.indexOf('.');\n        String base;\n\n        if (idx == -1)\n            base = remainder;\n        else\n            base = remainder.substring(0, idx);\n        base = Util.javaToIDLName(base);\n\n        if (previous.equals(\"\"))\n            previous = base;\n        else\n            previous = previous + \"/\" + base;\n        if (idx == -1)\n            remainder = \"\";\n        else\n            remainder = remainder.substring(idx + 1);\n\n        LocalContainer next = null;\n        LocalContained contained = (LocalContained) c._lookup(base);\n\n        if (contained instanceof LocalContainer)\n            next = (LocalContainer) contained;\n        else if (contained != null)\n            throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        if (next == null) {\n            String id = \"IDL:\" + previous + \":1.0\";\n\n            // Create module\n            ModuleDefImpl m = new ModuleDefImpl(id, base, \"1.0\", c, impl);\n\n            c.add(base, m);\n\n            if (idx == -1)\n                return m; // done\n\n            next = (LocalContainer) c._lookup(base); // Better be there now...\n        } else // Check that next _is_ a module\n            if (next.def_kind() != DefinitionKind.dk_Module)\n                throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        return ensurePackageExists(next, previous, remainder);\n    }", "language": "java", "Allcodes": "private ModuleDefImpl ensurePackageExists(LocalContainer c,\n                                              String previous,\n                                              String remainder)\n            throws IRConstructionException {\n        if (\"\".equals(remainder))\n            return (ModuleDefImpl) c; // done\n\n        int idx = remainder.indexOf('.');\n        String base;\n\n        if (idx == -1)\n            base = remainder;\n        else\n            base = remainder.substring(0, idx);\n        base = Util.javaToIDLName(base);\n\n        if (previous.equals(\"\"))\n            previous = base;\n        else\n            previous = previous + \"/\" + base;\n        if (idx == -1)\n            remainder = \"\";\n        else\n            remainder = remainder.substring(idx + 1);\n\n        LocalContainer next = null;\n        LocalContained contained = (LocalContained) c._lookup(base);\n\n        if (contained instanceof LocalContainer)\n            next = (LocalContainer) contained;\n        else if (contained != null)\n            throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        if (next == null) {\n            String id = \"IDL:\" + previous + \":1.0\";\n\n            // Create module\n            ModuleDefImpl m = new ModuleDefImpl(id, base, \"1.0\", c, impl);\n\n            c.add(base, m);\n\n            if (idx == -1)\n                return m; // done\n\n            next = (LocalContainer) c._lookup(base); // Better be there now...\n        } else // Check that next _is_ a module\n            if (next.def_kind() != DefinitionKind.dk_Module)\n                throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();\n\n        return ensurePackageExists(next, previous, remainder);\n    }", "code_tokens": ["private", "ModuleDefImpl", "ensurePackageExists", "(", "LocalContainer", "c", ",", "String", "previous", ",", "String", "remainder", ")", "throws", "IRConstructionException", "{", "if", "(", "\"\"", ".", "equals", "(", "remainder", ")", ")", "return", "(", "ModuleDefImpl", ")", "c", ";", "// done", "int", "idx", "=", "remainder", ".", "indexOf", "(", "'", "'", ")", ";", "String", "base", ";", "if", "(", "idx", "==", "-", "1", ")", "base", "=", "remainder", ";", "else", "base", "=", "remainder", ".", "substring", "(", "0", ",", "idx", ")", ";", "base", "=", "Util", ".", "javaToIDLName", "(", "base", ")", ";", "if", "(", "previous", ".", "equals", "(", "\"\"", ")", ")", "previous", "=", "base", ";", "else", "previous", "=", "previous", "+", "\"/\"", "+", "base", ";", "if", "(", "idx", "==", "-", "1", ")", "remainder", "=", "\"\"", ";", "else", "remainder", "=", "remainder", ".", "substring", "(", "idx", "+", "1", ")", ";", "LocalContainer", "next", "=", "null", ";", "LocalContained", "contained", "=", "(", "LocalContained", ")", "c", ".", "_lookup", "(", "base", ")", ";", "if", "(", "contained", "instanceof", "LocalContainer", ")", "next", "=", "(", "LocalContainer", ")", "contained", ";", "else", "if", "(", "contained", "!=", "null", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "collisionWhileCreatingPackage", "(", ")", ";", "if", "(", "next", "==", "null", ")", "{", "String", "id", "=", "\"IDL:\"", "+", "previous", "+", "\":1.0\"", ";", "// Create module", "ModuleDefImpl", "m", "=", "new", "ModuleDefImpl", "(", "id", ",", "base", ",", "\"1.0\"", ",", "c", ",", "impl", ")", ";", "c", ".", "add", "(", "base", ",", "m", ")", ";", "if", "(", "idx", "==", "-", "1", ")", "return", "m", ";", "// done", "next", "=", "(", "LocalContainer", ")", "c", ".", "_lookup", "(", "base", ")", ";", "// Better be there now...", "}", "else", "// Check that next _is_ a module", "if", "(", "next", ".", "def_kind", "(", ")", "!=", "DefinitionKind", ".", "dk_Module", ")", "throw", "IIOPLogger", ".", "ROOT_LOGGER", ".", "collisionWhileCreatingPackage", "(", ")", ";", "return", "ensurePackageExists", "(", "next", ",", "previous", ",", "remainder", ")", ";", "}"], "docstring": "Ensure that a package exists in the IR.\nThis will create modules in the IR as needed.\n\n@param c         The container that the remainder of modules should be defined in.\n@param previous  The IDL module name, from root to <code>c</code>.\n@param remainder The java package name, relative to <code>c</code>.\n@return A reference to the IR module that represents the package.", "docstring_tokens": ["Ensure", "that", "a", "package", "exists", "in", "the", "IR", ".", "This", "will", "create", "modules", "in", "the", "IR", "as", "needed", "."]}
{"code": "return;", "comments": "No need to add primitives.", "lines": 4, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ir/InterfaceRepository.java", "func_name": "InterfaceRepository.addClass", "original_string": "private void addClass(Class cls)\n            throws RMIIIOPViolationException, IRConstructionException {\n        if (cls.isPrimitive())\n            return; // No need to add primitives.\n\n        if (cls.isArray()) {\n            // Add array mapping\n            addArray(cls);\n        } else if (cls.isInterface()) {\n            if (!RmiIdlUtil.isAbstractValueType(cls)) {\n                // Analyse the interface\n                InterfaceAnalysis ia = InterfaceAnalysis.getInterfaceAnalysis(cls);\n\n                // Add analyzed interface (which may be abstract)\n                addInterface(ia);\n            } else {\n                // Analyse the value\n                ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);\n\n                // Add analyzed value\n                addValue(va);\n            }\n        } else if (Exception.class.isAssignableFrom(cls)) { // Exception type.\n            // Analyse the exception\n            ExceptionAnalysis ea = ExceptionAnalysis.getExceptionAnalysis(cls);\n\n            // Add analyzed exception\n            addException(ea);\n        } else { // Got to be a value type.\n            // Analyse the value\n            ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);\n\n            // Add analyzed value\n            addValue(va);\n        }\n    }", "language": "java", "Allcodes": "private void addClass(Class cls)\n            throws RMIIIOPViolationException, IRConstructionException {\n        if (cls.isPrimitive())\n            return; // No need to add primitives.\n\n        if (cls.isArray()) {\n            // Add array mapping\n            addArray(cls);\n        } else if (cls.isInterface()) {\n            if (!RmiIdlUtil.isAbstractValueType(cls)) {\n                // Analyse the interface\n                InterfaceAnalysis ia = InterfaceAnalysis.getInterfaceAnalysis(cls);\n\n                // Add analyzed interface (which may be abstract)\n                addInterface(ia);\n            } else {\n                // Analyse the value\n                ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);\n\n                // Add analyzed value\n                addValue(va);\n            }\n        } else if (Exception.class.isAssignableFrom(cls)) { // Exception type.\n            // Analyse the exception\n            ExceptionAnalysis ea = ExceptionAnalysis.getExceptionAnalysis(cls);\n\n            // Add analyzed exception\n            addException(ea);\n        } else { // Got to be a value type.\n            // Analyse the value\n            ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);\n\n            // Add analyzed value\n            addValue(va);\n        }\n    }", "code_tokens": ["private", "void", "addClass", "(", "Class", "cls", ")", "throws", "RMIIIOPViolationException", ",", "IRConstructionException", "{", "if", "(", "cls", ".", "isPrimitive", "(", ")", ")", "return", ";", "// No need to add primitives.", "if", "(", "cls", ".", "isArray", "(", ")", ")", "{", "// Add array mapping", "addArray", "(", "cls", ")", ";", "}", "else", "if", "(", "cls", ".", "isInterface", "(", ")", ")", "{", "if", "(", "!", "RmiIdlUtil", ".", "isAbstractValueType", "(", "cls", ")", ")", "{", "// Analyse the interface", "InterfaceAnalysis", "ia", "=", "InterfaceAnalysis", ".", "getInterfaceAnalysis", "(", "cls", ")", ";", "// Add analyzed interface (which may be abstract)", "addInterface", "(", "ia", ")", ";", "}", "else", "{", "// Analyse the value", "ValueAnalysis", "va", "=", "ValueAnalysis", ".", "getValueAnalysis", "(", "cls", ")", ";", "// Add analyzed value", "addValue", "(", "va", ")", ";", "}", "}", "else", "if", "(", "Exception", ".", "class", ".", "isAssignableFrom", "(", "cls", ")", ")", "{", "// Exception type.", "// Analyse the exception", "ExceptionAnalysis", "ea", "=", "ExceptionAnalysis", ".", "getExceptionAnalysis", "(", "cls", ")", ";", "// Add analyzed exception", "addException", "(", "ea", ")", ";", "}", "else", "{", "// Got to be a value type.", "// Analyse the value", "ValueAnalysis", "va", "=", "ValueAnalysis", ".", "getValueAnalysis", "(", "cls", ")", ";", "// Add analyzed value", "addValue", "(", "va", ")", ";", "}", "}"], "docstring": "Map the class and add its IIOP mapping to the repository.", "docstring_tokens": ["Map", "the", "class", "and", "add", "its", "IIOP", "mapping", "to", "the", "repository", "."]}
{"code": "return iDef;", "comments": "Yes, just return it.", "lines": 9, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ir/InterfaceRepository.java", "func_name": "InterfaceRepository.addInterface", "original_string": "private InterfaceDefImpl addInterface(InterfaceAnalysis ia)\n            throws RMIIIOPViolationException, IRConstructionException {\n        InterfaceDefImpl iDef;\n        Class cls = ia.getCls();\n\n        // Lookup: Has it already been added?\n        iDef = (InterfaceDefImpl) interfaceMap.get(cls);\n        if (iDef != null)\n            return iDef; // Yes, just return it.\n\n        // Get module to add interface to.\n        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());\n\n        // Add superinterfaces\n        String[] base_interfaces = addInterfaces(ia);\n\n        // Create the interface\n        String base = cls.getName();\n        base = base.substring(base.lastIndexOf('.') + 1);\n        base = Util.javaToIDLName(base);\n\n        iDef = new InterfaceDefImpl(ia.getRepositoryId(),\n                base, \"1.0\", m,\n                base_interfaces, impl);\n        addTypeCode(cls, iDef.type());\n        m.add(base, iDef);\n        interfaceMap.put(cls, iDef); // Remember we mapped this.\n\n        // Fill in constants\n        addConstants(iDef, ia);\n\n        // Add attributes\n        addAttributes(iDef, ia);\n\n        // Fill in operations\n        addOperations(iDef, ia);\n\n        return iDef;\n    }", "language": "java", "Allcodes": "private InterfaceDefImpl addInterface(InterfaceAnalysis ia)\n            throws RMIIIOPViolationException, IRConstructionException {\n        InterfaceDefImpl iDef;\n        Class cls = ia.getCls();\n\n        // Lookup: Has it already been added?\n        iDef = (InterfaceDefImpl) interfaceMap.get(cls);\n        if (iDef != null)\n            return iDef; // Yes, just return it.\n\n        // Get module to add interface to.\n        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());\n\n        // Add superinterfaces\n        String[] base_interfaces = addInterfaces(ia);\n\n        // Create the interface\n        String base = cls.getName();\n        base = base.substring(base.lastIndexOf('.') + 1);\n        base = Util.javaToIDLName(base);\n\n        iDef = new InterfaceDefImpl(ia.getRepositoryId(),\n                base, \"1.0\", m,\n                base_interfaces, impl);\n        addTypeCode(cls, iDef.type());\n        m.add(base, iDef);\n        interfaceMap.put(cls, iDef); // Remember we mapped this.\n\n        // Fill in constants\n        addConstants(iDef, ia);\n\n        // Add attributes\n        addAttributes(iDef, ia);\n\n        // Fill in operations\n        addOperations(iDef, ia);\n\n        return iDef;\n    }", "code_tokens": ["private", "InterfaceDefImpl", "addInterface", "(", "InterfaceAnalysis", "ia", ")", "throws", "RMIIIOPViolationException", ",", "IRConstructionException", "{", "InterfaceDefImpl", "iDef", ";", "Class", "cls", "=", "ia", ".", "getCls", "(", ")", ";", "// Lookup: Has it already been added?", "iDef", "=", "(", "InterfaceDefImpl", ")", "interfaceMap", ".", "get", "(", "cls", ")", ";", "if", "(", "iDef", "!=", "null", ")", "return", "iDef", ";", "// Yes, just return it.", "// Get module to add interface to.", "ModuleDefImpl", "m", "=", "ensurePackageExists", "(", "cls", ".", "getPackage", "(", ")", ".", "getName", "(", ")", ")", ";", "// Add superinterfaces", "String", "[", "]", "base_interfaces", "=", "addInterfaces", "(", "ia", ")", ";", "// Create the interface", "String", "base", "=", "cls", ".", "getName", "(", ")", ";", "base", "=", "base", ".", "substring", "(", "base", ".", "lastIndexOf", "(", "'", "'", ")", "+", "1", ")", ";", "base", "=", "Util", ".", "javaToIDLName", "(", "base", ")", ";", "iDef", "=", "new", "InterfaceDefImpl", "(", "ia", ".", "getRepositoryId", "(", ")", ",", "base", ",", "\"1.0\"", ",", "m", ",", "base_interfaces", ",", "impl", ")", ";", "addTypeCode", "(", "cls", ",", "iDef", ".", "type", "(", ")", ")", ";", "m", ".", "add", "(", "base", ",", "iDef", ")", ";", "interfaceMap", ".", "put", "(", "cls", ",", "iDef", ")", ";", "// Remember we mapped this.", "// Fill in constants", "addConstants", "(", "iDef", ",", "ia", ")", ";", "// Add attributes", "addAttributes", "(", "iDef", ",", "ia", ")", ";", "// Fill in operations", "addOperations", "(", "iDef", ",", "ia", ")", ";", "return", "iDef", ";", "}"], "docstring": "Add an interface.", "docstring_tokens": ["Add", "an", "interface", "."]}
{"code": "interfaceMap.put(cls, iDef);", "comments": "Remember we mapped this.", "lines": 27, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/rmi/ir/InterfaceRepository.java", "func_name": "InterfaceRepository.addInterface", "original_string": "private InterfaceDefImpl addInterface(InterfaceAnalysis ia)\n            throws RMIIIOPViolationException, IRConstructionException {\n        InterfaceDefImpl iDef;\n        Class cls = ia.getCls();\n\n        // Lookup: Has it already been added?\n        iDef = (InterfaceDefImpl) interfaceMap.get(cls);\n        if (iDef != null)\n            return iDef; // Yes, just return it.\n\n        // Get module to add interface to.\n        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());\n\n        // Add superinterfaces\n        String[] base_interfaces = addInterfaces(ia);\n\n        // Create the interface\n        String base = cls.getName();\n        base = base.substring(base.lastIndexOf('.') + 1);\n        base = Util.javaToIDLName(base);\n\n        iDef = new InterfaceDefImpl(ia.getRepositoryId(),\n                base, \"1.0\", m,\n                base_interfaces, impl);\n        addTypeCode(cls, iDef.type());\n        m.add(base, iDef);\n        interfaceMap.put(cls, iDef); // Remember we mapped this.\n\n        // Fill in constants\n        addConstants(iDef, ia);\n\n        // Add attributes\n        addAttributes(iDef, ia);\n\n        // Fill in operations\n        addOperations(iDef, ia);\n\n        return iDef;\n    }", "language": "java", "Allcodes": "private InterfaceDefImpl addInterface(InterfaceAnalysis ia)\n            throws RMIIIOPViolationException, IRConstructionException {\n        InterfaceDefImpl iDef;\n        Class cls = ia.getCls();\n\n        // Lookup: Has it already been added?\n        iDef = (InterfaceDefImpl) interfaceMap.get(cls);\n        if (iDef != null)\n            return iDef; // Yes, just return it.\n\n        // Get module to add interface to.\n        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());\n\n        // Add superinterfaces\n        String[] base_interfaces = addInterfaces(ia);\n\n        // Create the interface\n        String base = cls.getName();\n        base = base.substring(base.lastIndexOf('.') + 1);\n        base = Util.javaToIDLName(base);\n\n        iDef = new InterfaceDefImpl(ia.getRepositoryId(),\n                base, \"1.0\", m,\n                base_interfaces, impl);\n        addTypeCode(cls, iDef.type());\n        m.add(base, iDef);\n        interfaceMap.put(cls, iDef); // Remember we mapped this.\n\n        // Fill in constants\n        addConstants(iDef, ia);\n\n        // Add attributes\n        addAttributes(iDef, ia);\n\n        // Fill in operations\n        addOperations(iDef, ia);\n\n        return iDef;\n    }", "code_tokens": ["private", "InterfaceDefImpl", "addInterface", "(", "InterfaceAnalysis", "ia", ")", "throws", "RMIIIOPViolationException", ",", "IRConstructionException", "{", "InterfaceDefImpl", "iDef", ";", "Class", "cls", "=", "ia", ".", "getCls", "(", ")", ";", "// Lookup: Has it already been added?", "iDef", "=", "(", "InterfaceDefImpl", ")", "interfaceMap", ".", "get", "(", "cls", ")", ";", "if", "(", "iDef", "!=", "null", ")", "return", "iDef", ";", "// Yes, just return it.", "// Get module to add interface to.", "ModuleDefImpl", "m", "=", "ensurePackageExists", "(", "cls", ".", "getPackage", "(", ")", ".", "getName", "(", ")", ")", ";", "// Add superinterfaces", "String", "[", "]", "base_interfaces", "=", "addInterfaces", "(", "ia", ")", ";", "// Create the interface", "String", "base", "=", "cls", ".", "getName", "(", ")", ";", "base", "=", "base", ".", "substring", "(", "base", ".", "lastIndexOf", "(", "'", "'", ")", "+", "1", ")", ";", "base", "=", "Util", ".", "javaToIDLName", "(", "base", ")", ";", "iDef", "=", "new", "InterfaceDefImpl", "(", "ia", ".", "getRepositoryId", "(", ")", ",", "base", ",", "\"1.0\"", ",", "m", ",", "base_interfaces", ",", "impl", ")", ";", "addTypeCode", "(", "cls", ",", "iDef", ".", "type", "(", ")", ")", ";", "m", ".", "add", "(", "base", ",", "iDef", ")", ";", "interfaceMap", ".", "put", "(", "cls", ",", "iDef", ")", ";", "// Remember we mapped this.", "// Fill in constants", "addConstants", "(", "iDef", ",", "ia", ")", ";", "// Add attributes", "addAttributes", "(", "iDef", ",", "ia", ")", ";", "// Fill in operations", "addOperations", "(", "iDef", ",", "ia", ")", ";", "return", "iDef", ";", "}"], "docstring": "Add an interface.", "docstring_tokens": ["Add", "an", "interface", "."]}
{"code": "counter = 0;", "comments": "reset", "lines": 4, "repo": "wildfly/wildfly", "path": "iiop-openjdk/src/main/java/org/wildfly/iiop/openjdk/naming/jndi/CNBindingEnumeration.java", "func_name": "CNBindingEnumeration.getMore", "original_string": "private boolean getMore() throws NamingException {\n        try {\n            more = _bindingIter.next_n(batchsize, _bindingList);\n            counter = 0; // reset\n        } catch (Exception e) {\n            more = false;\n            NamingException ne = IIOPLogger.ROOT_LOGGER.errorGettingBindingList();\n            ne.setRootCause(e);\n            throw ne;\n        }\n        return more;\n    }", "language": "java", "Allcodes": "private boolean getMore() throws NamingException {\n        try {\n            more = _bindingIter.next_n(batchsize, _bindingList);\n            counter = 0; // reset\n        } catch (Exception e) {\n            more = false;\n            NamingException ne = IIOPLogger.ROOT_LOGGER.errorGettingBindingList();\n            ne.setRootCause(e);\n            throw ne;\n        }\n        return more;\n    }", "code_tokens": ["private", "boolean", "getMore", "(", ")", "throws", "NamingException", "{", "try", "{", "more", "=", "_bindingIter", ".", "next_n", "(", "batchsize", ",", "_bindingList", ")", ";", "counter", "=", "0", ";", "// reset", "}", "catch", "(", "Exception", "e", ")", "{", "more", "=", "false", ";", "NamingException", "ne", "=", "IIOPLogger", ".", "ROOT_LOGGER", ".", "errorGettingBindingList", "(", ")", ";", "ne", ".", "setRootCause", "(", "e", ")", ";", "throw", "ne", ";", "}", "return", "more", ";", "}"], "docstring": "Get the next batch using _bindingIter. Update the 'more' field.", "docstring_tokens": ["Get", "the", "next", "batch", "using", "_bindingIter", ".", "Update", "the", "more", "field", "."]}
{"code": "deployment.addAttachment(WebDeploymentController.class, startWebApp(host, unit));", "comments": "TODO simplify and use findChild later in destroy()/stopWebApp()", "lines": 19, "repo": "wildfly/wildfly", "path": "webservices/server-integration/src/main/java/org/jboss/as/webservices/publish/EndpointPublisherImpl.java", "func_name": "EndpointPublisherImpl.doPublish", "original_string": "protected Context doPublish(ServiceTarget target, DeploymentUnit unit) throws Exception {\n        Deployment deployment = unit.getAttachment(WSAttachmentKeys.DEPLOYMENT_KEY);\n        List<Endpoint> endpoints = deployment.getService().getEndpoints();\n        //If we're running in a Service, that will already have proper dependencies set on the installed endpoint services,\n        //otherwise we need to explicitly wait for the endpoint services to be started before creating the webapp.\n        if (!runningInService) {\n            final ServiceRegistry registry = unit.getServiceRegistry();\n            final StabilityMonitor monitor = new StabilityMonitor();\n            for (Endpoint ep : endpoints) {\n                final ServiceName serviceName = EndpointService.getServiceName(unit, ep.getShortName());\n                monitor.addController(registry.getRequiredService(serviceName));\n            }\n            try {\n                monitor.awaitStability();\n            } finally {\n                monitor.clear();\n            }\n        }\n        deployment.addAttachment(WebDeploymentController.class, startWebApp(host, unit)); //TODO simplify and use findChild later in destroy()/stopWebApp()\n        return new Context(unit.getAttachment(WSAttachmentKeys.JBOSSWEB_METADATA_KEY).getContextRoot(), endpoints);\n    }", "language": "java", "Allcodes": "protected Context doPublish(ServiceTarget target, DeploymentUnit unit) throws Exception {\n        Deployment deployment = unit.getAttachment(WSAttachmentKeys.DEPLOYMENT_KEY);\n        List<Endpoint> endpoints = deployment.getService().getEndpoints();\n        //If we're running in a Service, that will already have proper dependencies set on the installed endpoint services,\n        //otherwise we need to explicitly wait for the endpoint services to be started before creating the webapp.\n        if (!runningInService) {\n            final ServiceRegistry registry = unit.getServiceRegistry();\n            final StabilityMonitor monitor = new StabilityMonitor();\n            for (Endpoint ep : endpoints) {\n                final ServiceName serviceName = EndpointService.getServiceName(unit, ep.getShortName());\n                monitor.addController(registry.getRequiredService(serviceName));\n            }\n            try {\n                monitor.awaitStability();\n            } finally {\n                monitor.clear();\n            }\n        }\n        deployment.addAttachment(WebDeploymentController.class, startWebApp(host, unit)); //TODO simplify and use findChild later in destroy()/stopWebApp()\n        return new Context(unit.getAttachment(WSAttachmentKeys.JBOSSWEB_METADATA_KEY).getContextRoot(), endpoints);\n    }", "code_tokens": ["protected", "Context", "doPublish", "(", "ServiceTarget", "target", ",", "DeploymentUnit", "unit", ")", "throws", "Exception", "{", "Deployment", "deployment", "=", "unit", ".", "getAttachment", "(", "WSAttachmentKeys", ".", "DEPLOYMENT_KEY", ")", ";", "List", "<", "Endpoint", ">", "endpoints", "=", "deployment", ".", "getService", "(", ")", ".", "getEndpoints", "(", ")", ";", "//If we're running in a Service, that will already have proper dependencies set on the installed endpoint services,", "//otherwise we need to explicitly wait for the endpoint services to be started before creating the webapp.", "if", "(", "!", "runningInService", ")", "{", "final", "ServiceRegistry", "registry", "=", "unit", ".", "getServiceRegistry", "(", ")", ";", "final", "StabilityMonitor", "monitor", "=", "new", "StabilityMonitor", "(", ")", ";", "for", "(", "Endpoint", "ep", ":", "endpoints", ")", "{", "final", "ServiceName", "serviceName", "=", "EndpointService", ".", "getServiceName", "(", "unit", ",", "ep", ".", "getShortName", "(", ")", ")", ";", "monitor", ".", "addController", "(", "registry", ".", "getRequiredService", "(", "serviceName", ")", ")", ";", "}", "try", "{", "monitor", ".", "awaitStability", "(", ")", ";", "}", "finally", "{", "monitor", ".", "clear", "(", ")", ";", "}", "}", "deployment", ".", "addAttachment", "(", "WebDeploymentController", ".", "class", ",", "startWebApp", "(", "host", ",", "unit", ")", ")", ";", "//TODO simplify and use findChild later in destroy()/stopWebApp()", "return", "new", "Context", "(", "unit", ".", "getAttachment", "(", "WSAttachmentKeys", ".", "JBOSSWEB_METADATA_KEY", ")", ".", "getContextRoot", "(", ")", ",", "endpoints", ")", ";", "}"], "docstring": "Publish the webapp for the WS deployment unit\n\n@param target\n@param unit\n@return\n@throws Exception", "docstring_tokens": ["Publish", "the", "webapp", "for", "the", "WS", "deployment", "unit"]}
{"code": "info.orderBy = newOrderBy;", "comments": "the ORDER BY has changed", "lines": 12, "repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.addOrderByProjections", "original_string": "private static void addOrderByProjections(QueryPlanningInfo info) {\n    if (info.orderApplied || info.expand || info.unwind != null || info.orderBy == null || info.orderBy.getItems().size() == 0\n        || info.projection == null || info.projection.getItems() == null || (info.projection.getItems().size() == 1\n        && info.projection.getItems().get(0).isAll())) {\n      return;\n    }\n\n    OOrderBy newOrderBy = info.orderBy == null ? null : info.orderBy.copy();\n    List<OProjectionItem> additionalOrderByProjections = calculateAdditionalOrderByProjections(info.projection.getAllAliases(),\n        newOrderBy);\n    if (additionalOrderByProjections.size() > 0) {\n      info.orderBy = newOrderBy;//the ORDER BY has changed\n    }\n    if (additionalOrderByProjections.size() > 0) {\n      info.projectionAfterOrderBy = new OProjection(-1);\n      info.projectionAfterOrderBy.setItems(new ArrayList<>());\n      for (String alias : info.projection.getAllAliases()) {\n        info.projectionAfterOrderBy.getItems().add(projectionFromAlias(new OIdentifier(alias)));\n      }\n\n      for (OProjectionItem item : additionalOrderByProjections) {\n        if (info.preAggregateProjection != null) {\n          info.preAggregateProjection.getItems().add(item);\n          info.aggregateProjection.getItems().add(projectionFromAlias(item.getAlias()));\n          info.projection.getItems().add(projectionFromAlias(item.getAlias()));\n        } else {\n          info.projection.getItems().add(item);\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "private static void addOrderByProjections(QueryPlanningInfo info) {\n    if (info.orderApplied || info.expand || info.unwind != null || info.orderBy == null || info.orderBy.getItems().size() == 0\n        || info.projection == null || info.projection.getItems() == null || (info.projection.getItems().size() == 1\n        && info.projection.getItems().get(0).isAll())) {\n      return;\n    }\n\n    OOrderBy newOrderBy = info.orderBy == null ? null : info.orderBy.copy();\n    List<OProjectionItem> additionalOrderByProjections = calculateAdditionalOrderByProjections(info.projection.getAllAliases(),\n        newOrderBy);\n    if (additionalOrderByProjections.size() > 0) {\n      info.orderBy = newOrderBy;//the ORDER BY has changed\n    }\n    if (additionalOrderByProjections.size() > 0) {\n      info.projectionAfterOrderBy = new OProjection(-1);\n      info.projectionAfterOrderBy.setItems(new ArrayList<>());\n      for (String alias : info.projection.getAllAliases()) {\n        info.projectionAfterOrderBy.getItems().add(projectionFromAlias(new OIdentifier(alias)));\n      }\n\n      for (OProjectionItem item : additionalOrderByProjections) {\n        if (info.preAggregateProjection != null) {\n          info.preAggregateProjection.getItems().add(item);\n          info.aggregateProjection.getItems().add(projectionFromAlias(item.getAlias()));\n          info.projection.getItems().add(projectionFromAlias(item.getAlias()));\n        } else {\n          info.projection.getItems().add(item);\n        }\n      }\n    }\n  }", "code_tokens": ["private", "static", "void", "addOrderByProjections", "(", "QueryPlanningInfo", "info", ")", "{", "if", "(", "info", ".", "orderApplied", "||", "info", ".", "expand", "||", "info", ".", "unwind", "!=", "null", "||", "info", ".", "orderBy", "==", "null", "||", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "size", "(", ")", "==", "0", "||", "info", ".", "projection", "==", "null", "||", "info", ".", "projection", ".", "getItems", "(", ")", "==", "null", "||", "(", "info", ".", "projection", ".", "getItems", "(", ")", ".", "size", "(", ")", "==", "1", "&&", "info", ".", "projection", ".", "getItems", "(", ")", ".", "get", "(", "0", ")", ".", "isAll", "(", ")", ")", ")", "{", "return", ";", "}", "OOrderBy", "newOrderBy", "=", "info", ".", "orderBy", "==", "null", "?", "null", ":", "info", ".", "orderBy", ".", "copy", "(", ")", ";", "List", "<", "OProjectionItem", ">", "additionalOrderByProjections", "=", "calculateAdditionalOrderByProjections", "(", "info", ".", "projection", ".", "getAllAliases", "(", ")", ",", "newOrderBy", ")", ";", "if", "(", "additionalOrderByProjections", ".", "size", "(", ")", ">", "0", ")", "{", "info", ".", "orderBy", "=", "newOrderBy", ";", "//the ORDER BY has changed", "}", "if", "(", "additionalOrderByProjections", ".", "size", "(", ")", ">", "0", ")", "{", "info", ".", "projectionAfterOrderBy", "=", "new", "OProjection", "(", "-", "1", ")", ";", "info", ".", "projectionAfterOrderBy", ".", "setItems", "(", "new", "ArrayList", "<>", "(", ")", ")", ";", "for", "(", "String", "alias", ":", "info", ".", "projection", ".", "getAllAliases", "(", ")", ")", "{", "info", ".", "projectionAfterOrderBy", ".", "getItems", "(", ")", ".", "add", "(", "projectionFromAlias", "(", "new", "OIdentifier", "(", "alias", ")", ")", ")", ";", "}", "for", "(", "OProjectionItem", "item", ":", "additionalOrderByProjections", ")", "{", "if", "(", "info", ".", "preAggregateProjection", "!=", "null", ")", "{", "info", ".", "preAggregateProjection", ".", "getItems", "(", ")", ".", "add", "(", "item", ")", ";", "info", ".", "aggregateProjection", ".", "getItems", "(", ")", ".", "add", "(", "projectionFromAlias", "(", "item", ".", "getAlias", "(", ")", ")", ")", ";", "info", ".", "projection", ".", "getItems", "(", ")", ".", "add", "(", "projectionFromAlias", "(", "item", ".", "getAlias", "(", ")", ")", ")", ";", "}", "else", "{", "info", ".", "projection", ".", "getItems", "(", ")", ".", "add", "(", "item", ")", ";", "}", "}", "}", "}"], "docstring": "creates additional projections for ORDER BY", "docstring_tokens": ["creates", "additional", "projections", "for", "ORDER", "BY"]}
{"code": "break;", "comments": "ASC/DESC interleaved, cannot be used with index.", "lines": 31, "repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/sql/executor/OSelectExecutionPlanner.java", "func_name": "OSelectExecutionPlanner.handleClassWithIndexForSortOnly", "original_string": "private boolean handleClassWithIndexForSortOnly(OSelectExecutionPlan plan, OIdentifier queryTarget, Set<String> filterClusters,\n      QueryPlanningInfo info, OCommandContext ctx, boolean profilingEnabled) {\n    OSchema schema = getSchemaFromContext(ctx);\n    OClass clazz = schema.getClass(queryTarget.getStringValue());\n    if (clazz == null) {\n      clazz = schema.getView(queryTarget.getStringValue());\n      if (clazz == null) {\n        throw new OCommandExecutionException(\"Class not found: \" + queryTarget);\n      }\n    }\n\n    for (OIndex idx : clazz.getIndexes().stream().filter(i -> i.supportsOrderedIterations()).filter(i -> i.getDefinition() != null)\n        .collect(Collectors.toList())) {\n      List<String> indexFields = idx.getDefinition().getFields();\n      if (indexFields.size() < info.orderBy.getItems().size()) {\n        continue;\n      }\n      boolean indexFound = true;\n      String orderType = null;\n      for (int i = 0; i < info.orderBy.getItems().size(); i++) {\n        OOrderByItem orderItem = info.orderBy.getItems().get(i);\n        if (orderItem.getCollate() != null) {\n          return false;\n        }\n        String indexField = indexFields.get(i);\n        if (i == 0) {\n          orderType = orderItem.getType();\n        } else {\n          if (orderType == null || !orderType.equals(orderItem.getType())) {\n            indexFound = false;\n            break;//ASC/DESC interleaved, cannot be used with index.\n          }\n        }\n        if (!(indexField.equals(orderItem.getAlias()) || isInOriginalProjection(indexField, orderItem.getAlias()))) {\n          indexFound = false;\n          break;\n        }\n      }\n      if (indexFound && orderType != null) {\n        plan.chain(new FetchFromIndexValuesStep(idx, orderType.equals(OOrderByItem.ASC), ctx, profilingEnabled));\n        int[] filterClusterIds = null;\n        if (filterClusters != null) {\n          filterClusterIds = filterClusters.stream().map(name -> ctx.getDatabase().getClusterIdByName(name)).mapToInt(i -> i)\n              .toArray();\n        }\n        plan.chain(new GetValueFromIndexEntryStep(ctx, filterClusterIds, profilingEnabled));\n        if (info.serverToClusters.size() == 1) {\n          info.orderApplied = true;\n        }\n        return true;\n      }\n    }\n    return false;\n  }", "language": "java", "Allcodes": "private boolean handleClassWithIndexForSortOnly(OSelectExecutionPlan plan, OIdentifier queryTarget, Set<String> filterClusters,\n      QueryPlanningInfo info, OCommandContext ctx, boolean profilingEnabled) {\n    OSchema schema = getSchemaFromContext(ctx);\n    OClass clazz = schema.getClass(queryTarget.getStringValue());\n    if (clazz == null) {\n      clazz = schema.getView(queryTarget.getStringValue());\n      if (clazz == null) {\n        throw new OCommandExecutionException(\"Class not found: \" + queryTarget);\n      }\n    }\n\n    for (OIndex idx : clazz.getIndexes().stream().filter(i -> i.supportsOrderedIterations()).filter(i -> i.getDefinition() != null)\n        .collect(Collectors.toList())) {\n      List<String> indexFields = idx.getDefinition().getFields();\n      if (indexFields.size() < info.orderBy.getItems().size()) {\n        continue;\n      }\n      boolean indexFound = true;\n      String orderType = null;\n      for (int i = 0; i < info.orderBy.getItems().size(); i++) {\n        OOrderByItem orderItem = info.orderBy.getItems().get(i);\n        if (orderItem.getCollate() != null) {\n          return false;\n        }\n        String indexField = indexFields.get(i);\n        if (i == 0) {\n          orderType = orderItem.getType();\n        } else {\n          if (orderType == null || !orderType.equals(orderItem.getType())) {\n            indexFound = false;\n            break;//ASC/DESC interleaved, cannot be used with index.\n          }\n        }\n        if (!(indexField.equals(orderItem.getAlias()) || isInOriginalProjection(indexField, orderItem.getAlias()))) {\n          indexFound = false;\n          break;\n        }\n      }\n      if (indexFound && orderType != null) {\n        plan.chain(new FetchFromIndexValuesStep(idx, orderType.equals(OOrderByItem.ASC), ctx, profilingEnabled));\n        int[] filterClusterIds = null;\n        if (filterClusters != null) {\n          filterClusterIds = filterClusters.stream().map(name -> ctx.getDatabase().getClusterIdByName(name)).mapToInt(i -> i)\n              .toArray();\n        }\n        plan.chain(new GetValueFromIndexEntryStep(ctx, filterClusterIds, profilingEnabled));\n        if (info.serverToClusters.size() == 1) {\n          info.orderApplied = true;\n        }\n        return true;\n      }\n    }\n    return false;\n  }", "code_tokens": ["private", "boolean", "handleClassWithIndexForSortOnly", "(", "OSelectExecutionPlan", "plan", ",", "OIdentifier", "queryTarget", ",", "Set", "<", "String", ">", "filterClusters", ",", "QueryPlanningInfo", "info", ",", "OCommandContext", "ctx", ",", "boolean", "profilingEnabled", ")", "{", "OSchema", "schema", "=", "getSchemaFromContext", "(", "ctx", ")", ";", "OClass", "clazz", "=", "schema", ".", "getClass", "(", "queryTarget", ".", "getStringValue", "(", ")", ")", ";", "if", "(", "clazz", "==", "null", ")", "{", "clazz", "=", "schema", ".", "getView", "(", "queryTarget", ".", "getStringValue", "(", ")", ")", ";", "if", "(", "clazz", "==", "null", ")", "{", "throw", "new", "OCommandExecutionException", "(", "\"Class not found: \"", "+", "queryTarget", ")", ";", "}", "}", "for", "(", "OIndex", "idx", ":", "clazz", ".", "getIndexes", "(", ")", ".", "stream", "(", ")", ".", "filter", "(", "i", "->", "i", ".", "supportsOrderedIterations", "(", ")", ")", ".", "filter", "(", "i", "->", "i", ".", "getDefinition", "(", ")", "!=", "null", ")", ".", "collect", "(", "Collectors", ".", "toList", "(", ")", ")", ")", "{", "List", "<", "String", ">", "indexFields", "=", "idx", ".", "getDefinition", "(", ")", ".", "getFields", "(", ")", ";", "if", "(", "indexFields", ".", "size", "(", ")", "<", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "size", "(", ")", ")", "{", "continue", ";", "}", "boolean", "indexFound", "=", "true", ";", "String", "orderType", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "size", "(", ")", ";", "i", "++", ")", "{", "OOrderByItem", "orderItem", "=", "info", ".", "orderBy", ".", "getItems", "(", ")", ".", "get", "(", "i", ")", ";", "if", "(", "orderItem", ".", "getCollate", "(", ")", "!=", "null", ")", "{", "return", "false", ";", "}", "String", "indexField", "=", "indexFields", ".", "get", "(", "i", ")", ";", "if", "(", "i", "==", "0", ")", "{", "orderType", "=", "orderItem", ".", "getType", "(", ")", ";", "}", "else", "{", "if", "(", "orderType", "==", "null", "||", "!", "orderType", ".", "equals", "(", "orderItem", ".", "getType", "(", ")", ")", ")", "{", "indexFound", "=", "false", ";", "break", ";", "//ASC/DESC interleaved, cannot be used with index.", "}", "}", "if", "(", "!", "(", "indexField", ".", "equals", "(", "orderItem", ".", "getAlias", "(", ")", ")", "||", "isInOriginalProjection", "(", "indexField", ",", "orderItem", ".", "getAlias", "(", ")", ")", ")", ")", "{", "indexFound", "=", "false", ";", "break", ";", "}", "}", "if", "(", "indexFound", "&&", "orderType", "!=", "null", ")", "{", "plan", ".", "chain", "(", "new", "FetchFromIndexValuesStep", "(", "idx", ",", "orderType", ".", "equals", "(", "OOrderByItem", ".", "ASC", ")", ",", "ctx", ",", "profilingEnabled", ")", ")", ";", "int", "[", "]", "filterClusterIds", "=", "null", ";", "if", "(", "filterClusters", "!=", "null", ")", "{", "filterClusterIds", "=", "filterClusters", ".", "stream", "(", ")", ".", "map", "(", "name", "->", "ctx", ".", "getDatabase", "(", ")", ".", "getClusterIdByName", "(", "name", ")", ")", ".", "mapToInt", "(", "i", "->", "i", ")", ".", "toArray", "(", ")", ";", "}", "plan", ".", "chain", "(", "new", "GetValueFromIndexEntryStep", "(", "ctx", ",", "filterClusterIds", ",", "profilingEnabled", ")", ")", ";", "if", "(", "info", ".", "serverToClusters", ".", "size", "(", ")", "==", "1", ")", "{", "info", ".", "orderApplied", "=", "true", ";", "}", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "tries to use an index for sorting only. Also adds the fetch step to the execution plan\n\n@param plan current execution plan\n@param info the query planning information\n@param ctx  the current context\n\n@return true if it succeeded to use an index to sort, false otherwise.", "docstring_tokens": ["tries", "to", "use", "an", "index", "for", "sorting", "only", ".", "Also", "adds", "the", "fetch", "step", "to", "the", "execution", "plan"]}
{"code": "return;", "comments": "no change, ignore", "lines": 3, "repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OMicroTransaction.java", "func_name": "OMicroTransaction.updateIdentityAfterRecordCommit", "original_string": "public void updateIdentityAfterRecordCommit(final ORID oldRid, final ORID newRid) {\n    if (oldRid.equals(newRid))\n      return; // no change, ignore\n\n    // XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep\n    // the OTransactionIndexChanges.changesPerKey in a consistent state.\n\n    final List<KeyChangesUpdateRecord> keyRecordsToReinsert = new ArrayList<>();\n    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\n    for (Map.Entry<String, OTransactionIndexChanges> entry : indexOperations.entrySet()) {\n      final OIndex<?> index = indexManager.getIndex(entry.getKey());\n      if (index == null)\n        throw new OTransactionException(\"Cannot find index '\" + entry.getValue() + \"' while committing transaction\");\n\n      final Dependency[] fieldRidDependencies = getIndexFieldRidDependencies(index);\n      if (!isIndexMayDependOnRids(fieldRidDependencies))\n        continue;\n\n      final OTransactionIndexChanges indexChanges = entry.getValue();\n      for (final Iterator<OTransactionIndexChangesPerKey> iterator = indexChanges.changesPerKey.values().iterator(); iterator\n          .hasNext(); ) {\n        final OTransactionIndexChangesPerKey keyChanges = iterator.next();\n        if (isIndexKeyMayDependOnRid(keyChanges.key, oldRid, fieldRidDependencies)) {\n          keyRecordsToReinsert.add(new KeyChangesUpdateRecord(keyChanges, indexChanges));\n          iterator.remove();\n        }\n      }\n    }\n\n    // Update the identity.\n\n    final ORecordOperation rec = resolveRecordOperation(oldRid);\n    if (rec != null) {\n      updatedRids.put(newRid.copy(), oldRid.copy());\n\n      if (!rec.getRecord().getIdentity().equals(newRid)) {\n        ORecordInternal.onBeforeIdentityChanged(rec.getRecord());\n\n        final ORecordId recordId = (ORecordId) rec.getRecord().getIdentity();\n        if (recordId == null) {\n          ORecordInternal.setIdentity(rec.getRecord(), new ORecordId(newRid));\n        } else {\n          recordId.setClusterPosition(newRid.getClusterPosition());\n          recordId.setClusterId(newRid.getClusterId());\n        }\n\n        ORecordInternal.onAfterIdentityChanged(rec.getRecord());\n      }\n    }\n\n    // Reinsert the potentially affected index keys.\n\n    for (KeyChangesUpdateRecord record : keyRecordsToReinsert)\n      record.indexChanges.changesPerKey.put(record.keyChanges.key, record.keyChanges);\n\n    // Update the indexes.\n\n    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(translateRid(oldRid));\n    if (transactionIndexOperations != null) {\n      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\n        OTransactionIndexChanges indexEntryChanges = indexOperations.get(indexOperation.index);\n        if (indexEntryChanges == null)\n          continue;\n        final OTransactionIndexChangesPerKey keyChanges;\n        if (indexOperation.key == null) {\n          keyChanges = indexEntryChanges.nullKeyChanges;\n        } else {\n          keyChanges = indexEntryChanges.changesPerKey.get(indexOperation.key);\n        }\n        if (keyChanges != null)\n          updateChangesIdentity(oldRid, newRid, keyChanges);\n      }\n    }\n  }", "language": "java", "Allcodes": "public void updateIdentityAfterRecordCommit(final ORID oldRid, final ORID newRid) {\n    if (oldRid.equals(newRid))\n      return; // no change, ignore\n\n    // XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep\n    // the OTransactionIndexChanges.changesPerKey in a consistent state.\n\n    final List<KeyChangesUpdateRecord> keyRecordsToReinsert = new ArrayList<>();\n    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();\n    for (Map.Entry<String, OTransactionIndexChanges> entry : indexOperations.entrySet()) {\n      final OIndex<?> index = indexManager.getIndex(entry.getKey());\n      if (index == null)\n        throw new OTransactionException(\"Cannot find index '\" + entry.getValue() + \"' while committing transaction\");\n\n      final Dependency[] fieldRidDependencies = getIndexFieldRidDependencies(index);\n      if (!isIndexMayDependOnRids(fieldRidDependencies))\n        continue;\n\n      final OTransactionIndexChanges indexChanges = entry.getValue();\n      for (final Iterator<OTransactionIndexChangesPerKey> iterator = indexChanges.changesPerKey.values().iterator(); iterator\n          .hasNext(); ) {\n        final OTransactionIndexChangesPerKey keyChanges = iterator.next();\n        if (isIndexKeyMayDependOnRid(keyChanges.key, oldRid, fieldRidDependencies)) {\n          keyRecordsToReinsert.add(new KeyChangesUpdateRecord(keyChanges, indexChanges));\n          iterator.remove();\n        }\n      }\n    }\n\n    // Update the identity.\n\n    final ORecordOperation rec = resolveRecordOperation(oldRid);\n    if (rec != null) {\n      updatedRids.put(newRid.copy(), oldRid.copy());\n\n      if (!rec.getRecord().getIdentity().equals(newRid)) {\n        ORecordInternal.onBeforeIdentityChanged(rec.getRecord());\n\n        final ORecordId recordId = (ORecordId) rec.getRecord().getIdentity();\n        if (recordId == null) {\n          ORecordInternal.setIdentity(rec.getRecord(), new ORecordId(newRid));\n        } else {\n          recordId.setClusterPosition(newRid.getClusterPosition());\n          recordId.setClusterId(newRid.getClusterId());\n        }\n\n        ORecordInternal.onAfterIdentityChanged(rec.getRecord());\n      }\n    }\n\n    // Reinsert the potentially affected index keys.\n\n    for (KeyChangesUpdateRecord record : keyRecordsToReinsert)\n      record.indexChanges.changesPerKey.put(record.keyChanges.key, record.keyChanges);\n\n    // Update the indexes.\n\n    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(translateRid(oldRid));\n    if (transactionIndexOperations != null) {\n      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {\n        OTransactionIndexChanges indexEntryChanges = indexOperations.get(indexOperation.index);\n        if (indexEntryChanges == null)\n          continue;\n        final OTransactionIndexChangesPerKey keyChanges;\n        if (indexOperation.key == null) {\n          keyChanges = indexEntryChanges.nullKeyChanges;\n        } else {\n          keyChanges = indexEntryChanges.changesPerKey.get(indexOperation.key);\n        }\n        if (keyChanges != null)\n          updateChangesIdentity(oldRid, newRid, keyChanges);\n      }\n    }\n  }", "code_tokens": ["public", "void", "updateIdentityAfterRecordCommit", "(", "final", "ORID", "oldRid", ",", "final", "ORID", "newRid", ")", "{", "if", "(", "oldRid", ".", "equals", "(", "newRid", ")", ")", "return", ";", "// no change, ignore", "// XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep", "// the OTransactionIndexChanges.changesPerKey in a consistent state.", "final", "List", "<", "KeyChangesUpdateRecord", ">", "keyRecordsToReinsert", "=", "new", "ArrayList", "<>", "(", ")", ";", "final", "OIndexManager", "indexManager", "=", "getDatabase", "(", ")", ".", "getMetadata", "(", ")", ".", "getIndexManager", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "OTransactionIndexChanges", ">", "entry", ":", "indexOperations", ".", "entrySet", "(", ")", ")", "{", "final", "OIndex", "<", "?", ">", "index", "=", "indexManager", ".", "getIndex", "(", "entry", ".", "getKey", "(", ")", ")", ";", "if", "(", "index", "==", "null", ")", "throw", "new", "OTransactionException", "(", "\"Cannot find index '\"", "+", "entry", ".", "getValue", "(", ")", "+", "\"' while committing transaction\"", ")", ";", "final", "Dependency", "[", "]", "fieldRidDependencies", "=", "getIndexFieldRidDependencies", "(", "index", ")", ";", "if", "(", "!", "isIndexMayDependOnRids", "(", "fieldRidDependencies", ")", ")", "continue", ";", "final", "OTransactionIndexChanges", "indexChanges", "=", "entry", ".", "getValue", "(", ")", ";", "for", "(", "final", "Iterator", "<", "OTransactionIndexChangesPerKey", ">", "iterator", "=", "indexChanges", ".", "changesPerKey", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "iterator", ".", "hasNext", "(", ")", ";", ")", "{", "final", "OTransactionIndexChangesPerKey", "keyChanges", "=", "iterator", ".", "next", "(", ")", ";", "if", "(", "isIndexKeyMayDependOnRid", "(", "keyChanges", ".", "key", ",", "oldRid", ",", "fieldRidDependencies", ")", ")", "{", "keyRecordsToReinsert", ".", "add", "(", "new", "KeyChangesUpdateRecord", "(", "keyChanges", ",", "indexChanges", ")", ")", ";", "iterator", ".", "remove", "(", ")", ";", "}", "}", "}", "// Update the identity.", "final", "ORecordOperation", "rec", "=", "resolveRecordOperation", "(", "oldRid", ")", ";", "if", "(", "rec", "!=", "null", ")", "{", "updatedRids", ".", "put", "(", "newRid", ".", "copy", "(", ")", ",", "oldRid", ".", "copy", "(", ")", ")", ";", "if", "(", "!", "rec", ".", "getRecord", "(", ")", ".", "getIdentity", "(", ")", ".", "equals", "(", "newRid", ")", ")", "{", "ORecordInternal", ".", "onBeforeIdentityChanged", "(", "rec", ".", "getRecord", "(", ")", ")", ";", "final", "ORecordId", "recordId", "=", "(", "ORecordId", ")", "rec", ".", "getRecord", "(", ")", ".", "getIdentity", "(", ")", ";", "if", "(", "recordId", "==", "null", ")", "{", "ORecordInternal", ".", "setIdentity", "(", "rec", ".", "getRecord", "(", ")", ",", "new", "ORecordId", "(", "newRid", ")", ")", ";", "}", "else", "{", "recordId", ".", "setClusterPosition", "(", "newRid", ".", "getClusterPosition", "(", ")", ")", ";", "recordId", ".", "setClusterId", "(", "newRid", ".", "getClusterId", "(", ")", ")", ";", "}", "ORecordInternal", ".", "onAfterIdentityChanged", "(", "rec", ".", "getRecord", "(", ")", ")", ";", "}", "}", "// Reinsert the potentially affected index keys.", "for", "(", "KeyChangesUpdateRecord", "record", ":", "keyRecordsToReinsert", ")", "record", ".", "indexChanges", ".", "changesPerKey", ".", "put", "(", "record", ".", "keyChanges", ".", "key", ",", "record", ".", "keyChanges", ")", ";", "// Update the indexes.", "final", "List", "<", "OTransactionRecordIndexOperation", ">", "transactionIndexOperations", "=", "recordIndexOperations", ".", "get", "(", "translateRid", "(", "oldRid", ")", ")", ";", "if", "(", "transactionIndexOperations", "!=", "null", ")", "{", "for", "(", "final", "OTransactionRecordIndexOperation", "indexOperation", ":", "transactionIndexOperations", ")", "{", "OTransactionIndexChanges", "indexEntryChanges", "=", "indexOperations", ".", "get", "(", "indexOperation", ".", "index", ")", ";", "if", "(", "indexEntryChanges", "==", "null", ")", "continue", ";", "final", "OTransactionIndexChangesPerKey", "keyChanges", ";", "if", "(", "indexOperation", ".", "key", "==", "null", ")", "{", "keyChanges", "=", "indexEntryChanges", ".", "nullKeyChanges", ";", "}", "else", "{", "keyChanges", "=", "indexEntryChanges", ".", "changesPerKey", ".", "get", "(", "indexOperation", ".", "key", ")", ";", "}", "if", "(", "keyChanges", "!=", "null", ")", "updateChangesIdentity", "(", "oldRid", ",", "newRid", ",", "keyChanges", ")", ";", "}", "}", "}"], "docstring": "Updates the record identity after its successful commit.", "docstring_tokens": ["Updates", "the", "record", "identity", "after", "its", "successful", "commit", "."]}
{"code": "probe ^= probe << 13;", "comments": "xorshift", "lines": 2, "repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/storage/cache/chm/readbuffer/StripedBuffer.java", "func_name": "StripedBuffer.advanceProbe", "original_string": "private int advanceProbe(int probe) {\n    probe ^= probe << 13; // xorshift\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n\n    this.probe.get().set(probe);\n    return probe;\n  }", "language": "java", "Allcodes": "private int advanceProbe(int probe) {\n    probe ^= probe << 13; // xorshift\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n\n    this.probe.get().set(probe);\n    return probe;\n  }", "code_tokens": ["private", "int", "advanceProbe", "(", "int", "probe", ")", "{", "probe", "^=", "probe", "<<", "13", ";", "// xorshift", "probe", "^=", "probe", ">>>", "17", ";", "probe", "^=", "probe", "<<", "5", ";", "this", ".", "probe", ".", "get", "(", ")", ".", "set", "(", "probe", ")", ";", "return", "probe", ";", "}"], "docstring": "Pseudo-randomly advances and records the given probe value for the given thread.", "docstring_tokens": ["Pseudo", "-", "randomly", "advances", "and", "records", "the", "given", "probe", "value", "for", "the", "given", "thread", "."]}
{"code": "final Set<String> remainingClusters = new HashSet<String>(iClusterNames);", "comments": "KEEPS THE REMAINING CLUSTER TO ADD IN FINAL", "lines": 58, "repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getServerClusterMap", "original_string": "public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,\n      final boolean optimizeForLocalOnly) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      iClusterNames = DEFAULT_CLUSTER_NAME;\n\n    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());\n\n    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY\n    boolean canUseLocalNode = true;\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null && !serverList.contains(iLocalNode)) {\n        canUseLocalNode = false;\n        break;\n      }\n    }\n\n    if (optimizeForLocalOnly && canUseLocalNode) {\n      // USE LOCAL NODE ONLY (MUCH FASTER)\n      servers.put(iLocalNode, iClusterNames);\n      return servers;\n    }\n\n// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS\n    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      for (String s : serverList) {\n        if (NEW_NODE_TAG.equalsIgnoreCase(s))\n          continue;\n\n        Collection<String> clustersInServer = serverMap.get(s);\n        if (clustersInServer == null) {\n          clustersInServer = new HashSet<String>();\n          serverMap.put(s, clustersInServer);\n        }\n        clustersInServer.add(p);\n      }\n    }\n\n    if (serverMap.size() == 1)\n      // RETURN THE ONLY SERVER INVOLVED\n      return serverMap;\n\n    if (!optimizeForLocalOnly)\n      return serverMap;\n\n// ORDER BY NUMBER OF CLUSTERS\n    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());\n    Collections.sort(orderedServers, new Comparator<String>() {\n      @Override\n      public int compare(final String o1, final String o2) {\n        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());\n      }\n    });\n\n// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS\n    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL\n// RESULT\n    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED\n    // CLUSTERS\n    for (String s : orderedServers) {\n      final Collection<String> clusters = serverMap.get(s);\n\n      if (!servers.isEmpty()) {\n        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES\n        clusters.removeAll(includedClusters);\n      }\n\n      servers.put(s, clusters);\n      remainingClusters.removeAll(clusters);\n      includedClusters.addAll(clusters);\n\n      if (remainingClusters.isEmpty())\n        // FOUND ALL CLUSTERS\n        break;\n    }\n\n    return servers;\n  }", "language": "java", "Allcodes": "public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,\n      final boolean optimizeForLocalOnly) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      iClusterNames = DEFAULT_CLUSTER_NAME;\n\n    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());\n\n    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY\n    boolean canUseLocalNode = true;\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null && !serverList.contains(iLocalNode)) {\n        canUseLocalNode = false;\n        break;\n      }\n    }\n\n    if (optimizeForLocalOnly && canUseLocalNode) {\n      // USE LOCAL NODE ONLY (MUCH FASTER)\n      servers.put(iLocalNode, iClusterNames);\n      return servers;\n    }\n\n// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS\n    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      for (String s : serverList) {\n        if (NEW_NODE_TAG.equalsIgnoreCase(s))\n          continue;\n\n        Collection<String> clustersInServer = serverMap.get(s);\n        if (clustersInServer == null) {\n          clustersInServer = new HashSet<String>();\n          serverMap.put(s, clustersInServer);\n        }\n        clustersInServer.add(p);\n      }\n    }\n\n    if (serverMap.size() == 1)\n      // RETURN THE ONLY SERVER INVOLVED\n      return serverMap;\n\n    if (!optimizeForLocalOnly)\n      return serverMap;\n\n// ORDER BY NUMBER OF CLUSTERS\n    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());\n    Collections.sort(orderedServers, new Comparator<String>() {\n      @Override\n      public int compare(final String o1, final String o2) {\n        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());\n      }\n    });\n\n// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS\n    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL\n// RESULT\n    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED\n    // CLUSTERS\n    for (String s : orderedServers) {\n      final Collection<String> clusters = serverMap.get(s);\n\n      if (!servers.isEmpty()) {\n        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES\n        clusters.removeAll(includedClusters);\n      }\n\n      servers.put(s, clusters);\n      remainingClusters.removeAll(clusters);\n      includedClusters.addAll(clusters);\n\n      if (remainingClusters.isEmpty())\n        // FOUND ALL CLUSTERS\n        break;\n    }\n\n    return servers;\n  }", "code_tokens": ["public", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "getServerClusterMap", "(", "Collection", "<", "String", ">", "iClusterNames", ",", "final", "String", "iLocalNode", ",", "final", "boolean", "optimizeForLocalOnly", ")", "{", "if", "(", "iClusterNames", "==", "null", "||", "iClusterNames", ".", "isEmpty", "(", ")", ")", "iClusterNames", "=", "DEFAULT_CLUSTER_NAME", ";", "final", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "servers", "=", "new", "HashMap", "<", "String", ",", "Collection", "<", "String", ">", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "// TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY", "boolean", "canUseLocalNode", "=", "true", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", "&&", "!", "serverList", ".", "contains", "(", "iLocalNode", ")", ")", "{", "canUseLocalNode", "=", "false", ";", "break", ";", "}", "}", "if", "(", "optimizeForLocalOnly", "&&", "canUseLocalNode", ")", "{", "// USE LOCAL NODE ONLY (MUCH FASTER)", "servers", ".", "put", "(", "iLocalNode", ",", "iClusterNames", ")", ";", "return", "servers", ";", "}", "// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS", "final", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "serverMap", "=", "new", "HashMap", "<", "String", ",", "Collection", "<", "String", ">", ">", "(", ")", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "for", "(", "String", "s", ":", "serverList", ")", "{", "if", "(", "NEW_NODE_TAG", ".", "equalsIgnoreCase", "(", "s", ")", ")", "continue", ";", "Collection", "<", "String", ">", "clustersInServer", "=", "serverMap", ".", "get", "(", "s", ")", ";", "if", "(", "clustersInServer", "==", "null", ")", "{", "clustersInServer", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "serverMap", ".", "put", "(", "s", ",", "clustersInServer", ")", ";", "}", "clustersInServer", ".", "add", "(", "p", ")", ";", "}", "}", "if", "(", "serverMap", ".", "size", "(", ")", "==", "1", ")", "// RETURN THE ONLY SERVER INVOLVED", "return", "serverMap", ";", "if", "(", "!", "optimizeForLocalOnly", ")", "return", "serverMap", ";", "// ORDER BY NUMBER OF CLUSTERS", "final", "List", "<", "String", ">", "orderedServers", "=", "new", "ArrayList", "<", "String", ">", "(", "serverMap", ".", "keySet", "(", ")", ")", ";", "Collections", ".", "sort", "(", "orderedServers", ",", "new", "Comparator", "<", "String", ">", "(", ")", "{", "@", "Override", "public", "int", "compare", "(", "final", "String", "o1", ",", "final", "String", "o2", ")", "{", "return", "(", "(", "Integer", ")", "serverMap", ".", "get", "(", "o2", ")", ".", "size", "(", ")", ")", ".", "compareTo", "(", "(", "Integer", ")", "serverMap", ".", "get", "(", "o1", ")", ".", "size", "(", ")", ")", ";", "}", "}", ")", ";", "// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS", "final", "Set", "<", "String", ">", "remainingClusters", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ")", ";", "// KEEPS THE REMAINING CLUSTER TO ADD IN FINAL", "// RESULT", "final", "Set", "<", "String", ">", "includedClusters", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "// KEEPS THE COLLECTION OF ALREADY INCLUDED", "// CLUSTERS", "for", "(", "String", "s", ":", "orderedServers", ")", "{", "final", "Collection", "<", "String", ">", "clusters", "=", "serverMap", ".", "get", "(", "s", ")", ";", "if", "(", "!", "servers", ".", "isEmpty", "(", ")", ")", "{", "// FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES", "clusters", ".", "removeAll", "(", "includedClusters", ")", ";", "}", "servers", ".", "put", "(", "s", ",", "clusters", ")", ";", "remainingClusters", ".", "removeAll", "(", "clusters", ")", ";", "includedClusters", ".", "addAll", "(", "clusters", ")", ";", "if", "(", "remainingClusters", ".", "isEmpty", "(", ")", ")", "// FOUND ALL CLUSTERS", "break", ";", "}", "return", "servers", ";", "}"], "docstring": "Returns the list of servers that can manage a list of clusters. The algorithm makes its best to involve the less servers as it\ncan.\n\n@param iClusterNames Set of cluster names to find\n@param iLocalNode    Local node name", "docstring_tokens": ["Returns", "the", "list", "of", "servers", "that", "can", "manage", "a", "list", "of", "clusters", ".", "The", "algorithm", "makes", "its", "best", "to", "involve", "the", "less", "servers", "as", "it", "can", "."]}
{"code": "final Set<String> includedClusters = new HashSet<String>(iClusterNames.size());", "comments": "KEEPS THE COLLECTION OF ALREADY INCLUDED", "lines": 60, "repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/distributed/ODistributedConfiguration.java", "func_name": "ODistributedConfiguration.getServerClusterMap", "original_string": "public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,\n      final boolean optimizeForLocalOnly) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      iClusterNames = DEFAULT_CLUSTER_NAME;\n\n    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());\n\n    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY\n    boolean canUseLocalNode = true;\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null && !serverList.contains(iLocalNode)) {\n        canUseLocalNode = false;\n        break;\n      }\n    }\n\n    if (optimizeForLocalOnly && canUseLocalNode) {\n      // USE LOCAL NODE ONLY (MUCH FASTER)\n      servers.put(iLocalNode, iClusterNames);\n      return servers;\n    }\n\n// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS\n    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      for (String s : serverList) {\n        if (NEW_NODE_TAG.equalsIgnoreCase(s))\n          continue;\n\n        Collection<String> clustersInServer = serverMap.get(s);\n        if (clustersInServer == null) {\n          clustersInServer = new HashSet<String>();\n          serverMap.put(s, clustersInServer);\n        }\n        clustersInServer.add(p);\n      }\n    }\n\n    if (serverMap.size() == 1)\n      // RETURN THE ONLY SERVER INVOLVED\n      return serverMap;\n\n    if (!optimizeForLocalOnly)\n      return serverMap;\n\n// ORDER BY NUMBER OF CLUSTERS\n    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());\n    Collections.sort(orderedServers, new Comparator<String>() {\n      @Override\n      public int compare(final String o1, final String o2) {\n        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());\n      }\n    });\n\n// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS\n    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL\n// RESULT\n    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED\n    // CLUSTERS\n    for (String s : orderedServers) {\n      final Collection<String> clusters = serverMap.get(s);\n\n      if (!servers.isEmpty()) {\n        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES\n        clusters.removeAll(includedClusters);\n      }\n\n      servers.put(s, clusters);\n      remainingClusters.removeAll(clusters);\n      includedClusters.addAll(clusters);\n\n      if (remainingClusters.isEmpty())\n        // FOUND ALL CLUSTERS\n        break;\n    }\n\n    return servers;\n  }", "language": "java", "Allcodes": "public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,\n      final boolean optimizeForLocalOnly) {\n    if (iClusterNames == null || iClusterNames.isEmpty())\n      iClusterNames = DEFAULT_CLUSTER_NAME;\n\n    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());\n\n    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY\n    boolean canUseLocalNode = true;\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      if (serverList != null && !serverList.contains(iLocalNode)) {\n        canUseLocalNode = false;\n        break;\n      }\n    }\n\n    if (optimizeForLocalOnly && canUseLocalNode) {\n      // USE LOCAL NODE ONLY (MUCH FASTER)\n      servers.put(iLocalNode, iClusterNames);\n      return servers;\n    }\n\n// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS\n    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();\n    for (String p : iClusterNames) {\n      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);\n      for (String s : serverList) {\n        if (NEW_NODE_TAG.equalsIgnoreCase(s))\n          continue;\n\n        Collection<String> clustersInServer = serverMap.get(s);\n        if (clustersInServer == null) {\n          clustersInServer = new HashSet<String>();\n          serverMap.put(s, clustersInServer);\n        }\n        clustersInServer.add(p);\n      }\n    }\n\n    if (serverMap.size() == 1)\n      // RETURN THE ONLY SERVER INVOLVED\n      return serverMap;\n\n    if (!optimizeForLocalOnly)\n      return serverMap;\n\n// ORDER BY NUMBER OF CLUSTERS\n    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());\n    Collections.sort(orderedServers, new Comparator<String>() {\n      @Override\n      public int compare(final String o1, final String o2) {\n        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());\n      }\n    });\n\n// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS\n    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL\n// RESULT\n    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED\n    // CLUSTERS\n    for (String s : orderedServers) {\n      final Collection<String> clusters = serverMap.get(s);\n\n      if (!servers.isEmpty()) {\n        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES\n        clusters.removeAll(includedClusters);\n      }\n\n      servers.put(s, clusters);\n      remainingClusters.removeAll(clusters);\n      includedClusters.addAll(clusters);\n\n      if (remainingClusters.isEmpty())\n        // FOUND ALL CLUSTERS\n        break;\n    }\n\n    return servers;\n  }", "code_tokens": ["public", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "getServerClusterMap", "(", "Collection", "<", "String", ">", "iClusterNames", ",", "final", "String", "iLocalNode", ",", "final", "boolean", "optimizeForLocalOnly", ")", "{", "if", "(", "iClusterNames", "==", "null", "||", "iClusterNames", ".", "isEmpty", "(", ")", ")", "iClusterNames", "=", "DEFAULT_CLUSTER_NAME", ";", "final", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "servers", "=", "new", "HashMap", "<", "String", ",", "Collection", "<", "String", ">", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "// TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY", "boolean", "canUseLocalNode", "=", "true", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "if", "(", "serverList", "!=", "null", "&&", "!", "serverList", ".", "contains", "(", "iLocalNode", ")", ")", "{", "canUseLocalNode", "=", "false", ";", "break", ";", "}", "}", "if", "(", "optimizeForLocalOnly", "&&", "canUseLocalNode", ")", "{", "// USE LOCAL NODE ONLY (MUCH FASTER)", "servers", ".", "put", "(", "iLocalNode", ",", "iClusterNames", ")", ";", "return", "servers", ";", "}", "// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS", "final", "Map", "<", "String", ",", "Collection", "<", "String", ">", ">", "serverMap", "=", "new", "HashMap", "<", "String", ",", "Collection", "<", "String", ">", ">", "(", ")", ";", "for", "(", "String", "p", ":", "iClusterNames", ")", "{", "final", "List", "<", "String", ">", "serverList", "=", "getClusterConfiguration", "(", "p", ")", ".", "field", "(", "SERVERS", ")", ";", "for", "(", "String", "s", ":", "serverList", ")", "{", "if", "(", "NEW_NODE_TAG", ".", "equalsIgnoreCase", "(", "s", ")", ")", "continue", ";", "Collection", "<", "String", ">", "clustersInServer", "=", "serverMap", ".", "get", "(", "s", ")", ";", "if", "(", "clustersInServer", "==", "null", ")", "{", "clustersInServer", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "serverMap", ".", "put", "(", "s", ",", "clustersInServer", ")", ";", "}", "clustersInServer", ".", "add", "(", "p", ")", ";", "}", "}", "if", "(", "serverMap", ".", "size", "(", ")", "==", "1", ")", "// RETURN THE ONLY SERVER INVOLVED", "return", "serverMap", ";", "if", "(", "!", "optimizeForLocalOnly", ")", "return", "serverMap", ";", "// ORDER BY NUMBER OF CLUSTERS", "final", "List", "<", "String", ">", "orderedServers", "=", "new", "ArrayList", "<", "String", ">", "(", "serverMap", ".", "keySet", "(", ")", ")", ";", "Collections", ".", "sort", "(", "orderedServers", ",", "new", "Comparator", "<", "String", ">", "(", ")", "{", "@", "Override", "public", "int", "compare", "(", "final", "String", "o1", ",", "final", "String", "o2", ")", "{", "return", "(", "(", "Integer", ")", "serverMap", ".", "get", "(", "o2", ")", ".", "size", "(", ")", ")", ".", "compareTo", "(", "(", "Integer", ")", "serverMap", ".", "get", "(", "o1", ")", ".", "size", "(", ")", ")", ";", "}", "}", ")", ";", "// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS", "final", "Set", "<", "String", ">", "remainingClusters", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ")", ";", "// KEEPS THE REMAINING CLUSTER TO ADD IN FINAL", "// RESULT", "final", "Set", "<", "String", ">", "includedClusters", "=", "new", "HashSet", "<", "String", ">", "(", "iClusterNames", ".", "size", "(", ")", ")", ";", "// KEEPS THE COLLECTION OF ALREADY INCLUDED", "// CLUSTERS", "for", "(", "String", "s", ":", "orderedServers", ")", "{", "final", "Collection", "<", "String", ">", "clusters", "=", "serverMap", ".", "get", "(", "s", ")", ";", "if", "(", "!", "servers", ".", "isEmpty", "(", ")", ")", "{", "// FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES", "clusters", ".", "removeAll", "(", "includedClusters", ")", ";", "}", "servers", ".", "put", "(", "s", ",", "clusters", ")", ";", "remainingClusters", ".", "removeAll", "(", "clusters", ")", ";", "includedClusters", ".", "addAll", "(", "clusters", ")", ";", "if", "(", "remainingClusters", ".", "isEmpty", "(", ")", ")", "// FOUND ALL CLUSTERS", "break", ";", "}", "return", "servers", ";", "}"], "docstring": "Returns the list of servers that can manage a list of clusters. The algorithm makes its best to involve the less servers as it\ncan.\n\n@param iClusterNames Set of cluster names to find\n@param iLocalNode    Local node name", "docstring_tokens": ["Returns", "the", "list", "of", "servers", "that", "can", "manage", "a", "list", "of", "clusters", ".", "The", "algorithm", "makes", "its", "best", "to", "involve", "the", "less", "servers", "as", "it", "can", "."]}
{"code": "gout = new GZIPOutputStream(baos, 16384);", "comments": "16KB", "lines": 10, "repo": "orientechnologies/orientdb", "path": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpResponse.java", "func_name": "OHttpResponse.compress", "original_string": "public byte[] compress(String jsonStr) {\n    if (jsonStr == null || jsonStr.length() == 0) {\n      return null;\n    }\n    GZIPOutputStream gout = null;\n    ByteArrayOutputStream baos = null;\n    try {\n      byte[] incoming = jsonStr.getBytes(\"UTF-8\");\n      baos = new ByteArrayOutputStream();\n      gout = new GZIPOutputStream(baos, 16384); // 16KB\n      gout.write(incoming);\n      gout.finish();\n      return baos.toByteArray();\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"Error on compressing HTTP response\", ex);\n    } finally {\n      try {\n        if (gout != null) {\n          gout.close();\n        }\n        if (baos != null) {\n          baos.close();\n        }\n      } catch (Exception ex) {\n      }\n    }\n    return null;\n  }", "language": "java", "Allcodes": "public byte[] compress(String jsonStr) {\n    if (jsonStr == null || jsonStr.length() == 0) {\n      return null;\n    }\n    GZIPOutputStream gout = null;\n    ByteArrayOutputStream baos = null;\n    try {\n      byte[] incoming = jsonStr.getBytes(\"UTF-8\");\n      baos = new ByteArrayOutputStream();\n      gout = new GZIPOutputStream(baos, 16384); // 16KB\n      gout.write(incoming);\n      gout.finish();\n      return baos.toByteArray();\n    } catch (Exception ex) {\n      OLogManager.instance().error(this, \"Error on compressing HTTP response\", ex);\n    } finally {\n      try {\n        if (gout != null) {\n          gout.close();\n        }\n        if (baos != null) {\n          baos.close();\n        }\n      } catch (Exception ex) {\n      }\n    }\n    return null;\n  }", "code_tokens": ["public", "byte", "[", "]", "compress", "(", "String", "jsonStr", ")", "{", "if", "(", "jsonStr", "==", "null", "||", "jsonStr", ".", "length", "(", ")", "==", "0", ")", "{", "return", "null", ";", "}", "GZIPOutputStream", "gout", "=", "null", ";", "ByteArrayOutputStream", "baos", "=", "null", ";", "try", "{", "byte", "[", "]", "incoming", "=", "jsonStr", ".", "getBytes", "(", "\"UTF-8\"", ")", ";", "baos", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "gout", "=", "new", "GZIPOutputStream", "(", "baos", ",", "16384", ")", ";", "// 16KB", "gout", ".", "write", "(", "incoming", ")", ";", "gout", ".", "finish", "(", ")", ";", "return", "baos", ".", "toByteArray", "(", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "OLogManager", ".", "instance", "(", ")", ".", "error", "(", "this", ",", "\"Error on compressing HTTP response\"", ",", "ex", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "gout", "!=", "null", ")", "{", "gout", ".", "close", "(", ")", ";", "}", "if", "(", "baos", "!=", "null", ")", "{", "baos", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "Exception", "ex", ")", "{", "}", "}", "return", "null", ";", "}"], "docstring": "Compress content string", "docstring_tokens": ["Compress", "content", "string"]}
{"code": "OClass identityClass = database.getMetadata().getSchema().getClass(OIdentity.CLASS_NAME);", "comments": "SINCE 1.2.0", "lines": 4, "repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/metadata/security/OSecurityShared.java", "func_name": "OSecurityShared.createMetadata", "original_string": "public OUser createMetadata() {\n    final ODatabaseDocument database = getDatabase();\n\n    OClass identityClass = database.getMetadata().getSchema().getClass(OIdentity.CLASS_NAME); // SINCE 1.2.0\n    if (identityClass == null)\n      identityClass = database.getMetadata().getSchema().createAbstractClass(OIdentity.CLASS_NAME);\n\n    OClass roleClass = createOrUpdateORoleClass(database, identityClass);\n\n    createOrUpdateOUserClass(database, identityClass, roleClass);\n\n    // CREATE ROLES AND USERS\n    ORole adminRole = getRole(ORole.ADMIN);\n    if (adminRole == null) {\n      adminRole = createRole(ORole.ADMIN, ORole.ALLOW_MODES.ALLOW_ALL_BUT);\n      adminRole.addRule(ORule.ResourceGeneric.BYPASS_RESTRICTED, null, ORole.PERMISSION_ALL).save();\n    }\n\n    OUser adminUser = getUser(OUser.ADMIN);\n\n    if (adminUser == null) {\n      // This will return the global value if a local storage context configuration value does not exist.\n      boolean createDefUsers = getDatabase().getStorage().getConfiguration().getContextConfiguration()\n          .getValueAsBoolean(OGlobalConfiguration.CREATE_DEFAULT_USERS);\n\n      if (createDefUsers) {\n        adminUser = createUser(OUser.ADMIN, OUser.ADMIN, adminRole);\n      }\n    }\n\n    // SINCE 1.2.0\n    createOrUpdateORestrictedClass(database);\n\n    return adminUser;\n  }", "language": "java", "Allcodes": "public OUser createMetadata() {\n    final ODatabaseDocument database = getDatabase();\n\n    OClass identityClass = database.getMetadata().getSchema().getClass(OIdentity.CLASS_NAME); // SINCE 1.2.0\n    if (identityClass == null)\n      identityClass = database.getMetadata().getSchema().createAbstractClass(OIdentity.CLASS_NAME);\n\n    OClass roleClass = createOrUpdateORoleClass(database, identityClass);\n\n    createOrUpdateOUserClass(database, identityClass, roleClass);\n\n    // CREATE ROLES AND USERS\n    ORole adminRole = getRole(ORole.ADMIN);\n    if (adminRole == null) {\n      adminRole = createRole(ORole.ADMIN, ORole.ALLOW_MODES.ALLOW_ALL_BUT);\n      adminRole.addRule(ORule.ResourceGeneric.BYPASS_RESTRICTED, null, ORole.PERMISSION_ALL).save();\n    }\n\n    OUser adminUser = getUser(OUser.ADMIN);\n\n    if (adminUser == null) {\n      // This will return the global value if a local storage context configuration value does not exist.\n      boolean createDefUsers = getDatabase().getStorage().getConfiguration().getContextConfiguration()\n          .getValueAsBoolean(OGlobalConfiguration.CREATE_DEFAULT_USERS);\n\n      if (createDefUsers) {\n        adminUser = createUser(OUser.ADMIN, OUser.ADMIN, adminRole);\n      }\n    }\n\n    // SINCE 1.2.0\n    createOrUpdateORestrictedClass(database);\n\n    return adminUser;\n  }", "code_tokens": ["public", "OUser", "createMetadata", "(", ")", "{", "final", "ODatabaseDocument", "database", "=", "getDatabase", "(", ")", ";", "OClass", "identityClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "getClass", "(", "OIdentity", ".", "CLASS_NAME", ")", ";", "// SINCE 1.2.0", "if", "(", "identityClass", "==", "null", ")", "identityClass", "=", "database", ".", "getMetadata", "(", ")", ".", "getSchema", "(", ")", ".", "createAbstractClass", "(", "OIdentity", ".", "CLASS_NAME", ")", ";", "OClass", "roleClass", "=", "createOrUpdateORoleClass", "(", "database", ",", "identityClass", ")", ";", "createOrUpdateOUserClass", "(", "database", ",", "identityClass", ",", "roleClass", ")", ";", "// CREATE ROLES AND USERS", "ORole", "adminRole", "=", "getRole", "(", "ORole", ".", "ADMIN", ")", ";", "if", "(", "adminRole", "==", "null", ")", "{", "adminRole", "=", "createRole", "(", "ORole", ".", "ADMIN", ",", "ORole", ".", "ALLOW_MODES", ".", "ALLOW_ALL_BUT", ")", ";", "adminRole", ".", "addRule", "(", "ORule", ".", "ResourceGeneric", ".", "BYPASS_RESTRICTED", ",", "null", ",", "ORole", ".", "PERMISSION_ALL", ")", ".", "save", "(", ")", ";", "}", "OUser", "adminUser", "=", "getUser", "(", "OUser", ".", "ADMIN", ")", ";", "if", "(", "adminUser", "==", "null", ")", "{", "// This will return the global value if a local storage context configuration value does not exist.", "boolean", "createDefUsers", "=", "getDatabase", "(", ")", ".", "getStorage", "(", ")", ".", "getConfiguration", "(", ")", ".", "getContextConfiguration", "(", ")", ".", "getValueAsBoolean", "(", "OGlobalConfiguration", ".", "CREATE_DEFAULT_USERS", ")", ";", "if", "(", "createDefUsers", ")", "{", "adminUser", "=", "createUser", "(", "OUser", ".", "ADMIN", ",", "OUser", ".", "ADMIN", ",", "adminRole", ")", ";", "}", "}", "// SINCE 1.2.0", "createOrUpdateORestrictedClass", "(", "database", ")", ";", "return", "adminUser", ";", "}"], "docstring": "Repairs the security structure if broken by creating the ADMIN role and user with default password.\n\n@return", "docstring_tokens": ["Repairs", "the", "security", "structure", "if", "broken", "by", "creating", "the", "ADMIN", "role", "and", "user", "with", "default", "password", "."]}
{"code": "break;", "comments": "TARGET NODE", "lines": 27, "repo": "orientechnologies/orientdb", "path": "core/src/main/java/com/orientechnologies/orient/core/db/document/ODatabaseDocumentAbstract.java", "func_name": "ODatabaseDocumentAbstract.callbackHooks", "original_string": "public ORecordHook.RESULT callbackHooks(final ORecordHook.TYPE type, final OIdentifiable id) {\n    if (id == null || hooks.isEmpty() || id.getIdentity().getClusterId() == 0)\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    final ORecordHook.SCOPE scope = ORecordHook.SCOPE.typeToScope(type);\n    final int scopeOrdinal = scope.ordinal();\n\n    final ORID identity = id.getIdentity().copy();\n    if (!pushInHook(identity))\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    try {\n      final ORecord rec = id.getRecord();\n      if (rec == null)\n        return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n      final OScenarioThreadLocal.RUN_MODE runMode = OScenarioThreadLocal.INSTANCE.getRunMode();\n\n      boolean recordChanged = false;\n      for (ORecordHook hook : hooksByScope[scopeOrdinal]) {\n        switch (runMode) {\n        case DEFAULT: // NON_DISTRIBUTED OR PROXIED DB\n          if (getStorage().isDistributed()\n              && hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.TARGET_NODE)\n            // SKIP\n            continue;\n          break; // TARGET NODE\n        case RUNNING_DISTRIBUTED:\n          if (hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.SOURCE_NODE)\n            continue;\n        }\n\n        final ORecordHook.RESULT res = hook.onTrigger(type, rec);\n\n        if (res == ORecordHook.RESULT.RECORD_CHANGED)\n          recordChanged = true;\n        else if (res == ORecordHook.RESULT.SKIP_IO)\n          // SKIP IO OPERATION\n          return res;\n        else if (res == ORecordHook.RESULT.SKIP)\n          // SKIP NEXT HOOKS AND RETURN IT\n          return res;\n        else if (res == ORecordHook.RESULT.RECORD_REPLACED)\n          return res;\n      }\n\n      return recordChanged ? ORecordHook.RESULT.RECORD_CHANGED : ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    } finally {\n      popInHook(identity);\n    }\n  }", "language": "java", "Allcodes": "public ORecordHook.RESULT callbackHooks(final ORecordHook.TYPE type, final OIdentifiable id) {\n    if (id == null || hooks.isEmpty() || id.getIdentity().getClusterId() == 0)\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    final ORecordHook.SCOPE scope = ORecordHook.SCOPE.typeToScope(type);\n    final int scopeOrdinal = scope.ordinal();\n\n    final ORID identity = id.getIdentity().copy();\n    if (!pushInHook(identity))\n      return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    try {\n      final ORecord rec = id.getRecord();\n      if (rec == null)\n        return ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n      final OScenarioThreadLocal.RUN_MODE runMode = OScenarioThreadLocal.INSTANCE.getRunMode();\n\n      boolean recordChanged = false;\n      for (ORecordHook hook : hooksByScope[scopeOrdinal]) {\n        switch (runMode) {\n        case DEFAULT: // NON_DISTRIBUTED OR PROXIED DB\n          if (getStorage().isDistributed()\n              && hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.TARGET_NODE)\n            // SKIP\n            continue;\n          break; // TARGET NODE\n        case RUNNING_DISTRIBUTED:\n          if (hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.SOURCE_NODE)\n            continue;\n        }\n\n        final ORecordHook.RESULT res = hook.onTrigger(type, rec);\n\n        if (res == ORecordHook.RESULT.RECORD_CHANGED)\n          recordChanged = true;\n        else if (res == ORecordHook.RESULT.SKIP_IO)\n          // SKIP IO OPERATION\n          return res;\n        else if (res == ORecordHook.RESULT.SKIP)\n          // SKIP NEXT HOOKS AND RETURN IT\n          return res;\n        else if (res == ORecordHook.RESULT.RECORD_REPLACED)\n          return res;\n      }\n\n      return recordChanged ? ORecordHook.RESULT.RECORD_CHANGED : ORecordHook.RESULT.RECORD_NOT_CHANGED;\n\n    } finally {\n      popInHook(identity);\n    }\n  }", "code_tokens": ["public", "ORecordHook", ".", "RESULT", "callbackHooks", "(", "final", "ORecordHook", ".", "TYPE", "type", ",", "final", "OIdentifiable", "id", ")", "{", "if", "(", "id", "==", "null", "||", "hooks", ".", "isEmpty", "(", ")", "||", "id", ".", "getIdentity", "(", ")", ".", "getClusterId", "(", ")", "==", "0", ")", "return", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "final", "ORecordHook", ".", "SCOPE", "scope", "=", "ORecordHook", ".", "SCOPE", ".", "typeToScope", "(", "type", ")", ";", "final", "int", "scopeOrdinal", "=", "scope", ".", "ordinal", "(", ")", ";", "final", "ORID", "identity", "=", "id", ".", "getIdentity", "(", ")", ".", "copy", "(", ")", ";", "if", "(", "!", "pushInHook", "(", "identity", ")", ")", "return", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "try", "{", "final", "ORecord", "rec", "=", "id", ".", "getRecord", "(", ")", ";", "if", "(", "rec", "==", "null", ")", "return", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "final", "OScenarioThreadLocal", ".", "RUN_MODE", "runMode", "=", "OScenarioThreadLocal", ".", "INSTANCE", ".", "getRunMode", "(", ")", ";", "boolean", "recordChanged", "=", "false", ";", "for", "(", "ORecordHook", "hook", ":", "hooksByScope", "[", "scopeOrdinal", "]", ")", "{", "switch", "(", "runMode", ")", "{", "case", "DEFAULT", ":", "// NON_DISTRIBUTED OR PROXIED DB", "if", "(", "getStorage", "(", ")", ".", "isDistributed", "(", ")", "&&", "hook", ".", "getDistributedExecutionMode", "(", ")", "==", "ORecordHook", ".", "DISTRIBUTED_EXECUTION_MODE", ".", "TARGET_NODE", ")", "// SKIP", "continue", ";", "break", ";", "// TARGET NODE", "case", "RUNNING_DISTRIBUTED", ":", "if", "(", "hook", ".", "getDistributedExecutionMode", "(", ")", "==", "ORecordHook", ".", "DISTRIBUTED_EXECUTION_MODE", ".", "SOURCE_NODE", ")", "continue", ";", "}", "final", "ORecordHook", ".", "RESULT", "res", "=", "hook", ".", "onTrigger", "(", "type", ",", "rec", ")", ";", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "RECORD_CHANGED", ")", "recordChanged", "=", "true", ";", "else", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "SKIP_IO", ")", "// SKIP IO OPERATION", "return", "res", ";", "else", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "SKIP", ")", "// SKIP NEXT HOOKS AND RETURN IT", "return", "res", ";", "else", "if", "(", "res", "==", "ORecordHook", ".", "RESULT", ".", "RECORD_REPLACED", ")", "return", "res", ";", "}", "return", "recordChanged", "?", "ORecordHook", ".", "RESULT", ".", "RECORD_CHANGED", ":", "ORecordHook", ".", "RESULT", ".", "RECORD_NOT_CHANGED", ";", "}", "finally", "{", "popInHook", "(", "identity", ")", ";", "}", "}"], "docstring": "Callback the registered hooks if any.\n\n@param type Hook type. Define when hook is called.\n@param id   Record received in the callback\n\n@return True if the input record is changed, otherwise false", "docstring_tokens": ["Callback", "the", "registered", "hooks", "if", "any", "."]}
{"code": "if (len == 0) return 0;", "comments": "0-length reads always return 0", "lines": 3, "repo": "vigna/fastutil", "path": "src/it/unimi/dsi/fastutil/io/FastBufferedInputStream.java", "func_name": "FastBufferedInputStream.readLine", "original_string": "public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {\n\t\tByteArrays.ensureOffsetLength(array ,off, len);\n\t\tif (len == 0) return 0; // 0-length reads always return 0\n\t\tif (noMoreCharacters()) return -1;\n\t\tint i, k = 0, remaining = len, read = 0; // The number of bytes still to be read\n\t\tfor(;;) {\n\t\t\tfor(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\\n' && k != '\\r' ; i++);\n\t\t\tSystem.arraycopy(buffer, pos, array, off + read, i);\n\t\t\tpos += i;\n\t\t\tavail -= i;\n\t\t\tread += i;\n\t\t\tremaining -= i;\n\t\t\tif (remaining == 0) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read; // We did not stop because of a terminator\n\t\t\t}\n\n\t\t\tif (avail > 0) { // We met a terminator\n\t\t\t\tif (k == '\\n') { // LF first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\t\t\t\t\tif (terminators.contains(LineTerminator.LF)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarray[off + read++] = '\\n';\n\t\t\t\t\t\tremaining--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (k == '\\r') { // CR first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR_LF)) {\n\t\t\t\t\t\tif (avail > 0) {\n\t\t\t\t\t\t\tif (buffer[pos] == '\\n') { // CR/LF with LF already in the buffer.\n\t\t\t\t\t\t\t\tpos ++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // We must search for the LF.\n\t\t\t\t\t\t\tif (noMoreCharacters()) {\n\t\t\t\t\t\t\t\t// Not found a matching LF because of end of file, will return CR in buffer if not a terminator\n\n\t\t\t\t\t\t\t\tif (! terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\treadBytes += read;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse readBytes += read + 1;\n\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (buffer[0] == '\\n') {\n\t\t\t\t\t\t\t\t// Found matching LF, won't return terminators in the buffer\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\tremaining--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (noMoreCharacters()) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {\n\t\tByteArrays.ensureOffsetLength(array ,off, len);\n\t\tif (len == 0) return 0; // 0-length reads always return 0\n\t\tif (noMoreCharacters()) return -1;\n\t\tint i, k = 0, remaining = len, read = 0; // The number of bytes still to be read\n\t\tfor(;;) {\n\t\t\tfor(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\\n' && k != '\\r' ; i++);\n\t\t\tSystem.arraycopy(buffer, pos, array, off + read, i);\n\t\t\tpos += i;\n\t\t\tavail -= i;\n\t\t\tread += i;\n\t\t\tremaining -= i;\n\t\t\tif (remaining == 0) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read; // We did not stop because of a terminator\n\t\t\t}\n\n\t\t\tif (avail > 0) { // We met a terminator\n\t\t\t\tif (k == '\\n') { // LF first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\t\t\t\t\tif (terminators.contains(LineTerminator.LF)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarray[off + read++] = '\\n';\n\t\t\t\t\t\tremaining--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (k == '\\r') { // CR first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR_LF)) {\n\t\t\t\t\t\tif (avail > 0) {\n\t\t\t\t\t\t\tif (buffer[pos] == '\\n') { // CR/LF with LF already in the buffer.\n\t\t\t\t\t\t\t\tpos ++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // We must search for the LF.\n\t\t\t\t\t\t\tif (noMoreCharacters()) {\n\t\t\t\t\t\t\t\t// Not found a matching LF because of end of file, will return CR in buffer if not a terminator\n\n\t\t\t\t\t\t\t\tif (! terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\treadBytes += read;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse readBytes += read + 1;\n\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (buffer[0] == '\\n') {\n\t\t\t\t\t\t\t\t// Found matching LF, won't return terminators in the buffer\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\tremaining--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (noMoreCharacters()) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "int", "readLine", "(", "final", "byte", "[", "]", "array", ",", "final", "int", "off", ",", "final", "int", "len", ",", "final", "EnumSet", "<", "LineTerminator", ">", "terminators", ")", "throws", "IOException", "{", "ByteArrays", ".", "ensureOffsetLength", "(", "array", ",", "off", ",", "len", ")", ";", "if", "(", "len", "==", "0", ")", "return", "0", ";", "// 0-length reads always return 0", "if", "(", "noMoreCharacters", "(", ")", ")", "return", "-", "1", ";", "int", "i", ",", "k", "=", "0", ",", "remaining", "=", "len", ",", "read", "=", "0", ";", "// The number of bytes still to be read", "for", "(", ";", ";", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "avail", "&&", "i", "<", "remaining", "&&", "(", "k", "=", "buffer", "[", "pos", "+", "i", "]", ")", "!=", "'", "'", "&&", "k", "!=", "'", "'", ";", "i", "++", ")", ";", "System", ".", "arraycopy", "(", "buffer", ",", "pos", ",", "array", ",", "off", "+", "read", ",", "i", ")", ";", "pos", "+=", "i", ";", "avail", "-=", "i", ";", "read", "+=", "i", ";", "remaining", "-=", "i", ";", "if", "(", "remaining", "==", "0", ")", "{", "readBytes", "+=", "read", ";", "return", "read", ";", "// We did not stop because of a terminator", "}", "if", "(", "avail", ">", "0", ")", "{", "// We met a terminator", "if", "(", "k", "==", "'", "'", ")", "{", "// LF first", "pos", "++", ";", "avail", "--", ";", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "LF", ")", ")", "{", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "else", "{", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "}", "}", "else", "if", "(", "k", "==", "'", "'", ")", "{", "// CR first", "pos", "++", ";", "avail", "--", ";", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR_LF", ")", ")", "{", "if", "(", "avail", ">", "0", ")", "{", "if", "(", "buffer", "[", "pos", "]", "==", "'", "'", ")", "{", "// CR/LF with LF already in the buffer.", "pos", "++", ";", "avail", "--", ";", "readBytes", "+=", "read", "+", "2", ";", "return", "read", ";", "}", "}", "else", "{", "// We must search for the LF.", "if", "(", "noMoreCharacters", "(", ")", ")", "{", "// Not found a matching LF because of end of file, will return CR in buffer if not a terminator", "if", "(", "!", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR", ")", ")", "{", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "readBytes", "+=", "read", ";", "}", "else", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "if", "(", "buffer", "[", "0", "]", "==", "'", "'", ")", "{", "// Found matching LF, won't return terminators in the buffer", "pos", "++", ";", "avail", "--", ";", "readBytes", "+=", "read", "+", "2", ";", "return", "read", ";", "}", "}", "}", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR", ")", ")", "{", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "}", "}", "else", "if", "(", "noMoreCharacters", "(", ")", ")", "{", "readBytes", "+=", "read", ";", "return", "read", ";", "}", "}", "}"], "docstring": "Reads a line into the given byte-array fragment.\n\n<p>Reading lines (i.e., characters) out of a byte stream is not always sensible\n(methods available to that purpose in old versions of Java have been mercilessly deprecated).\nNonetheless, in several situations, such as when decoding network protocols or headers\nknown to be ASCII, it is very useful to be able to read a line from a byte stream.\n\n<p>This method will attempt to read the next line into {@code array} starting at {@code off},\nreading at most {@code len} bytes. The read, however, will be stopped by the end of file or\nwhen meeting a {@linkplain LineTerminator <em>line terminator</em>}. Of course, for this operation\nto be sensible the encoding of the text contained in the stream, if any, must not generate spurious\ncarriage returns or line feeds. Note that the termination detection uses a maximisation\ncriterion, so if you specify both {@link LineTerminator#CR} and\n{@link LineTerminator#CR_LF} meeting a pair CR/LF will consider the whole pair a terminator.\n\n<p>Terminators are <em>not</em> copied into <em>array</em> or included in the returned count. The\nreturned integer can be used to check whether the line is complete: if it is smaller than\n{@code len}, then more bytes might be available, but note that this method (contrarily\nto {@link #read(byte[], int, int)}) can legitimately return zero when {@code len}\nis nonzero just because a terminator was found as the first character. Thus, the intended\nusage of this method is to call it on a given array, check whether {@code len} bytes\nhave been read, and if so try again (possibly extending the array) until a number of read bytes\nstrictly smaller than {@code len} (possibly, -1) is returned.\n\n<p>If you need to guarantee that a full line is read, use the following idiom:\n<pre>\nint start = off, len;\nwhile((len = fbis.readLine(array, start, array.length - start, terminators)) == array.length - start) {\nstart += len;\narray = ByteArrays.grow(array, array.length + 1);\n}\n</pre>\n\n<p>At the end of the loop, the line will be placed in {@code array} starting at\n{@code off} (inclusive) and ending at {@code start + Math.max(len, 0)} (exclusive).\n\n@param array byte array where the next line will be stored.\n@param off the first byte to use in {@code array}.\n@param len the maximum number of bytes to read.\n@param terminators a set containing the line termination sequences that we want\nto consider as valid.\n@return the number of bytes actually placed in {@code array}, or -1 at end of file.\nNote that the returned number will be {@code len} if no line termination sequence\nspecified in {@code terminators} has been met before scanning {@code len} byte,\nand if also we did not meet the end of file.", "docstring_tokens": ["Reads", "a", "line", "into", "the", "given", "byte", "-", "array", "fragment", "."]}
{"code": "int i, k = 0, remaining = len, read = 0;", "comments": "The number of bytes still to be read", "lines": 5, "repo": "vigna/fastutil", "path": "src/it/unimi/dsi/fastutil/io/FastBufferedInputStream.java", "func_name": "FastBufferedInputStream.readLine", "original_string": "public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {\n\t\tByteArrays.ensureOffsetLength(array ,off, len);\n\t\tif (len == 0) return 0; // 0-length reads always return 0\n\t\tif (noMoreCharacters()) return -1;\n\t\tint i, k = 0, remaining = len, read = 0; // The number of bytes still to be read\n\t\tfor(;;) {\n\t\t\tfor(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\\n' && k != '\\r' ; i++);\n\t\t\tSystem.arraycopy(buffer, pos, array, off + read, i);\n\t\t\tpos += i;\n\t\t\tavail -= i;\n\t\t\tread += i;\n\t\t\tremaining -= i;\n\t\t\tif (remaining == 0) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read; // We did not stop because of a terminator\n\t\t\t}\n\n\t\t\tif (avail > 0) { // We met a terminator\n\t\t\t\tif (k == '\\n') { // LF first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\t\t\t\t\tif (terminators.contains(LineTerminator.LF)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarray[off + read++] = '\\n';\n\t\t\t\t\t\tremaining--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (k == '\\r') { // CR first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR_LF)) {\n\t\t\t\t\t\tif (avail > 0) {\n\t\t\t\t\t\t\tif (buffer[pos] == '\\n') { // CR/LF with LF already in the buffer.\n\t\t\t\t\t\t\t\tpos ++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // We must search for the LF.\n\t\t\t\t\t\t\tif (noMoreCharacters()) {\n\t\t\t\t\t\t\t\t// Not found a matching LF because of end of file, will return CR in buffer if not a terminator\n\n\t\t\t\t\t\t\t\tif (! terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\treadBytes += read;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse readBytes += read + 1;\n\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (buffer[0] == '\\n') {\n\t\t\t\t\t\t\t\t// Found matching LF, won't return terminators in the buffer\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\tremaining--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (noMoreCharacters()) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {\n\t\tByteArrays.ensureOffsetLength(array ,off, len);\n\t\tif (len == 0) return 0; // 0-length reads always return 0\n\t\tif (noMoreCharacters()) return -1;\n\t\tint i, k = 0, remaining = len, read = 0; // The number of bytes still to be read\n\t\tfor(;;) {\n\t\t\tfor(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\\n' && k != '\\r' ; i++);\n\t\t\tSystem.arraycopy(buffer, pos, array, off + read, i);\n\t\t\tpos += i;\n\t\t\tavail -= i;\n\t\t\tread += i;\n\t\t\tremaining -= i;\n\t\t\tif (remaining == 0) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read; // We did not stop because of a terminator\n\t\t\t}\n\n\t\t\tif (avail > 0) { // We met a terminator\n\t\t\t\tif (k == '\\n') { // LF first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\t\t\t\t\tif (terminators.contains(LineTerminator.LF)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarray[off + read++] = '\\n';\n\t\t\t\t\t\tremaining--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (k == '\\r') { // CR first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR_LF)) {\n\t\t\t\t\t\tif (avail > 0) {\n\t\t\t\t\t\t\tif (buffer[pos] == '\\n') { // CR/LF with LF already in the buffer.\n\t\t\t\t\t\t\t\tpos ++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // We must search for the LF.\n\t\t\t\t\t\t\tif (noMoreCharacters()) {\n\t\t\t\t\t\t\t\t// Not found a matching LF because of end of file, will return CR in buffer if not a terminator\n\n\t\t\t\t\t\t\t\tif (! terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\treadBytes += read;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse readBytes += read + 1;\n\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (buffer[0] == '\\n') {\n\t\t\t\t\t\t\t\t// Found matching LF, won't return terminators in the buffer\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\tremaining--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (noMoreCharacters()) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "int", "readLine", "(", "final", "byte", "[", "]", "array", ",", "final", "int", "off", ",", "final", "int", "len", ",", "final", "EnumSet", "<", "LineTerminator", ">", "terminators", ")", "throws", "IOException", "{", "ByteArrays", ".", "ensureOffsetLength", "(", "array", ",", "off", ",", "len", ")", ";", "if", "(", "len", "==", "0", ")", "return", "0", ";", "// 0-length reads always return 0", "if", "(", "noMoreCharacters", "(", ")", ")", "return", "-", "1", ";", "int", "i", ",", "k", "=", "0", ",", "remaining", "=", "len", ",", "read", "=", "0", ";", "// The number of bytes still to be read", "for", "(", ";", ";", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "avail", "&&", "i", "<", "remaining", "&&", "(", "k", "=", "buffer", "[", "pos", "+", "i", "]", ")", "!=", "'", "'", "&&", "k", "!=", "'", "'", ";", "i", "++", ")", ";", "System", ".", "arraycopy", "(", "buffer", ",", "pos", ",", "array", ",", "off", "+", "read", ",", "i", ")", ";", "pos", "+=", "i", ";", "avail", "-=", "i", ";", "read", "+=", "i", ";", "remaining", "-=", "i", ";", "if", "(", "remaining", "==", "0", ")", "{", "readBytes", "+=", "read", ";", "return", "read", ";", "// We did not stop because of a terminator", "}", "if", "(", "avail", ">", "0", ")", "{", "// We met a terminator", "if", "(", "k", "==", "'", "'", ")", "{", "// LF first", "pos", "++", ";", "avail", "--", ";", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "LF", ")", ")", "{", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "else", "{", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "}", "}", "else", "if", "(", "k", "==", "'", "'", ")", "{", "// CR first", "pos", "++", ";", "avail", "--", ";", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR_LF", ")", ")", "{", "if", "(", "avail", ">", "0", ")", "{", "if", "(", "buffer", "[", "pos", "]", "==", "'", "'", ")", "{", "// CR/LF with LF already in the buffer.", "pos", "++", ";", "avail", "--", ";", "readBytes", "+=", "read", "+", "2", ";", "return", "read", ";", "}", "}", "else", "{", "// We must search for the LF.", "if", "(", "noMoreCharacters", "(", ")", ")", "{", "// Not found a matching LF because of end of file, will return CR in buffer if not a terminator", "if", "(", "!", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR", ")", ")", "{", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "readBytes", "+=", "read", ";", "}", "else", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "if", "(", "buffer", "[", "0", "]", "==", "'", "'", ")", "{", "// Found matching LF, won't return terminators in the buffer", "pos", "++", ";", "avail", "--", ";", "readBytes", "+=", "read", "+", "2", ";", "return", "read", ";", "}", "}", "}", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR", ")", ")", "{", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "}", "}", "else", "if", "(", "noMoreCharacters", "(", ")", ")", "{", "readBytes", "+=", "read", ";", "return", "read", ";", "}", "}", "}"], "docstring": "Reads a line into the given byte-array fragment.\n\n<p>Reading lines (i.e., characters) out of a byte stream is not always sensible\n(methods available to that purpose in old versions of Java have been mercilessly deprecated).\nNonetheless, in several situations, such as when decoding network protocols or headers\nknown to be ASCII, it is very useful to be able to read a line from a byte stream.\n\n<p>This method will attempt to read the next line into {@code array} starting at {@code off},\nreading at most {@code len} bytes. The read, however, will be stopped by the end of file or\nwhen meeting a {@linkplain LineTerminator <em>line terminator</em>}. Of course, for this operation\nto be sensible the encoding of the text contained in the stream, if any, must not generate spurious\ncarriage returns or line feeds. Note that the termination detection uses a maximisation\ncriterion, so if you specify both {@link LineTerminator#CR} and\n{@link LineTerminator#CR_LF} meeting a pair CR/LF will consider the whole pair a terminator.\n\n<p>Terminators are <em>not</em> copied into <em>array</em> or included in the returned count. The\nreturned integer can be used to check whether the line is complete: if it is smaller than\n{@code len}, then more bytes might be available, but note that this method (contrarily\nto {@link #read(byte[], int, int)}) can legitimately return zero when {@code len}\nis nonzero just because a terminator was found as the first character. Thus, the intended\nusage of this method is to call it on a given array, check whether {@code len} bytes\nhave been read, and if so try again (possibly extending the array) until a number of read bytes\nstrictly smaller than {@code len} (possibly, -1) is returned.\n\n<p>If you need to guarantee that a full line is read, use the following idiom:\n<pre>\nint start = off, len;\nwhile((len = fbis.readLine(array, start, array.length - start, terminators)) == array.length - start) {\nstart += len;\narray = ByteArrays.grow(array, array.length + 1);\n}\n</pre>\n\n<p>At the end of the loop, the line will be placed in {@code array} starting at\n{@code off} (inclusive) and ending at {@code start + Math.max(len, 0)} (exclusive).\n\n@param array byte array where the next line will be stored.\n@param off the first byte to use in {@code array}.\n@param len the maximum number of bytes to read.\n@param terminators a set containing the line termination sequences that we want\nto consider as valid.\n@return the number of bytes actually placed in {@code array}, or -1 at end of file.\nNote that the returned number will be {@code len} if no line termination sequence\nspecified in {@code terminators} has been met before scanning {@code len} byte,\nand if also we did not meet the end of file.", "docstring_tokens": ["Reads", "a", "line", "into", "the", "given", "byte", "-", "array", "fragment", "."]}
{"code": "return read;", "comments": "We did not stop because of a terminator", "lines": 15, "repo": "vigna/fastutil", "path": "src/it/unimi/dsi/fastutil/io/FastBufferedInputStream.java", "func_name": "FastBufferedInputStream.readLine", "original_string": "public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {\n\t\tByteArrays.ensureOffsetLength(array ,off, len);\n\t\tif (len == 0) return 0; // 0-length reads always return 0\n\t\tif (noMoreCharacters()) return -1;\n\t\tint i, k = 0, remaining = len, read = 0; // The number of bytes still to be read\n\t\tfor(;;) {\n\t\t\tfor(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\\n' && k != '\\r' ; i++);\n\t\t\tSystem.arraycopy(buffer, pos, array, off + read, i);\n\t\t\tpos += i;\n\t\t\tavail -= i;\n\t\t\tread += i;\n\t\t\tremaining -= i;\n\t\t\tif (remaining == 0) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read; // We did not stop because of a terminator\n\t\t\t}\n\n\t\t\tif (avail > 0) { // We met a terminator\n\t\t\t\tif (k == '\\n') { // LF first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\t\t\t\t\tif (terminators.contains(LineTerminator.LF)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarray[off + read++] = '\\n';\n\t\t\t\t\t\tremaining--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (k == '\\r') { // CR first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR_LF)) {\n\t\t\t\t\t\tif (avail > 0) {\n\t\t\t\t\t\t\tif (buffer[pos] == '\\n') { // CR/LF with LF already in the buffer.\n\t\t\t\t\t\t\t\tpos ++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // We must search for the LF.\n\t\t\t\t\t\t\tif (noMoreCharacters()) {\n\t\t\t\t\t\t\t\t// Not found a matching LF because of end of file, will return CR in buffer if not a terminator\n\n\t\t\t\t\t\t\t\tif (! terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\treadBytes += read;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse readBytes += read + 1;\n\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (buffer[0] == '\\n') {\n\t\t\t\t\t\t\t\t// Found matching LF, won't return terminators in the buffer\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\tremaining--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (noMoreCharacters()) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {\n\t\tByteArrays.ensureOffsetLength(array ,off, len);\n\t\tif (len == 0) return 0; // 0-length reads always return 0\n\t\tif (noMoreCharacters()) return -1;\n\t\tint i, k = 0, remaining = len, read = 0; // The number of bytes still to be read\n\t\tfor(;;) {\n\t\t\tfor(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\\n' && k != '\\r' ; i++);\n\t\t\tSystem.arraycopy(buffer, pos, array, off + read, i);\n\t\t\tpos += i;\n\t\t\tavail -= i;\n\t\t\tread += i;\n\t\t\tremaining -= i;\n\t\t\tif (remaining == 0) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read; // We did not stop because of a terminator\n\t\t\t}\n\n\t\t\tif (avail > 0) { // We met a terminator\n\t\t\t\tif (k == '\\n') { // LF first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\t\t\t\t\tif (terminators.contains(LineTerminator.LF)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarray[off + read++] = '\\n';\n\t\t\t\t\t\tremaining--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (k == '\\r') { // CR first\n\t\t\t\t\tpos++;\n\t\t\t\t\tavail--;\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR_LF)) {\n\t\t\t\t\t\tif (avail > 0) {\n\t\t\t\t\t\t\tif (buffer[pos] == '\\n') { // CR/LF with LF already in the buffer.\n\t\t\t\t\t\t\t\tpos ++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // We must search for the LF.\n\t\t\t\t\t\t\tif (noMoreCharacters()) {\n\t\t\t\t\t\t\t\t// Not found a matching LF because of end of file, will return CR in buffer if not a terminator\n\n\t\t\t\t\t\t\t\tif (! terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\treadBytes += read;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse readBytes += read + 1;\n\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (buffer[0] == '\\n') {\n\t\t\t\t\t\t\t\t// Found matching LF, won't return terminators in the buffer\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\tavail--;\n\t\t\t\t\t\t\t\treadBytes += read + 2;\n\t\t\t\t\t\t\t\treturn read;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (terminators.contains(LineTerminator.CR)) {\n\t\t\t\t\t\treadBytes += read + 1;\n\t\t\t\t\t\treturn read;\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[off + read++] = '\\r';\n\t\t\t\t\tremaining--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (noMoreCharacters()) {\n\t\t\t\treadBytes += read;\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "int", "readLine", "(", "final", "byte", "[", "]", "array", ",", "final", "int", "off", ",", "final", "int", "len", ",", "final", "EnumSet", "<", "LineTerminator", ">", "terminators", ")", "throws", "IOException", "{", "ByteArrays", ".", "ensureOffsetLength", "(", "array", ",", "off", ",", "len", ")", ";", "if", "(", "len", "==", "0", ")", "return", "0", ";", "// 0-length reads always return 0", "if", "(", "noMoreCharacters", "(", ")", ")", "return", "-", "1", ";", "int", "i", ",", "k", "=", "0", ",", "remaining", "=", "len", ",", "read", "=", "0", ";", "// The number of bytes still to be read", "for", "(", ";", ";", ")", "{", "for", "(", "i", "=", "0", ";", "i", "<", "avail", "&&", "i", "<", "remaining", "&&", "(", "k", "=", "buffer", "[", "pos", "+", "i", "]", ")", "!=", "'", "'", "&&", "k", "!=", "'", "'", ";", "i", "++", ")", ";", "System", ".", "arraycopy", "(", "buffer", ",", "pos", ",", "array", ",", "off", "+", "read", ",", "i", ")", ";", "pos", "+=", "i", ";", "avail", "-=", "i", ";", "read", "+=", "i", ";", "remaining", "-=", "i", ";", "if", "(", "remaining", "==", "0", ")", "{", "readBytes", "+=", "read", ";", "return", "read", ";", "// We did not stop because of a terminator", "}", "if", "(", "avail", ">", "0", ")", "{", "// We met a terminator", "if", "(", "k", "==", "'", "'", ")", "{", "// LF first", "pos", "++", ";", "avail", "--", ";", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "LF", ")", ")", "{", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "else", "{", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "}", "}", "else", "if", "(", "k", "==", "'", "'", ")", "{", "// CR first", "pos", "++", ";", "avail", "--", ";", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR_LF", ")", ")", "{", "if", "(", "avail", ">", "0", ")", "{", "if", "(", "buffer", "[", "pos", "]", "==", "'", "'", ")", "{", "// CR/LF with LF already in the buffer.", "pos", "++", ";", "avail", "--", ";", "readBytes", "+=", "read", "+", "2", ";", "return", "read", ";", "}", "}", "else", "{", "// We must search for the LF.", "if", "(", "noMoreCharacters", "(", ")", ")", "{", "// Not found a matching LF because of end of file, will return CR in buffer if not a terminator", "if", "(", "!", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR", ")", ")", "{", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "readBytes", "+=", "read", ";", "}", "else", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "if", "(", "buffer", "[", "0", "]", "==", "'", "'", ")", "{", "// Found matching LF, won't return terminators in the buffer", "pos", "++", ";", "avail", "--", ";", "readBytes", "+=", "read", "+", "2", ";", "return", "read", ";", "}", "}", "}", "if", "(", "terminators", ".", "contains", "(", "LineTerminator", ".", "CR", ")", ")", "{", "readBytes", "+=", "read", "+", "1", ";", "return", "read", ";", "}", "array", "[", "off", "+", "read", "++", "]", "=", "'", "'", ";", "remaining", "--", ";", "}", "}", "else", "if", "(", "noMoreCharacters", "(", ")", ")", "{", "readBytes", "+=", "read", ";", "return", "read", ";", "}", "}", "}"], "docstring": "Reads a line into the given byte-array fragment.\n\n<p>Reading lines (i.e., characters) out of a byte stream is not always sensible\n(methods available to that purpose in old versions of Java have been mercilessly deprecated).\nNonetheless, in several situations, such as when decoding network protocols or headers\nknown to be ASCII, it is very useful to be able to read a line from a byte stream.\n\n<p>This method will attempt to read the next line into {@code array} starting at {@code off},\nreading at most {@code len} bytes. The read, however, will be stopped by the end of file or\nwhen meeting a {@linkplain LineTerminator <em>line terminator</em>}. Of course, for this operation\nto be sensible the encoding of the text contained in the stream, if any, must not generate spurious\ncarriage returns or line feeds. Note that the termination detection uses a maximisation\ncriterion, so if you specify both {@link LineTerminator#CR} and\n{@link LineTerminator#CR_LF} meeting a pair CR/LF will consider the whole pair a terminator.\n\n<p>Terminators are <em>not</em> copied into <em>array</em> or included in the returned count. The\nreturned integer can be used to check whether the line is complete: if it is smaller than\n{@code len}, then more bytes might be available, but note that this method (contrarily\nto {@link #read(byte[], int, int)}) can legitimately return zero when {@code len}\nis nonzero just because a terminator was found as the first character. Thus, the intended\nusage of this method is to call it on a given array, check whether {@code len} bytes\nhave been read, and if so try again (possibly extending the array) until a number of read bytes\nstrictly smaller than {@code len} (possibly, -1) is returned.\n\n<p>If you need to guarantee that a full line is read, use the following idiom:\n<pre>\nint start = off, len;\nwhile((len = fbis.readLine(array, start, array.length - start, terminators)) == array.length - start) {\nstart += len;\narray = ByteArrays.grow(array, array.length + 1);\n}\n</pre>\n\n<p>At the end of the loop, the line will be placed in {@code array} starting at\n{@code off} (inclusive) and ending at {@code start + Math.max(len, 0)} (exclusive).\n\n@param array byte array where the next line will be stored.\n@param off the first byte to use in {@code array}.\n@param len the maximum number of bytes to read.\n@param terminators a set containing the line termination sequences that we want\nto consider as valid.\n@return the number of bytes actually placed in {@code array}, or -1 at end of file.\nNote that the returned number will be {@code len} if no line termination sequence\nspecified in {@code terminators} has been met before scanning {@code len} byte,\nand if also we did not meet the end of file.", "docstring_tokens": ["Reads", "a", "line", "into", "the", "given", "byte", "-", "array", "fragment", "."]}
{"code": "if (config.isUseHollowPrimitiveTypes() && HollowCodeGenerationUtils.isPrimitiveType(type)) continue;", "comments": "skip if using hollow primitive type", "lines": 4, "repo": "Netflix/hollow", "path": "hollow/src/main/java/com/netflix/hollow/api/codegen/HollowAPIGenerator.java", "func_name": "HollowAPIGenerator.generateFilesForHollowSchemas", "original_string": "protected void generateFilesForHollowSchemas(File directory) throws IOException {\n        for(HollowSchema schema : dataset.getSchemas()) {\n            String type = schema.getName();\n            if (config.isUseHollowPrimitiveTypes() && HollowCodeGenerationUtils.isPrimitiveType(type)) continue; // skip if using hollow primitive type\n\n            generateFile(directory, getStaticAPIGenerator(schema));\n            generateFile(directory, getHollowObjectGenerator(schema));\n            generateFile(directory, getHollowFactoryGenerator(schema));\n\n            if(schema.getSchemaType() == SchemaType.OBJECT) {\n                HollowObjectSchema objSchema = (HollowObjectSchema)schema;\n                generateFile(directory, new HollowObjectDelegateInterfaceGenerator(packageName, objSchema,\n                        ergonomicShortcuts, dataset, config));\n                generateFile(directory, new HollowObjectDelegateCachedImplGenerator(packageName, objSchema,\n                        ergonomicShortcuts, dataset, config));\n                generateFile(directory, new HollowObjectDelegateLookupImplGenerator(packageName, objSchema,\n                        ergonomicShortcuts, dataset, config));\n\n                generateFile(directory, new HollowDataAccessorGenerator(packageName, apiClassname, objSchema,\n                        dataset, config));\n                if (!config.isReservePrimaryKeyIndexForTypeWithPrimaryKey()) {\n                    generateFile(directory, new LegacyHollowPrimaryKeyIndexGenerator(packageName, apiClassname,\n                            objSchema, dataset, config));\n                } else if ((objSchema).getPrimaryKey() != null) {\n                    generateFile(directory, new HollowPrimaryKeyIndexGenerator(dataset, packageName, apiClassname,\n                            objSchema, config));\n                    generateFile(directory, new HollowUniqueKeyIndexGenerator(packageName, apiClassname, objSchema,\n                            dataset, config));\n                }\n            }\n        }\n    }", "language": "java", "Allcodes": "protected void generateFilesForHollowSchemas(File directory) throws IOException {\n        for(HollowSchema schema : dataset.getSchemas()) {\n            String type = schema.getName();\n            if (config.isUseHollowPrimitiveTypes() && HollowCodeGenerationUtils.isPrimitiveType(type)) continue; // skip if using hollow primitive type\n\n            generateFile(directory, getStaticAPIGenerator(schema));\n            generateFile(directory, getHollowObjectGenerator(schema));\n            generateFile(directory, getHollowFactoryGenerator(schema));\n\n            if(schema.getSchemaType() == SchemaType.OBJECT) {\n                HollowObjectSchema objSchema = (HollowObjectSchema)schema;\n                generateFile(directory, new HollowObjectDelegateInterfaceGenerator(packageName, objSchema,\n                        ergonomicShortcuts, dataset, config));\n                generateFile(directory, new HollowObjectDelegateCachedImplGenerator(packageName, objSchema,\n                        ergonomicShortcuts, dataset, config));\n                generateFile(directory, new HollowObjectDelegateLookupImplGenerator(packageName, objSchema,\n                        ergonomicShortcuts, dataset, config));\n\n                generateFile(directory, new HollowDataAccessorGenerator(packageName, apiClassname, objSchema,\n                        dataset, config));\n                if (!config.isReservePrimaryKeyIndexForTypeWithPrimaryKey()) {\n                    generateFile(directory, new LegacyHollowPrimaryKeyIndexGenerator(packageName, apiClassname,\n                            objSchema, dataset, config));\n                } else if ((objSchema).getPrimaryKey() != null) {\n                    generateFile(directory, new HollowPrimaryKeyIndexGenerator(dataset, packageName, apiClassname,\n                            objSchema, config));\n                    generateFile(directory, new HollowUniqueKeyIndexGenerator(packageName, apiClassname, objSchema,\n                            dataset, config));\n                }\n            }\n        }\n    }", "code_tokens": ["protected", "void", "generateFilesForHollowSchemas", "(", "File", "directory", ")", "throws", "IOException", "{", "for", "(", "HollowSchema", "schema", ":", "dataset", ".", "getSchemas", "(", ")", ")", "{", "String", "type", "=", "schema", ".", "getName", "(", ")", ";", "if", "(", "config", ".", "isUseHollowPrimitiveTypes", "(", ")", "&&", "HollowCodeGenerationUtils", ".", "isPrimitiveType", "(", "type", ")", ")", "continue", ";", "// skip if using hollow primitive type", "generateFile", "(", "directory", ",", "getStaticAPIGenerator", "(", "schema", ")", ")", ";", "generateFile", "(", "directory", ",", "getHollowObjectGenerator", "(", "schema", ")", ")", ";", "generateFile", "(", "directory", ",", "getHollowFactoryGenerator", "(", "schema", ")", ")", ";", "if", "(", "schema", ".", "getSchemaType", "(", ")", "==", "SchemaType", ".", "OBJECT", ")", "{", "HollowObjectSchema", "objSchema", "=", "(", "HollowObjectSchema", ")", "schema", ";", "generateFile", "(", "directory", ",", "new", "HollowObjectDelegateInterfaceGenerator", "(", "packageName", ",", "objSchema", ",", "ergonomicShortcuts", ",", "dataset", ",", "config", ")", ")", ";", "generateFile", "(", "directory", ",", "new", "HollowObjectDelegateCachedImplGenerator", "(", "packageName", ",", "objSchema", ",", "ergonomicShortcuts", ",", "dataset", ",", "config", ")", ")", ";", "generateFile", "(", "directory", ",", "new", "HollowObjectDelegateLookupImplGenerator", "(", "packageName", ",", "objSchema", ",", "ergonomicShortcuts", ",", "dataset", ",", "config", ")", ")", ";", "generateFile", "(", "directory", ",", "new", "HollowDataAccessorGenerator", "(", "packageName", ",", "apiClassname", ",", "objSchema", ",", "dataset", ",", "config", ")", ")", ";", "if", "(", "!", "config", ".", "isReservePrimaryKeyIndexForTypeWithPrimaryKey", "(", ")", ")", "{", "generateFile", "(", "directory", ",", "new", "LegacyHollowPrimaryKeyIndexGenerator", "(", "packageName", ",", "apiClassname", ",", "objSchema", ",", "dataset", ",", "config", ")", ")", ";", "}", "else", "if", "(", "(", "objSchema", ")", ".", "getPrimaryKey", "(", ")", "!=", "null", ")", "{", "generateFile", "(", "directory", ",", "new", "HollowPrimaryKeyIndexGenerator", "(", "dataset", ",", "packageName", ",", "apiClassname", ",", "objSchema", ",", "config", ")", ")", ";", "generateFile", "(", "directory", ",", "new", "HollowUniqueKeyIndexGenerator", "(", "packageName", ",", "apiClassname", ",", "objSchema", ",", "dataset", ",", "config", ")", ")", ";", "}", "}", "}", "}"], "docstring": "Generate files based on dataset schemas under the specified directory\n\n@param directory the directory under which to generate files\n@throws IOException if the files cannot be generated\n@deprecated construct {@code HollowAPIGenerator} with a {@code destinationPath} then call {@link #generateSourceFilesForHollowSchemas()}", "docstring_tokens": ["Generate", "files", "based", "on", "dataset", "schemas", "under", "the", "specified", "directory"]}
{"code": "VarInt.writeVInt(dos, schemasData.length + 1);", "comments": "plus one byte for new backwards compatibility envelope.", "lines": 18, "repo": "Netflix/hollow", "path": "hollow/src/main/java/com/netflix/hollow/core/write/HollowBlobHeaderWriter.java", "func_name": "HollowBlobHeaderWriter.writeHeader", "original_string": "public void writeHeader(HollowBlobHeader header, DataOutputStream dos) throws IOException {\n        /// save 4 bytes to indicate FastBlob version header.  This will be changed to indicate backwards incompatibility.\n        dos.writeInt(HollowBlobHeader.HOLLOW_BLOB_VERSION_HEADER);\n\n        /// Write randomized tag data -- every state gets a random 64-bit tag.\n        /// When attempting to apply a delta, the originating state's random 64-bit tag is compared against the current 64-bit tag.\n        /// This prevents deltas from being applied to incorrect states.\n        dos.writeLong(header.getOriginRandomizedTag());\n        dos.writeLong(header.getDestinationRandomizedTag());\n\n        /// write the schemas contained in this blob to the stream in the pre v2.2.0 backwards compatibility envelope\n        ByteArrayOutputStream schemasStream = new ByteArrayOutputStream();\n        VarInt.writeVInt(schemasStream, header.getSchemas().size());\n        for(HollowSchema schema : header.getSchemas())\n            schema.writeTo(schemasStream);\n        byte[] schemasData = schemasStream.toByteArray();\n        \n        VarInt.writeVInt(dos, schemasData.length + 1); // plus one byte for new backwards compatibility envelope.\n        dos.write(schemasData);\n        \n        ///backwards compatibility -- new data can be added here by first indicating number of bytes used, will be skipped by existing readers.\n        VarInt.writeVInt(dos, 0);\n\n        /// write the header tags -- intended to include input source data versions\n        dos.writeShort(header.getHeaderTags().size());\n\n        for (Map.Entry<String, String> headerTag : header.getHeaderTags().entrySet()) {\n            dos.writeUTF(headerTag.getKey());\n            dos.writeUTF(headerTag.getValue());\n        }\n    }", "language": "java", "Allcodes": "public void writeHeader(HollowBlobHeader header, DataOutputStream dos) throws IOException {\n        /// save 4 bytes to indicate FastBlob version header.  This will be changed to indicate backwards incompatibility.\n        dos.writeInt(HollowBlobHeader.HOLLOW_BLOB_VERSION_HEADER);\n\n        /// Write randomized tag data -- every state gets a random 64-bit tag.\n        /// When attempting to apply a delta, the originating state's random 64-bit tag is compared against the current 64-bit tag.\n        /// This prevents deltas from being applied to incorrect states.\n        dos.writeLong(header.getOriginRandomizedTag());\n        dos.writeLong(header.getDestinationRandomizedTag());\n\n        /// write the schemas contained in this blob to the stream in the pre v2.2.0 backwards compatibility envelope\n        ByteArrayOutputStream schemasStream = new ByteArrayOutputStream();\n        VarInt.writeVInt(schemasStream, header.getSchemas().size());\n        for(HollowSchema schema : header.getSchemas())\n            schema.writeTo(schemasStream);\n        byte[] schemasData = schemasStream.toByteArray();\n        \n        VarInt.writeVInt(dos, schemasData.length + 1); // plus one byte for new backwards compatibility envelope.\n        dos.write(schemasData);\n        \n        ///backwards compatibility -- new data can be added here by first indicating number of bytes used, will be skipped by existing readers.\n        VarInt.writeVInt(dos, 0);\n\n        /// write the header tags -- intended to include input source data versions\n        dos.writeShort(header.getHeaderTags().size());\n\n        for (Map.Entry<String, String> headerTag : header.getHeaderTags().entrySet()) {\n            dos.writeUTF(headerTag.getKey());\n            dos.writeUTF(headerTag.getValue());\n        }\n    }", "code_tokens": ["public", "void", "writeHeader", "(", "HollowBlobHeader", "header", ",", "DataOutputStream", "dos", ")", "throws", "IOException", "{", "/// save 4 bytes to indicate FastBlob version header.  This will be changed to indicate backwards incompatibility.", "dos", ".", "writeInt", "(", "HollowBlobHeader", ".", "HOLLOW_BLOB_VERSION_HEADER", ")", ";", "/// Write randomized tag data -- every state gets a random 64-bit tag.", "/// When attempting to apply a delta, the originating state's random 64-bit tag is compared against the current 64-bit tag.", "/// This prevents deltas from being applied to incorrect states.", "dos", ".", "writeLong", "(", "header", ".", "getOriginRandomizedTag", "(", ")", ")", ";", "dos", ".", "writeLong", "(", "header", ".", "getDestinationRandomizedTag", "(", ")", ")", ";", "/// write the schemas contained in this blob to the stream in the pre v2.2.0 backwards compatibility envelope", "ByteArrayOutputStream", "schemasStream", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "VarInt", ".", "writeVInt", "(", "schemasStream", ",", "header", ".", "getSchemas", "(", ")", ".", "size", "(", ")", ")", ";", "for", "(", "HollowSchema", "schema", ":", "header", ".", "getSchemas", "(", ")", ")", "schema", ".", "writeTo", "(", "schemasStream", ")", ";", "byte", "[", "]", "schemasData", "=", "schemasStream", ".", "toByteArray", "(", ")", ";", "VarInt", ".", "writeVInt", "(", "dos", ",", "schemasData", ".", "length", "+", "1", ")", ";", "// plus one byte for new backwards compatibility envelope.", "dos", ".", "write", "(", "schemasData", ")", ";", "///backwards compatibility -- new data can be added here by first indicating number of bytes used, will be skipped by existing readers.", "VarInt", ".", "writeVInt", "(", "dos", ",", "0", ")", ";", "/// write the header tags -- intended to include input source data versions", "dos", ".", "writeShort", "(", "header", ".", "getHeaderTags", "(", ")", ".", "size", "(", ")", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "headerTag", ":", "header", ".", "getHeaderTags", "(", ")", ".", "entrySet", "(", ")", ")", "{", "dos", ".", "writeUTF", "(", "headerTag", ".", "getKey", "(", ")", ")", ";", "dos", ".", "writeUTF", "(", "headerTag", ".", "getValue", "(", ")", ")", ";", "}", "}"], "docstring": "Write the header to the data output stream\n@param header the blob header\n@param dos the data output stream to write the blov header\n@throws IOException if the blob header could not be written", "docstring_tokens": ["Write", "the", "header", "to", "the", "data", "output", "stream"]}
{"code": "break;", "comments": "we have exhausted the elements at this index", "lines": 17, "repo": "Netflix/hollow", "path": "hollow/src/main/java/com/netflix/hollow/core/memory/encoding/FixedLengthMultipleOccurrenceElementArray.java", "func_name": "FixedLengthMultipleOccurrenceElementArray.resizeStorage", "original_string": "private void resizeStorage() {\n        int currentElementsPerNode = maxElementsPerNode;\n        int newElementsPerNode = (int) (currentElementsPerNode * RESIZE_MULTIPLE);\n        if (newElementsPerNode <= currentElementsPerNode) {\n            throw new IllegalStateException(\"cannot resize fixed length array from \"\n                    + currentElementsPerNode + \" to \" + newElementsPerNode);\n        }\n        FixedLengthElementArray newStorage = new FixedLengthElementArray(memoryRecycler,\n                numNodes * bitsPerElement * newElementsPerNode);\n        LongStream.range(0, numNodes).forEach(nodeIndex -> {\n            long currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement;\n            long newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement;\n            for (int offset = 0; offset < currentElementsPerNode; offset++) {\n                long element = storage.getElementValue(currentBucketStart + offset * bitsPerElement,\n                        bitsPerElement, elementMask);\n                if (element == NO_ELEMENT) {\n                    break; // we have exhausted the elements at this index\n                }\n                newStorage.setElementValue(\n                        newBucketStart + offset * bitsPerElement, bitsPerElement, element);\n            }\n        });\n        storage.destroy(memoryRecycler);\n        storage = newStorage;\n        maxElementsPerNode = newElementsPerNode;\n    }", "language": "java", "Allcodes": "private void resizeStorage() {\n        int currentElementsPerNode = maxElementsPerNode;\n        int newElementsPerNode = (int) (currentElementsPerNode * RESIZE_MULTIPLE);\n        if (newElementsPerNode <= currentElementsPerNode) {\n            throw new IllegalStateException(\"cannot resize fixed length array from \"\n                    + currentElementsPerNode + \" to \" + newElementsPerNode);\n        }\n        FixedLengthElementArray newStorage = new FixedLengthElementArray(memoryRecycler,\n                numNodes * bitsPerElement * newElementsPerNode);\n        LongStream.range(0, numNodes).forEach(nodeIndex -> {\n            long currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement;\n            long newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement;\n            for (int offset = 0; offset < currentElementsPerNode; offset++) {\n                long element = storage.getElementValue(currentBucketStart + offset * bitsPerElement,\n                        bitsPerElement, elementMask);\n                if (element == NO_ELEMENT) {\n                    break; // we have exhausted the elements at this index\n                }\n                newStorage.setElementValue(\n                        newBucketStart + offset * bitsPerElement, bitsPerElement, element);\n            }\n        });\n        storage.destroy(memoryRecycler);\n        storage = newStorage;\n        maxElementsPerNode = newElementsPerNode;\n    }", "code_tokens": ["private", "void", "resizeStorage", "(", ")", "{", "int", "currentElementsPerNode", "=", "maxElementsPerNode", ";", "int", "newElementsPerNode", "=", "(", "int", ")", "(", "currentElementsPerNode", "*", "RESIZE_MULTIPLE", ")", ";", "if", "(", "newElementsPerNode", "<=", "currentElementsPerNode", ")", "{", "throw", "new", "IllegalStateException", "(", "\"cannot resize fixed length array from \"", "+", "currentElementsPerNode", "+", "\" to \"", "+", "newElementsPerNode", ")", ";", "}", "FixedLengthElementArray", "newStorage", "=", "new", "FixedLengthElementArray", "(", "memoryRecycler", ",", "numNodes", "*", "bitsPerElement", "*", "newElementsPerNode", ")", ";", "LongStream", ".", "range", "(", "0", ",", "numNodes", ")", ".", "forEach", "(", "nodeIndex", "->", "{", "long", "currentBucketStart", "=", "nodeIndex", "*", "currentElementsPerNode", "*", "bitsPerElement", ";", "long", "newBucketStart", "=", "nodeIndex", "*", "newElementsPerNode", "*", "bitsPerElement", ";", "for", "(", "int", "offset", "=", "0", ";", "offset", "<", "currentElementsPerNode", ";", "offset", "++", ")", "{", "long", "element", "=", "storage", ".", "getElementValue", "(", "currentBucketStart", "+", "offset", "*", "bitsPerElement", ",", "bitsPerElement", ",", "elementMask", ")", ";", "if", "(", "element", "==", "NO_ELEMENT", ")", "{", "break", ";", "// we have exhausted the elements at this index", "}", "newStorage", ".", "setElementValue", "(", "newBucketStart", "+", "offset", "*", "bitsPerElement", ",", "bitsPerElement", ",", "element", ")", ";", "}", "}", ")", ";", "storage", ".", "destroy", "(", "memoryRecycler", ")", ";", "storage", "=", "newStorage", ";", "maxElementsPerNode", "=", "newElementsPerNode", ";", "}"], "docstring": "Resize the underlying storage to a multiple of what it currently is. This method is not\nthread-safe.", "docstring_tokens": ["Resize", "the", "underlying", "storage", "to", "a", "multiple", "of", "what", "it", "currently", "is", ".", "This", "method", "is", "not", "thread", "-", "safe", "."]}
{"code": "if(config.frameLengthFlag) throw new AACException(\"config uses 960-sample frames, not yet supported\");", "comments": "TODO: are 960-frames working yet?", "lines": 27, "repo": "jcodec/jcodec", "path": "src/main/java/net/sourceforge/jaad/aac/AACDecoderConfig.java", "func_name": "AACDecoderConfig.parseMP4DecoderSpecificInfo", "original_string": "public static AACDecoderConfig parseMP4DecoderSpecificInfo(byte[] data) throws AACException {\n\t\tfinal IBitStream _in = BitStream.createBitStream(data);\n\t\tfinal AACDecoderConfig config = new AACDecoderConfig();\n\n\t\ttry {\n\t\t\tconfig.profile = readProfile(_in);\n\n\t\t\tint sf = _in.readBits(4);\n\t\t\tif(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n\t\t\telse config.sampleFrequency = SampleFrequency.forInt(sf);\n\t\t\tconfig.channelConfiguration = ChannelConfiguration.forInt(_in.readBits(4));\n\n\t\t\tProfile cp = config.profile;\n\t\t\tif (AAC_SBR == cp) {\n                config.extProfile = cp;\n                config.sbrPresent = true;\n                sf = _in.readBits(4);\n                //TODO: 24 bits already read; read again?\n                //if(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n                //if sample frequencies are the same: downsample SBR\n                config.downSampledSBR = config.sampleFrequency.getIndex()==sf;\n                config.sampleFrequency = SampleFrequency.forInt(sf);\n                config.profile = readProfile(_in);\n\t\t\t} else if (AAC_MAIN == cp || AAC_LC ==  cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) {\n                //ga-specific info:\n                config.frameLengthFlag = _in.readBool();\n                if(config.frameLengthFlag) throw new AACException(\"config uses 960-sample frames, not yet supported\"); //TODO: are 960-frames working yet?\n                config.dependsOnCoreCoder = _in.readBool();\n                if(config.dependsOnCoreCoder) config.coreCoderDelay = _in.readBits(14);\n                else config.coreCoderDelay = 0;\n                config.extensionFlag = _in.readBool();\n\n                if(config.extensionFlag) {\n                    if(cp.isErrorResilientProfile()) {\n                        config.sectionDataResilience = _in.readBool();\n                        config.scalefactorResilience = _in.readBool();\n                        config.spectralDataResilience = _in.readBool();\n                    }\n                    //extensionFlag3\n                    _in.skipBit();\n                }\n\n                if(config.channelConfiguration==ChannelConfiguration.CHANNEL_CONFIG_NONE) {\n                    //TODO: is this working correct? -> ISO 14496-3 part 1: 1.A.4.3\n                    _in.skipBits(3); //PCE\n                    PCE pce = new PCE();\n                    pce.decode(_in);\n                    config.profile = pce.getProfile();\n                    config.sampleFrequency = pce.getSampleFrequency();\n                    config.channelConfiguration = ChannelConfiguration.forInt(pce.getChannelCount());\n                }\n\n                if(_in.getBitsLeft()>10) readSyncExtension(_in, config);\n\t\t\t} else {\n                throw new AACException(\"profile not supported: \"+cp.getIndex());\n\t\t\t}\n\t\t\treturn config;\n\t\t}\n\t\tfinally {\n\t\t\t_in.destroy();\n\t\t}\n\t}", "language": "java", "Allcodes": "public static AACDecoderConfig parseMP4DecoderSpecificInfo(byte[] data) throws AACException {\n\t\tfinal IBitStream _in = BitStream.createBitStream(data);\n\t\tfinal AACDecoderConfig config = new AACDecoderConfig();\n\n\t\ttry {\n\t\t\tconfig.profile = readProfile(_in);\n\n\t\t\tint sf = _in.readBits(4);\n\t\t\tif(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n\t\t\telse config.sampleFrequency = SampleFrequency.forInt(sf);\n\t\t\tconfig.channelConfiguration = ChannelConfiguration.forInt(_in.readBits(4));\n\n\t\t\tProfile cp = config.profile;\n\t\t\tif (AAC_SBR == cp) {\n                config.extProfile = cp;\n                config.sbrPresent = true;\n                sf = _in.readBits(4);\n                //TODO: 24 bits already read; read again?\n                //if(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n                //if sample frequencies are the same: downsample SBR\n                config.downSampledSBR = config.sampleFrequency.getIndex()==sf;\n                config.sampleFrequency = SampleFrequency.forInt(sf);\n                config.profile = readProfile(_in);\n\t\t\t} else if (AAC_MAIN == cp || AAC_LC ==  cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) {\n                //ga-specific info:\n                config.frameLengthFlag = _in.readBool();\n                if(config.frameLengthFlag) throw new AACException(\"config uses 960-sample frames, not yet supported\"); //TODO: are 960-frames working yet?\n                config.dependsOnCoreCoder = _in.readBool();\n                if(config.dependsOnCoreCoder) config.coreCoderDelay = _in.readBits(14);\n                else config.coreCoderDelay = 0;\n                config.extensionFlag = _in.readBool();\n\n                if(config.extensionFlag) {\n                    if(cp.isErrorResilientProfile()) {\n                        config.sectionDataResilience = _in.readBool();\n                        config.scalefactorResilience = _in.readBool();\n                        config.spectralDataResilience = _in.readBool();\n                    }\n                    //extensionFlag3\n                    _in.skipBit();\n                }\n\n                if(config.channelConfiguration==ChannelConfiguration.CHANNEL_CONFIG_NONE) {\n                    //TODO: is this working correct? -> ISO 14496-3 part 1: 1.A.4.3\n                    _in.skipBits(3); //PCE\n                    PCE pce = new PCE();\n                    pce.decode(_in);\n                    config.profile = pce.getProfile();\n                    config.sampleFrequency = pce.getSampleFrequency();\n                    config.channelConfiguration = ChannelConfiguration.forInt(pce.getChannelCount());\n                }\n\n                if(_in.getBitsLeft()>10) readSyncExtension(_in, config);\n\t\t\t} else {\n                throw new AACException(\"profile not supported: \"+cp.getIndex());\n\t\t\t}\n\t\t\treturn config;\n\t\t}\n\t\tfinally {\n\t\t\t_in.destroy();\n\t\t}\n\t}", "code_tokens": ["public", "static", "AACDecoderConfig", "parseMP4DecoderSpecificInfo", "(", "byte", "[", "]", "data", ")", "throws", "AACException", "{", "final", "IBitStream", "_in", "=", "BitStream", ".", "createBitStream", "(", "data", ")", ";", "final", "AACDecoderConfig", "config", "=", "new", "AACDecoderConfig", "(", ")", ";", "try", "{", "config", ".", "profile", "=", "readProfile", "(", "_in", ")", ";", "int", "sf", "=", "_in", ".", "readBits", "(", "4", ")", ";", "if", "(", "sf", "==", "0xF", ")", "config", ".", "sampleFrequency", "=", "SampleFrequency", ".", "forFrequency", "(", "_in", ".", "readBits", "(", "24", ")", ")", ";", "else", "config", ".", "sampleFrequency", "=", "SampleFrequency", ".", "forInt", "(", "sf", ")", ";", "config", ".", "channelConfiguration", "=", "ChannelConfiguration", ".", "forInt", "(", "_in", ".", "readBits", "(", "4", ")", ")", ";", "Profile", "cp", "=", "config", ".", "profile", ";", "if", "(", "AAC_SBR", "==", "cp", ")", "{", "config", ".", "extProfile", "=", "cp", ";", "config", ".", "sbrPresent", "=", "true", ";", "sf", "=", "_in", ".", "readBits", "(", "4", ")", ";", "//TODO: 24 bits already read; read again?", "//if(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));", "//if sample frequencies are the same: downsample SBR", "config", ".", "downSampledSBR", "=", "config", ".", "sampleFrequency", ".", "getIndex", "(", ")", "==", "sf", ";", "config", ".", "sampleFrequency", "=", "SampleFrequency", ".", "forInt", "(", "sf", ")", ";", "config", ".", "profile", "=", "readProfile", "(", "_in", ")", ";", "}", "else", "if", "(", "AAC_MAIN", "==", "cp", "||", "AAC_LC", "==", "cp", "||", "AAC_SSR", "==", "cp", "||", "AAC_LTP", "==", "cp", "||", "ER_AAC_LC", "==", "cp", "||", "ER_AAC_LTP", "==", "cp", "||", "ER_AAC_LD", "==", "cp", ")", "{", "//ga-specific info:", "config", ".", "frameLengthFlag", "=", "_in", ".", "readBool", "(", ")", ";", "if", "(", "config", ".", "frameLengthFlag", ")", "throw", "new", "AACException", "(", "\"config uses 960-sample frames, not yet supported\"", ")", ";", "//TODO: are 960-frames working yet?", "config", ".", "dependsOnCoreCoder", "=", "_in", ".", "readBool", "(", ")", ";", "if", "(", "config", ".", "dependsOnCoreCoder", ")", "config", ".", "coreCoderDelay", "=", "_in", ".", "readBits", "(", "14", ")", ";", "else", "config", ".", "coreCoderDelay", "=", "0", ";", "config", ".", "extensionFlag", "=", "_in", ".", "readBool", "(", ")", ";", "if", "(", "config", ".", "extensionFlag", ")", "{", "if", "(", "cp", ".", "isErrorResilientProfile", "(", ")", ")", "{", "config", ".", "sectionDataResilience", "=", "_in", ".", "readBool", "(", ")", ";", "config", ".", "scalefactorResilience", "=", "_in", ".", "readBool", "(", ")", ";", "config", ".", "spectralDataResilience", "=", "_in", ".", "readBool", "(", ")", ";", "}", "//extensionFlag3", "_in", ".", "skipBit", "(", ")", ";", "}", "if", "(", "config", ".", "channelConfiguration", "==", "ChannelConfiguration", ".", "CHANNEL_CONFIG_NONE", ")", "{", "//TODO: is this working correct? -> ISO 14496-3 part 1: 1.A.4.3", "_in", ".", "skipBits", "(", "3", ")", ";", "//PCE", "PCE", "pce", "=", "new", "PCE", "(", ")", ";", "pce", ".", "decode", "(", "_in", ")", ";", "config", ".", "profile", "=", "pce", ".", "getProfile", "(", ")", ";", "config", ".", "sampleFrequency", "=", "pce", ".", "getSampleFrequency", "(", ")", ";", "config", ".", "channelConfiguration", "=", "ChannelConfiguration", ".", "forInt", "(", "pce", ".", "getChannelCount", "(", ")", ")", ";", "}", "if", "(", "_in", ".", "getBitsLeft", "(", ")", ">", "10", ")", "readSyncExtension", "(", "_in", ",", "config", ")", ";", "}", "else", "{", "throw", "new", "AACException", "(", "\"profile not supported: \"", "+", "cp", ".", "getIndex", "(", ")", ")", ";", "}", "return", "config", ";", "}", "finally", "{", "_in", ".", "destroy", "(", ")", ";", "}", "}"], "docstring": "Parses the input arrays as a DecoderSpecificInfo, as used in MP4\ncontainers.\n\n@return a AACDecoderConfig", "docstring_tokens": ["Parses", "the", "input", "arrays", "as", "a", "DecoderSpecificInfo", "as", "used", "in", "MP4", "containers", "."]}
{"code": "_in.skipBits(3);", "comments": "PCE", "lines": 45, "repo": "jcodec/jcodec", "path": "src/main/java/net/sourceforge/jaad/aac/AACDecoderConfig.java", "func_name": "AACDecoderConfig.parseMP4DecoderSpecificInfo", "original_string": "public static AACDecoderConfig parseMP4DecoderSpecificInfo(byte[] data) throws AACException {\n\t\tfinal IBitStream _in = BitStream.createBitStream(data);\n\t\tfinal AACDecoderConfig config = new AACDecoderConfig();\n\n\t\ttry {\n\t\t\tconfig.profile = readProfile(_in);\n\n\t\t\tint sf = _in.readBits(4);\n\t\t\tif(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n\t\t\telse config.sampleFrequency = SampleFrequency.forInt(sf);\n\t\t\tconfig.channelConfiguration = ChannelConfiguration.forInt(_in.readBits(4));\n\n\t\t\tProfile cp = config.profile;\n\t\t\tif (AAC_SBR == cp) {\n                config.extProfile = cp;\n                config.sbrPresent = true;\n                sf = _in.readBits(4);\n                //TODO: 24 bits already read; read again?\n                //if(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n                //if sample frequencies are the same: downsample SBR\n                config.downSampledSBR = config.sampleFrequency.getIndex()==sf;\n                config.sampleFrequency = SampleFrequency.forInt(sf);\n                config.profile = readProfile(_in);\n\t\t\t} else if (AAC_MAIN == cp || AAC_LC ==  cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) {\n                //ga-specific info:\n                config.frameLengthFlag = _in.readBool();\n                if(config.frameLengthFlag) throw new AACException(\"config uses 960-sample frames, not yet supported\"); //TODO: are 960-frames working yet?\n                config.dependsOnCoreCoder = _in.readBool();\n                if(config.dependsOnCoreCoder) config.coreCoderDelay = _in.readBits(14);\n                else config.coreCoderDelay = 0;\n                config.extensionFlag = _in.readBool();\n\n                if(config.extensionFlag) {\n                    if(cp.isErrorResilientProfile()) {\n                        config.sectionDataResilience = _in.readBool();\n                        config.scalefactorResilience = _in.readBool();\n                        config.spectralDataResilience = _in.readBool();\n                    }\n                    //extensionFlag3\n                    _in.skipBit();\n                }\n\n                if(config.channelConfiguration==ChannelConfiguration.CHANNEL_CONFIG_NONE) {\n                    //TODO: is this working correct? -> ISO 14496-3 part 1: 1.A.4.3\n                    _in.skipBits(3); //PCE\n                    PCE pce = new PCE();\n                    pce.decode(_in);\n                    config.profile = pce.getProfile();\n                    config.sampleFrequency = pce.getSampleFrequency();\n                    config.channelConfiguration = ChannelConfiguration.forInt(pce.getChannelCount());\n                }\n\n                if(_in.getBitsLeft()>10) readSyncExtension(_in, config);\n\t\t\t} else {\n                throw new AACException(\"profile not supported: \"+cp.getIndex());\n\t\t\t}\n\t\t\treturn config;\n\t\t}\n\t\tfinally {\n\t\t\t_in.destroy();\n\t\t}\n\t}", "language": "java", "Allcodes": "public static AACDecoderConfig parseMP4DecoderSpecificInfo(byte[] data) throws AACException {\n\t\tfinal IBitStream _in = BitStream.createBitStream(data);\n\t\tfinal AACDecoderConfig config = new AACDecoderConfig();\n\n\t\ttry {\n\t\t\tconfig.profile = readProfile(_in);\n\n\t\t\tint sf = _in.readBits(4);\n\t\t\tif(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n\t\t\telse config.sampleFrequency = SampleFrequency.forInt(sf);\n\t\t\tconfig.channelConfiguration = ChannelConfiguration.forInt(_in.readBits(4));\n\n\t\t\tProfile cp = config.profile;\n\t\t\tif (AAC_SBR == cp) {\n                config.extProfile = cp;\n                config.sbrPresent = true;\n                sf = _in.readBits(4);\n                //TODO: 24 bits already read; read again?\n                //if(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));\n                //if sample frequencies are the same: downsample SBR\n                config.downSampledSBR = config.sampleFrequency.getIndex()==sf;\n                config.sampleFrequency = SampleFrequency.forInt(sf);\n                config.profile = readProfile(_in);\n\t\t\t} else if (AAC_MAIN == cp || AAC_LC ==  cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) {\n                //ga-specific info:\n                config.frameLengthFlag = _in.readBool();\n                if(config.frameLengthFlag) throw new AACException(\"config uses 960-sample frames, not yet supported\"); //TODO: are 960-frames working yet?\n                config.dependsOnCoreCoder = _in.readBool();\n                if(config.dependsOnCoreCoder) config.coreCoderDelay = _in.readBits(14);\n                else config.coreCoderDelay = 0;\n                config.extensionFlag = _in.readBool();\n\n                if(config.extensionFlag) {\n                    if(cp.isErrorResilientProfile()) {\n                        config.sectionDataResilience = _in.readBool();\n                        config.scalefactorResilience = _in.readBool();\n                        config.spectralDataResilience = _in.readBool();\n                    }\n                    //extensionFlag3\n                    _in.skipBit();\n                }\n\n                if(config.channelConfiguration==ChannelConfiguration.CHANNEL_CONFIG_NONE) {\n                    //TODO: is this working correct? -> ISO 14496-3 part 1: 1.A.4.3\n                    _in.skipBits(3); //PCE\n                    PCE pce = new PCE();\n                    pce.decode(_in);\n                    config.profile = pce.getProfile();\n                    config.sampleFrequency = pce.getSampleFrequency();\n                    config.channelConfiguration = ChannelConfiguration.forInt(pce.getChannelCount());\n                }\n\n                if(_in.getBitsLeft()>10) readSyncExtension(_in, config);\n\t\t\t} else {\n                throw new AACException(\"profile not supported: \"+cp.getIndex());\n\t\t\t}\n\t\t\treturn config;\n\t\t}\n\t\tfinally {\n\t\t\t_in.destroy();\n\t\t}\n\t}", "code_tokens": ["public", "static", "AACDecoderConfig", "parseMP4DecoderSpecificInfo", "(", "byte", "[", "]", "data", ")", "throws", "AACException", "{", "final", "IBitStream", "_in", "=", "BitStream", ".", "createBitStream", "(", "data", ")", ";", "final", "AACDecoderConfig", "config", "=", "new", "AACDecoderConfig", "(", ")", ";", "try", "{", "config", ".", "profile", "=", "readProfile", "(", "_in", ")", ";", "int", "sf", "=", "_in", ".", "readBits", "(", "4", ")", ";", "if", "(", "sf", "==", "0xF", ")", "config", ".", "sampleFrequency", "=", "SampleFrequency", ".", "forFrequency", "(", "_in", ".", "readBits", "(", "24", ")", ")", ";", "else", "config", ".", "sampleFrequency", "=", "SampleFrequency", ".", "forInt", "(", "sf", ")", ";", "config", ".", "channelConfiguration", "=", "ChannelConfiguration", ".", "forInt", "(", "_in", ".", "readBits", "(", "4", ")", ")", ";", "Profile", "cp", "=", "config", ".", "profile", ";", "if", "(", "AAC_SBR", "==", "cp", ")", "{", "config", ".", "extProfile", "=", "cp", ";", "config", ".", "sbrPresent", "=", "true", ";", "sf", "=", "_in", ".", "readBits", "(", "4", ")", ";", "//TODO: 24 bits already read; read again?", "//if(sf==0xF) config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));", "//if sample frequencies are the same: downsample SBR", "config", ".", "downSampledSBR", "=", "config", ".", "sampleFrequency", ".", "getIndex", "(", ")", "==", "sf", ";", "config", ".", "sampleFrequency", "=", "SampleFrequency", ".", "forInt", "(", "sf", ")", ";", "config", ".", "profile", "=", "readProfile", "(", "_in", ")", ";", "}", "else", "if", "(", "AAC_MAIN", "==", "cp", "||", "AAC_LC", "==", "cp", "||", "AAC_SSR", "==", "cp", "||", "AAC_LTP", "==", "cp", "||", "ER_AAC_LC", "==", "cp", "||", "ER_AAC_LTP", "==", "cp", "||", "ER_AAC_LD", "==", "cp", ")", "{", "//ga-specific info:", "config", ".", "frameLengthFlag", "=", "_in", ".", "readBool", "(", ")", ";", "if", "(", "config", ".", "frameLengthFlag", ")", "throw", "new", "AACException", "(", "\"config uses 960-sample frames, not yet supported\"", ")", ";", "//TODO: are 960-frames working yet?", "config", ".", "dependsOnCoreCoder", "=", "_in", ".", "readBool", "(", ")", ";", "if", "(", "config", ".", "dependsOnCoreCoder", ")", "config", ".", "coreCoderDelay", "=", "_in", ".", "readBits", "(", "14", ")", ";", "else", "config", ".", "coreCoderDelay", "=", "0", ";", "config", ".", "extensionFlag", "=", "_in", ".", "readBool", "(", ")", ";", "if", "(", "config", ".", "extensionFlag", ")", "{", "if", "(", "cp", ".", "isErrorResilientProfile", "(", ")", ")", "{", "config", ".", "sectionDataResilience", "=", "_in", ".", "readBool", "(", ")", ";", "config", ".", "scalefactorResilience", "=", "_in", ".", "readBool", "(", ")", ";", "config", ".", "spectralDataResilience", "=", "_in", ".", "readBool", "(", ")", ";", "}", "//extensionFlag3", "_in", ".", "skipBit", "(", ")", ";", "}", "if", "(", "config", ".", "channelConfiguration", "==", "ChannelConfiguration", ".", "CHANNEL_CONFIG_NONE", ")", "{", "//TODO: is this working correct? -> ISO 14496-3 part 1: 1.A.4.3", "_in", ".", "skipBits", "(", "3", ")", ";", "//PCE", "PCE", "pce", "=", "new", "PCE", "(", ")", ";", "pce", ".", "decode", "(", "_in", ")", ";", "config", ".", "profile", "=", "pce", ".", "getProfile", "(", ")", ";", "config", ".", "sampleFrequency", "=", "pce", ".", "getSampleFrequency", "(", ")", ";", "config", ".", "channelConfiguration", "=", "ChannelConfiguration", ".", "forInt", "(", "pce", ".", "getChannelCount", "(", ")", ")", ";", "}", "if", "(", "_in", ".", "getBitsLeft", "(", ")", ">", "10", ")", "readSyncExtension", "(", "_in", ",", "config", ")", ";", "}", "else", "{", "throw", "new", "AACException", "(", "\"profile not supported: \"", "+", "cp", ".", "getIndex", "(", ")", ")", ";", "}", "return", "config", ";", "}", "finally", "{", "_in", ".", "destroy", "(", ")", ";", "}", "}"], "docstring": "Parses the input arrays as a DecoderSpecificInfo, as used in MP4\ncontainers.\n\n@return a AACDecoderConfig", "docstring_tokens": ["Parses", "the", "input", "arrays", "as", "a", "DecoderSpecificInfo", "as", "used", "in", "MP4", "containers", "."]}
{"code": "return 0;", "comments": "shouldn't happen", "lines": 5, "repo": "jcodec/jcodec", "path": "src/main/java/net/sourceforge/jaad/aac/gain/GainControl.java", "func_name": "GainControl.getGainChangePointID", "original_string": "private int getGainChangePointID(int lngain) {\n\t\tfor(int i = 0; i<ID_GAIN; i++) {\n\t\t\tif(lngain==LN_GAIN[i]) return i;\n\t\t}\n\t\treturn 0; //shouldn't happen\n\t}", "language": "java", "Allcodes": "private int getGainChangePointID(int lngain) {\n\t\tfor(int i = 0; i<ID_GAIN; i++) {\n\t\t\tif(lngain==LN_GAIN[i]) return i;\n\t\t}\n\t\treturn 0; //shouldn't happen\n\t}", "code_tokens": ["private", "int", "getGainChangePointID", "(", "int", "lngain", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "ID_GAIN", ";", "i", "++", ")", "{", "if", "(", "lngain", "==", "LN_GAIN", "[", "i", "]", ")", "return", "i", ";", "}", "return", "0", ";", "//shouldn't happen", "}"], "docstring": "transformes the exponent value of the gain to the id of the gain change\npoint", "docstring_tokens": ["transformes", "the", "exponent", "value", "of", "the", "gain", "to", "the", "id", "of", "the", "gain", "change", "point"]}
{"code": ";", "comments": "grab the spin lock", "lines": 37, "repo": "artclarke/humble-video", "path": "humble-video-noarch/src/main/java/io/humble/ferry/JNIMemoryManager.java", "func_name": "JNIMemoryManager.addReference", "original_string": "final boolean addReference(final JNIReference ref)\n  {\n    /* Implementation note: This method is extremely\n     * hot, and so I've unrolled the lock and unlock\n     * methods from above.  Take care if you change\n     * them to change the unrolled versions here.\n     * \n     */\n    // First try to grab the non blocking lock\n    boolean gotNonblockingLock = false;\n    gotNonblockingLock = mSpinLock.compareAndSet(false, true);\n    if (gotNonblockingLock)\n    {\n      final int slot = mNextAvailableReferenceSlot++;\n      if (slot < mMaxValidReference)\n      {\n        mValidReferences[slot] = ref;\n        // unlock the non-blocking lock, and progress to a full lock.\n        final boolean result = mSpinLock.compareAndSet(true, false);\n        assert result : \"Should never be unlocked here\";\n        return true;\n      }\n      // try the big lock without blocking\n      if (!mLock.tryLock()) {\n        // we couldn't get the big lock, so release the spin lock\n        // and try getting the bit lock while blocking\n        gotNonblockingLock = false;\n        mSpinLock.compareAndSet(true, false);\n      }\n    }\n    // The above code needs to make sure that we never\n    // have gotNonblockingLock set, unless we have both\n    // the spin lock and the big lock.\n    if (!gotNonblockingLock){\n      mLock.lock();\n      while(!mSpinLock.compareAndSet(false, true))\n        ; // grab the spin lock\n    }\n    try {\n      int slot = mNextAvailableReferenceSlot++;\n      if (slot >= mMaxValidReference)\n      {\n        sweepAndCollect();\n        slot = mNextAvailableReferenceSlot++;\n      }\n      mValidReferences[slot] = ref;\n    } finally {\n      final boolean result = mSpinLock.compareAndSet(true, false);\n      assert result : \"Should never ever be unlocked here\";\n      mLock.unlock();\n    }\n    return true;\n  }", "language": "java", "Allcodes": "final boolean addReference(final JNIReference ref)\n  {\n    /* Implementation note: This method is extremely\n     * hot, and so I've unrolled the lock and unlock\n     * methods from above.  Take care if you change\n     * them to change the unrolled versions here.\n     * \n     */\n    // First try to grab the non blocking lock\n    boolean gotNonblockingLock = false;\n    gotNonblockingLock = mSpinLock.compareAndSet(false, true);\n    if (gotNonblockingLock)\n    {\n      final int slot = mNextAvailableReferenceSlot++;\n      if (slot < mMaxValidReference)\n      {\n        mValidReferences[slot] = ref;\n        // unlock the non-blocking lock, and progress to a full lock.\n        final boolean result = mSpinLock.compareAndSet(true, false);\n        assert result : \"Should never be unlocked here\";\n        return true;\n      }\n      // try the big lock without blocking\n      if (!mLock.tryLock()) {\n        // we couldn't get the big lock, so release the spin lock\n        // and try getting the bit lock while blocking\n        gotNonblockingLock = false;\n        mSpinLock.compareAndSet(true, false);\n      }\n    }\n    // The above code needs to make sure that we never\n    // have gotNonblockingLock set, unless we have both\n    // the spin lock and the big lock.\n    if (!gotNonblockingLock){\n      mLock.lock();\n      while(!mSpinLock.compareAndSet(false, true))\n        ; // grab the spin lock\n    }\n    try {\n      int slot = mNextAvailableReferenceSlot++;\n      if (slot >= mMaxValidReference)\n      {\n        sweepAndCollect();\n        slot = mNextAvailableReferenceSlot++;\n      }\n      mValidReferences[slot] = ref;\n    } finally {\n      final boolean result = mSpinLock.compareAndSet(true, false);\n      assert result : \"Should never ever be unlocked here\";\n      mLock.unlock();\n    }\n    return true;\n  }", "code_tokens": ["final", "boolean", "addReference", "(", "final", "JNIReference", "ref", ")", "{", "/* Implementation note: This method is extremely\n     * hot, and so I've unrolled the lock and unlock\n     * methods from above.  Take care if you change\n     * them to change the unrolled versions here.\n     * \n     */", "// First try to grab the non blocking lock", "boolean", "gotNonblockingLock", "=", "false", ";", "gotNonblockingLock", "=", "mSpinLock", ".", "compareAndSet", "(", "false", ",", "true", ")", ";", "if", "(", "gotNonblockingLock", ")", "{", "final", "int", "slot", "=", "mNextAvailableReferenceSlot", "++", ";", "if", "(", "slot", "<", "mMaxValidReference", ")", "{", "mValidReferences", "[", "slot", "]", "=", "ref", ";", "// unlock the non-blocking lock, and progress to a full lock.", "final", "boolean", "result", "=", "mSpinLock", ".", "compareAndSet", "(", "true", ",", "false", ")", ";", "assert", "result", ":", "\"Should never be unlocked here\"", ";", "return", "true", ";", "}", "// try the big lock without blocking", "if", "(", "!", "mLock", ".", "tryLock", "(", ")", ")", "{", "// we couldn't get the big lock, so release the spin lock", "// and try getting the bit lock while blocking", "gotNonblockingLock", "=", "false", ";", "mSpinLock", ".", "compareAndSet", "(", "true", ",", "false", ")", ";", "}", "}", "// The above code needs to make sure that we never", "// have gotNonblockingLock set, unless we have both", "// the spin lock and the big lock.", "if", "(", "!", "gotNonblockingLock", ")", "{", "mLock", ".", "lock", "(", ")", ";", "while", "(", "!", "mSpinLock", ".", "compareAndSet", "(", "false", ",", "true", ")", ")", ";", "// grab the spin lock", "}", "try", "{", "int", "slot", "=", "mNextAvailableReferenceSlot", "++", ";", "if", "(", "slot", ">=", "mMaxValidReference", ")", "{", "sweepAndCollect", "(", ")", ";", "slot", "=", "mNextAvailableReferenceSlot", "++", ";", "}", "mValidReferences", "[", "slot", "]", "=", "ref", ";", "}", "finally", "{", "final", "boolean", "result", "=", "mSpinLock", ".", "compareAndSet", "(", "true", ",", "false", ")", ";", "assert", "result", ":", "\"Should never ever be unlocked here\"", ";", "mLock", ".", "unlock", "(", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Add a reference to the set of references we'll collect.\n\n@param ref The reference to collect.\n@return true if already in list; false otherwise.", "docstring_tokens": ["Add", "a", "reference", "to", "the", "set", "of", "references", "we", "ll", "collect", "."]}
{"code": "++inputStart;", "comments": "optimization - skip leading zeros", "lines": 26, "repo": "wavesplatform/WavesJ", "path": "src/main/java/com/wavesplatform/wavesj/Base58.java", "func_name": "Base58.decode", "original_string": "public static byte[] decode(String input) throws IllegalArgumentException {\n        if (input.startsWith(\"base58:\")) input = input.substring(7);\n        if (input.length() == 0) return new byte[0];\n\n        // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).\n        byte[] input58 = new byte[input.length()];\n        for (int i = 0; i < input.length(); ++i) {\n            char c = input.charAt(i);\n            int digit = c < 128 ? INDEXES[c] : -1;\n            if (digit < 0) {\n                throw new IllegalArgumentException(\"Illegal character \" + c + \" at position \" + i);\n            }\n            input58[i] = (byte) digit;\n        }\n        // Count leading zeros.\n        int zeros = 0;\n        while (zeros < input58.length && input58[zeros] == 0) {\n            ++zeros;\n        }\n        // Convert base-58 digits to base-256 digits.\n        byte[] decoded = new byte[input.length()];\n        int outputStart = decoded.length;\n        for (int inputStart = zeros; inputStart < input58.length; ) {\n            decoded[--outputStart] = divmod(input58, inputStart, 58, 256);\n            if (input58[inputStart] == 0) {\n                ++inputStart; // optimization - skip leading zeros\n            }\n        }\n        // Ignore extra leading zeroes that were added during the calculation.\n        while (outputStart < decoded.length && decoded[outputStart] == 0) {\n            ++outputStart;\n        }\n        // Return decoded data (including original number of leading zeros).\n        return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);\n    }", "language": "java", "Allcodes": "public static byte[] decode(String input) throws IllegalArgumentException {\n        if (input.startsWith(\"base58:\")) input = input.substring(7);\n        if (input.length() == 0) return new byte[0];\n\n        // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).\n        byte[] input58 = new byte[input.length()];\n        for (int i = 0; i < input.length(); ++i) {\n            char c = input.charAt(i);\n            int digit = c < 128 ? INDEXES[c] : -1;\n            if (digit < 0) {\n                throw new IllegalArgumentException(\"Illegal character \" + c + \" at position \" + i);\n            }\n            input58[i] = (byte) digit;\n        }\n        // Count leading zeros.\n        int zeros = 0;\n        while (zeros < input58.length && input58[zeros] == 0) {\n            ++zeros;\n        }\n        // Convert base-58 digits to base-256 digits.\n        byte[] decoded = new byte[input.length()];\n        int outputStart = decoded.length;\n        for (int inputStart = zeros; inputStart < input58.length; ) {\n            decoded[--outputStart] = divmod(input58, inputStart, 58, 256);\n            if (input58[inputStart] == 0) {\n                ++inputStart; // optimization - skip leading zeros\n            }\n        }\n        // Ignore extra leading zeroes that were added during the calculation.\n        while (outputStart < decoded.length && decoded[outputStart] == 0) {\n            ++outputStart;\n        }\n        // Return decoded data (including original number of leading zeros).\n        return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);\n    }", "code_tokens": ["public", "static", "byte", "[", "]", "decode", "(", "String", "input", ")", "throws", "IllegalArgumentException", "{", "if", "(", "input", ".", "startsWith", "(", "\"base58:\"", ")", ")", "input", "=", "input", ".", "substring", "(", "7", ")", ";", "if", "(", "input", ".", "length", "(", ")", "==", "0", ")", "return", "new", "byte", "[", "0", "]", ";", "// Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).", "byte", "[", "]", "input58", "=", "new", "byte", "[", "input", ".", "length", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "input", ".", "length", "(", ")", ";", "++", "i", ")", "{", "char", "c", "=", "input", ".", "charAt", "(", "i", ")", ";", "int", "digit", "=", "c", "<", "128", "?", "INDEXES", "[", "c", "]", ":", "-", "1", ";", "if", "(", "digit", "<", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Illegal character \"", "+", "c", "+", "\" at position \"", "+", "i", ")", ";", "}", "input58", "[", "i", "]", "=", "(", "byte", ")", "digit", ";", "}", "// Count leading zeros.", "int", "zeros", "=", "0", ";", "while", "(", "zeros", "<", "input58", ".", "length", "&&", "input58", "[", "zeros", "]", "==", "0", ")", "{", "++", "zeros", ";", "}", "// Convert base-58 digits to base-256 digits.", "byte", "[", "]", "decoded", "=", "new", "byte", "[", "input", ".", "length", "(", ")", "]", ";", "int", "outputStart", "=", "decoded", ".", "length", ";", "for", "(", "int", "inputStart", "=", "zeros", ";", "inputStart", "<", "input58", ".", "length", ";", ")", "{", "decoded", "[", "--", "outputStart", "]", "=", "divmod", "(", "input58", ",", "inputStart", ",", "58", ",", "256", ")", ";", "if", "(", "input58", "[", "inputStart", "]", "==", "0", ")", "{", "++", "inputStart", ";", "// optimization - skip leading zeros", "}", "}", "// Ignore extra leading zeroes that were added during the calculation.", "while", "(", "outputStart", "<", "decoded", ".", "length", "&&", "decoded", "[", "outputStart", "]", "==", "0", ")", "{", "++", "outputStart", ";", "}", "// Return decoded data (including original number of leading zeros).", "return", "Arrays", ".", "copyOfRange", "(", "decoded", ",", "outputStart", "-", "zeros", ",", "decoded", ".", "length", ")", ";", "}"], "docstring": "Decodes the given base58 string into the original data bytes.\n\n@param input the base58-encoded string to decode\n@return the decoded data bytes\n@throws IllegalArgumentException if the given string is not a valid base58 string", "docstring_tokens": ["Decodes", "the", "given", "base58", "string", "into", "the", "original", "data", "bytes", "."]}
{"code": "BigInteger mask = new BigInteger(new byte[]{0, 0, 7, -1});", "comments": "11 lower bits", "lines": 7, "repo": "wavesplatform/WavesJ", "path": "src/main/java/com/wavesplatform/wavesj/PrivateKeyAccount.java", "func_name": "PrivateKeyAccount.generateSeed", "original_string": "public static String generateSeed() {\n        byte[] bytes = new byte[21];\n        new SecureRandom().nextBytes(bytes);\n        byte[] rhash = hash(bytes, 0, 20, SHA256);\n        bytes[20] = rhash[0];\n        BigInteger rand = new BigInteger(bytes);\n        BigInteger mask = new BigInteger(new byte[]{0, 0, 7, -1}); // 11 lower bits\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 15; i++) {\n            sb.append(i > 0 ? ' ' : \"\")\n                    .append(SEED_WORDS[rand.and(mask).intValue()]);\n            rand = rand.shiftRight(11);\n        }\n        return sb.toString();\n    }", "language": "java", "Allcodes": "public static String generateSeed() {\n        byte[] bytes = new byte[21];\n        new SecureRandom().nextBytes(bytes);\n        byte[] rhash = hash(bytes, 0, 20, SHA256);\n        bytes[20] = rhash[0];\n        BigInteger rand = new BigInteger(bytes);\n        BigInteger mask = new BigInteger(new byte[]{0, 0, 7, -1}); // 11 lower bits\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 15; i++) {\n            sb.append(i > 0 ? ' ' : \"\")\n                    .append(SEED_WORDS[rand.and(mask).intValue()]);\n            rand = rand.shiftRight(11);\n        }\n        return sb.toString();\n    }", "code_tokens": ["public", "static", "String", "generateSeed", "(", ")", "{", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "21", "]", ";", "new", "SecureRandom", "(", ")", ".", "nextBytes", "(", "bytes", ")", ";", "byte", "[", "]", "rhash", "=", "hash", "(", "bytes", ",", "0", ",", "20", ",", "SHA256", ")", ";", "bytes", "[", "20", "]", "=", "rhash", "[", "0", "]", ";", "BigInteger", "rand", "=", "new", "BigInteger", "(", "bytes", ")", ";", "BigInteger", "mask", "=", "new", "BigInteger", "(", "new", "byte", "[", "]", "{", "0", ",", "0", ",", "7", ",", "-", "1", "}", ")", ";", "// 11 lower bits", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "15", ";", "i", "++", ")", "{", "sb", ".", "append", "(", "i", ">", "0", "?", "'", "'", ":", "\"\"", ")", ".", "append", "(", "SEED_WORDS", "[", "rand", ".", "and", "(", "mask", ")", ".", "intValue", "(", ")", "]", ")", ";", "rand", "=", "rand", ".", "shiftRight", "(", "11", ")", ";", "}", "return", "sb", ".", "toString", "(", ")", ";", "}"], "docstring": "Generates a 15-word random seed. This method implements the BIP-39 algorithm with 160 bits of entropy.\n\n@return the seed as a String", "docstring_tokens": ["Generates", "a", "15", "-", "word", "random", "seed", ".", "This", "method", "implements", "the", "BIP", "-", "39", "algorithm", "with", "160", "bits", "of", "entropy", "."]}
{"code": "buffout.reset();", "comments": "reset resued fstoutput", "lines": 10, "repo": "RuedigerMoeller/fast-serialization", "path": "src/main/java/org/nustaq/serialization/coders/FSTStreamEncoder.java", "func_name": "FSTStreamEncoder.setOutstream", "original_string": "@Override\n    public void setOutstream(OutputStream outstream) {\n        if ( buffout == null ) \n        {\n            // try reuse\n            buffout = (FSTOutputStream) conf.getCachedObject(FSTOutputStream.class);\n            if ( buffout == null ) // if fail, alloc\n                buffout = new FSTOutputStream(1000, outstream);\n            else\n                buffout.reset(); // reset resued fstoutput\n        }\n        if ( outstream == null )\n            buffout.setOutstream(buffout);\n        else\n            buffout.setOutstream(outstream);\n    }", "language": "java", "Allcodes": "@Override\n    public void setOutstream(OutputStream outstream) {\n        if ( buffout == null ) \n        {\n            // try reuse\n            buffout = (FSTOutputStream) conf.getCachedObject(FSTOutputStream.class);\n            if ( buffout == null ) // if fail, alloc\n                buffout = new FSTOutputStream(1000, outstream);\n            else\n                buffout.reset(); // reset resued fstoutput\n        }\n        if ( outstream == null )\n            buffout.setOutstream(buffout);\n        else\n            buffout.setOutstream(outstream);\n    }", "code_tokens": ["@", "Override", "public", "void", "setOutstream", "(", "OutputStream", "outstream", ")", "{", "if", "(", "buffout", "==", "null", ")", "{", "// try reuse", "buffout", "=", "(", "FSTOutputStream", ")", "conf", ".", "getCachedObject", "(", "FSTOutputStream", ".", "class", ")", ";", "if", "(", "buffout", "==", "null", ")", "// if fail, alloc", "buffout", "=", "new", "FSTOutputStream", "(", "1000", ",", "outstream", ")", ";", "else", "buffout", ".", "reset", "(", ")", ";", "// reset resued fstoutput", "}", "if", "(", "outstream", "==", "null", ")", "buffout", ".", "setOutstream", "(", "buffout", ")", ";", "else", "buffout", ".", "setOutstream", "(", "outstream", ")", ";", "}"], "docstring": "if output stream is null, just encode into a byte array\n@param outstream", "docstring_tokens": ["if", "output", "stream", "is", "null", "just", "encode", "into", "a", "byte", "array"]}
{"code": "System.setProperty(\"cassandra.native.epoll.enabled\", \"false\");", "comments": "JNA doesnt cope with relocated netty", "lines": 14, "repo": "jsevellec/cassandra-unit", "path": "cassandra-unit/src/main/java/org/cassandraunit/utils/EmbeddedCassandraServerHelper.java", "func_name": "EmbeddedCassandraServerHelper.startEmbeddedCassandra", "original_string": "public static void startEmbeddedCassandra(File file, String tmpDir, long timeout) throws IOException, ConfigurationException {\n        if (cassandraDaemon != null) {\n            /* nothing to do Cassandra is already started */\n            return;\n        }\n\n        checkConfigNameForRestart(file.getAbsolutePath());\n\n        log.debug(\"Starting cassandra...\");\n        log.debug(\"Initialization needed\");\n\n        System.setProperty(\"cassandra.config\", \"file:\" + file.getAbsolutePath());\n        System.setProperty(\"cassandra-foreground\", \"true\");\n        System.setProperty(\"cassandra.native.epoll.enabled\", \"false\"); // JNA doesnt cope with relocated netty\n        System.setProperty(\"cassandra.unsafesystem\", \"true\"); // disable fsync for a massive speedup on old platters\n\n        // If there is no log4j config set already, set the default config\n        if (System.getProperty(\"log4j.configuration\") == null) {\n            copy(DEFAULT_LOG4J_CONFIG_FILE, tmpDir);\n            System.setProperty(\"log4j.configuration\", \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE);\n        }\n\n        DatabaseDescriptor.daemonInitialization();\n\n        cleanupAndLeaveDirs();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            cassandraDaemon = new CassandraDaemon();\n            cassandraDaemon.activate();\n            startupLatch.countDown();\n        });\n        try {\n            if (!startupLatch.await(timeout, MILLISECONDS)) {\n                log.error(\"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\");\n                throw new AssertionError(\"Cassandra daemon did not start within timeout\");\n            }\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                if (session != null) session.close();\n                if (cluster != null) cluster.close();\n            }));\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted waiting for Cassandra daemon to start:\", e);\n            throw new AssertionError(e);\n        } finally {\n            executor.shutdown();\n        }\n    }", "language": "java", "Allcodes": "public static void startEmbeddedCassandra(File file, String tmpDir, long timeout) throws IOException, ConfigurationException {\n        if (cassandraDaemon != null) {\n            /* nothing to do Cassandra is already started */\n            return;\n        }\n\n        checkConfigNameForRestart(file.getAbsolutePath());\n\n        log.debug(\"Starting cassandra...\");\n        log.debug(\"Initialization needed\");\n\n        System.setProperty(\"cassandra.config\", \"file:\" + file.getAbsolutePath());\n        System.setProperty(\"cassandra-foreground\", \"true\");\n        System.setProperty(\"cassandra.native.epoll.enabled\", \"false\"); // JNA doesnt cope with relocated netty\n        System.setProperty(\"cassandra.unsafesystem\", \"true\"); // disable fsync for a massive speedup on old platters\n\n        // If there is no log4j config set already, set the default config\n        if (System.getProperty(\"log4j.configuration\") == null) {\n            copy(DEFAULT_LOG4J_CONFIG_FILE, tmpDir);\n            System.setProperty(\"log4j.configuration\", \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE);\n        }\n\n        DatabaseDescriptor.daemonInitialization();\n\n        cleanupAndLeaveDirs();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            cassandraDaemon = new CassandraDaemon();\n            cassandraDaemon.activate();\n            startupLatch.countDown();\n        });\n        try {\n            if (!startupLatch.await(timeout, MILLISECONDS)) {\n                log.error(\"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\");\n                throw new AssertionError(\"Cassandra daemon did not start within timeout\");\n            }\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                if (session != null) session.close();\n                if (cluster != null) cluster.close();\n            }));\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted waiting for Cassandra daemon to start:\", e);\n            throw new AssertionError(e);\n        } finally {\n            executor.shutdown();\n        }\n    }", "code_tokens": ["public", "static", "void", "startEmbeddedCassandra", "(", "File", "file", ",", "String", "tmpDir", ",", "long", "timeout", ")", "throws", "IOException", ",", "ConfigurationException", "{", "if", "(", "cassandraDaemon", "!=", "null", ")", "{", "/* nothing to do Cassandra is already started */", "return", ";", "}", "checkConfigNameForRestart", "(", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "log", ".", "debug", "(", "\"Starting cassandra...\"", ")", ";", "log", ".", "debug", "(", "\"Initialization needed\"", ")", ";", "System", ".", "setProperty", "(", "\"cassandra.config\"", ",", "\"file:\"", "+", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "System", ".", "setProperty", "(", "\"cassandra-foreground\"", ",", "\"true\"", ")", ";", "System", ".", "setProperty", "(", "\"cassandra.native.epoll.enabled\"", ",", "\"false\"", ")", ";", "// JNA doesnt cope with relocated netty", "System", ".", "setProperty", "(", "\"cassandra.unsafesystem\"", ",", "\"true\"", ")", ";", "// disable fsync for a massive speedup on old platters", "// If there is no log4j config set already, set the default config", "if", "(", "System", ".", "getProperty", "(", "\"log4j.configuration\"", ")", "==", "null", ")", "{", "copy", "(", "DEFAULT_LOG4J_CONFIG_FILE", ",", "tmpDir", ")", ";", "System", ".", "setProperty", "(", "\"log4j.configuration\"", ",", "\"file:\"", "+", "tmpDir", "+", "DEFAULT_LOG4J_CONFIG_FILE", ")", ";", "}", "DatabaseDescriptor", ".", "daemonInitialization", "(", ")", ";", "cleanupAndLeaveDirs", "(", ")", ";", "final", "CountDownLatch", "startupLatch", "=", "new", "CountDownLatch", "(", "1", ")", ";", "ExecutorService", "executor", "=", "Executors", ".", "newSingleThreadExecutor", "(", ")", ";", "executor", ".", "execute", "(", "(", ")", "->", "{", "cassandraDaemon", "=", "new", "CassandraDaemon", "(", ")", ";", "cassandraDaemon", ".", "activate", "(", ")", ";", "startupLatch", ".", "countDown", "(", ")", ";", "}", ")", ";", "try", "{", "if", "(", "!", "startupLatch", ".", "await", "(", "timeout", ",", "MILLISECONDS", ")", ")", "{", "log", ".", "error", "(", "\"Cassandra daemon did not start after \"", "+", "timeout", "+", "\" ms. Consider increasing the timeout\"", ")", ";", "throw", "new", "AssertionError", "(", "\"Cassandra daemon did not start within timeout\"", ")", ";", "}", "Runtime", ".", "getRuntime", "(", ")", ".", "addShutdownHook", "(", "new", "Thread", "(", "(", ")", "->", "{", "if", "(", "session", "!=", "null", ")", "session", ".", "close", "(", ")", ";", "if", "(", "cluster", "!=", "null", ")", "cluster", ".", "close", "(", ")", ";", "}", ")", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "log", ".", "error", "(", "\"Interrupted waiting for Cassandra daemon to start:\"", ",", "e", ")", ";", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "finally", "{", "executor", ".", "shutdown", "(", ")", ";", "}", "}"], "docstring": "Set embedded cassandra up and spawn it in a new thread.\n\n@throws TTransportException\n@throws IOException\n@throws ConfigurationException", "docstring_tokens": ["Set", "embedded", "cassandra", "up", "and", "spawn", "it", "in", "a", "new", "thread", "."]}
{"code": "System.setProperty(\"cassandra.unsafesystem\", \"true\");", "comments": "disable fsync for a massive speedup on old platters", "lines": 15, "repo": "jsevellec/cassandra-unit", "path": "cassandra-unit/src/main/java/org/cassandraunit/utils/EmbeddedCassandraServerHelper.java", "func_name": "EmbeddedCassandraServerHelper.startEmbeddedCassandra", "original_string": "public static void startEmbeddedCassandra(File file, String tmpDir, long timeout) throws IOException, ConfigurationException {\n        if (cassandraDaemon != null) {\n            /* nothing to do Cassandra is already started */\n            return;\n        }\n\n        checkConfigNameForRestart(file.getAbsolutePath());\n\n        log.debug(\"Starting cassandra...\");\n        log.debug(\"Initialization needed\");\n\n        System.setProperty(\"cassandra.config\", \"file:\" + file.getAbsolutePath());\n        System.setProperty(\"cassandra-foreground\", \"true\");\n        System.setProperty(\"cassandra.native.epoll.enabled\", \"false\"); // JNA doesnt cope with relocated netty\n        System.setProperty(\"cassandra.unsafesystem\", \"true\"); // disable fsync for a massive speedup on old platters\n\n        // If there is no log4j config set already, set the default config\n        if (System.getProperty(\"log4j.configuration\") == null) {\n            copy(DEFAULT_LOG4J_CONFIG_FILE, tmpDir);\n            System.setProperty(\"log4j.configuration\", \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE);\n        }\n\n        DatabaseDescriptor.daemonInitialization();\n\n        cleanupAndLeaveDirs();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            cassandraDaemon = new CassandraDaemon();\n            cassandraDaemon.activate();\n            startupLatch.countDown();\n        });\n        try {\n            if (!startupLatch.await(timeout, MILLISECONDS)) {\n                log.error(\"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\");\n                throw new AssertionError(\"Cassandra daemon did not start within timeout\");\n            }\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                if (session != null) session.close();\n                if (cluster != null) cluster.close();\n            }));\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted waiting for Cassandra daemon to start:\", e);\n            throw new AssertionError(e);\n        } finally {\n            executor.shutdown();\n        }\n    }", "language": "java", "Allcodes": "public static void startEmbeddedCassandra(File file, String tmpDir, long timeout) throws IOException, ConfigurationException {\n        if (cassandraDaemon != null) {\n            /* nothing to do Cassandra is already started */\n            return;\n        }\n\n        checkConfigNameForRestart(file.getAbsolutePath());\n\n        log.debug(\"Starting cassandra...\");\n        log.debug(\"Initialization needed\");\n\n        System.setProperty(\"cassandra.config\", \"file:\" + file.getAbsolutePath());\n        System.setProperty(\"cassandra-foreground\", \"true\");\n        System.setProperty(\"cassandra.native.epoll.enabled\", \"false\"); // JNA doesnt cope with relocated netty\n        System.setProperty(\"cassandra.unsafesystem\", \"true\"); // disable fsync for a massive speedup on old platters\n\n        // If there is no log4j config set already, set the default config\n        if (System.getProperty(\"log4j.configuration\") == null) {\n            copy(DEFAULT_LOG4J_CONFIG_FILE, tmpDir);\n            System.setProperty(\"log4j.configuration\", \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE);\n        }\n\n        DatabaseDescriptor.daemonInitialization();\n\n        cleanupAndLeaveDirs();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(() -> {\n            cassandraDaemon = new CassandraDaemon();\n            cassandraDaemon.activate();\n            startupLatch.countDown();\n        });\n        try {\n            if (!startupLatch.await(timeout, MILLISECONDS)) {\n                log.error(\"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\");\n                throw new AssertionError(\"Cassandra daemon did not start within timeout\");\n            }\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                if (session != null) session.close();\n                if (cluster != null) cluster.close();\n            }));\n        } catch (InterruptedException e) {\n            log.error(\"Interrupted waiting for Cassandra daemon to start:\", e);\n            throw new AssertionError(e);\n        } finally {\n            executor.shutdown();\n        }\n    }", "code_tokens": ["public", "static", "void", "startEmbeddedCassandra", "(", "File", "file", ",", "String", "tmpDir", ",", "long", "timeout", ")", "throws", "IOException", ",", "ConfigurationException", "{", "if", "(", "cassandraDaemon", "!=", "null", ")", "{", "/* nothing to do Cassandra is already started */", "return", ";", "}", "checkConfigNameForRestart", "(", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "log", ".", "debug", "(", "\"Starting cassandra...\"", ")", ";", "log", ".", "debug", "(", "\"Initialization needed\"", ")", ";", "System", ".", "setProperty", "(", "\"cassandra.config\"", ",", "\"file:\"", "+", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "System", ".", "setProperty", "(", "\"cassandra-foreground\"", ",", "\"true\"", ")", ";", "System", ".", "setProperty", "(", "\"cassandra.native.epoll.enabled\"", ",", "\"false\"", ")", ";", "// JNA doesnt cope with relocated netty", "System", ".", "setProperty", "(", "\"cassandra.unsafesystem\"", ",", "\"true\"", ")", ";", "// disable fsync for a massive speedup on old platters", "// If there is no log4j config set already, set the default config", "if", "(", "System", ".", "getProperty", "(", "\"log4j.configuration\"", ")", "==", "null", ")", "{", "copy", "(", "DEFAULT_LOG4J_CONFIG_FILE", ",", "tmpDir", ")", ";", "System", ".", "setProperty", "(", "\"log4j.configuration\"", ",", "\"file:\"", "+", "tmpDir", "+", "DEFAULT_LOG4J_CONFIG_FILE", ")", ";", "}", "DatabaseDescriptor", ".", "daemonInitialization", "(", ")", ";", "cleanupAndLeaveDirs", "(", ")", ";", "final", "CountDownLatch", "startupLatch", "=", "new", "CountDownLatch", "(", "1", ")", ";", "ExecutorService", "executor", "=", "Executors", ".", "newSingleThreadExecutor", "(", ")", ";", "executor", ".", "execute", "(", "(", ")", "->", "{", "cassandraDaemon", "=", "new", "CassandraDaemon", "(", ")", ";", "cassandraDaemon", ".", "activate", "(", ")", ";", "startupLatch", ".", "countDown", "(", ")", ";", "}", ")", ";", "try", "{", "if", "(", "!", "startupLatch", ".", "await", "(", "timeout", ",", "MILLISECONDS", ")", ")", "{", "log", ".", "error", "(", "\"Cassandra daemon did not start after \"", "+", "timeout", "+", "\" ms. Consider increasing the timeout\"", ")", ";", "throw", "new", "AssertionError", "(", "\"Cassandra daemon did not start within timeout\"", ")", ";", "}", "Runtime", ".", "getRuntime", "(", ")", ".", "addShutdownHook", "(", "new", "Thread", "(", "(", ")", "->", "{", "if", "(", "session", "!=", "null", ")", "session", ".", "close", "(", ")", ";", "if", "(", "cluster", "!=", "null", ")", "cluster", ".", "close", "(", ")", ";", "}", ")", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "log", ".", "error", "(", "\"Interrupted waiting for Cassandra daemon to start:\"", ",", "e", ")", ";", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "finally", "{", "executor", ".", "shutdown", "(", ")", ";", "}", "}"], "docstring": "Set embedded cassandra up and spawn it in a new thread.\n\n@throws TTransportException\n@throws IOException\n@throws ConfigurationException", "docstring_tokens": ["Set", "embedded", "cassandra", "up", "and", "spawn", "it", "in", "a", "new", "thread", "."]}
{"code": "++index;", "comments": "move over the separator for next search", "lines": 10, "repo": "deeplearning4j/nd4j", "path": "nd4j-common/src/main/java/org/nd4j/util/StringUtils.java", "func_name": "StringUtils.split", "original_string": "public static String[] split(\n            String str, char escapeChar, char separator) {\n        if (str==null) {\n            return null;\n        }\n        ArrayList<String> strList = new ArrayList<String>();\n        StringBuilder split = new StringBuilder();\n        int index = 0;\n        while ((index = findNext(str, separator, escapeChar, index, split)) >= 0) {\n            ++index; // move over the separator for next search\n            strList.add(split.toString());\n            split.setLength(0); // reset the buffer\n        }\n        strList.add(split.toString());\n        // remove trailing empty split(s)\n        int last = strList.size(); // last split\n        while (--last>=0 && \"\".equals(strList.get(last))) {\n            strList.remove(last);\n        }\n        return strList.toArray(new String[strList.size()]);\n    }", "language": "java", "Allcodes": "public static String[] split(\n            String str, char escapeChar, char separator) {\n        if (str==null) {\n            return null;\n        }\n        ArrayList<String> strList = new ArrayList<String>();\n        StringBuilder split = new StringBuilder();\n        int index = 0;\n        while ((index = findNext(str, separator, escapeChar, index, split)) >= 0) {\n            ++index; // move over the separator for next search\n            strList.add(split.toString());\n            split.setLength(0); // reset the buffer\n        }\n        strList.add(split.toString());\n        // remove trailing empty split(s)\n        int last = strList.size(); // last split\n        while (--last>=0 && \"\".equals(strList.get(last))) {\n            strList.remove(last);\n        }\n        return strList.toArray(new String[strList.size()]);\n    }", "code_tokens": ["public", "static", "String", "[", "]", "split", "(", "String", "str", ",", "char", "escapeChar", ",", "char", "separator", ")", "{", "if", "(", "str", "==", "null", ")", "{", "return", "null", ";", "}", "ArrayList", "<", "String", ">", "strList", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "StringBuilder", "split", "=", "new", "StringBuilder", "(", ")", ";", "int", "index", "=", "0", ";", "while", "(", "(", "index", "=", "findNext", "(", "str", ",", "separator", ",", "escapeChar", ",", "index", ",", "split", ")", ")", ">=", "0", ")", "{", "++", "index", ";", "// move over the separator for next search", "strList", ".", "add", "(", "split", ".", "toString", "(", ")", ")", ";", "split", ".", "setLength", "(", "0", ")", ";", "// reset the buffer", "}", "strList", ".", "add", "(", "split", ".", "toString", "(", ")", ")", ";", "// remove trailing empty split(s)", "int", "last", "=", "strList", ".", "size", "(", ")", ";", "// last split", "while", "(", "--", "last", ">=", "0", "&&", "\"\"", ".", "equals", "(", "strList", ".", "get", "(", "last", ")", ")", ")", "{", "strList", ".", "remove", "(", "last", ")", ";", "}", "return", "strList", ".", "toArray", "(", "new", "String", "[", "strList", ".", "size", "(", ")", "]", ")", ";", "}"], "docstring": "Split a string using the given separator\n@param str a string that may have escaped separator\n@param escapeChar a char that be used to escape the separator\n@param separator a separator char\n@return an array of strings", "docstring_tokens": ["Split", "a", "string", "using", "the", "given", "separator"]}
{"code": "split.setLength(0);", "comments": "reset the buffer", "lines": 12, "repo": "deeplearning4j/nd4j", "path": "nd4j-common/src/main/java/org/nd4j/util/StringUtils.java", "func_name": "StringUtils.split", "original_string": "public static String[] split(\n            String str, char escapeChar, char separator) {\n        if (str==null) {\n            return null;\n        }\n        ArrayList<String> strList = new ArrayList<String>();\n        StringBuilder split = new StringBuilder();\n        int index = 0;\n        while ((index = findNext(str, separator, escapeChar, index, split)) >= 0) {\n            ++index; // move over the separator for next search\n            strList.add(split.toString());\n            split.setLength(0); // reset the buffer\n        }\n        strList.add(split.toString());\n        // remove trailing empty split(s)\n        int last = strList.size(); // last split\n        while (--last>=0 && \"\".equals(strList.get(last))) {\n            strList.remove(last);\n        }\n        return strList.toArray(new String[strList.size()]);\n    }", "language": "java", "Allcodes": "public static String[] split(\n            String str, char escapeChar, char separator) {\n        if (str==null) {\n            return null;\n        }\n        ArrayList<String> strList = new ArrayList<String>();\n        StringBuilder split = new StringBuilder();\n        int index = 0;\n        while ((index = findNext(str, separator, escapeChar, index, split)) >= 0) {\n            ++index; // move over the separator for next search\n            strList.add(split.toString());\n            split.setLength(0); // reset the buffer\n        }\n        strList.add(split.toString());\n        // remove trailing empty split(s)\n        int last = strList.size(); // last split\n        while (--last>=0 && \"\".equals(strList.get(last))) {\n            strList.remove(last);\n        }\n        return strList.toArray(new String[strList.size()]);\n    }", "code_tokens": ["public", "static", "String", "[", "]", "split", "(", "String", "str", ",", "char", "escapeChar", ",", "char", "separator", ")", "{", "if", "(", "str", "==", "null", ")", "{", "return", "null", ";", "}", "ArrayList", "<", "String", ">", "strList", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "StringBuilder", "split", "=", "new", "StringBuilder", "(", ")", ";", "int", "index", "=", "0", ";", "while", "(", "(", "index", "=", "findNext", "(", "str", ",", "separator", ",", "escapeChar", ",", "index", ",", "split", ")", ")", ">=", "0", ")", "{", "++", "index", ";", "// move over the separator for next search", "strList", ".", "add", "(", "split", ".", "toString", "(", ")", ")", ";", "split", ".", "setLength", "(", "0", ")", ";", "// reset the buffer", "}", "strList", ".", "add", "(", "split", ".", "toString", "(", ")", ")", ";", "// remove trailing empty split(s)", "int", "last", "=", "strList", ".", "size", "(", ")", ";", "// last split", "while", "(", "--", "last", ">=", "0", "&&", "\"\"", ".", "equals", "(", "strList", ".", "get", "(", "last", ")", ")", ")", "{", "strList", ".", "remove", "(", "last", ")", ";", "}", "return", "strList", ".", "toArray", "(", "new", "String", "[", "strList", ".", "size", "(", ")", "]", ")", ";", "}"], "docstring": "Split a string using the given separator\n@param str a string that may have escaped separator\n@param escapeChar a char that be used to escape the separator\n@param separator a separator char\n@return an array of strings", "docstring_tokens": ["Split", "a", "string", "using", "the", "given", "separator"]}
{"code": "int last = strList.size();", "comments": "last split", "lines": 16, "repo": "deeplearning4j/nd4j", "path": "nd4j-common/src/main/java/org/nd4j/util/StringUtils.java", "func_name": "StringUtils.split", "original_string": "public static String[] split(\n            String str, char escapeChar, char separator) {\n        if (str==null) {\n            return null;\n        }\n        ArrayList<String> strList = new ArrayList<String>();\n        StringBuilder split = new StringBuilder();\n        int index = 0;\n        while ((index = findNext(str, separator, escapeChar, index, split)) >= 0) {\n            ++index; // move over the separator for next search\n            strList.add(split.toString());\n            split.setLength(0); // reset the buffer\n        }\n        strList.add(split.toString());\n        // remove trailing empty split(s)\n        int last = strList.size(); // last split\n        while (--last>=0 && \"\".equals(strList.get(last))) {\n            strList.remove(last);\n        }\n        return strList.toArray(new String[strList.size()]);\n    }", "language": "java", "Allcodes": "public static String[] split(\n            String str, char escapeChar, char separator) {\n        if (str==null) {\n            return null;\n        }\n        ArrayList<String> strList = new ArrayList<String>();\n        StringBuilder split = new StringBuilder();\n        int index = 0;\n        while ((index = findNext(str, separator, escapeChar, index, split)) >= 0) {\n            ++index; // move over the separator for next search\n            strList.add(split.toString());\n            split.setLength(0); // reset the buffer\n        }\n        strList.add(split.toString());\n        // remove trailing empty split(s)\n        int last = strList.size(); // last split\n        while (--last>=0 && \"\".equals(strList.get(last))) {\n            strList.remove(last);\n        }\n        return strList.toArray(new String[strList.size()]);\n    }", "code_tokens": ["public", "static", "String", "[", "]", "split", "(", "String", "str", ",", "char", "escapeChar", ",", "char", "separator", ")", "{", "if", "(", "str", "==", "null", ")", "{", "return", "null", ";", "}", "ArrayList", "<", "String", ">", "strList", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "StringBuilder", "split", "=", "new", "StringBuilder", "(", ")", ";", "int", "index", "=", "0", ";", "while", "(", "(", "index", "=", "findNext", "(", "str", ",", "separator", ",", "escapeChar", ",", "index", ",", "split", ")", ")", ">=", "0", ")", "{", "++", "index", ";", "// move over the separator for next search", "strList", ".", "add", "(", "split", ".", "toString", "(", ")", ")", ";", "split", ".", "setLength", "(", "0", ")", ";", "// reset the buffer", "}", "strList", ".", "add", "(", "split", ".", "toString", "(", ")", ")", ";", "// remove trailing empty split(s)", "int", "last", "=", "strList", ".", "size", "(", ")", ";", "// last split", "while", "(", "--", "last", ">=", "0", "&&", "\"\"", ".", "equals", "(", "strList", ".", "get", "(", "last", ")", ")", ")", "{", "strList", ".", "remove", "(", "last", ")", ";", "}", "return", "strList", ".", "toArray", "(", "new", "String", "[", "strList", ".", "size", "(", ")", "]", ")", ";", "}"], "docstring": "Split a string using the given separator\n@param str a string that may have escaped separator\n@param escapeChar a char that be used to escape the separator\n@param separator a separator char\n@return an array of strings", "docstring_tokens": ["Split", "a", "string", "using", "the", "given", "separator"]}
{"code": "|| accessDeviceRead.get() >= accessHostWrite.get();", "comments": "accessHostWrite.get() <= getDeviceAccessTime();", "lines": 4, "repo": "deeplearning4j/nd4j", "path": "nd4j-backends/nd4j-backend-impls/nd4j-cuda/src/main/java/org/nd4j/jita/allocator/impl/AllocationPoint.java", "func_name": "AllocationPoint.isActualOnDeviceSide", "original_string": "public boolean isActualOnDeviceSide() {\n        //log.info(\"isActuialOnDeviceSide() -> Host side: [{}], Device side: [{}]\", accessHostWrite.get(), accessDeviceWrite.get());\n        boolean result = accessDeviceWrite.get() >= accessHostWrite.get()\n                        || accessDeviceRead.get() >= accessHostWrite.get(); //accessHostWrite.get() <= getDeviceAccessTime();\n        //        log.info(\"isActuialOnDeviceSide() -> {} ({}), Shape: {}\", result, objectId, shape);\n        return result;\n    }", "language": "java", "Allcodes": "public boolean isActualOnDeviceSide() {\n        //log.info(\"isActuialOnDeviceSide() -> Host side: [{}], Device side: [{}]\", accessHostWrite.get(), accessDeviceWrite.get());\n        boolean result = accessDeviceWrite.get() >= accessHostWrite.get()\n                        || accessDeviceRead.get() >= accessHostWrite.get(); //accessHostWrite.get() <= getDeviceAccessTime();\n        //        log.info(\"isActuialOnDeviceSide() -> {} ({}), Shape: {}\", result, objectId, shape);\n        return result;\n    }", "code_tokens": ["public", "boolean", "isActualOnDeviceSide", "(", ")", "{", "//log.info(\"isActuialOnDeviceSide() -> Host side: [{}], Device side: [{}]\", accessHostWrite.get(), accessDeviceWrite.get());", "boolean", "result", "=", "accessDeviceWrite", ".", "get", "(", ")", ">=", "accessHostWrite", ".", "get", "(", ")", "||", "accessDeviceRead", ".", "get", "(", ")", ">=", "accessHostWrite", ".", "get", "(", ")", ";", "//accessHostWrite.get() <= getDeviceAccessTime();", "//        log.info(\"isActuialOnDeviceSide() -> {} ({}), Shape: {}\", result, objectId, shape);", "return", "result", ";", "}"], "docstring": "This method returns, if device side has actual copy of data\n\n@return", "docstring_tokens": ["This", "method", "returns", "if", "device", "side", "has", "actual", "copy", "of", "data"]}
{"code": "return ptr;", "comments": "allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();", "lines": 16, "repo": "deeplearning4j/nd4j", "path": "nd4j-backends/nd4j-backend-impls/nd4j-cuda/src/main/java/org/nd4j/jita/memory/CudaMemoryManager.java", "func_name": "CudaMemoryManager.allocate", "original_string": "@Override\n    public Pointer allocate(long bytes, MemoryKind kind, boolean initialize) {\n        AtomicAllocator allocator = AtomicAllocator.getInstance();\n\n        //log.info(\"Allocating {} bytes in {} memory...\", bytes, kind);\n\n        if (kind == MemoryKind.HOST) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocHost(bytes, 0);\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from HOST memory\");\n\n            if (initialize)\n                Pointer.memset(ptr, 0, bytes);\n\n            return ptr;//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();\n        } else if (kind == MemoryKind.DEVICE) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocDevice(bytes, null, 0);\n\n\n            //log.info(\"Allocating {} bytes for device_{}\", bytes, Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j.getAffinityManager().getDeviceForCurrentThread() + \"] memory\");\n\n            if (initialize) {\n                CudaContext context = (CudaContext) AtomicAllocator.getInstance().getDeviceContext().getContext();\n\n                int i = NativeOpsHolder.getInstance().getDeviceNativeOps().memsetAsync(ptr, 0, bytes, 0, context.getSpecialStream());\n                if (i == 0)\n                    throw new ND4JIllegalStateException(\"memset failed on device_\" + Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n                context.getSpecialStream().synchronize();\n            }\n\n\n            return ptr; //allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();\n        } else\n            throw new RuntimeException(\"Unknown MemoryKind requested: \" + kind);\n    }", "language": "java", "Allcodes": "@Override\n    public Pointer allocate(long bytes, MemoryKind kind, boolean initialize) {\n        AtomicAllocator allocator = AtomicAllocator.getInstance();\n\n        //log.info(\"Allocating {} bytes in {} memory...\", bytes, kind);\n\n        if (kind == MemoryKind.HOST) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocHost(bytes, 0);\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from HOST memory\");\n\n            if (initialize)\n                Pointer.memset(ptr, 0, bytes);\n\n            return ptr;//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();\n        } else if (kind == MemoryKind.DEVICE) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocDevice(bytes, null, 0);\n\n\n            //log.info(\"Allocating {} bytes for device_{}\", bytes, Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j.getAffinityManager().getDeviceForCurrentThread() + \"] memory\");\n\n            if (initialize) {\n                CudaContext context = (CudaContext) AtomicAllocator.getInstance().getDeviceContext().getContext();\n\n                int i = NativeOpsHolder.getInstance().getDeviceNativeOps().memsetAsync(ptr, 0, bytes, 0, context.getSpecialStream());\n                if (i == 0)\n                    throw new ND4JIllegalStateException(\"memset failed on device_\" + Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n                context.getSpecialStream().synchronize();\n            }\n\n\n            return ptr; //allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();\n        } else\n            throw new RuntimeException(\"Unknown MemoryKind requested: \" + kind);\n    }", "code_tokens": ["@", "Override", "public", "Pointer", "allocate", "(", "long", "bytes", ",", "MemoryKind", "kind", ",", "boolean", "initialize", ")", "{", "AtomicAllocator", "allocator", "=", "AtomicAllocator", ".", "getInstance", "(", ")", ";", "//log.info(\"Allocating {} bytes in {} memory...\", bytes, kind);", "if", "(", "kind", "==", "MemoryKind", ".", "HOST", ")", "{", "Pointer", "ptr", "=", "NativeOpsHolder", ".", "getInstance", "(", ")", ".", "getDeviceNativeOps", "(", ")", ".", "mallocHost", "(", "bytes", ",", "0", ")", ";", "if", "(", "ptr", "==", "null", ")", "throw", "new", "RuntimeException", "(", "\"Failed to allocate \"", "+", "bytes", "+", "\" bytes from HOST memory\"", ")", ";", "if", "(", "initialize", ")", "Pointer", ".", "memset", "(", "ptr", ",", "0", ",", "bytes", ")", ";", "return", "ptr", ";", "//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();", "}", "else", "if", "(", "kind", "==", "MemoryKind", ".", "DEVICE", ")", "{", "Pointer", "ptr", "=", "NativeOpsHolder", ".", "getInstance", "(", ")", ".", "getDeviceNativeOps", "(", ")", ".", "mallocDevice", "(", "bytes", ",", "null", ",", "0", ")", ";", "//log.info(\"Allocating {} bytes for device_{}\", bytes, Nd4j.getAffinityManager().getDeviceForCurrentThread());", "if", "(", "ptr", "==", "null", ")", "throw", "new", "RuntimeException", "(", "\"Failed to allocate \"", "+", "bytes", "+", "\" bytes from DEVICE [\"", "+", "Nd4j", ".", "getAffinityManager", "(", ")", ".", "getDeviceForCurrentThread", "(", ")", "+", "\"] memory\"", ")", ";", "if", "(", "initialize", ")", "{", "CudaContext", "context", "=", "(", "CudaContext", ")", "AtomicAllocator", ".", "getInstance", "(", ")", ".", "getDeviceContext", "(", ")", ".", "getContext", "(", ")", ";", "int", "i", "=", "NativeOpsHolder", ".", "getInstance", "(", ")", ".", "getDeviceNativeOps", "(", ")", ".", "memsetAsync", "(", "ptr", ",", "0", ",", "bytes", ",", "0", ",", "context", ".", "getSpecialStream", "(", ")", ")", ";", "if", "(", "i", "==", "0", ")", "throw", "new", "ND4JIllegalStateException", "(", "\"memset failed on device_\"", "+", "Nd4j", ".", "getAffinityManager", "(", ")", ".", "getDeviceForCurrentThread", "(", ")", ")", ";", "context", ".", "getSpecialStream", "(", ")", ".", "synchronize", "(", ")", ";", "}", "return", "ptr", ";", "//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();", "}", "else", "throw", "new", "RuntimeException", "(", "\"Unknown MemoryKind requested: \"", "+", "kind", ")", ";", "}"], "docstring": "This method returns Pointer to allocated memory chunk\n\nPLEASE NOTE: Cache options depend on specific implementations\n\n@param bytes\n@param kind\n@param initialize", "docstring_tokens": ["This", "method", "returns", "Pointer", "to", "allocated", "memory", "chunk"]}
{"code": "return ptr;", "comments": "allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();", "lines": 37, "repo": "deeplearning4j/nd4j", "path": "nd4j-backends/nd4j-backend-impls/nd4j-cuda/src/main/java/org/nd4j/jita/memory/CudaMemoryManager.java", "func_name": "CudaMemoryManager.allocate", "original_string": "@Override\n    public Pointer allocate(long bytes, MemoryKind kind, boolean initialize) {\n        AtomicAllocator allocator = AtomicAllocator.getInstance();\n\n        //log.info(\"Allocating {} bytes in {} memory...\", bytes, kind);\n\n        if (kind == MemoryKind.HOST) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocHost(bytes, 0);\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from HOST memory\");\n\n            if (initialize)\n                Pointer.memset(ptr, 0, bytes);\n\n            return ptr;//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();\n        } else if (kind == MemoryKind.DEVICE) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocDevice(bytes, null, 0);\n\n\n            //log.info(\"Allocating {} bytes for device_{}\", bytes, Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j.getAffinityManager().getDeviceForCurrentThread() + \"] memory\");\n\n            if (initialize) {\n                CudaContext context = (CudaContext) AtomicAllocator.getInstance().getDeviceContext().getContext();\n\n                int i = NativeOpsHolder.getInstance().getDeviceNativeOps().memsetAsync(ptr, 0, bytes, 0, context.getSpecialStream());\n                if (i == 0)\n                    throw new ND4JIllegalStateException(\"memset failed on device_\" + Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n                context.getSpecialStream().synchronize();\n            }\n\n\n            return ptr; //allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();\n        } else\n            throw new RuntimeException(\"Unknown MemoryKind requested: \" + kind);\n    }", "language": "java", "Allcodes": "@Override\n    public Pointer allocate(long bytes, MemoryKind kind, boolean initialize) {\n        AtomicAllocator allocator = AtomicAllocator.getInstance();\n\n        //log.info(\"Allocating {} bytes in {} memory...\", bytes, kind);\n\n        if (kind == MemoryKind.HOST) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocHost(bytes, 0);\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from HOST memory\");\n\n            if (initialize)\n                Pointer.memset(ptr, 0, bytes);\n\n            return ptr;//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();\n        } else if (kind == MemoryKind.DEVICE) {\n            Pointer ptr = NativeOpsHolder.getInstance().getDeviceNativeOps().mallocDevice(bytes, null, 0);\n\n\n            //log.info(\"Allocating {} bytes for device_{}\", bytes, Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n            if (ptr == null)\n                throw new RuntimeException(\"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j.getAffinityManager().getDeviceForCurrentThread() + \"] memory\");\n\n            if (initialize) {\n                CudaContext context = (CudaContext) AtomicAllocator.getInstance().getDeviceContext().getContext();\n\n                int i = NativeOpsHolder.getInstance().getDeviceNativeOps().memsetAsync(ptr, 0, bytes, 0, context.getSpecialStream());\n                if (i == 0)\n                    throw new ND4JIllegalStateException(\"memset failed on device_\" + Nd4j.getAffinityManager().getDeviceForCurrentThread());\n\n                context.getSpecialStream().synchronize();\n            }\n\n\n            return ptr; //allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();\n        } else\n            throw new RuntimeException(\"Unknown MemoryKind requested: \" + kind);\n    }", "code_tokens": ["@", "Override", "public", "Pointer", "allocate", "(", "long", "bytes", ",", "MemoryKind", "kind", ",", "boolean", "initialize", ")", "{", "AtomicAllocator", "allocator", "=", "AtomicAllocator", ".", "getInstance", "(", ")", ";", "//log.info(\"Allocating {} bytes in {} memory...\", bytes, kind);", "if", "(", "kind", "==", "MemoryKind", ".", "HOST", ")", "{", "Pointer", "ptr", "=", "NativeOpsHolder", ".", "getInstance", "(", ")", ".", "getDeviceNativeOps", "(", ")", ".", "mallocHost", "(", "bytes", ",", "0", ")", ";", "if", "(", "ptr", "==", "null", ")", "throw", "new", "RuntimeException", "(", "\"Failed to allocate \"", "+", "bytes", "+", "\" bytes from HOST memory\"", ")", ";", "if", "(", "initialize", ")", "Pointer", ".", "memset", "(", "ptr", ",", "0", ",", "bytes", ")", ";", "return", "ptr", ";", "//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getHostPointer();", "}", "else", "if", "(", "kind", "==", "MemoryKind", ".", "DEVICE", ")", "{", "Pointer", "ptr", "=", "NativeOpsHolder", ".", "getInstance", "(", ")", ".", "getDeviceNativeOps", "(", ")", ".", "mallocDevice", "(", "bytes", ",", "null", ",", "0", ")", ";", "//log.info(\"Allocating {} bytes for device_{}\", bytes, Nd4j.getAffinityManager().getDeviceForCurrentThread());", "if", "(", "ptr", "==", "null", ")", "throw", "new", "RuntimeException", "(", "\"Failed to allocate \"", "+", "bytes", "+", "\" bytes from DEVICE [\"", "+", "Nd4j", ".", "getAffinityManager", "(", ")", ".", "getDeviceForCurrentThread", "(", ")", "+", "\"] memory\"", ")", ";", "if", "(", "initialize", ")", "{", "CudaContext", "context", "=", "(", "CudaContext", ")", "AtomicAllocator", ".", "getInstance", "(", ")", ".", "getDeviceContext", "(", ")", ".", "getContext", "(", ")", ";", "int", "i", "=", "NativeOpsHolder", ".", "getInstance", "(", ")", ".", "getDeviceNativeOps", "(", ")", ".", "memsetAsync", "(", "ptr", ",", "0", ",", "bytes", ",", "0", ",", "context", ".", "getSpecialStream", "(", ")", ")", ";", "if", "(", "i", "==", "0", ")", "throw", "new", "ND4JIllegalStateException", "(", "\"memset failed on device_\"", "+", "Nd4j", ".", "getAffinityManager", "(", ")", ".", "getDeviceForCurrentThread", "(", ")", ")", ";", "context", ".", "getSpecialStream", "(", ")", ".", "synchronize", "(", ")", ";", "}", "return", "ptr", ";", "//allocator.getMemoryHandler().alloc(AllocationStatus.HOST, null, null, initialize).getDevicePointer();", "}", "else", "throw", "new", "RuntimeException", "(", "\"Unknown MemoryKind requested: \"", "+", "kind", ")", ";", "}"], "docstring": "This method returns Pointer to allocated memory chunk\n\nPLEASE NOTE: Cache options depend on specific implementations\n\n@param bytes\n@param kind\n@param initialize", "docstring_tokens": ["This", "method", "returns", "Pointer", "to", "allocated", "memory", "chunk"]}
{"code": "return true;", "comments": "class has no parameters, or it's a raw type", "lines": 11, "repo": "objectify/objectify", "path": "src/main/java/com/googlecode/objectify/repackaged/gentyref/GenericTypeReflector.java", "func_name": "GenericTypeReflector.isSuperType", "original_string": "public static boolean isSuperType(Type superType, Type subType) {\n\t\tif (superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType) {\n\t\t\tClass<?> superClass = erase(superType);\n\t\t\tType mappedSubType = getExactSuperType(capture(subType), superClass);\n\t\t\tif (mappedSubType == null) {\n\t\t\t\treturn false;\n\t\t\t} else if (superType instanceof Class<?>) {\n\t\t\t\treturn true;\n\t\t\t} else if (mappedSubType instanceof Class<?>) {\n\t\t\t\t// TODO treat supertype by being raw type differently (\"supertype, but with warnings\")\n\t\t\t\treturn true; // class has no parameters, or it's a raw type\n\t\t\t} else if (mappedSubType instanceof GenericArrayType) {\n\t\t\t\tType superComponentType = getArrayComponentType(superType);\n\t\t\t\tassert superComponentType != null;\n\t\t\t\tType mappedSubComponentType = getArrayComponentType(mappedSubType);\n\t\t\t\tassert mappedSubComponentType != null;\n\t\t\t\treturn isSuperType(superComponentType, mappedSubComponentType);\n\t\t\t} else {\n\t\t\t\tassert mappedSubType instanceof ParameterizedType;\n\t\t\t\tParameterizedType pMappedSubType = (ParameterizedType) mappedSubType;\n\t\t\t\tassert pMappedSubType.getRawType() == superClass;\n\t\t\t\tParameterizedType pSuperType = (ParameterizedType)superType;\n\t\t\t\t\n\t\t\t\tType[] superTypeArgs = pSuperType.getActualTypeArguments();\n\t\t\t\tType[] subTypeArgs = pMappedSubType.getActualTypeArguments();\n\t\t\t\tassert superTypeArgs.length == subTypeArgs.length;\n\t\t\t\tfor (int i = 0; i < superTypeArgs.length; i++) {\n\t\t\t\t\tif (! contains(superTypeArgs[i], subTypeArgs[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// params of the class itself match, so if the owner types are supertypes too, it's a supertype.\n\t\t\t\treturn pSuperType.getOwnerType() == null || isSuperType(pSuperType.getOwnerType(), pMappedSubType.getOwnerType());\n\t\t\t}\n\t\t} else if (superType instanceof CaptureType) {\n\t\t\tif (superType.equals(subType))\n\t\t\t\treturn true;\n\t\t\tfor (Type lowerBound : ((CaptureType) superType).getLowerBounds()) {\n\t\t\t\tif (isSuperType(lowerBound, subType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (superType instanceof GenericArrayType) {\n\t\t\treturn isArraySupertype(superType, subType);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"not implemented: \" + superType.getClass());\n\t\t}\n\t}", "language": "java", "Allcodes": "public static boolean isSuperType(Type superType, Type subType) {\n\t\tif (superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType) {\n\t\t\tClass<?> superClass = erase(superType);\n\t\t\tType mappedSubType = getExactSuperType(capture(subType), superClass);\n\t\t\tif (mappedSubType == null) {\n\t\t\t\treturn false;\n\t\t\t} else if (superType instanceof Class<?>) {\n\t\t\t\treturn true;\n\t\t\t} else if (mappedSubType instanceof Class<?>) {\n\t\t\t\t// TODO treat supertype by being raw type differently (\"supertype, but with warnings\")\n\t\t\t\treturn true; // class has no parameters, or it's a raw type\n\t\t\t} else if (mappedSubType instanceof GenericArrayType) {\n\t\t\t\tType superComponentType = getArrayComponentType(superType);\n\t\t\t\tassert superComponentType != null;\n\t\t\t\tType mappedSubComponentType = getArrayComponentType(mappedSubType);\n\t\t\t\tassert mappedSubComponentType != null;\n\t\t\t\treturn isSuperType(superComponentType, mappedSubComponentType);\n\t\t\t} else {\n\t\t\t\tassert mappedSubType instanceof ParameterizedType;\n\t\t\t\tParameterizedType pMappedSubType = (ParameterizedType) mappedSubType;\n\t\t\t\tassert pMappedSubType.getRawType() == superClass;\n\t\t\t\tParameterizedType pSuperType = (ParameterizedType)superType;\n\t\t\t\t\n\t\t\t\tType[] superTypeArgs = pSuperType.getActualTypeArguments();\n\t\t\t\tType[] subTypeArgs = pMappedSubType.getActualTypeArguments();\n\t\t\t\tassert superTypeArgs.length == subTypeArgs.length;\n\t\t\t\tfor (int i = 0; i < superTypeArgs.length; i++) {\n\t\t\t\t\tif (! contains(superTypeArgs[i], subTypeArgs[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// params of the class itself match, so if the owner types are supertypes too, it's a supertype.\n\t\t\t\treturn pSuperType.getOwnerType() == null || isSuperType(pSuperType.getOwnerType(), pMappedSubType.getOwnerType());\n\t\t\t}\n\t\t} else if (superType instanceof CaptureType) {\n\t\t\tif (superType.equals(subType))\n\t\t\t\treturn true;\n\t\t\tfor (Type lowerBound : ((CaptureType) superType).getLowerBounds()) {\n\t\t\t\tif (isSuperType(lowerBound, subType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (superType instanceof GenericArrayType) {\n\t\t\treturn isArraySupertype(superType, subType);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"not implemented: \" + superType.getClass());\n\t\t}\n\t}", "code_tokens": ["public", "static", "boolean", "isSuperType", "(", "Type", "superType", ",", "Type", "subType", ")", "{", "if", "(", "superType", "instanceof", "ParameterizedType", "||", "superType", "instanceof", "Class", "||", "superType", "instanceof", "GenericArrayType", ")", "{", "Class", "<", "?", ">", "superClass", "=", "erase", "(", "superType", ")", ";", "Type", "mappedSubType", "=", "getExactSuperType", "(", "capture", "(", "subType", ")", ",", "superClass", ")", ";", "if", "(", "mappedSubType", "==", "null", ")", "{", "return", "false", ";", "}", "else", "if", "(", "superType", "instanceof", "Class", "<", "?", ">", ")", "{", "return", "true", ";", "}", "else", "if", "(", "mappedSubType", "instanceof", "Class", "<", "?", ">", ")", "{", "// TODO treat supertype by being raw type differently (\"supertype, but with warnings\")", "return", "true", ";", "// class has no parameters, or it's a raw type", "}", "else", "if", "(", "mappedSubType", "instanceof", "GenericArrayType", ")", "{", "Type", "superComponentType", "=", "getArrayComponentType", "(", "superType", ")", ";", "assert", "superComponentType", "!=", "null", ";", "Type", "mappedSubComponentType", "=", "getArrayComponentType", "(", "mappedSubType", ")", ";", "assert", "mappedSubComponentType", "!=", "null", ";", "return", "isSuperType", "(", "superComponentType", ",", "mappedSubComponentType", ")", ";", "}", "else", "{", "assert", "mappedSubType", "instanceof", "ParameterizedType", ";", "ParameterizedType", "pMappedSubType", "=", "(", "ParameterizedType", ")", "mappedSubType", ";", "assert", "pMappedSubType", ".", "getRawType", "(", ")", "==", "superClass", ";", "ParameterizedType", "pSuperType", "=", "(", "ParameterizedType", ")", "superType", ";", "Type", "[", "]", "superTypeArgs", "=", "pSuperType", ".", "getActualTypeArguments", "(", ")", ";", "Type", "[", "]", "subTypeArgs", "=", "pMappedSubType", ".", "getActualTypeArguments", "(", ")", ";", "assert", "superTypeArgs", ".", "length", "==", "subTypeArgs", ".", "length", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "superTypeArgs", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "contains", "(", "superTypeArgs", "[", "i", "]", ",", "subTypeArgs", "[", "i", "]", ")", ")", "{", "return", "false", ";", "}", "}", "// params of the class itself match, so if the owner types are supertypes too, it's a supertype.", "return", "pSuperType", ".", "getOwnerType", "(", ")", "==", "null", "||", "isSuperType", "(", "pSuperType", ".", "getOwnerType", "(", ")", ",", "pMappedSubType", ".", "getOwnerType", "(", ")", ")", ";", "}", "}", "else", "if", "(", "superType", "instanceof", "CaptureType", ")", "{", "if", "(", "superType", ".", "equals", "(", "subType", ")", ")", "return", "true", ";", "for", "(", "Type", "lowerBound", ":", "(", "(", "CaptureType", ")", "superType", ")", ".", "getLowerBounds", "(", ")", ")", "{", "if", "(", "isSuperType", "(", "lowerBound", ",", "subType", ")", ")", "{", "return", "true", ";", "}", "}", "return", "false", ";", "}", "else", "if", "(", "superType", "instanceof", "GenericArrayType", ")", "{", "return", "isArraySupertype", "(", "superType", ",", "subType", ")", ";", "}", "else", "{", "throw", "new", "RuntimeException", "(", "\"not implemented: \"", "+", "superType", ".", "getClass", "(", ")", ")", ";", "}", "}"], "docstring": "Checks if the capture of subType is a subtype of superType", "docstring_tokens": ["Checks", "if", "the", "capture", "of", "subType", "is", "a", "subtype", "of", "superType"]}
{"code": "deferred = null;", "comments": "reset this because it might get filled with more", "lines": 6, "repo": "objectify/objectify", "path": "src/main/java/com/googlecode/objectify/impl/translate/LoadContext.java", "func_name": "LoadContext.done", "original_string": "public void done() {\n\t\tengine.execute();\n\n\t\twhile (deferred != null) {\n\t\t\tfinal List<Runnable> runme = deferred;\n\t\t\tdeferred = null;\t// reset this because it might get filled with more\n\n\t\t\tfor (final Runnable run: runme) {\n\t\t\t\tlog.trace(\"Executing {}\", run);\n\t\t\t\trun.run();\n\t\t\t}\n\t\t}\n\t}", "language": "java", "Allcodes": "public void done() {\n\t\tengine.execute();\n\n\t\twhile (deferred != null) {\n\t\t\tfinal List<Runnable> runme = deferred;\n\t\t\tdeferred = null;\t// reset this because it might get filled with more\n\n\t\t\tfor (final Runnable run: runme) {\n\t\t\t\tlog.trace(\"Executing {}\", run);\n\t\t\t\trun.run();\n\t\t\t}\n\t\t}\n\t}", "code_tokens": ["public", "void", "done", "(", ")", "{", "engine", ".", "execute", "(", ")", ";", "while", "(", "deferred", "!=", "null", ")", "{", "final", "List", "<", "Runnable", ">", "runme", "=", "deferred", ";", "deferred", "=", "null", ";", "// reset this because it might get filled with more", "for", "(", "final", "Runnable", "run", ":", "runme", ")", "{", "log", ".", "trace", "(", "\"Executing {}\"", ",", "run", ")", ";", "run", ".", "run", "(", ")", ";", "}", "}", "}"], "docstring": "Call this when a load process completes.  Executes anything in the batch and then executes any delayed operations.", "docstring_tokens": ["Call", "this", "when", "a", "load", "process", "completes", ".", "Executes", "anything", "in", "the", "batch", "and", "then", "executes", "any", "delayed", "operations", "."]}
{"code": ": getPropertyFromContainer(container, containerPath);", "comments": "will throw SkipException if property not present", "lines": 9, "repo": "objectify/objectify", "path": "src/main/java/com/googlecode/objectify/impl/PropertyPopulator.java", "func_name": "PropertyPopulator.load", "original_string": "@Override\n\tpublic void load(final FullEntity<?> container, final LoadContext ctx, final Path containerPath, final P intoPojo) {\n\t\ttry {\n\t\t\tif (translator instanceof Recycles)\n\t\t\t\tctx.recycle(property.get(intoPojo));\n\n\t\t\tfinal Value<D> value = (translator instanceof Synthetic)\n\t\t\t\t? null\n\t\t\t\t: getPropertyFromContainer(container, containerPath);\t// will throw SkipException if property not present\n\n\t\t\tsetValue(intoPojo, value, ctx, containerPath);\n\t\t}\n\t\tcatch (SkipException ex) {\n\t\t\t// Irrelevant\n\t\t}\n\t}", "language": "java", "Allcodes": "@Override\n\tpublic void load(final FullEntity<?> container, final LoadContext ctx, final Path containerPath, final P intoPojo) {\n\t\ttry {\n\t\t\tif (translator instanceof Recycles)\n\t\t\t\tctx.recycle(property.get(intoPojo));\n\n\t\t\tfinal Value<D> value = (translator instanceof Synthetic)\n\t\t\t\t? null\n\t\t\t\t: getPropertyFromContainer(container, containerPath);\t// will throw SkipException if property not present\n\n\t\t\tsetValue(intoPojo, value, ctx, containerPath);\n\t\t}\n\t\tcatch (SkipException ex) {\n\t\t\t// Irrelevant\n\t\t}\n\t}", "code_tokens": ["@", "Override", "public", "void", "load", "(", "final", "FullEntity", "<", "?", ">", "container", ",", "final", "LoadContext", "ctx", ",", "final", "Path", "containerPath", ",", "final", "P", "intoPojo", ")", "{", "try", "{", "if", "(", "translator", "instanceof", "Recycles", ")", "ctx", ".", "recycle", "(", "property", ".", "get", "(", "intoPojo", ")", ")", ";", "final", "Value", "<", "D", ">", "value", "=", "(", "translator", "instanceof", "Synthetic", ")", "?", "null", ":", "getPropertyFromContainer", "(", "container", ",", "containerPath", ")", ";", "// will throw SkipException if property not present", "setValue", "(", "intoPojo", ",", "value", ",", "ctx", ",", "containerPath", ")", ";", "}", "catch", "(", "SkipException", "ex", ")", "{", "// Irrelevant", "}", "}"], "docstring": "Gets the appropriate value from the container and sets it on the appropriate field of the pojo.", "docstring_tokens": ["Gets", "the", "appropriate", "value", "from", "the", "container", "and", "sets", "it", "on", "the", "appropriate", "field", "of", "the", "pojo", "."]}
{"code": "return;", "comments": "avoid DOM006 Hierarchy request error", "lines": 5, "repo": "DigitalPebble/storm-crawler", "path": "external/tika/src/main/java/com/digitalpebble/stormcrawler/tika/DOMBuilder.java", "func_name": "DOMBuilder.ignorableWhitespace", "original_string": "@Override\n    public void ignorableWhitespace(char ch[], int start, int length)\n            throws org.xml.sax.SAXException {\n        if (isOutsideDocElem()) {\n            return; // avoid DOM006 Hierarchy request error\n        }\n\n        String s = new String(ch, start, length);\n\n        append(m_doc.createTextNode(s));\n    }", "language": "java", "Allcodes": "@Override\n    public void ignorableWhitespace(char ch[], int start, int length)\n            throws org.xml.sax.SAXException {\n        if (isOutsideDocElem()) {\n            return; // avoid DOM006 Hierarchy request error\n        }\n\n        String s = new String(ch, start, length);\n\n        append(m_doc.createTextNode(s));\n    }", "code_tokens": ["@", "Override", "public", "void", "ignorableWhitespace", "(", "char", "ch", "[", "]", ",", "int", "start", ",", "int", "length", ")", "throws", "org", ".", "xml", ".", "sax", ".", "SAXException", "{", "if", "(", "isOutsideDocElem", "(", ")", ")", "{", "return", ";", "// avoid DOM006 Hierarchy request error", "}", "String", "s", "=", "new", "String", "(", "ch", ",", "start", ",", "length", ")", ";", "append", "(", "m_doc", ".", "createTextNode", "(", "s", ")", ")", ";", "}"], "docstring": "Receive notification of ignorable whitespace in element content.\n\n<p>\nValidating Parsers must use this method to report each chunk of ignorable\nwhitespace (see the W3C XML 1.0 recommendation, section 2.10):\nnon-validating parsers may also use this method if they are capable of\nparsing and using content models.\n</p>\n\n<p>\nSAX parsers may return all contiguous whitespace in a single chunk, or\nthey may split it into several chunks; however, all of the characters in\nany single event must come from the same external entity, so that the\nLocator provides useful information.\n</p>\n\n<p>\nThe application must not attempt to read from the array outside of the\nspecified range.\n</p>\n\n@param ch\nThe characters from the XML document.\n@param start\nThe start position in the array.\n@param length\nThe number of characters to read from the array.\n@see #characters", "docstring_tokens": ["Receive", "notification", "of", "ignorable", "whitespace", "in", "element", "content", "."]}
{"code": "* elem.getAttribute(qname);", "comments": "Obsolete, should be DOM2...? if(val ==", "lines": 13, "repo": "DigitalPebble/storm-crawler", "path": "external/tika/src/main/java/com/digitalpebble/stormcrawler/tika/DOMBuilder.java", "func_name": "DOMBuilder.startPrefixMapping", "original_string": "@Override\n    public void startPrefixMapping(String prefix, String uri)\n            throws org.xml.sax.SAXException {\n\n        /*\n         * // Not sure if this is needed or wanted // Also, it fails in the\n         * stree. if((null != m_currentNode) && (m_currentNode.getNodeType() ==\n         * Node.ELEMENT_NODE)) { String qname; if(((null != prefix) &&\n         * (prefix.length() == 0)) || (null == prefix)) qname = \"xmlns\"; else\n         * qname = \"xmlns:\"+prefix;\n         * \n         * Element elem = (Element)m_currentNode; String val =\n         * elem.getAttribute(qname); // Obsolete, should be DOM2...? if(val ==\n         * null) { elem.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\",\n         * qname, uri); } }\n         */\n    }", "language": "java", "Allcodes": "@Override\n    public void startPrefixMapping(String prefix, String uri)\n            throws org.xml.sax.SAXException {\n\n        /*\n         * // Not sure if this is needed or wanted // Also, it fails in the\n         * stree. if((null != m_currentNode) && (m_currentNode.getNodeType() ==\n         * Node.ELEMENT_NODE)) { String qname; if(((null != prefix) &&\n         * (prefix.length() == 0)) || (null == prefix)) qname = \"xmlns\"; else\n         * qname = \"xmlns:\"+prefix;\n         * \n         * Element elem = (Element)m_currentNode; String val =\n         * elem.getAttribute(qname); // Obsolete, should be DOM2...? if(val ==\n         * null) { elem.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\",\n         * qname, uri); } }\n         */\n    }", "code_tokens": ["@", "Override", "public", "void", "startPrefixMapping", "(", "String", "prefix", ",", "String", "uri", ")", "throws", "org", ".", "xml", ".", "sax", ".", "SAXException", "{", "/*\n         * // Not sure if this is needed or wanted // Also, it fails in the\n         * stree. if((null != m_currentNode) && (m_currentNode.getNodeType() ==\n         * Node.ELEMENT_NODE)) { String qname; if(((null != prefix) &&\n         * (prefix.length() == 0)) || (null == prefix)) qname = \"xmlns\"; else\n         * qname = \"xmlns:\"+prefix;\n         * \n         * Element elem = (Element)m_currentNode; String val =\n         * elem.getAttribute(qname); // Obsolete, should be DOM2...? if(val ==\n         * null) { elem.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\",\n         * qname, uri); } }\n         */", "}"], "docstring": "Begin the scope of a prefix-URI Namespace mapping.\n\n<p>\nThe information from this event is not necessary for normal Namespace\nprocessing: the SAX XML reader will automatically replace prefixes for\nelement and attribute names when the\nhttp://xml.org/sax/features/namespaces feature is true (the default).\n</p>\n\n<p>\nThere are cases, however, when applications need to use prefixes in\ncharacter data or in attribute values, where they cannot safely be\nexpanded automatically; the start/endPrefixMapping event supplies the\ninformation to the application to expand prefixes in those contexts\nitself, if necessary.\n</p>\n\n<p>\nNote that start/endPrefixMapping events are not guaranteed to be properly\nnested relative to each-other: all startPrefixMapping events will occur\nbefore the corresponding startElement event, and all endPrefixMapping\nevents will occur after the corresponding endElement event, but their\norder is not guaranteed.\n</p>\n\n@param prefix\nThe Namespace prefix being declared.\n@param uri\nThe Namespace URI the prefix is mapped to.\n@see #endPrefixMapping\n@see #startElement", "docstring_tokens": ["Begin", "the", "scope", "of", "a", "prefix", "-", "URI", "Namespace", "mapping", "."]}
{"code": "e.printStackTrace();", "comments": "cant happen.", "lines": 26, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/ArrayChar.java", "func_name": "ArrayChar.makeFromStringArray", "original_string": "public static ArrayChar makeFromStringArray(ArrayObject values, int strlen) {\r\n\r\n    // create shape for equivilent charArray\r\n    try {\r\n      Section section = new Section(values.getShape());\r\n      section.appendRange(strlen);\r\n\r\n      int[] shape = section.getShape();\r\n      long size = section.computeSize();\r\n\r\n      // populate char array\r\n      char[] cdata = new char[(int) size];\r\n      int start = 0;\r\n      IndexIterator ii = values.getIndexIterator();\r\n      while (ii.hasNext()) {\r\n        String s = (String) ii.next();\r\n        for (int k = 0; k < s.length() && k < strlen; k++)\r\n          cdata[start + k] = s.charAt(k);\r\n        start += strlen;\r\n      }\r\n\r\n      // ready to create the char Array\r\n      Array carr = Array.factory(DataType.CHAR, shape, cdata);\r\n      return (ArrayChar) carr;\r\n    } catch (InvalidRangeException e) {\r\n      e.printStackTrace();  // cant happen.\r\n      return null;\r\n    }\r\n  }", "language": "java", "Allcodes": "public static ArrayChar makeFromStringArray(ArrayObject values, int strlen) {\r\n\r\n    // create shape for equivilent charArray\r\n    try {\r\n      Section section = new Section(values.getShape());\r\n      section.appendRange(strlen);\r\n\r\n      int[] shape = section.getShape();\r\n      long size = section.computeSize();\r\n\r\n      // populate char array\r\n      char[] cdata = new char[(int) size];\r\n      int start = 0;\r\n      IndexIterator ii = values.getIndexIterator();\r\n      while (ii.hasNext()) {\r\n        String s = (String) ii.next();\r\n        for (int k = 0; k < s.length() && k < strlen; k++)\r\n          cdata[start + k] = s.charAt(k);\r\n        start += strlen;\r\n      }\r\n\r\n      // ready to create the char Array\r\n      Array carr = Array.factory(DataType.CHAR, shape, cdata);\r\n      return (ArrayChar) carr;\r\n    } catch (InvalidRangeException e) {\r\n      e.printStackTrace();  // cant happen.\r\n      return null;\r\n    }\r\n  }", "code_tokens": ["public", "static", "ArrayChar", "makeFromStringArray", "(", "ArrayObject", "values", ",", "int", "strlen", ")", "{", "// create shape for equivilent charArray\r", "try", "{", "Section", "section", "=", "new", "Section", "(", "values", ".", "getShape", "(", ")", ")", ";", "section", ".", "appendRange", "(", "strlen", ")", ";", "int", "[", "]", "shape", "=", "section", ".", "getShape", "(", ")", ";", "long", "size", "=", "section", ".", "computeSize", "(", ")", ";", "// populate char array\r", "char", "[", "]", "cdata", "=", "new", "char", "[", "(", "int", ")", "size", "]", ";", "int", "start", "=", "0", ";", "IndexIterator", "ii", "=", "values", ".", "getIndexIterator", "(", ")", ";", "while", "(", "ii", ".", "hasNext", "(", ")", ")", "{", "String", "s", "=", "(", "String", ")", "ii", ".", "next", "(", ")", ";", "for", "(", "int", "k", "=", "0", ";", "k", "<", "s", ".", "length", "(", ")", "&&", "k", "<", "strlen", ";", "k", "++", ")", "cdata", "[", "start", "+", "k", "]", "=", "s", ".", "charAt", "(", "k", ")", ";", "start", "+=", "strlen", ";", "}", "// ready to create the char Array\r", "Array", "carr", "=", "Array", ".", "factory", "(", "DataType", ".", "CHAR", ",", "shape", ",", "cdata", ")", ";", "return", "(", "ArrayChar", ")", "carr", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "// cant happen.\r", "return", "null", ";", "}", "}"], "docstring": "Create an ArrayChar from an ArrayObject of Strings.\nInverse of make1DStringArray. Copies the data.\n\n@param values ArrayObject of String\n@param strlen string length dimension size\n@return equivilent ArrayChar. Unused are zero filled.", "docstring_tokens": ["Create", "an", "ArrayChar", "from", "an", "ArrayObject", "of", "Strings", ".", "Inverse", "of", "make1DStringArray", ".", "Copies", "the", "data", "."]}
{"code": "setState( Frame.NORMAL );", "comments": "deiconify if needed", "lines": 2, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/IndependentWindow.java", "func_name": "IndependentWindow.show", "original_string": "public void show() {\r\n    setState( Frame.NORMAL );   // deiconify if needed\r\n    super.toFront();\r\n    // need to put on event thread\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n      public void run() {\r\n        IndependentWindow.super.show();\r\n      }\r\n    });\r\n  }", "language": "java", "Allcodes": "public void show() {\r\n    setState( Frame.NORMAL );   // deiconify if needed\r\n    super.toFront();\r\n    // need to put on event thread\r\n    SwingUtilities.invokeLater(new Runnable() {\r\n      public void run() {\r\n        IndependentWindow.super.show();\r\n      }\r\n    });\r\n  }", "code_tokens": ["public", "void", "show", "(", ")", "{", "setState", "(", "Frame", ".", "NORMAL", ")", ";", "// deiconify if needed\r", "super", ".", "toFront", "(", ")", ";", "// need to put on event thread\r", "SwingUtilities", ".", "invokeLater", "(", "new", "Runnable", "(", ")", "{", "public", "void", "run", "(", ")", "{", "IndependentWindow", ".", "super", ".", "show", "(", ")", ";", "}", "}", ")", ";", "}"], "docstring": "show the window.", "docstring_tokens": ["show", "the", "window", "."]}
{"code": "MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog);", "comments": "LOOK we dont have a name", "lines": 24, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/FeatureDatasetFactoryManager.java", "func_name": "FeatureDatasetFactoryManager.open", "original_string": "static public FeatureDataset open(FeatureType wantFeatureType, String location, ucar.nc2.util.CancelTask task, Formatter errlog) throws IOException {\r\n\r\n    // special processing for thredds: datasets\r\n    if (location.startsWith(DataFactory.SCHEME)) {\r\n      DataFactory.Result result = new DataFactory().openFeatureDataset(wantFeatureType, location, task);\r\n      errlog.format(\"%s\", result.errLog);\r\n      if (!featureTypeOk(wantFeatureType, result.featureType)) {\r\n        errlog.format(\"wanted %s but dataset is of type %s%n\", wantFeatureType, result.featureType);\r\n        result.close();\r\n        return null;\r\n      }\r\n      return result.featureDataset;\r\n\r\n      // special processing for cdmrFeature: datasets\r\n    } else if (location.startsWith(CdmrFeatureDataset.SCHEME)) {\r\n      Optional<FeatureDataset> opt = CdmrFeatureDataset.factory(wantFeatureType, location);\r\n      if (opt.isPresent()) return opt.get();\r\n      errlog.format(\"%s\", opt.getErrorMessage());\r\n      return null;\r\n\r\n      // special processing for collection: datasets\r\n    } else if (location.startsWith(ucar.nc2.ft.point.collection.CompositeDatasetFactory.SCHEME)) {\r\n      String spec = location.substring(CompositeDatasetFactory.SCHEME.length());\r\n      MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog); // LOOK we dont have a name\r\n      return CompositeDatasetFactory.factory(location, wantFeatureType, dcm, errlog);\r\n    }\r\n\r\n    DatasetUrl durl = DatasetUrl.findDatasetUrl(location); // Cache ServiceType so we don't have to keep figuring it out\r\n    if (durl.serviceType == null) { // skip GRIB check for anything not a plain ole file\r\n      // check if its GRIB, may not have to go through NetcdfDataset\r\n      Optional<FeatureDatasetCoverage> opt = CoverageDatasetFactory.openGrib(location);\r\n      if (opt.isPresent()) { // its a GRIB file\r\n        return opt.get();\r\n\r\n      } else if (!opt.getErrorMessage().startsWith(CoverageDatasetFactory.NOT_GRIB_FILE) &&\r\n              !opt.getErrorMessage().startsWith(CoverageDatasetFactory.NO_GRIB_CLASS)) {\r\n        errlog.format(\"%s%n\", opt.getErrorMessage()); // its a GRIB file with an error\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r\n    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);\r\n    FeatureDataset fd = wrap(wantFeatureType, ncd, task, errlog);\r\n    if (fd == null)\r\n      ncd.close();\r\n    return fd;\r\n  }", "language": "java", "Allcodes": "static public FeatureDataset open(FeatureType wantFeatureType, String location, ucar.nc2.util.CancelTask task, Formatter errlog) throws IOException {\r\n\r\n    // special processing for thredds: datasets\r\n    if (location.startsWith(DataFactory.SCHEME)) {\r\n      DataFactory.Result result = new DataFactory().openFeatureDataset(wantFeatureType, location, task);\r\n      errlog.format(\"%s\", result.errLog);\r\n      if (!featureTypeOk(wantFeatureType, result.featureType)) {\r\n        errlog.format(\"wanted %s but dataset is of type %s%n\", wantFeatureType, result.featureType);\r\n        result.close();\r\n        return null;\r\n      }\r\n      return result.featureDataset;\r\n\r\n      // special processing for cdmrFeature: datasets\r\n    } else if (location.startsWith(CdmrFeatureDataset.SCHEME)) {\r\n      Optional<FeatureDataset> opt = CdmrFeatureDataset.factory(wantFeatureType, location);\r\n      if (opt.isPresent()) return opt.get();\r\n      errlog.format(\"%s\", opt.getErrorMessage());\r\n      return null;\r\n\r\n      // special processing for collection: datasets\r\n    } else if (location.startsWith(ucar.nc2.ft.point.collection.CompositeDatasetFactory.SCHEME)) {\r\n      String spec = location.substring(CompositeDatasetFactory.SCHEME.length());\r\n      MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog); // LOOK we dont have a name\r\n      return CompositeDatasetFactory.factory(location, wantFeatureType, dcm, errlog);\r\n    }\r\n\r\n    DatasetUrl durl = DatasetUrl.findDatasetUrl(location); // Cache ServiceType so we don't have to keep figuring it out\r\n    if (durl.serviceType == null) { // skip GRIB check for anything not a plain ole file\r\n      // check if its GRIB, may not have to go through NetcdfDataset\r\n      Optional<FeatureDatasetCoverage> opt = CoverageDatasetFactory.openGrib(location);\r\n      if (opt.isPresent()) { // its a GRIB file\r\n        return opt.get();\r\n\r\n      } else if (!opt.getErrorMessage().startsWith(CoverageDatasetFactory.NOT_GRIB_FILE) &&\r\n              !opt.getErrorMessage().startsWith(CoverageDatasetFactory.NO_GRIB_CLASS)) {\r\n        errlog.format(\"%s%n\", opt.getErrorMessage()); // its a GRIB file with an error\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r\n    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);\r\n    FeatureDataset fd = wrap(wantFeatureType, ncd, task, errlog);\r\n    if (fd == null)\r\n      ncd.close();\r\n    return fd;\r\n  }", "code_tokens": ["static", "public", "FeatureDataset", "open", "(", "FeatureType", "wantFeatureType", ",", "String", "location", ",", "ucar", ".", "nc2", ".", "util", ".", "CancelTask", "task", ",", "Formatter", "errlog", ")", "throws", "IOException", "{", "// special processing for thredds: datasets\r", "if", "(", "location", ".", "startsWith", "(", "DataFactory", ".", "SCHEME", ")", ")", "{", "DataFactory", ".", "Result", "result", "=", "new", "DataFactory", "(", ")", ".", "openFeatureDataset", "(", "wantFeatureType", ",", "location", ",", "task", ")", ";", "errlog", ".", "format", "(", "\"%s\"", ",", "result", ".", "errLog", ")", ";", "if", "(", "!", "featureTypeOk", "(", "wantFeatureType", ",", "result", ".", "featureType", ")", ")", "{", "errlog", ".", "format", "(", "\"wanted %s but dataset is of type %s%n\"", ",", "wantFeatureType", ",", "result", ".", "featureType", ")", ";", "result", ".", "close", "(", ")", ";", "return", "null", ";", "}", "return", "result", ".", "featureDataset", ";", "// special processing for cdmrFeature: datasets\r", "}", "else", "if", "(", "location", ".", "startsWith", "(", "CdmrFeatureDataset", ".", "SCHEME", ")", ")", "{", "Optional", "<", "FeatureDataset", ">", "opt", "=", "CdmrFeatureDataset", ".", "factory", "(", "wantFeatureType", ",", "location", ")", ";", "if", "(", "opt", ".", "isPresent", "(", ")", ")", "return", "opt", ".", "get", "(", ")", ";", "errlog", ".", "format", "(", "\"%s\"", ",", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "return", "null", ";", "// special processing for collection: datasets\r", "}", "else", "if", "(", "location", ".", "startsWith", "(", "ucar", ".", "nc2", ".", "ft", ".", "point", ".", "collection", ".", "CompositeDatasetFactory", ".", "SCHEME", ")", ")", "{", "String", "spec", "=", "location", ".", "substring", "(", "CompositeDatasetFactory", ".", "SCHEME", ".", "length", "(", ")", ")", ";", "MFileCollectionManager", "dcm", "=", "MFileCollectionManager", ".", "open", "(", "spec", ",", "spec", ",", "null", ",", "errlog", ")", ";", "// LOOK we dont have a name\r", "return", "CompositeDatasetFactory", ".", "factory", "(", "location", ",", "wantFeatureType", ",", "dcm", ",", "errlog", ")", ";", "}", "DatasetUrl", "durl", "=", "DatasetUrl", ".", "findDatasetUrl", "(", "location", ")", ";", "// Cache ServiceType so we don't have to keep figuring it out\r", "if", "(", "durl", ".", "serviceType", "==", "null", ")", "{", "// skip GRIB check for anything not a plain ole file\r", "// check if its GRIB, may not have to go through NetcdfDataset\r", "Optional", "<", "FeatureDatasetCoverage", ">", "opt", "=", "CoverageDatasetFactory", ".", "openGrib", "(", "location", ")", ";", "if", "(", "opt", ".", "isPresent", "(", ")", ")", "{", "// its a GRIB file\r", "return", "opt", ".", "get", "(", ")", ";", "}", "else", "if", "(", "!", "opt", ".", "getErrorMessage", "(", ")", ".", "startsWith", "(", "CoverageDatasetFactory", ".", "NOT_GRIB_FILE", ")", "&&", "!", "opt", ".", "getErrorMessage", "(", ")", ".", "startsWith", "(", "CoverageDatasetFactory", ".", "NO_GRIB_CLASS", ")", ")", "{", "errlog", ".", "format", "(", "\"%s%n\"", ",", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "// its a GRIB file with an error\r", "return", "null", ";", "}", "}", "// otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r", "NetcdfDataset", "ncd", "=", "NetcdfDataset", ".", "acquireDataset", "(", "durl", ",", "true", ",", "task", ")", ";", "FeatureDataset", "fd", "=", "wrap", "(", "wantFeatureType", ",", "ncd", ",", "task", ",", "errlog", ")", ";", "if", "(", "fd", "==", "null", ")", "ncd", ".", "close", "(", ")", ";", "return", "fd", ";", "}"], "docstring": "Open a dataset as a FeatureDataset.\n\n@param wantFeatureType open this kind of FeatureDataset; may be null, which means search all factories.\nIf datatype is not null, only return correct FeatureDataset (eg PointFeatureDataset for DataType.POINT).\n@param location        URL or file location of the dataset. This may be a\n<ol>\n<li>thredds catalog#dataset (with a thredds: prefix)\n<li>cdmrFeature dataset (with a cdmrFeature: prefix)\n<li>cdmremote dataset (with a cdmremote: prefix)\n<li>collection dataset (with a collection: prefix)\n<li>file location for a CDM dataset opened with NetcdfDataset.acquireDataset()\n</ol>\n@param task            user may cancel\n@param errlog          place errors here, may not be null\n@return a subclass of FeatureDataset, or null if no suitable factory was found, message in errlog\n@throws java.io.IOException on io error", "docstring_tokens": ["Open", "a", "dataset", "as", "a", "FeatureDataset", "."]}
{"code": "DatasetUrl durl = DatasetUrl.findDatasetUrl(location);", "comments": "Cache ServiceType so we don't have to keep figuring it out", "lines": 28, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/FeatureDatasetFactoryManager.java", "func_name": "FeatureDatasetFactoryManager.open", "original_string": "static public FeatureDataset open(FeatureType wantFeatureType, String location, ucar.nc2.util.CancelTask task, Formatter errlog) throws IOException {\r\n\r\n    // special processing for thredds: datasets\r\n    if (location.startsWith(DataFactory.SCHEME)) {\r\n      DataFactory.Result result = new DataFactory().openFeatureDataset(wantFeatureType, location, task);\r\n      errlog.format(\"%s\", result.errLog);\r\n      if (!featureTypeOk(wantFeatureType, result.featureType)) {\r\n        errlog.format(\"wanted %s but dataset is of type %s%n\", wantFeatureType, result.featureType);\r\n        result.close();\r\n        return null;\r\n      }\r\n      return result.featureDataset;\r\n\r\n      // special processing for cdmrFeature: datasets\r\n    } else if (location.startsWith(CdmrFeatureDataset.SCHEME)) {\r\n      Optional<FeatureDataset> opt = CdmrFeatureDataset.factory(wantFeatureType, location);\r\n      if (opt.isPresent()) return opt.get();\r\n      errlog.format(\"%s\", opt.getErrorMessage());\r\n      return null;\r\n\r\n      // special processing for collection: datasets\r\n    } else if (location.startsWith(ucar.nc2.ft.point.collection.CompositeDatasetFactory.SCHEME)) {\r\n      String spec = location.substring(CompositeDatasetFactory.SCHEME.length());\r\n      MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog); // LOOK we dont have a name\r\n      return CompositeDatasetFactory.factory(location, wantFeatureType, dcm, errlog);\r\n    }\r\n\r\n    DatasetUrl durl = DatasetUrl.findDatasetUrl(location); // Cache ServiceType so we don't have to keep figuring it out\r\n    if (durl.serviceType == null) { // skip GRIB check for anything not a plain ole file\r\n      // check if its GRIB, may not have to go through NetcdfDataset\r\n      Optional<FeatureDatasetCoverage> opt = CoverageDatasetFactory.openGrib(location);\r\n      if (opt.isPresent()) { // its a GRIB file\r\n        return opt.get();\r\n\r\n      } else if (!opt.getErrorMessage().startsWith(CoverageDatasetFactory.NOT_GRIB_FILE) &&\r\n              !opt.getErrorMessage().startsWith(CoverageDatasetFactory.NO_GRIB_CLASS)) {\r\n        errlog.format(\"%s%n\", opt.getErrorMessage()); // its a GRIB file with an error\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r\n    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);\r\n    FeatureDataset fd = wrap(wantFeatureType, ncd, task, errlog);\r\n    if (fd == null)\r\n      ncd.close();\r\n    return fd;\r\n  }", "language": "java", "Allcodes": "static public FeatureDataset open(FeatureType wantFeatureType, String location, ucar.nc2.util.CancelTask task, Formatter errlog) throws IOException {\r\n\r\n    // special processing for thredds: datasets\r\n    if (location.startsWith(DataFactory.SCHEME)) {\r\n      DataFactory.Result result = new DataFactory().openFeatureDataset(wantFeatureType, location, task);\r\n      errlog.format(\"%s\", result.errLog);\r\n      if (!featureTypeOk(wantFeatureType, result.featureType)) {\r\n        errlog.format(\"wanted %s but dataset is of type %s%n\", wantFeatureType, result.featureType);\r\n        result.close();\r\n        return null;\r\n      }\r\n      return result.featureDataset;\r\n\r\n      // special processing for cdmrFeature: datasets\r\n    } else if (location.startsWith(CdmrFeatureDataset.SCHEME)) {\r\n      Optional<FeatureDataset> opt = CdmrFeatureDataset.factory(wantFeatureType, location);\r\n      if (opt.isPresent()) return opt.get();\r\n      errlog.format(\"%s\", opt.getErrorMessage());\r\n      return null;\r\n\r\n      // special processing for collection: datasets\r\n    } else if (location.startsWith(ucar.nc2.ft.point.collection.CompositeDatasetFactory.SCHEME)) {\r\n      String spec = location.substring(CompositeDatasetFactory.SCHEME.length());\r\n      MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog); // LOOK we dont have a name\r\n      return CompositeDatasetFactory.factory(location, wantFeatureType, dcm, errlog);\r\n    }\r\n\r\n    DatasetUrl durl = DatasetUrl.findDatasetUrl(location); // Cache ServiceType so we don't have to keep figuring it out\r\n    if (durl.serviceType == null) { // skip GRIB check for anything not a plain ole file\r\n      // check if its GRIB, may not have to go through NetcdfDataset\r\n      Optional<FeatureDatasetCoverage> opt = CoverageDatasetFactory.openGrib(location);\r\n      if (opt.isPresent()) { // its a GRIB file\r\n        return opt.get();\r\n\r\n      } else if (!opt.getErrorMessage().startsWith(CoverageDatasetFactory.NOT_GRIB_FILE) &&\r\n              !opt.getErrorMessage().startsWith(CoverageDatasetFactory.NO_GRIB_CLASS)) {\r\n        errlog.format(\"%s%n\", opt.getErrorMessage()); // its a GRIB file with an error\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r\n    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);\r\n    FeatureDataset fd = wrap(wantFeatureType, ncd, task, errlog);\r\n    if (fd == null)\r\n      ncd.close();\r\n    return fd;\r\n  }", "code_tokens": ["static", "public", "FeatureDataset", "open", "(", "FeatureType", "wantFeatureType", ",", "String", "location", ",", "ucar", ".", "nc2", ".", "util", ".", "CancelTask", "task", ",", "Formatter", "errlog", ")", "throws", "IOException", "{", "// special processing for thredds: datasets\r", "if", "(", "location", ".", "startsWith", "(", "DataFactory", ".", "SCHEME", ")", ")", "{", "DataFactory", ".", "Result", "result", "=", "new", "DataFactory", "(", ")", ".", "openFeatureDataset", "(", "wantFeatureType", ",", "location", ",", "task", ")", ";", "errlog", ".", "format", "(", "\"%s\"", ",", "result", ".", "errLog", ")", ";", "if", "(", "!", "featureTypeOk", "(", "wantFeatureType", ",", "result", ".", "featureType", ")", ")", "{", "errlog", ".", "format", "(", "\"wanted %s but dataset is of type %s%n\"", ",", "wantFeatureType", ",", "result", ".", "featureType", ")", ";", "result", ".", "close", "(", ")", ";", "return", "null", ";", "}", "return", "result", ".", "featureDataset", ";", "// special processing for cdmrFeature: datasets\r", "}", "else", "if", "(", "location", ".", "startsWith", "(", "CdmrFeatureDataset", ".", "SCHEME", ")", ")", "{", "Optional", "<", "FeatureDataset", ">", "opt", "=", "CdmrFeatureDataset", ".", "factory", "(", "wantFeatureType", ",", "location", ")", ";", "if", "(", "opt", ".", "isPresent", "(", ")", ")", "return", "opt", ".", "get", "(", ")", ";", "errlog", ".", "format", "(", "\"%s\"", ",", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "return", "null", ";", "// special processing for collection: datasets\r", "}", "else", "if", "(", "location", ".", "startsWith", "(", "ucar", ".", "nc2", ".", "ft", ".", "point", ".", "collection", ".", "CompositeDatasetFactory", ".", "SCHEME", ")", ")", "{", "String", "spec", "=", "location", ".", "substring", "(", "CompositeDatasetFactory", ".", "SCHEME", ".", "length", "(", ")", ")", ";", "MFileCollectionManager", "dcm", "=", "MFileCollectionManager", ".", "open", "(", "spec", ",", "spec", ",", "null", ",", "errlog", ")", ";", "// LOOK we dont have a name\r", "return", "CompositeDatasetFactory", ".", "factory", "(", "location", ",", "wantFeatureType", ",", "dcm", ",", "errlog", ")", ";", "}", "DatasetUrl", "durl", "=", "DatasetUrl", ".", "findDatasetUrl", "(", "location", ")", ";", "// Cache ServiceType so we don't have to keep figuring it out\r", "if", "(", "durl", ".", "serviceType", "==", "null", ")", "{", "// skip GRIB check for anything not a plain ole file\r", "// check if its GRIB, may not have to go through NetcdfDataset\r", "Optional", "<", "FeatureDatasetCoverage", ">", "opt", "=", "CoverageDatasetFactory", ".", "openGrib", "(", "location", ")", ";", "if", "(", "opt", ".", "isPresent", "(", ")", ")", "{", "// its a GRIB file\r", "return", "opt", ".", "get", "(", ")", ";", "}", "else", "if", "(", "!", "opt", ".", "getErrorMessage", "(", ")", ".", "startsWith", "(", "CoverageDatasetFactory", ".", "NOT_GRIB_FILE", ")", "&&", "!", "opt", ".", "getErrorMessage", "(", ")", ".", "startsWith", "(", "CoverageDatasetFactory", ".", "NO_GRIB_CLASS", ")", ")", "{", "errlog", ".", "format", "(", "\"%s%n\"", ",", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "// its a GRIB file with an error\r", "return", "null", ";", "}", "}", "// otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r", "NetcdfDataset", "ncd", "=", "NetcdfDataset", ".", "acquireDataset", "(", "durl", ",", "true", ",", "task", ")", ";", "FeatureDataset", "fd", "=", "wrap", "(", "wantFeatureType", ",", "ncd", ",", "task", ",", "errlog", ")", ";", "if", "(", "fd", "==", "null", ")", "ncd", ".", "close", "(", ")", ";", "return", "fd", ";", "}"], "docstring": "Open a dataset as a FeatureDataset.\n\n@param wantFeatureType open this kind of FeatureDataset; may be null, which means search all factories.\nIf datatype is not null, only return correct FeatureDataset (eg PointFeatureDataset for DataType.POINT).\n@param location        URL or file location of the dataset. This may be a\n<ol>\n<li>thredds catalog#dataset (with a thredds: prefix)\n<li>cdmrFeature dataset (with a cdmrFeature: prefix)\n<li>cdmremote dataset (with a cdmremote: prefix)\n<li>collection dataset (with a collection: prefix)\n<li>file location for a CDM dataset opened with NetcdfDataset.acquireDataset()\n</ol>\n@param task            user may cancel\n@param errlog          place errors here, may not be null\n@return a subclass of FeatureDataset, or null if no suitable factory was found, message in errlog\n@throws java.io.IOException on io error", "docstring_tokens": ["Open", "a", "dataset", "as", "a", "FeatureDataset", "."]}
{"code": "errlog.format(\"%s%n\", opt.getErrorMessage());", "comments": "its a GRIB file with an error", "lines": 37, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/FeatureDatasetFactoryManager.java", "func_name": "FeatureDatasetFactoryManager.open", "original_string": "static public FeatureDataset open(FeatureType wantFeatureType, String location, ucar.nc2.util.CancelTask task, Formatter errlog) throws IOException {\r\n\r\n    // special processing for thredds: datasets\r\n    if (location.startsWith(DataFactory.SCHEME)) {\r\n      DataFactory.Result result = new DataFactory().openFeatureDataset(wantFeatureType, location, task);\r\n      errlog.format(\"%s\", result.errLog);\r\n      if (!featureTypeOk(wantFeatureType, result.featureType)) {\r\n        errlog.format(\"wanted %s but dataset is of type %s%n\", wantFeatureType, result.featureType);\r\n        result.close();\r\n        return null;\r\n      }\r\n      return result.featureDataset;\r\n\r\n      // special processing for cdmrFeature: datasets\r\n    } else if (location.startsWith(CdmrFeatureDataset.SCHEME)) {\r\n      Optional<FeatureDataset> opt = CdmrFeatureDataset.factory(wantFeatureType, location);\r\n      if (opt.isPresent()) return opt.get();\r\n      errlog.format(\"%s\", opt.getErrorMessage());\r\n      return null;\r\n\r\n      // special processing for collection: datasets\r\n    } else if (location.startsWith(ucar.nc2.ft.point.collection.CompositeDatasetFactory.SCHEME)) {\r\n      String spec = location.substring(CompositeDatasetFactory.SCHEME.length());\r\n      MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog); // LOOK we dont have a name\r\n      return CompositeDatasetFactory.factory(location, wantFeatureType, dcm, errlog);\r\n    }\r\n\r\n    DatasetUrl durl = DatasetUrl.findDatasetUrl(location); // Cache ServiceType so we don't have to keep figuring it out\r\n    if (durl.serviceType == null) { // skip GRIB check for anything not a plain ole file\r\n      // check if its GRIB, may not have to go through NetcdfDataset\r\n      Optional<FeatureDatasetCoverage> opt = CoverageDatasetFactory.openGrib(location);\r\n      if (opt.isPresent()) { // its a GRIB file\r\n        return opt.get();\r\n\r\n      } else if (!opt.getErrorMessage().startsWith(CoverageDatasetFactory.NOT_GRIB_FILE) &&\r\n              !opt.getErrorMessage().startsWith(CoverageDatasetFactory.NO_GRIB_CLASS)) {\r\n        errlog.format(\"%s%n\", opt.getErrorMessage()); // its a GRIB file with an error\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r\n    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);\r\n    FeatureDataset fd = wrap(wantFeatureType, ncd, task, errlog);\r\n    if (fd == null)\r\n      ncd.close();\r\n    return fd;\r\n  }", "language": "java", "Allcodes": "static public FeatureDataset open(FeatureType wantFeatureType, String location, ucar.nc2.util.CancelTask task, Formatter errlog) throws IOException {\r\n\r\n    // special processing for thredds: datasets\r\n    if (location.startsWith(DataFactory.SCHEME)) {\r\n      DataFactory.Result result = new DataFactory().openFeatureDataset(wantFeatureType, location, task);\r\n      errlog.format(\"%s\", result.errLog);\r\n      if (!featureTypeOk(wantFeatureType, result.featureType)) {\r\n        errlog.format(\"wanted %s but dataset is of type %s%n\", wantFeatureType, result.featureType);\r\n        result.close();\r\n        return null;\r\n      }\r\n      return result.featureDataset;\r\n\r\n      // special processing for cdmrFeature: datasets\r\n    } else if (location.startsWith(CdmrFeatureDataset.SCHEME)) {\r\n      Optional<FeatureDataset> opt = CdmrFeatureDataset.factory(wantFeatureType, location);\r\n      if (opt.isPresent()) return opt.get();\r\n      errlog.format(\"%s\", opt.getErrorMessage());\r\n      return null;\r\n\r\n      // special processing for collection: datasets\r\n    } else if (location.startsWith(ucar.nc2.ft.point.collection.CompositeDatasetFactory.SCHEME)) {\r\n      String spec = location.substring(CompositeDatasetFactory.SCHEME.length());\r\n      MFileCollectionManager dcm = MFileCollectionManager.open(spec, spec, null, errlog); // LOOK we dont have a name\r\n      return CompositeDatasetFactory.factory(location, wantFeatureType, dcm, errlog);\r\n    }\r\n\r\n    DatasetUrl durl = DatasetUrl.findDatasetUrl(location); // Cache ServiceType so we don't have to keep figuring it out\r\n    if (durl.serviceType == null) { // skip GRIB check for anything not a plain ole file\r\n      // check if its GRIB, may not have to go through NetcdfDataset\r\n      Optional<FeatureDatasetCoverage> opt = CoverageDatasetFactory.openGrib(location);\r\n      if (opt.isPresent()) { // its a GRIB file\r\n        return opt.get();\r\n\r\n      } else if (!opt.getErrorMessage().startsWith(CoverageDatasetFactory.NOT_GRIB_FILE) &&\r\n              !opt.getErrorMessage().startsWith(CoverageDatasetFactory.NO_GRIB_CLASS)) {\r\n        errlog.format(\"%s%n\", opt.getErrorMessage()); // its a GRIB file with an error\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r\n    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);\r\n    FeatureDataset fd = wrap(wantFeatureType, ncd, task, errlog);\r\n    if (fd == null)\r\n      ncd.close();\r\n    return fd;\r\n  }", "code_tokens": ["static", "public", "FeatureDataset", "open", "(", "FeatureType", "wantFeatureType", ",", "String", "location", ",", "ucar", ".", "nc2", ".", "util", ".", "CancelTask", "task", ",", "Formatter", "errlog", ")", "throws", "IOException", "{", "// special processing for thredds: datasets\r", "if", "(", "location", ".", "startsWith", "(", "DataFactory", ".", "SCHEME", ")", ")", "{", "DataFactory", ".", "Result", "result", "=", "new", "DataFactory", "(", ")", ".", "openFeatureDataset", "(", "wantFeatureType", ",", "location", ",", "task", ")", ";", "errlog", ".", "format", "(", "\"%s\"", ",", "result", ".", "errLog", ")", ";", "if", "(", "!", "featureTypeOk", "(", "wantFeatureType", ",", "result", ".", "featureType", ")", ")", "{", "errlog", ".", "format", "(", "\"wanted %s but dataset is of type %s%n\"", ",", "wantFeatureType", ",", "result", ".", "featureType", ")", ";", "result", ".", "close", "(", ")", ";", "return", "null", ";", "}", "return", "result", ".", "featureDataset", ";", "// special processing for cdmrFeature: datasets\r", "}", "else", "if", "(", "location", ".", "startsWith", "(", "CdmrFeatureDataset", ".", "SCHEME", ")", ")", "{", "Optional", "<", "FeatureDataset", ">", "opt", "=", "CdmrFeatureDataset", ".", "factory", "(", "wantFeatureType", ",", "location", ")", ";", "if", "(", "opt", ".", "isPresent", "(", ")", ")", "return", "opt", ".", "get", "(", ")", ";", "errlog", ".", "format", "(", "\"%s\"", ",", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "return", "null", ";", "// special processing for collection: datasets\r", "}", "else", "if", "(", "location", ".", "startsWith", "(", "ucar", ".", "nc2", ".", "ft", ".", "point", ".", "collection", ".", "CompositeDatasetFactory", ".", "SCHEME", ")", ")", "{", "String", "spec", "=", "location", ".", "substring", "(", "CompositeDatasetFactory", ".", "SCHEME", ".", "length", "(", ")", ")", ";", "MFileCollectionManager", "dcm", "=", "MFileCollectionManager", ".", "open", "(", "spec", ",", "spec", ",", "null", ",", "errlog", ")", ";", "// LOOK we dont have a name\r", "return", "CompositeDatasetFactory", ".", "factory", "(", "location", ",", "wantFeatureType", ",", "dcm", ",", "errlog", ")", ";", "}", "DatasetUrl", "durl", "=", "DatasetUrl", ".", "findDatasetUrl", "(", "location", ")", ";", "// Cache ServiceType so we don't have to keep figuring it out\r", "if", "(", "durl", ".", "serviceType", "==", "null", ")", "{", "// skip GRIB check for anything not a plain ole file\r", "// check if its GRIB, may not have to go through NetcdfDataset\r", "Optional", "<", "FeatureDatasetCoverage", ">", "opt", "=", "CoverageDatasetFactory", ".", "openGrib", "(", "location", ")", ";", "if", "(", "opt", ".", "isPresent", "(", ")", ")", "{", "// its a GRIB file\r", "return", "opt", ".", "get", "(", ")", ";", "}", "else", "if", "(", "!", "opt", ".", "getErrorMessage", "(", ")", ".", "startsWith", "(", "CoverageDatasetFactory", ".", "NOT_GRIB_FILE", ")", "&&", "!", "opt", ".", "getErrorMessage", "(", ")", ".", "startsWith", "(", "CoverageDatasetFactory", ".", "NO_GRIB_CLASS", ")", ")", "{", "errlog", ".", "format", "(", "\"%s%n\"", ",", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "// its a GRIB file with an error\r", "return", "null", ";", "}", "}", "// otherwise open as NetcdfDataset and run it through the FeatureDatasetFactories\r", "NetcdfDataset", "ncd", "=", "NetcdfDataset", ".", "acquireDataset", "(", "durl", ",", "true", ",", "task", ")", ";", "FeatureDataset", "fd", "=", "wrap", "(", "wantFeatureType", ",", "ncd", ",", "task", ",", "errlog", ")", ";", "if", "(", "fd", "==", "null", ")", "ncd", ".", "close", "(", ")", ";", "return", "fd", ";", "}"], "docstring": "Open a dataset as a FeatureDataset.\n\n@param wantFeatureType open this kind of FeatureDataset; may be null, which means search all factories.\nIf datatype is not null, only return correct FeatureDataset (eg PointFeatureDataset for DataType.POINT).\n@param location        URL or file location of the dataset. This may be a\n<ol>\n<li>thredds catalog#dataset (with a thredds: prefix)\n<li>cdmrFeature dataset (with a cdmrFeature: prefix)\n<li>cdmremote dataset (with a cdmremote: prefix)\n<li>collection dataset (with a collection: prefix)\n<li>file location for a CDM dataset opened with NetcdfDataset.acquireDataset()\n</ol>\n@param task            user may cancel\n@param errlog          place errors here, may not be null\n@return a subclass of FeatureDataset, or null if no suitable factory was found, message in errlog\n@throws java.io.IOException on io error", "docstring_tokens": ["Open", "a", "dataset", "as", "a", "FeatureDataset", "."]}
{"code": "sb.append(getHtmlDoctypeAndOpenTag());", "comments": "\"<html>\\n\" );", "lines": 10, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/ConfigCatalogHtmlWriter.java", "func_name": "ConfigCatalogHtmlWriter.convertCatalogToHtml", "original_string": "String convertCatalogToHtml(Catalog cat, boolean isLocalCatalog) {\n    StringBuilder sb = new StringBuilder(10000);\n\n    String uri = cat.getUriString();\n    if (uri == null) uri = cat.getName();\n    if (uri == null) uri = \"unknown\";\n    String catname = Escape.html(uri);\n\n    // Render the page header\n    sb.append(getHtmlDoctypeAndOpenTag()); // \"<html>\\n\" );\n    sb.append(\"<head>\\r\\n\");\n    sb.append(\"<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>\");\n    sb.append(\"<title>\");\n    //if (cat.isStatic())\n    //  sb.append(\"TdsStaticCatalog \").append(catname); // for searching\n    //else\n    sb.append(\"Catalog \").append(catname);\n    sb.append(\"</title>\\r\\n\");\n    sb.append(getTdsCatalogCssLink()).append(\"\\n\");\n    sb.append(this.getGoogleTrackingContent());\n    sb.append(\"</head>\\r\\n\");\n    sb.append(\"<body>\");\n    sb.append(\"<h1>\");\n\n    // Logo\n    //String logoUrl = this.htmlConfig.getInstallLogoUrl();\n    String logoUrl = htmlConfig.prepareUrlStringForHtml(htmlConfig.getInstallLogoUrl());\n    if (logoUrl != null) {\n      sb.append(\"<img src='\").append(logoUrl);\n      String logoAlt = htmlConfig.getInstallLogoAlt();\n      if (logoAlt != null) sb.append(\"' alt='\").append(logoAlt);\n      sb.append(\"' align='left' valign='top'\").append(\">\\n\");\n    }\n\n    sb.append(\" Catalog \").append(catname);\n    sb.append(\"</h1>\");\n    sb.append(\"<HR size='1' noshade='noshade'>\");\n\n    sb.append(\"<table width='100%' cellspacing='0' cellpadding='5' align='center'>\\r\\n\");\n\n    // Render the column headings\n    sb.append(\"<tr>\\r\\n\");\n    sb.append(\"<th align='left'><font size='+1'>\");\n    sb.append(\"Dataset\");\n    sb.append(\"</font></th>\\r\\n\");\n    sb.append(\"<th align='center'><font size='+1'>\");\n    sb.append(\"Size\");\n    sb.append(\"</font></th>\\r\\n\");\n    sb.append(\"<th align='right'><font size='+1'>\");\n    sb.append(\"Last Modified\");\n    sb.append(\"</font></th>\\r\\n\");\n    sb.append(\"</tr>\");\n\n    // Recursively render the datasets\n    doDatasets(cat, cat.getDatasetsLocal(), sb, false, 0, isLocalCatalog);\n\n    // Render the page footer\n    sb.append(\"</table>\\r\\n\");\n    sb.append(\"<HR size='1' noshade='noshade'>\");\n    appendSimpleFooter(sb);\n    sb.append(\"</body>\\r\\n\");\n    sb.append(\"</html>\\r\\n\");\n\n    return (sb.toString());\n  }", "language": "java", "Allcodes": "String convertCatalogToHtml(Catalog cat, boolean isLocalCatalog) {\n    StringBuilder sb = new StringBuilder(10000);\n\n    String uri = cat.getUriString();\n    if (uri == null) uri = cat.getName();\n    if (uri == null) uri = \"unknown\";\n    String catname = Escape.html(uri);\n\n    // Render the page header\n    sb.append(getHtmlDoctypeAndOpenTag()); // \"<html>\\n\" );\n    sb.append(\"<head>\\r\\n\");\n    sb.append(\"<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>\");\n    sb.append(\"<title>\");\n    //if (cat.isStatic())\n    //  sb.append(\"TdsStaticCatalog \").append(catname); // for searching\n    //else\n    sb.append(\"Catalog \").append(catname);\n    sb.append(\"</title>\\r\\n\");\n    sb.append(getTdsCatalogCssLink()).append(\"\\n\");\n    sb.append(this.getGoogleTrackingContent());\n    sb.append(\"</head>\\r\\n\");\n    sb.append(\"<body>\");\n    sb.append(\"<h1>\");\n\n    // Logo\n    //String logoUrl = this.htmlConfig.getInstallLogoUrl();\n    String logoUrl = htmlConfig.prepareUrlStringForHtml(htmlConfig.getInstallLogoUrl());\n    if (logoUrl != null) {\n      sb.append(\"<img src='\").append(logoUrl);\n      String logoAlt = htmlConfig.getInstallLogoAlt();\n      if (logoAlt != null) sb.append(\"' alt='\").append(logoAlt);\n      sb.append(\"' align='left' valign='top'\").append(\">\\n\");\n    }\n\n    sb.append(\" Catalog \").append(catname);\n    sb.append(\"</h1>\");\n    sb.append(\"<HR size='1' noshade='noshade'>\");\n\n    sb.append(\"<table width='100%' cellspacing='0' cellpadding='5' align='center'>\\r\\n\");\n\n    // Render the column headings\n    sb.append(\"<tr>\\r\\n\");\n    sb.append(\"<th align='left'><font size='+1'>\");\n    sb.append(\"Dataset\");\n    sb.append(\"</font></th>\\r\\n\");\n    sb.append(\"<th align='center'><font size='+1'>\");\n    sb.append(\"Size\");\n    sb.append(\"</font></th>\\r\\n\");\n    sb.append(\"<th align='right'><font size='+1'>\");\n    sb.append(\"Last Modified\");\n    sb.append(\"</font></th>\\r\\n\");\n    sb.append(\"</tr>\");\n\n    // Recursively render the datasets\n    doDatasets(cat, cat.getDatasetsLocal(), sb, false, 0, isLocalCatalog);\n\n    // Render the page footer\n    sb.append(\"</table>\\r\\n\");\n    sb.append(\"<HR size='1' noshade='noshade'>\");\n    appendSimpleFooter(sb);\n    sb.append(\"</body>\\r\\n\");\n    sb.append(\"</html>\\r\\n\");\n\n    return (sb.toString());\n  }", "code_tokens": ["String", "convertCatalogToHtml", "(", "Catalog", "cat", ",", "boolean", "isLocalCatalog", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "10000", ")", ";", "String", "uri", "=", "cat", ".", "getUriString", "(", ")", ";", "if", "(", "uri", "==", "null", ")", "uri", "=", "cat", ".", "getName", "(", ")", ";", "if", "(", "uri", "==", "null", ")", "uri", "=", "\"unknown\"", ";", "String", "catname", "=", "Escape", ".", "html", "(", "uri", ")", ";", "// Render the page header", "sb", ".", "append", "(", "getHtmlDoctypeAndOpenTag", "(", ")", ")", ";", "// \"<html>\\n\" );", "sb", ".", "append", "(", "\"<head>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>\"", ")", ";", "sb", ".", "append", "(", "\"<title>\"", ")", ";", "//if (cat.isStatic())", "//  sb.append(\"TdsStaticCatalog \").append(catname); // for searching", "//else", "sb", ".", "append", "(", "\"Catalog \"", ")", ".", "append", "(", "catname", ")", ";", "sb", ".", "append", "(", "\"</title>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "getTdsCatalogCssLink", "(", ")", ")", ".", "append", "(", "\"\\n\"", ")", ";", "sb", ".", "append", "(", "this", ".", "getGoogleTrackingContent", "(", ")", ")", ";", "sb", ".", "append", "(", "\"</head>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"<body>\"", ")", ";", "sb", ".", "append", "(", "\"<h1>\"", ")", ";", "// Logo", "//String logoUrl = this.htmlConfig.getInstallLogoUrl();", "String", "logoUrl", "=", "htmlConfig", ".", "prepareUrlStringForHtml", "(", "htmlConfig", ".", "getInstallLogoUrl", "(", ")", ")", ";", "if", "(", "logoUrl", "!=", "null", ")", "{", "sb", ".", "append", "(", "\"<img src='\"", ")", ".", "append", "(", "logoUrl", ")", ";", "String", "logoAlt", "=", "htmlConfig", ".", "getInstallLogoAlt", "(", ")", ";", "if", "(", "logoAlt", "!=", "null", ")", "sb", ".", "append", "(", "\"' alt='\"", ")", ".", "append", "(", "logoAlt", ")", ";", "sb", ".", "append", "(", "\"' align='left' valign='top'\"", ")", ".", "append", "(", "\">\\n\"", ")", ";", "}", "sb", ".", "append", "(", "\" Catalog \"", ")", ".", "append", "(", "catname", ")", ";", "sb", ".", "append", "(", "\"</h1>\"", ")", ";", "sb", ".", "append", "(", "\"<HR size='1' noshade='noshade'>\"", ")", ";", "sb", ".", "append", "(", "\"<table width='100%' cellspacing='0' cellpadding='5' align='center'>\\r\\n\"", ")", ";", "// Render the column headings", "sb", ".", "append", "(", "\"<tr>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"<th align='left'><font size='+1'>\"", ")", ";", "sb", ".", "append", "(", "\"Dataset\"", ")", ";", "sb", ".", "append", "(", "\"</font></th>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"<th align='center'><font size='+1'>\"", ")", ";", "sb", ".", "append", "(", "\"Size\"", ")", ";", "sb", ".", "append", "(", "\"</font></th>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"<th align='right'><font size='+1'>\"", ")", ";", "sb", ".", "append", "(", "\"Last Modified\"", ")", ";", "sb", ".", "append", "(", "\"</font></th>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"</tr>\"", ")", ";", "// Recursively render the datasets", "doDatasets", "(", "cat", ",", "cat", ".", "getDatasetsLocal", "(", ")", ",", "sb", ",", "false", ",", "0", ",", "isLocalCatalog", ")", ";", "// Render the page footer", "sb", ".", "append", "(", "\"</table>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"<HR size='1' noshade='noshade'>\"", ")", ";", "appendSimpleFooter", "(", "sb", ")", ";", "sb", ".", "append", "(", "\"</body>\\r\\n\"", ")", ";", "sb", ".", "append", "(", "\"</html>\\r\\n\"", ")", ";", "return", "(", "sb", ".", "toString", "(", ")", ")", ";", "}"], "docstring": "Write a catalog in HTML, make it look like a file directory.\n\n@param cat catalog to write", "docstring_tokens": ["Write", "a", "catalog", "in", "HTML", "make", "it", "look", "like", "a", "file", "directory", "."]}
{"code": "findServices(cat.getDatasets(), allServiceNames);", "comments": "all services used", "lines": 5, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/CatalogManager.java", "func_name": "CatalogManager.addGlobalServices", "original_string": "private void addGlobalServices(CatalogBuilder cat) {\n\n    // look for datasets that want to use global services\n    Set<String> allServiceNames = new HashSet<>();\n    findServices(cat.getDatasets(), allServiceNames);  // all services used\n    if (!allServiceNames.isEmpty()) {\n      List<Service> servicesMissing = new ArrayList<>();   // all services missing\n      for (String name : allServiceNames) {\n        if (cat.hasServiceInDataset(name)) continue;\n        Service s = globalServices.findGlobalService(name);\n        if (s != null) servicesMissing.add(s);\n      }\n      servicesMissing.forEach(cat::addService);\n    }\n\n    // look for datasets that want to use standard services\n    for (DatasetBuilder node : cat.getDatasets()) {\n      String sname = (String) node.getFldOrInherited(Dataset.ServiceName);\n      String urlPath = (String) node.get(Dataset.UrlPath);\n      String ftypeS = (String) node.getFldOrInherited(Dataset.FeatureType);\n      if (sname == null && urlPath != null && ftypeS != null) {\n        Service s = globalServices.getStandardServices(ftypeS);\n        if (s != null) {\n          node.put(Dataset.ServiceName, s.getName());\n          cat.addService(s);\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "private void addGlobalServices(CatalogBuilder cat) {\n\n    // look for datasets that want to use global services\n    Set<String> allServiceNames = new HashSet<>();\n    findServices(cat.getDatasets(), allServiceNames);  // all services used\n    if (!allServiceNames.isEmpty()) {\n      List<Service> servicesMissing = new ArrayList<>();   // all services missing\n      for (String name : allServiceNames) {\n        if (cat.hasServiceInDataset(name)) continue;\n        Service s = globalServices.findGlobalService(name);\n        if (s != null) servicesMissing.add(s);\n      }\n      servicesMissing.forEach(cat::addService);\n    }\n\n    // look for datasets that want to use standard services\n    for (DatasetBuilder node : cat.getDatasets()) {\n      String sname = (String) node.getFldOrInherited(Dataset.ServiceName);\n      String urlPath = (String) node.get(Dataset.UrlPath);\n      String ftypeS = (String) node.getFldOrInherited(Dataset.FeatureType);\n      if (sname == null && urlPath != null && ftypeS != null) {\n        Service s = globalServices.getStandardServices(ftypeS);\n        if (s != null) {\n          node.put(Dataset.ServiceName, s.getName());\n          cat.addService(s);\n        }\n      }\n    }\n  }", "code_tokens": ["private", "void", "addGlobalServices", "(", "CatalogBuilder", "cat", ")", "{", "// look for datasets that want to use global services", "Set", "<", "String", ">", "allServiceNames", "=", "new", "HashSet", "<>", "(", ")", ";", "findServices", "(", "cat", ".", "getDatasets", "(", ")", ",", "allServiceNames", ")", ";", "// all services used", "if", "(", "!", "allServiceNames", ".", "isEmpty", "(", ")", ")", "{", "List", "<", "Service", ">", "servicesMissing", "=", "new", "ArrayList", "<>", "(", ")", ";", "// all services missing", "for", "(", "String", "name", ":", "allServiceNames", ")", "{", "if", "(", "cat", ".", "hasServiceInDataset", "(", "name", ")", ")", "continue", ";", "Service", "s", "=", "globalServices", ".", "findGlobalService", "(", "name", ")", ";", "if", "(", "s", "!=", "null", ")", "servicesMissing", ".", "add", "(", "s", ")", ";", "}", "servicesMissing", ".", "forEach", "(", "cat", "::", "addService", ")", ";", "}", "// look for datasets that want to use standard services", "for", "(", "DatasetBuilder", "node", ":", "cat", ".", "getDatasets", "(", ")", ")", "{", "String", "sname", "=", "(", "String", ")", "node", ".", "getFldOrInherited", "(", "Dataset", ".", "ServiceName", ")", ";", "String", "urlPath", "=", "(", "String", ")", "node", ".", "get", "(", "Dataset", ".", "UrlPath", ")", ";", "String", "ftypeS", "=", "(", "String", ")", "node", ".", "getFldOrInherited", "(", "Dataset", ".", "FeatureType", ")", ";", "if", "(", "sname", "==", "null", "&&", "urlPath", "!=", "null", "&&", "ftypeS", "!=", "null", ")", "{", "Service", "s", "=", "globalServices", ".", "getStandardServices", "(", "ftypeS", ")", ";", "if", "(", "s", "!=", "null", ")", "{", "node", ".", "put", "(", "Dataset", ".", "ServiceName", ",", "s", ".", "getName", "(", ")", ")", ";", "cat", ".", "addService", "(", "s", ")", ";", "}", "}", "}", "}"], "docstring": "rigamorole to modify invariant catalogs; we may need to add global services", "docstring_tokens": ["rigamorole", "to", "modify", "invariant", "catalogs", ";", "we", "may", "need", "to", "add", "global", "services"]}
{"code": "List<Service> servicesMissing = new ArrayList<>();", "comments": "all services missing", "lines": 7, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/CatalogManager.java", "func_name": "CatalogManager.addGlobalServices", "original_string": "private void addGlobalServices(CatalogBuilder cat) {\n\n    // look for datasets that want to use global services\n    Set<String> allServiceNames = new HashSet<>();\n    findServices(cat.getDatasets(), allServiceNames);  // all services used\n    if (!allServiceNames.isEmpty()) {\n      List<Service> servicesMissing = new ArrayList<>();   // all services missing\n      for (String name : allServiceNames) {\n        if (cat.hasServiceInDataset(name)) continue;\n        Service s = globalServices.findGlobalService(name);\n        if (s != null) servicesMissing.add(s);\n      }\n      servicesMissing.forEach(cat::addService);\n    }\n\n    // look for datasets that want to use standard services\n    for (DatasetBuilder node : cat.getDatasets()) {\n      String sname = (String) node.getFldOrInherited(Dataset.ServiceName);\n      String urlPath = (String) node.get(Dataset.UrlPath);\n      String ftypeS = (String) node.getFldOrInherited(Dataset.FeatureType);\n      if (sname == null && urlPath != null && ftypeS != null) {\n        Service s = globalServices.getStandardServices(ftypeS);\n        if (s != null) {\n          node.put(Dataset.ServiceName, s.getName());\n          cat.addService(s);\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "private void addGlobalServices(CatalogBuilder cat) {\n\n    // look for datasets that want to use global services\n    Set<String> allServiceNames = new HashSet<>();\n    findServices(cat.getDatasets(), allServiceNames);  // all services used\n    if (!allServiceNames.isEmpty()) {\n      List<Service> servicesMissing = new ArrayList<>();   // all services missing\n      for (String name : allServiceNames) {\n        if (cat.hasServiceInDataset(name)) continue;\n        Service s = globalServices.findGlobalService(name);\n        if (s != null) servicesMissing.add(s);\n      }\n      servicesMissing.forEach(cat::addService);\n    }\n\n    // look for datasets that want to use standard services\n    for (DatasetBuilder node : cat.getDatasets()) {\n      String sname = (String) node.getFldOrInherited(Dataset.ServiceName);\n      String urlPath = (String) node.get(Dataset.UrlPath);\n      String ftypeS = (String) node.getFldOrInherited(Dataset.FeatureType);\n      if (sname == null && urlPath != null && ftypeS != null) {\n        Service s = globalServices.getStandardServices(ftypeS);\n        if (s != null) {\n          node.put(Dataset.ServiceName, s.getName());\n          cat.addService(s);\n        }\n      }\n    }\n  }", "code_tokens": ["private", "void", "addGlobalServices", "(", "CatalogBuilder", "cat", ")", "{", "// look for datasets that want to use global services", "Set", "<", "String", ">", "allServiceNames", "=", "new", "HashSet", "<>", "(", ")", ";", "findServices", "(", "cat", ".", "getDatasets", "(", ")", ",", "allServiceNames", ")", ";", "// all services used", "if", "(", "!", "allServiceNames", ".", "isEmpty", "(", ")", ")", "{", "List", "<", "Service", ">", "servicesMissing", "=", "new", "ArrayList", "<>", "(", ")", ";", "// all services missing", "for", "(", "String", "name", ":", "allServiceNames", ")", "{", "if", "(", "cat", ".", "hasServiceInDataset", "(", "name", ")", ")", "continue", ";", "Service", "s", "=", "globalServices", ".", "findGlobalService", "(", "name", ")", ";", "if", "(", "s", "!=", "null", ")", "servicesMissing", ".", "add", "(", "s", ")", ";", "}", "servicesMissing", ".", "forEach", "(", "cat", "::", "addService", ")", ";", "}", "// look for datasets that want to use standard services", "for", "(", "DatasetBuilder", "node", ":", "cat", ".", "getDatasets", "(", ")", ")", "{", "String", "sname", "=", "(", "String", ")", "node", ".", "getFldOrInherited", "(", "Dataset", ".", "ServiceName", ")", ";", "String", "urlPath", "=", "(", "String", ")", "node", ".", "get", "(", "Dataset", ".", "UrlPath", ")", ";", "String", "ftypeS", "=", "(", "String", ")", "node", ".", "getFldOrInherited", "(", "Dataset", ".", "FeatureType", ")", ";", "if", "(", "sname", "==", "null", "&&", "urlPath", "!=", "null", "&&", "ftypeS", "!=", "null", ")", "{", "Service", "s", "=", "globalServices", ".", "getStandardServices", "(", "ftypeS", ")", ";", "if", "(", "s", "!=", "null", ")", "{", "node", ".", "put", "(", "Dataset", ".", "ServiceName", ",", "s", ".", "getName", "(", ")", ")", ";", "cat", ".", "addService", "(", "s", ")", ";", "}", "}", "}", "}"], "docstring": "rigamorole to modify invariant catalogs; we may need to add global services", "docstring_tokens": ["rigamorole", "to", "modify", "invariant", "catalogs", ";", "we", "may", "need", "to", "add", "global", "services"]}
{"code": "if (localState == null) return null;", "comments": "not ready yet maybe", "lines": 4, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/featurecollection/InvDatasetFcGrib.java", "func_name": "InvDatasetFcGrib.makeCatalog", "original_string": "@Override\n  public CatalogBuilder makeCatalog(String match, String reqPath, URI catURI) throws IOException {\n    StateGrib localState = (StateGrib) checkState();\n    if (localState == null) return null; // not ready yet maybe\n    if (localState.gribCollection == null) return null; // not ready yet maybe\n\n    try {\n\n      // case 0\n      if ((match == null) || (match.length() == 0)) {\n        return makeCatalogTop(catURI, localState);  // top catalog : uses state.top previously made in checkState()\n      }\n\n      // case 1\n      if (localState.gribCollection instanceof PartitionCollectionImmutable) {\n        String[] paths = match.split(\"/\");\n        PartitionCollectionImmutable pc = (PartitionCollectionImmutable) localState.gribCollection;\n        return makeCatalogFromPartition(pc, paths, 0, catURI);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      logger.error(\"Error making catalog for \" + configPath, e);\n    }\n\n    return null;\n  }", "language": "java", "Allcodes": "@Override\n  public CatalogBuilder makeCatalog(String match, String reqPath, URI catURI) throws IOException {\n    StateGrib localState = (StateGrib) checkState();\n    if (localState == null) return null; // not ready yet maybe\n    if (localState.gribCollection == null) return null; // not ready yet maybe\n\n    try {\n\n      // case 0\n      if ((match == null) || (match.length() == 0)) {\n        return makeCatalogTop(catURI, localState);  // top catalog : uses state.top previously made in checkState()\n      }\n\n      // case 1\n      if (localState.gribCollection instanceof PartitionCollectionImmutable) {\n        String[] paths = match.split(\"/\");\n        PartitionCollectionImmutable pc = (PartitionCollectionImmutable) localState.gribCollection;\n        return makeCatalogFromPartition(pc, paths, 0, catURI);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      logger.error(\"Error making catalog for \" + configPath, e);\n    }\n\n    return null;\n  }", "code_tokens": ["@", "Override", "public", "CatalogBuilder", "makeCatalog", "(", "String", "match", ",", "String", "reqPath", ",", "URI", "catURI", ")", "throws", "IOException", "{", "StateGrib", "localState", "=", "(", "StateGrib", ")", "checkState", "(", ")", ";", "if", "(", "localState", "==", "null", ")", "return", "null", ";", "// not ready yet maybe", "if", "(", "localState", ".", "gribCollection", "==", "null", ")", "return", "null", ";", "// not ready yet maybe", "try", "{", "// case 0", "if", "(", "(", "match", "==", "null", ")", "||", "(", "match", ".", "length", "(", ")", "==", "0", ")", ")", "{", "return", "makeCatalogTop", "(", "catURI", ",", "localState", ")", ";", "// top catalog : uses state.top previously made in checkState()", "}", "// case 1", "if", "(", "localState", ".", "gribCollection", "instanceof", "PartitionCollectionImmutable", ")", "{", "String", "[", "]", "paths", "=", "match", ".", "split", "(", "\"/\"", ")", ";", "PartitionCollectionImmutable", "pc", "=", "(", "PartitionCollectionImmutable", ")", "localState", ".", "gribCollection", ";", "return", "makeCatalogFromPartition", "(", "pc", ",", "paths", ",", "0", ",", "catURI", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "logger", ".", "error", "(", "\"Error making catalog for \"", "+", "configPath", ",", "e", ")", ";", "}", "return", "null", ";", "}"], "docstring": "see top javadoc for possible URLs", "docstring_tokens": ["see", "top", "javadoc", "for", "possible", "URLs"]}
{"code": "return makeCatalogTop(catURI, localState);", "comments": "top catalog : uses state.top previously made in checkState()", "lines": 11, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/featurecollection/InvDatasetFcGrib.java", "func_name": "InvDatasetFcGrib.makeCatalog", "original_string": "@Override\n  public CatalogBuilder makeCatalog(String match, String reqPath, URI catURI) throws IOException {\n    StateGrib localState = (StateGrib) checkState();\n    if (localState == null) return null; // not ready yet maybe\n    if (localState.gribCollection == null) return null; // not ready yet maybe\n\n    try {\n\n      // case 0\n      if ((match == null) || (match.length() == 0)) {\n        return makeCatalogTop(catURI, localState);  // top catalog : uses state.top previously made in checkState()\n      }\n\n      // case 1\n      if (localState.gribCollection instanceof PartitionCollectionImmutable) {\n        String[] paths = match.split(\"/\");\n        PartitionCollectionImmutable pc = (PartitionCollectionImmutable) localState.gribCollection;\n        return makeCatalogFromPartition(pc, paths, 0, catURI);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      logger.error(\"Error making catalog for \" + configPath, e);\n    }\n\n    return null;\n  }", "language": "java", "Allcodes": "@Override\n  public CatalogBuilder makeCatalog(String match, String reqPath, URI catURI) throws IOException {\n    StateGrib localState = (StateGrib) checkState();\n    if (localState == null) return null; // not ready yet maybe\n    if (localState.gribCollection == null) return null; // not ready yet maybe\n\n    try {\n\n      // case 0\n      if ((match == null) || (match.length() == 0)) {\n        return makeCatalogTop(catURI, localState);  // top catalog : uses state.top previously made in checkState()\n      }\n\n      // case 1\n      if (localState.gribCollection instanceof PartitionCollectionImmutable) {\n        String[] paths = match.split(\"/\");\n        PartitionCollectionImmutable pc = (PartitionCollectionImmutable) localState.gribCollection;\n        return makeCatalogFromPartition(pc, paths, 0, catURI);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      logger.error(\"Error making catalog for \" + configPath, e);\n    }\n\n    return null;\n  }", "code_tokens": ["@", "Override", "public", "CatalogBuilder", "makeCatalog", "(", "String", "match", ",", "String", "reqPath", ",", "URI", "catURI", ")", "throws", "IOException", "{", "StateGrib", "localState", "=", "(", "StateGrib", ")", "checkState", "(", ")", ";", "if", "(", "localState", "==", "null", ")", "return", "null", ";", "// not ready yet maybe", "if", "(", "localState", ".", "gribCollection", "==", "null", ")", "return", "null", ";", "// not ready yet maybe", "try", "{", "// case 0", "if", "(", "(", "match", "==", "null", ")", "||", "(", "match", ".", "length", "(", ")", "==", "0", ")", ")", "{", "return", "makeCatalogTop", "(", "catURI", ",", "localState", ")", ";", "// top catalog : uses state.top previously made in checkState()", "}", "// case 1", "if", "(", "localState", ".", "gribCollection", "instanceof", "PartitionCollectionImmutable", ")", "{", "String", "[", "]", "paths", "=", "match", ".", "split", "(", "\"/\"", ")", ";", "PartitionCollectionImmutable", "pc", "=", "(", "PartitionCollectionImmutable", ")", "localState", ".", "gribCollection", ";", "return", "makeCatalogFromPartition", "(", "pc", ",", "paths", ",", "0", ",", "catURI", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "logger", ".", "error", "(", "\"Error making catalog for \"", "+", "configPath", ",", "e", ")", ";", "}", "return", "null", ";", "}"], "docstring": "see top javadoc for possible URLs", "docstring_tokens": ["see", "top", "javadoc", "for", "possible", "URLs"]}
{"code": "id = null;", "comments": "can't happen", "lines": 10, "repo": "Unidata/thredds", "path": "udunits/src/main/java/ucar/units/UnitID.java", "func_name": "UnitID.newUnitID", "original_string": "public static UnitID newUnitID(final String name, final String plural,\n\t\t\tfinal String symbol) {\n\t\tUnitID id;\n\t\ttry {\n\t\t\tid = name == null\n\t\t\t\t\t? new UnitSymbol(symbol)\n\t\t\t\t\t: UnitName.newUnitName(name, plural, symbol);\n\t\t}\n\t\tcatch (final NameException e) {\n\t\t\tid = null; // can't happen\n\t\t}\n\t\treturn id;\n\t}", "language": "java", "Allcodes": "public static UnitID newUnitID(final String name, final String plural,\n\t\t\tfinal String symbol) {\n\t\tUnitID id;\n\t\ttry {\n\t\t\tid = name == null\n\t\t\t\t\t? new UnitSymbol(symbol)\n\t\t\t\t\t: UnitName.newUnitName(name, plural, symbol);\n\t\t}\n\t\tcatch (final NameException e) {\n\t\t\tid = null; // can't happen\n\t\t}\n\t\treturn id;\n\t}", "code_tokens": ["public", "static", "UnitID", "newUnitID", "(", "final", "String", "name", ",", "final", "String", "plural", ",", "final", "String", "symbol", ")", "{", "UnitID", "id", ";", "try", "{", "id", "=", "name", "==", "null", "?", "new", "UnitSymbol", "(", "symbol", ")", ":", "UnitName", ".", "newUnitName", "(", "name", ",", "plural", ",", "symbol", ")", ";", "}", "catch", "(", "final", "NameException", "e", ")", "{", "id", "=", "null", ";", "// can't happen", "}", "return", "id", ";", "}"], "docstring": "Factory method for constructing an identifier from a name, plural, and\nsymbol.\n\n@param name\nThe name for the unit. May be <code>null\n</code>.\n@param plural\nThe plural form of the name. If <code>null\n</code> and\n<code>name</code> is non-<code>\nnull</code>, then regular\nplural-forming rules are used on the name.\n@param symbol\nThe symbol for the unit. May be <code>null\n</code>.", "docstring_tokens": ["Factory", "method", "for", "constructing", "an", "identifier", "from", "a", "name", "plural", "and", "symbol", "."]}
{"code": "raf.seek(header.recStart + recnum * header.recsize);", "comments": "where the record starts", "lines": 32, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java", "func_name": "N3iosp.readRecordData", "original_string": "private ucar.ma2.Array readRecordData(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    //if (s.isSubset())\n    //  return readRecordDataSubset(s, section);\n\n    // has to be 1D\n    Range recordRange = section.getRange(0);\n\n    // create the ArrayStructure\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart));\n    }\n\n    // protect agains too large of reads\n    if (header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Cant read records when recsize > \"+Integer.MAX_VALUE);\n    long nrecs = section.computeSize();\n    if (nrecs * header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Too large read: nrecs * recsize= \"+(nrecs * header.recsize) +\"bytes exceeds \"+Integer.MAX_VALUE);\n\n    members.setStructureSize((int) header.recsize);\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, new int[]{recordRange.length()});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] result = structureArray.getByteBuffer().array();\n    int count = 0;\n    for (int recnum : recordRange) {\n      if (debugRecord) System.out.println(\" read record \" + recnum);\n      raf.seek(header.recStart + recnum * header.recsize); // where the record starts\n\n      if (recnum != header.numrecs - 1)\n        raf.readFully(result, (int) (count * header.recsize), (int) header.recsize);\n      else\n        raf.read(result, (int) (count * header.recsize), (int) header.recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n      count++;\n    }\n\n    return structureArray;\n  }", "language": "java", "Allcodes": "private ucar.ma2.Array readRecordData(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    //if (s.isSubset())\n    //  return readRecordDataSubset(s, section);\n\n    // has to be 1D\n    Range recordRange = section.getRange(0);\n\n    // create the ArrayStructure\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart));\n    }\n\n    // protect agains too large of reads\n    if (header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Cant read records when recsize > \"+Integer.MAX_VALUE);\n    long nrecs = section.computeSize();\n    if (nrecs * header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Too large read: nrecs * recsize= \"+(nrecs * header.recsize) +\"bytes exceeds \"+Integer.MAX_VALUE);\n\n    members.setStructureSize((int) header.recsize);\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, new int[]{recordRange.length()});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] result = structureArray.getByteBuffer().array();\n    int count = 0;\n    for (int recnum : recordRange) {\n      if (debugRecord) System.out.println(\" read record \" + recnum);\n      raf.seek(header.recStart + recnum * header.recsize); // where the record starts\n\n      if (recnum != header.numrecs - 1)\n        raf.readFully(result, (int) (count * header.recsize), (int) header.recsize);\n      else\n        raf.read(result, (int) (count * header.recsize), (int) header.recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n      count++;\n    }\n\n    return structureArray;\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "Array", "readRecordData", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", "{", "//if (s.isSubset())", "//  return readRecordDataSubset(s, section);", "// has to be 1D", "Range", "recordRange", "=", "section", ".", "getRange", "(", "0", ")", ";", "// create the ArrayStructure", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "N3header", ".", "Vinfo", "vinfo", "=", "(", "N3header", ".", "Vinfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "(", "int", ")", "(", "vinfo", ".", "begin", "-", "header", ".", "recStart", ")", ")", ";", "}", "// protect agains too large of reads", "if", "(", "header", ".", "recsize", ">", "Integer", ".", "MAX_VALUE", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cant read records when recsize > \"", "+", "Integer", ".", "MAX_VALUE", ")", ";", "long", "nrecs", "=", "section", ".", "computeSize", "(", ")", ";", "if", "(", "nrecs", "*", "header", ".", "recsize", ">", "Integer", ".", "MAX_VALUE", ")", "throw", "new", "IllegalArgumentException", "(", "\"Too large read: nrecs * recsize= \"", "+", "(", "nrecs", "*", "header", ".", "recsize", ")", "+", "\"bytes exceeds \"", "+", "Integer", ".", "MAX_VALUE", ")", ";", "members", ".", "setStructureSize", "(", "(", "int", ")", "header", ".", "recsize", ")", ";", "ArrayStructureBB", "structureArray", "=", "new", "ArrayStructureBB", "(", "members", ",", "new", "int", "[", "]", "{", "recordRange", ".", "length", "(", ")", "}", ")", ";", "// note dependency on raf; should probably defer to subclass", "// loop over records", "byte", "[", "]", "result", "=", "structureArray", ".", "getByteBuffer", "(", ")", ".", "array", "(", ")", ";", "int", "count", "=", "0", ";", "for", "(", "int", "recnum", ":", "recordRange", ")", "{", "if", "(", "debugRecord", ")", "System", ".", "out", ".", "println", "(", "\" read record \"", "+", "recnum", ")", ";", "raf", ".", "seek", "(", "header", ".", "recStart", "+", "recnum", "*", "header", ".", "recsize", ")", ";", "// where the record starts", "if", "(", "recnum", "!=", "header", ".", "numrecs", "-", "1", ")", "raf", ".", "readFully", "(", "result", ",", "(", "int", ")", "(", "count", "*", "header", ".", "recsize", ")", ",", "(", "int", ")", "header", ".", "recsize", ")", ";", "else", "raf", ".", "read", "(", "result", ",", "(", "int", ")", "(", "count", "*", "header", ".", "recsize", ")", ",", "(", "int", ")", "header", ".", "recsize", ")", ";", "// \"wart\" allows file to be one byte short. since its always padding, we allow", "count", "++", ";", "}", "return", "structureArray", ";", "}"], "docstring": "Read data from record structure. For N3, this is the only possible structure, and there can be no nesting.\nRead all variables for each record, put in ByteBuffer.\n\n@param s the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException on error", "docstring_tokens": ["Read", "data", "from", "record", "structure", ".", "For", "N3", "this", "is", "the", "only", "possible", "structure", "and", "there", "can", "be", "no", "nesting", ".", "Read", "all", "variables", "for", "each", "record", "put", "in", "ByteBuffer", "."]}
{"code": "raf.read(result, (int) (count * header.recsize), (int) header.recsize);", "comments": "\"wart\" allows file to be one byte short. since its always padding, we allow", "lines": 37, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java", "func_name": "N3iosp.readRecordData", "original_string": "private ucar.ma2.Array readRecordData(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    //if (s.isSubset())\n    //  return readRecordDataSubset(s, section);\n\n    // has to be 1D\n    Range recordRange = section.getRange(0);\n\n    // create the ArrayStructure\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart));\n    }\n\n    // protect agains too large of reads\n    if (header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Cant read records when recsize > \"+Integer.MAX_VALUE);\n    long nrecs = section.computeSize();\n    if (nrecs * header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Too large read: nrecs * recsize= \"+(nrecs * header.recsize) +\"bytes exceeds \"+Integer.MAX_VALUE);\n\n    members.setStructureSize((int) header.recsize);\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, new int[]{recordRange.length()});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] result = structureArray.getByteBuffer().array();\n    int count = 0;\n    for (int recnum : recordRange) {\n      if (debugRecord) System.out.println(\" read record \" + recnum);\n      raf.seek(header.recStart + recnum * header.recsize); // where the record starts\n\n      if (recnum != header.numrecs - 1)\n        raf.readFully(result, (int) (count * header.recsize), (int) header.recsize);\n      else\n        raf.read(result, (int) (count * header.recsize), (int) header.recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n      count++;\n    }\n\n    return structureArray;\n  }", "language": "java", "Allcodes": "private ucar.ma2.Array readRecordData(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    //if (s.isSubset())\n    //  return readRecordDataSubset(s, section);\n\n    // has to be 1D\n    Range recordRange = section.getRange(0);\n\n    // create the ArrayStructure\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart));\n    }\n\n    // protect agains too large of reads\n    if (header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Cant read records when recsize > \"+Integer.MAX_VALUE);\n    long nrecs = section.computeSize();\n    if (nrecs * header.recsize > Integer.MAX_VALUE)\n      throw new IllegalArgumentException(\"Too large read: nrecs * recsize= \"+(nrecs * header.recsize) +\"bytes exceeds \"+Integer.MAX_VALUE);\n\n    members.setStructureSize((int) header.recsize);\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, new int[]{recordRange.length()});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] result = structureArray.getByteBuffer().array();\n    int count = 0;\n    for (int recnum : recordRange) {\n      if (debugRecord) System.out.println(\" read record \" + recnum);\n      raf.seek(header.recStart + recnum * header.recsize); // where the record starts\n\n      if (recnum != header.numrecs - 1)\n        raf.readFully(result, (int) (count * header.recsize), (int) header.recsize);\n      else\n        raf.read(result, (int) (count * header.recsize), (int) header.recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n      count++;\n    }\n\n    return structureArray;\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "Array", "readRecordData", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", "{", "//if (s.isSubset())", "//  return readRecordDataSubset(s, section);", "// has to be 1D", "Range", "recordRange", "=", "section", ".", "getRange", "(", "0", ")", ";", "// create the ArrayStructure", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "N3header", ".", "Vinfo", "vinfo", "=", "(", "N3header", ".", "Vinfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "(", "int", ")", "(", "vinfo", ".", "begin", "-", "header", ".", "recStart", ")", ")", ";", "}", "// protect agains too large of reads", "if", "(", "header", ".", "recsize", ">", "Integer", ".", "MAX_VALUE", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cant read records when recsize > \"", "+", "Integer", ".", "MAX_VALUE", ")", ";", "long", "nrecs", "=", "section", ".", "computeSize", "(", ")", ";", "if", "(", "nrecs", "*", "header", ".", "recsize", ">", "Integer", ".", "MAX_VALUE", ")", "throw", "new", "IllegalArgumentException", "(", "\"Too large read: nrecs * recsize= \"", "+", "(", "nrecs", "*", "header", ".", "recsize", ")", "+", "\"bytes exceeds \"", "+", "Integer", ".", "MAX_VALUE", ")", ";", "members", ".", "setStructureSize", "(", "(", "int", ")", "header", ".", "recsize", ")", ";", "ArrayStructureBB", "structureArray", "=", "new", "ArrayStructureBB", "(", "members", ",", "new", "int", "[", "]", "{", "recordRange", ".", "length", "(", ")", "}", ")", ";", "// note dependency on raf; should probably defer to subclass", "// loop over records", "byte", "[", "]", "result", "=", "structureArray", ".", "getByteBuffer", "(", ")", ".", "array", "(", ")", ";", "int", "count", "=", "0", ";", "for", "(", "int", "recnum", ":", "recordRange", ")", "{", "if", "(", "debugRecord", ")", "System", ".", "out", ".", "println", "(", "\" read record \"", "+", "recnum", ")", ";", "raf", ".", "seek", "(", "header", ".", "recStart", "+", "recnum", "*", "header", ".", "recsize", ")", ";", "// where the record starts", "if", "(", "recnum", "!=", "header", ".", "numrecs", "-", "1", ")", "raf", ".", "readFully", "(", "result", ",", "(", "int", ")", "(", "count", "*", "header", ".", "recsize", ")", ",", "(", "int", ")", "header", ".", "recsize", ")", ";", "else", "raf", ".", "read", "(", "result", ",", "(", "int", ")", "(", "count", "*", "header", ".", "recsize", ")", ",", "(", "int", ")", "header", ".", "recsize", ")", ";", "// \"wart\" allows file to be one byte short. since its always padding, we allow", "count", "++", ";", "}", "return", "structureArray", ";", "}"], "docstring": "Read data from record structure. For N3, this is the only possible structure, and there can be no nesting.\nRead all variables for each record, put in ByteBuffer.\n\n@param s the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException on error", "docstring_tokens": ["Read", "data", "from", "record", "structure", ".", "For", "N3", "this", "is", "the", "only", "possible", "structure", "and", "there", "can", "be", "no", "nesting", ".", "Read", "all", "variables", "for", "each", "record", "put", "in", "ByteBuffer", "."]}
{"code": "m.setDataParam((int) (vinfo.begin - header.recStart));", "comments": "offset from start of record", "lines": 10, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java", "func_name": "N3iosp.readRecordDataSubset", "original_string": "private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    Range recordRange = section.getRange(0);\n    int nrecords = recordRange.length();\n\n    // create the ArrayStructureMA\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record\n\n      // construct the full shape\n      int rank = m.getShape().length;\n      int[] fullShape = new int[rank + 1];\n      fullShape[0] = nrecords;  // the first dimension\n      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions\n\n      Array data = Array.factory(m.getDataType(), fullShape);\n      m.setDataArray( data);\n      m.setDataObject( data.getIndexIterator());\n    }\n\n    //LOOK this is all wrong - why using recsize ???\n    return null;\n    /* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */\n  }", "language": "java", "Allcodes": "private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    Range recordRange = section.getRange(0);\n    int nrecords = recordRange.length();\n\n    // create the ArrayStructureMA\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record\n\n      // construct the full shape\n      int rank = m.getShape().length;\n      int[] fullShape = new int[rank + 1];\n      fullShape[0] = nrecords;  // the first dimension\n      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions\n\n      Array data = Array.factory(m.getDataType(), fullShape);\n      m.setDataArray( data);\n      m.setDataObject( data.getIndexIterator());\n    }\n\n    //LOOK this is all wrong - why using recsize ???\n    return null;\n    /* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "Array", "readRecordDataSubset", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", "{", "Range", "recordRange", "=", "section", ".", "getRange", "(", "0", ")", ";", "int", "nrecords", "=", "recordRange", ".", "length", "(", ")", ";", "// create the ArrayStructureMA", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "N3header", ".", "Vinfo", "vinfo", "=", "(", "N3header", ".", "Vinfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "(", "int", ")", "(", "vinfo", ".", "begin", "-", "header", ".", "recStart", ")", ")", ";", "// offset from start of record", "// construct the full shape", "int", "rank", "=", "m", ".", "getShape", "(", ")", ".", "length", ";", "int", "[", "]", "fullShape", "=", "new", "int", "[", "rank", "+", "1", "]", ";", "fullShape", "[", "0", "]", "=", "nrecords", ";", "// the first dimension", "System", ".", "arraycopy", "(", "m", ".", "getShape", "(", ")", ",", "0", ",", "fullShape", ",", "1", ",", "rank", ")", ";", "// the remaining dimensions", "Array", "data", "=", "Array", ".", "factory", "(", "m", ".", "getDataType", "(", ")", ",", "fullShape", ")", ";", "m", ".", "setDataArray", "(", "data", ")", ";", "m", ".", "setDataObject", "(", "data", ".", "getIndexIterator", "(", ")", ")", ";", "}", "//LOOK this is all wrong - why using recsize ???", "return", "null", ";", "/* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */", "}"], "docstring": "Read data from record structure, that has been subsetted.\nRead one record at at time, put requested variable into ArrayStructureMA.\n\n@param s the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException on error", "docstring_tokens": ["Read", "data", "from", "record", "structure", "that", "has", "been", "subsetted", ".", "Read", "one", "record", "at", "at", "time", "put", "requested", "variable", "into", "ArrayStructureMA", "."]}
{"code": "fullShape[0] = nrecords;", "comments": "the first dimension", "lines": 15, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java", "func_name": "N3iosp.readRecordDataSubset", "original_string": "private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    Range recordRange = section.getRange(0);\n    int nrecords = recordRange.length();\n\n    // create the ArrayStructureMA\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record\n\n      // construct the full shape\n      int rank = m.getShape().length;\n      int[] fullShape = new int[rank + 1];\n      fullShape[0] = nrecords;  // the first dimension\n      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions\n\n      Array data = Array.factory(m.getDataType(), fullShape);\n      m.setDataArray( data);\n      m.setDataObject( data.getIndexIterator());\n    }\n\n    //LOOK this is all wrong - why using recsize ???\n    return null;\n    /* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */\n  }", "language": "java", "Allcodes": "private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    Range recordRange = section.getRange(0);\n    int nrecords = recordRange.length();\n\n    // create the ArrayStructureMA\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record\n\n      // construct the full shape\n      int rank = m.getShape().length;\n      int[] fullShape = new int[rank + 1];\n      fullShape[0] = nrecords;  // the first dimension\n      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions\n\n      Array data = Array.factory(m.getDataType(), fullShape);\n      m.setDataArray( data);\n      m.setDataObject( data.getIndexIterator());\n    }\n\n    //LOOK this is all wrong - why using recsize ???\n    return null;\n    /* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "Array", "readRecordDataSubset", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", "{", "Range", "recordRange", "=", "section", ".", "getRange", "(", "0", ")", ";", "int", "nrecords", "=", "recordRange", ".", "length", "(", ")", ";", "// create the ArrayStructureMA", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "N3header", ".", "Vinfo", "vinfo", "=", "(", "N3header", ".", "Vinfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "(", "int", ")", "(", "vinfo", ".", "begin", "-", "header", ".", "recStart", ")", ")", ";", "// offset from start of record", "// construct the full shape", "int", "rank", "=", "m", ".", "getShape", "(", ")", ".", "length", ";", "int", "[", "]", "fullShape", "=", "new", "int", "[", "rank", "+", "1", "]", ";", "fullShape", "[", "0", "]", "=", "nrecords", ";", "// the first dimension", "System", ".", "arraycopy", "(", "m", ".", "getShape", "(", ")", ",", "0", ",", "fullShape", ",", "1", ",", "rank", ")", ";", "// the remaining dimensions", "Array", "data", "=", "Array", ".", "factory", "(", "m", ".", "getDataType", "(", ")", ",", "fullShape", ")", ";", "m", ".", "setDataArray", "(", "data", ")", ";", "m", ".", "setDataObject", "(", "data", ".", "getIndexIterator", "(", ")", ")", ";", "}", "//LOOK this is all wrong - why using recsize ???", "return", "null", ";", "/* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */", "}"], "docstring": "Read data from record structure, that has been subsetted.\nRead one record at at time, put requested variable into ArrayStructureMA.\n\n@param s the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException on error", "docstring_tokens": ["Read", "data", "from", "record", "structure", "that", "has", "been", "subsetted", ".", "Read", "one", "record", "at", "at", "time", "put", "requested", "variable", "into", "ArrayStructureMA", "."]}
{"code": "System.arraycopy(m.getShape(), 0, fullShape, 1, rank);", "comments": "the remaining dimensions", "lines": 16, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java", "func_name": "N3iosp.readRecordDataSubset", "original_string": "private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    Range recordRange = section.getRange(0);\n    int nrecords = recordRange.length();\n\n    // create the ArrayStructureMA\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record\n\n      // construct the full shape\n      int rank = m.getShape().length;\n      int[] fullShape = new int[rank + 1];\n      fullShape[0] = nrecords;  // the first dimension\n      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions\n\n      Array data = Array.factory(m.getDataType(), fullShape);\n      m.setDataArray( data);\n      m.setDataObject( data.getIndexIterator());\n    }\n\n    //LOOK this is all wrong - why using recsize ???\n    return null;\n    /* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */\n  }", "language": "java", "Allcodes": "private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {\n    Range recordRange = section.getRange(0);\n    int nrecords = recordRange.length();\n\n    // create the ArrayStructureMA\n    StructureMembers members = s.makeStructureMembers();\n    for (StructureMembers.Member m : members.getMembers()) {\n      Variable v2 = s.findVariable(m.getName());\n      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();\n      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record\n\n      // construct the full shape\n      int rank = m.getShape().length;\n      int[] fullShape = new int[rank + 1];\n      fullShape[0] = nrecords;  // the first dimension\n      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions\n\n      Array data = Array.factory(m.getDataType(), fullShape);\n      m.setDataArray( data);\n      m.setDataObject( data.getIndexIterator());\n    }\n\n    //LOOK this is all wrong - why using recsize ???\n    return null;\n    /* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "Array", "readRecordDataSubset", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", "{", "Range", "recordRange", "=", "section", ".", "getRange", "(", "0", ")", ";", "int", "nrecords", "=", "recordRange", ".", "length", "(", ")", ";", "// create the ArrayStructureMA", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "N3header", ".", "Vinfo", "vinfo", "=", "(", "N3header", ".", "Vinfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "(", "int", ")", "(", "vinfo", ".", "begin", "-", "header", ".", "recStart", ")", ")", ";", "// offset from start of record", "// construct the full shape", "int", "rank", "=", "m", ".", "getShape", "(", ")", ".", "length", ";", "int", "[", "]", "fullShape", "=", "new", "int", "[", "rank", "+", "1", "]", ";", "fullShape", "[", "0", "]", "=", "nrecords", ";", "// the first dimension", "System", ".", "arraycopy", "(", "m", ".", "getShape", "(", ")", ",", "0", ",", "fullShape", ",", "1", ",", "rank", ")", ";", "// the remaining dimensions", "Array", "data", "=", "Array", ".", "factory", "(", "m", ".", "getDataType", "(", ")", ",", "fullShape", ")", ";", "m", ".", "setDataArray", "(", "data", ")", ";", "m", ".", "setDataObject", "(", "data", ".", "getIndexIterator", "(", ")", ")", ";", "}", "//LOOK this is all wrong - why using recsize ???", "return", "null", ";", "/* members.setStructureSize(recsize);\n    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});\n\n    // note dependency on raf; should probably defer to subclass\n    // loop over records\n    byte[] record = new byte[ recsize];\n    ByteBuffer bb = ByteBuffer.wrap(record);\n    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {\n      if (debugRecord) System.out.println(\" readRecordDataSubset recno= \" + recnum);\n\n      // read one record\n      raf.seek(recStart + recnum * recsize); // where the record starts\n      if (recnum != numrecs - 1)\n        raf.readFully(record, 0, recsize);\n      else\n        raf.read(record, 0, recsize); // \"wart\" allows file to be one byte short. since its always padding, we allow\n\n      // transfer desired variable(s) to result array(s)\n      for (StructureMembers.Member m : members.getMembers()) {\n        IndexIterator dataIter = (IndexIterator) m.getDataObject();\n        IospHelper.copyFromByteBuffer(bb, m, dataIter);\n      }\n    }\n\n    return structureArray;  */", "}"], "docstring": "Read data from record structure, that has been subsetted.\nRead one record at at time, put requested variable into ArrayStructureMA.\n\n@param s the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException on error", "docstring_tokens": ["Read", "data", "from", "record", "structure", "that", "has", "been", "subsetted", ".", "Read", "one", "record", "at", "at", "time", "put", "requested", "variable", "into", "ArrayStructureMA", "."]}
{"code": "e.printStackTrace();", "comments": "shouldnt happen", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java", "func_name": "N3iosp.fillNonRecordVariables", "original_string": "protected void fillNonRecordVariables() throws IOException {\n    // run through each variable\n    for (Variable v : ncfile.getVariables()) {\n      if (v.isUnlimited()) continue;\n      try {\n        writeData(v, v.getShapeAsSection(), makeConstantArray(v));\n      } catch (InvalidRangeException e) {\n        e.printStackTrace();  // shouldnt happen\n      }\n    }\n  }", "language": "java", "Allcodes": "protected void fillNonRecordVariables() throws IOException {\n    // run through each variable\n    for (Variable v : ncfile.getVariables()) {\n      if (v.isUnlimited()) continue;\n      try {\n        writeData(v, v.getShapeAsSection(), makeConstantArray(v));\n      } catch (InvalidRangeException e) {\n        e.printStackTrace();  // shouldnt happen\n      }\n    }\n  }", "code_tokens": ["protected", "void", "fillNonRecordVariables", "(", ")", "throws", "IOException", "{", "// run through each variable", "for", "(", "Variable", "v", ":", "ncfile", ".", "getVariables", "(", ")", ")", "{", "if", "(", "v", ".", "isUnlimited", "(", ")", ")", "continue", ";", "try", "{", "writeData", "(", "v", ",", "v", ".", "getShapeAsSection", "(", ")", ",", "makeConstantArray", "(", "v", ")", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "// shouldnt happen", "}", "}", "}"], "docstring": "fill buffer with fill value", "docstring_tokens": ["fill", "buffer", "with", "fill", "value"]}
{"code": "ts.month  = calendar.get(Calendar.MONTH) + 1;", "comments": "MONTH is zero based", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/grads/GradsTimeDimension.java", "func_name": "GradsTimeDimension.makeTimeStruct", "original_string": "private GradsTimeStruct makeTimeStruct(Calendar calendar) {\n        GradsTimeStruct ts = new GradsTimeStruct();\n        ts.year   = calendar.get(Calendar.YEAR);\n        ts.month  = calendar.get(Calendar.MONTH) + 1;  // MONTH is zero based\n        ts.day    = calendar.get(Calendar.DAY_OF_MONTH);\n        ts.hour   = calendar.get(Calendar.HOUR_OF_DAY);\n        ts.minute = calendar.get(Calendar.MINUTE);\n        ts.jday   = calendar.get(Calendar.DAY_OF_YEAR);\n        return ts;\n    }", "language": "java", "Allcodes": "private GradsTimeStruct makeTimeStruct(Calendar calendar) {\n        GradsTimeStruct ts = new GradsTimeStruct();\n        ts.year   = calendar.get(Calendar.YEAR);\n        ts.month  = calendar.get(Calendar.MONTH) + 1;  // MONTH is zero based\n        ts.day    = calendar.get(Calendar.DAY_OF_MONTH);\n        ts.hour   = calendar.get(Calendar.HOUR_OF_DAY);\n        ts.minute = calendar.get(Calendar.MINUTE);\n        ts.jday   = calendar.get(Calendar.DAY_OF_YEAR);\n        return ts;\n    }", "code_tokens": ["private", "GradsTimeStruct", "makeTimeStruct", "(", "Calendar", "calendar", ")", "{", "GradsTimeStruct", "ts", "=", "new", "GradsTimeStruct", "(", ")", ";", "ts", ".", "year", "=", "calendar", ".", "get", "(", "Calendar", ".", "YEAR", ")", ";", "ts", ".", "month", "=", "calendar", ".", "get", "(", "Calendar", ".", "MONTH", ")", "+", "1", ";", "// MONTH is zero based", "ts", ".", "day", "=", "calendar", ".", "get", "(", "Calendar", ".", "DAY_OF_MONTH", ")", ";", "ts", ".", "hour", "=", "calendar", ".", "get", "(", "Calendar", ".", "HOUR_OF_DAY", ")", ";", "ts", ".", "minute", "=", "calendar", ".", "get", "(", "Calendar", ".", "MINUTE", ")", ";", "ts", ".", "jday", "=", "calendar", ".", "get", "(", "Calendar", ".", "DAY_OF_YEAR", ")", ";", "return", "ts", ";", "}"], "docstring": "Make a GradsTimeStruct from the calendar state\n\n@param calendar  the calendar\n\n@return the corresponding GradsTimeStruct", "docstring_tokens": ["Make", "a", "GradsTimeStruct", "from", "the", "calendar", "state"]}
{"code": "String units = AbstractTransformBuilder.getGeoCoordinateUnits(ds, ctv);", "comments": "barfola", "lines": 56, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/CoordTransBuilder.java", "func_name": "CoordTransBuilder.makeCoordinateTransform", "original_string": "static public CoordinateTransform makeCoordinateTransform (NetcdfDataset ds, AttributeContainer ctv, Formatter parseInfo, Formatter errInfo) {\r\n    // standard name\r\n    String transform_name = ctv.findAttValueIgnoreCase(\"transform_name\", null);\r\n    if (null == transform_name)\r\n      transform_name = ctv.findAttValueIgnoreCase(\"Projection_Name\", null);\r\n\r\n    // these names are from CF - dont want to have to duplicate\r\n    if (null == transform_name)\r\n      transform_name = ctv.findAttValueIgnoreCase(CF.GRID_MAPPING_NAME, null);\r\n    if (null == transform_name)\r\n      transform_name = ctv.findAttValueIgnoreCase(CF.STANDARD_NAME, null);\r\n\r\n    if (null == transform_name) {\r\n      parseInfo.format(\"**Failed to find Coordinate Transform name from Variable= %s%n\", ctv);\r\n      return null;\r\n    }\r\n\r\n    transform_name = transform_name.trim();\r\n\r\n    // do we have a transform registered for this ?\r\n    Class builderClass = null;\r\n    for (Transform transform : transformList) {\r\n      if (transform.transName.equals(transform_name)) {\r\n        builderClass = transform.transClass;\r\n        break;\r\n      }\r\n    }\r\n    if (null == builderClass) {\r\n      parseInfo.format(\"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\", transform_name, ctv);\r\n      return null;\r\n    }\r\n\r\n         // get an instance of that class\r\n    Object builderObject;\r\n    try {\r\n      builderObject = builderClass.newInstance();\r\n    } catch (InstantiationException | IllegalAccessException e) {\r\n      log.error(\"Cant create new instance \"+builderClass.getName(), e);\r\n      return null;\r\n    }\r\n\r\n    if (null == builderObject) { // cant happen - because this was tested in registerTransform()\r\n      parseInfo.format(\"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\", builderClass.getName(), ctv);\r\n      return null;\r\n    }\r\n\r\n    CoordinateTransform ct;\r\n    if (builderObject instanceof VertTransformBuilderIF){\r\n      VertTransformBuilderIF vertBuilder = (VertTransformBuilderIF) builderObject;\r\n      vertBuilder.setErrorBuffer(errInfo);\r\n      ct = vertBuilder.makeCoordinateTransform(ds, ctv);\r\n\r\n    } else if (builderObject instanceof HorizTransformBuilderIF){\r\n      HorizTransformBuilderIF horizBuilder = (HorizTransformBuilderIF) builderObject;\r\n      horizBuilder.setErrorBuffer(errInfo);\r\n      String units = AbstractTransformBuilder.getGeoCoordinateUnits(ds, ctv); // barfola\r\n      ct = horizBuilder.makeCoordinateTransform(ctv, units);\r\n\r\n    } else {\r\n      log.error(\"Illegals class \"+builderClass.getName());\r\n      return null;\r\n    }\r\n\r\n    if (ct != null) {\r\n      parseInfo.format(\" Made Coordinate transform %s from variable %s: %s%n\", transform_name, ctv.getName(), builderObject.getClass().getName());\r\n    }\r\n\r\n    return ct;\r\n  }", "language": "java", "Allcodes": "static public CoordinateTransform makeCoordinateTransform (NetcdfDataset ds, AttributeContainer ctv, Formatter parseInfo, Formatter errInfo) {\r\n    // standard name\r\n    String transform_name = ctv.findAttValueIgnoreCase(\"transform_name\", null);\r\n    if (null == transform_name)\r\n      transform_name = ctv.findAttValueIgnoreCase(\"Projection_Name\", null);\r\n\r\n    // these names are from CF - dont want to have to duplicate\r\n    if (null == transform_name)\r\n      transform_name = ctv.findAttValueIgnoreCase(CF.GRID_MAPPING_NAME, null);\r\n    if (null == transform_name)\r\n      transform_name = ctv.findAttValueIgnoreCase(CF.STANDARD_NAME, null);\r\n\r\n    if (null == transform_name) {\r\n      parseInfo.format(\"**Failed to find Coordinate Transform name from Variable= %s%n\", ctv);\r\n      return null;\r\n    }\r\n\r\n    transform_name = transform_name.trim();\r\n\r\n    // do we have a transform registered for this ?\r\n    Class builderClass = null;\r\n    for (Transform transform : transformList) {\r\n      if (transform.transName.equals(transform_name)) {\r\n        builderClass = transform.transClass;\r\n        break;\r\n      }\r\n    }\r\n    if (null == builderClass) {\r\n      parseInfo.format(\"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\", transform_name, ctv);\r\n      return null;\r\n    }\r\n\r\n         // get an instance of that class\r\n    Object builderObject;\r\n    try {\r\n      builderObject = builderClass.newInstance();\r\n    } catch (InstantiationException | IllegalAccessException e) {\r\n      log.error(\"Cant create new instance \"+builderClass.getName(), e);\r\n      return null;\r\n    }\r\n\r\n    if (null == builderObject) { // cant happen - because this was tested in registerTransform()\r\n      parseInfo.format(\"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\", builderClass.getName(), ctv);\r\n      return null;\r\n    }\r\n\r\n    CoordinateTransform ct;\r\n    if (builderObject instanceof VertTransformBuilderIF){\r\n      VertTransformBuilderIF vertBuilder = (VertTransformBuilderIF) builderObject;\r\n      vertBuilder.setErrorBuffer(errInfo);\r\n      ct = vertBuilder.makeCoordinateTransform(ds, ctv);\r\n\r\n    } else if (builderObject instanceof HorizTransformBuilderIF){\r\n      HorizTransformBuilderIF horizBuilder = (HorizTransformBuilderIF) builderObject;\r\n      horizBuilder.setErrorBuffer(errInfo);\r\n      String units = AbstractTransformBuilder.getGeoCoordinateUnits(ds, ctv); // barfola\r\n      ct = horizBuilder.makeCoordinateTransform(ctv, units);\r\n\r\n    } else {\r\n      log.error(\"Illegals class \"+builderClass.getName());\r\n      return null;\r\n    }\r\n\r\n    if (ct != null) {\r\n      parseInfo.format(\" Made Coordinate transform %s from variable %s: %s%n\", transform_name, ctv.getName(), builderObject.getClass().getName());\r\n    }\r\n\r\n    return ct;\r\n  }", "code_tokens": ["static", "public", "CoordinateTransform", "makeCoordinateTransform", "(", "NetcdfDataset", "ds", ",", "AttributeContainer", "ctv", ",", "Formatter", "parseInfo", ",", "Formatter", "errInfo", ")", "{", "// standard name\r", "String", "transform_name", "=", "ctv", ".", "findAttValueIgnoreCase", "(", "\"transform_name\"", ",", "null", ")", ";", "if", "(", "null", "==", "transform_name", ")", "transform_name", "=", "ctv", ".", "findAttValueIgnoreCase", "(", "\"Projection_Name\"", ",", "null", ")", ";", "// these names are from CF - dont want to have to duplicate\r", "if", "(", "null", "==", "transform_name", ")", "transform_name", "=", "ctv", ".", "findAttValueIgnoreCase", "(", "CF", ".", "GRID_MAPPING_NAME", ",", "null", ")", ";", "if", "(", "null", "==", "transform_name", ")", "transform_name", "=", "ctv", ".", "findAttValueIgnoreCase", "(", "CF", ".", "STANDARD_NAME", ",", "null", ")", ";", "if", "(", "null", "==", "transform_name", ")", "{", "parseInfo", ".", "format", "(", "\"**Failed to find Coordinate Transform name from Variable= %s%n\"", ",", "ctv", ")", ";", "return", "null", ";", "}", "transform_name", "=", "transform_name", ".", "trim", "(", ")", ";", "// do we have a transform registered for this ?\r", "Class", "builderClass", "=", "null", ";", "for", "(", "Transform", "transform", ":", "transformList", ")", "{", "if", "(", "transform", ".", "transName", ".", "equals", "(", "transform_name", ")", ")", "{", "builderClass", "=", "transform", ".", "transClass", ";", "break", ";", "}", "}", "if", "(", "null", "==", "builderClass", ")", "{", "parseInfo", ".", "format", "(", "\"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\"", ",", "transform_name", ",", "ctv", ")", ";", "return", "null", ";", "}", "// get an instance of that class\r", "Object", "builderObject", ";", "try", "{", "builderObject", "=", "builderClass", ".", "newInstance", "(", ")", ";", "}", "catch", "(", "InstantiationException", "|", "IllegalAccessException", "e", ")", "{", "log", ".", "error", "(", "\"Cant create new instance \"", "+", "builderClass", ".", "getName", "(", ")", ",", "e", ")", ";", "return", "null", ";", "}", "if", "(", "null", "==", "builderObject", ")", "{", "// cant happen - because this was tested in registerTransform()\r", "parseInfo", ".", "format", "(", "\"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\"", ",", "builderClass", ".", "getName", "(", ")", ",", "ctv", ")", ";", "return", "null", ";", "}", "CoordinateTransform", "ct", ";", "if", "(", "builderObject", "instanceof", "VertTransformBuilderIF", ")", "{", "VertTransformBuilderIF", "vertBuilder", "=", "(", "VertTransformBuilderIF", ")", "builderObject", ";", "vertBuilder", ".", "setErrorBuffer", "(", "errInfo", ")", ";", "ct", "=", "vertBuilder", ".", "makeCoordinateTransform", "(", "ds", ",", "ctv", ")", ";", "}", "else", "if", "(", "builderObject", "instanceof", "HorizTransformBuilderIF", ")", "{", "HorizTransformBuilderIF", "horizBuilder", "=", "(", "HorizTransformBuilderIF", ")", "builderObject", ";", "horizBuilder", ".", "setErrorBuffer", "(", "errInfo", ")", ";", "String", "units", "=", "AbstractTransformBuilder", ".", "getGeoCoordinateUnits", "(", "ds", ",", "ctv", ")", ";", "// barfola\r", "ct", "=", "horizBuilder", ".", "makeCoordinateTransform", "(", "ctv", ",", "units", ")", ";", "}", "else", "{", "log", ".", "error", "(", "\"Illegals class \"", "+", "builderClass", ".", "getName", "(", ")", ")", ";", "return", "null", ";", "}", "if", "(", "ct", "!=", "null", ")", "{", "parseInfo", ".", "format", "(", "\" Made Coordinate transform %s from variable %s: %s%n\"", ",", "transform_name", ",", "ctv", ".", "getName", "(", ")", ",", "builderObject", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "}", "return", "ct", ";", "}"], "docstring": "Make a CoordinateTransform object from the parameters in a Coordinate Transform Variable, using an intrinsic or registered CoordTransBuilder.\n@param ds enclosing dataset, only used for vertical transforms\n@param ctv the Coordinate Transform Variable - container for the transform parameters\n@param parseInfo pass back information about the parsing.\n@param errInfo pass back error information.\n@return CoordinateTransform, or null if failure.", "docstring_tokens": ["Make", "a", "CoordinateTransform", "object", "from", "the", "parameters", "in", "a", "Coordinate", "Transform", "Variable", "using", "an", "intrinsic", "or", "registered", "CoordTransBuilder", "."]}
{"code": "result.finish();", "comments": "stuff that cant be done in the constructor", "lines": 44, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib2/Grib2Gds.java", "func_name": "Grib2Gds.factory", "original_string": "public static Grib2Gds factory(int template, byte[] data) {\r\n    Grib2Gds result;\r\n    switch (template) {\r\n      case 0:\r\n        result = new LatLon(data);\r\n        break;\r\n      case 1:\r\n        result = new RotatedLatLon(data);\r\n        break;\r\n      case 10:\r\n        result = new Mercator(data);\r\n        break;\r\n      case 20:\r\n        result = new PolarStereographic(data);\r\n        break;\r\n      case 30:\r\n        result = new LambertConformal(data, 30);\r\n        break;\r\n      case 31:\r\n        result = new AlbersEqualArea(data);\r\n        break;\r\n      case 40:\r\n        result = new GaussLatLon(data);\r\n        break;\r\n      case 50:  // Spherical Harmonic Coefficients BOGUS\r\n        result = new GdsSpherical(data, template);\r\n        break;\r\n      case 90:\r\n        result = new SpaceViewPerspective(data);\r\n        break;\r\n\r\n      // LOOK NCEP specific\r\n      case 204:\r\n        result = new CurvilinearOrthogonal(data);\r\n        break;\r\n      case 32769:\r\n        result = new RotatedLatLon32769(data);\r\n        break;\r\n\r\n      default:\r\n        throw new UnsupportedOperationException(\"Unsupported GDS type = \" + template);\r\n    }\r\n\r\n    result.finish(); // stuff that cant be done in the constructor\r\n    return result;\r\n  }", "language": "java", "Allcodes": "public static Grib2Gds factory(int template, byte[] data) {\r\n    Grib2Gds result;\r\n    switch (template) {\r\n      case 0:\r\n        result = new LatLon(data);\r\n        break;\r\n      case 1:\r\n        result = new RotatedLatLon(data);\r\n        break;\r\n      case 10:\r\n        result = new Mercator(data);\r\n        break;\r\n      case 20:\r\n        result = new PolarStereographic(data);\r\n        break;\r\n      case 30:\r\n        result = new LambertConformal(data, 30);\r\n        break;\r\n      case 31:\r\n        result = new AlbersEqualArea(data);\r\n        break;\r\n      case 40:\r\n        result = new GaussLatLon(data);\r\n        break;\r\n      case 50:  // Spherical Harmonic Coefficients BOGUS\r\n        result = new GdsSpherical(data, template);\r\n        break;\r\n      case 90:\r\n        result = new SpaceViewPerspective(data);\r\n        break;\r\n\r\n      // LOOK NCEP specific\r\n      case 204:\r\n        result = new CurvilinearOrthogonal(data);\r\n        break;\r\n      case 32769:\r\n        result = new RotatedLatLon32769(data);\r\n        break;\r\n\r\n      default:\r\n        throw new UnsupportedOperationException(\"Unsupported GDS type = \" + template);\r\n    }\r\n\r\n    result.finish(); // stuff that cant be done in the constructor\r\n    return result;\r\n  }", "code_tokens": ["public", "static", "Grib2Gds", "factory", "(", "int", "template", ",", "byte", "[", "]", "data", ")", "{", "Grib2Gds", "result", ";", "switch", "(", "template", ")", "{", "case", "0", ":", "result", "=", "new", "LatLon", "(", "data", ")", ";", "break", ";", "case", "1", ":", "result", "=", "new", "RotatedLatLon", "(", "data", ")", ";", "break", ";", "case", "10", ":", "result", "=", "new", "Mercator", "(", "data", ")", ";", "break", ";", "case", "20", ":", "result", "=", "new", "PolarStereographic", "(", "data", ")", ";", "break", ";", "case", "30", ":", "result", "=", "new", "LambertConformal", "(", "data", ",", "30", ")", ";", "break", ";", "case", "31", ":", "result", "=", "new", "AlbersEqualArea", "(", "data", ")", ";", "break", ";", "case", "40", ":", "result", "=", "new", "GaussLatLon", "(", "data", ")", ";", "break", ";", "case", "50", ":", "// Spherical Harmonic Coefficients BOGUS\r", "result", "=", "new", "GdsSpherical", "(", "data", ",", "template", ")", ";", "break", ";", "case", "90", ":", "result", "=", "new", "SpaceViewPerspective", "(", "data", ")", ";", "break", ";", "// LOOK NCEP specific\r", "case", "204", ":", "result", "=", "new", "CurvilinearOrthogonal", "(", "data", ")", ";", "break", ";", "case", "32769", ":", "result", "=", "new", "RotatedLatLon32769", "(", "data", ")", ";", "break", ";", "default", ":", "throw", "new", "UnsupportedOperationException", "(", "\"Unsupported GDS type = \"", "+", "template", ")", ";", "}", "result", ".", "finish", "(", ")", ";", "// stuff that cant be done in the constructor\r", "return", "result", ";", "}"], "docstring": "reletive error in position - GRIB numbers sometimes miscoded", "docstring_tokens": ["reletive", "error", "in", "position", "-", "GRIB", "numbers", "sometimes", "miscoded"]}
{"code": "int temp = rf.readInt();", "comments": "check for missing value", "lines": 18, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/mcidas/McIDASGridReader.java", "func_name": "McIDASGridReader.readGrid", "original_string": "public float[] readGrid(McIDASGridRecord gr) throws IOException {\n\n    float[] data;\n    //try {\n      int te = (gr.getOffsetToHeader() + 64) * 4;\n      int rows = gr.getRows();\n      int cols = gr.getColumns();\n      rf.seek(te);\n\n      float scale = (float) gr.getParamScale();\n\n      data = new float[rows * cols];\n      rf.order(needToSwap ? RandomAccessFile.LITTLE_ENDIAN : RandomAccessFile.BIG_ENDIAN);\n      // int n = 0;\n      // store such that 0,0 is in lower left corner...\n      for (int nc = 0; nc < cols; nc++) {\n        for (int nr = 0; nr < rows; nr++) {\n          int temp = rf.readInt();  // check for missing value\n          data[(rows - nr - 1) * cols + nc] = (temp\n                  == McIDASUtil.MCMISSING)\n                  ? Float.NaN\n                  : ((float) temp) / scale;\n        }\n      }\n      rf.order(RandomAccessFile.BIG_ENDIAN);\n    //} catch (Exception esc) {\n    //  System.out.println(esc);\n    //}\n    return data;\n  }", "language": "java", "Allcodes": "public float[] readGrid(McIDASGridRecord gr) throws IOException {\n\n    float[] data;\n    //try {\n      int te = (gr.getOffsetToHeader() + 64) * 4;\n      int rows = gr.getRows();\n      int cols = gr.getColumns();\n      rf.seek(te);\n\n      float scale = (float) gr.getParamScale();\n\n      data = new float[rows * cols];\n      rf.order(needToSwap ? RandomAccessFile.LITTLE_ENDIAN : RandomAccessFile.BIG_ENDIAN);\n      // int n = 0;\n      // store such that 0,0 is in lower left corner...\n      for (int nc = 0; nc < cols; nc++) {\n        for (int nr = 0; nr < rows; nr++) {\n          int temp = rf.readInt();  // check for missing value\n          data[(rows - nr - 1) * cols + nc] = (temp\n                  == McIDASUtil.MCMISSING)\n                  ? Float.NaN\n                  : ((float) temp) / scale;\n        }\n      }\n      rf.order(RandomAccessFile.BIG_ENDIAN);\n    //} catch (Exception esc) {\n    //  System.out.println(esc);\n    //}\n    return data;\n  }", "code_tokens": ["public", "float", "[", "]", "readGrid", "(", "McIDASGridRecord", "gr", ")", "throws", "IOException", "{", "float", "[", "]", "data", ";", "//try {", "int", "te", "=", "(", "gr", ".", "getOffsetToHeader", "(", ")", "+", "64", ")", "*", "4", ";", "int", "rows", "=", "gr", ".", "getRows", "(", ")", ";", "int", "cols", "=", "gr", ".", "getColumns", "(", ")", ";", "rf", ".", "seek", "(", "te", ")", ";", "float", "scale", "=", "(", "float", ")", "gr", ".", "getParamScale", "(", ")", ";", "data", "=", "new", "float", "[", "rows", "*", "cols", "]", ";", "rf", ".", "order", "(", "needToSwap", "?", "RandomAccessFile", ".", "LITTLE_ENDIAN", ":", "RandomAccessFile", ".", "BIG_ENDIAN", ")", ";", "// int n = 0;", "// store such that 0,0 is in lower left corner...", "for", "(", "int", "nc", "=", "0", ";", "nc", "<", "cols", ";", "nc", "++", ")", "{", "for", "(", "int", "nr", "=", "0", ";", "nr", "<", "rows", ";", "nr", "++", ")", "{", "int", "temp", "=", "rf", ".", "readInt", "(", ")", ";", "// check for missing value", "data", "[", "(", "rows", "-", "nr", "-", "1", ")", "*", "cols", "+", "nc", "]", "=", "(", "temp", "==", "McIDASUtil", ".", "MCMISSING", ")", "?", "Float", ".", "NaN", ":", "(", "(", "float", ")", "temp", ")", "/", "scale", ";", "}", "}", "rf", ".", "order", "(", "RandomAccessFile", ".", "BIG_ENDIAN", ")", ";", "//} catch (Exception esc) {", "//  System.out.println(esc);", "//}", "return", "data", ";", "}"], "docstring": "Read the grid\n\n@param gr the grid record\n@return the data", "docstring_tokens": ["Read", "the", "grid"]}
{"code": "int irow = 1;", "comments": "Always 1 for grids", "lines": 3, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/gempak/GempakGridReader.java", "func_name": "GempakGridReader.getGridPackingType", "original_string": "public int getGridPackingType(int gridNumber) throws IOException {\n    // See DM_RDTR\n    int irow = 1;  // Always 1 for grids\n    if ((gridNumber < 1) || (gridNumber > dmLabel.kcol)) {\n      logWarning(\"bad grid number \" + gridNumber);\n      return -9;\n    }\n    int iprt = getPartNumber(\"GRID\");\n    if (iprt == 0) {\n      logWarning(\"couldn't find part: GRID\");\n      return -10;\n    }\n    // gotta subtract 1 because parts are 1 but List is 0 based\n    DMPart part = parts.get(iprt - 1);\n    // check for valid data type\n    if (part.ktyprt != MDGRID) {\n      logWarning(\"Not a valid type: \"\n              + GempakUtil.getDataType(part.ktyprt));\n      return -21;\n    }\n    int ilenhd = part.klnhdr;\n    int ipoint = dmLabel.kpdata\n            + (irow - 1) * dmLabel.kcol * dmLabel.kprt\n            + (gridNumber - 1) * dmLabel.kprt + (iprt - 1);\n    // From DM_RPKG\n    int istart = DM_RINT(ipoint);\n    if (istart == 0) {\n      return -15;\n    }\n    int length = DM_RINT(istart);\n    int isword = istart + 1;\n    if (length <= ilenhd) {\n      logWarning(\"length (\" + length + \") is less than header length (\"\n              + ilenhd + \")\");\n      return -15;\n    } else if (Math.abs(length) > 10000000) {\n      logWarning(\"length is huge: \" + length);\n      return -34;\n    }\n    int[] header = new int[ilenhd];\n    DM_RINT(isword, header);\n    // int nword = length - ilenhd;\n    isword += ilenhd;\n    // read the data packing type\n    return DM_RINT(isword);\n  }", "language": "java", "Allcodes": "public int getGridPackingType(int gridNumber) throws IOException {\n    // See DM_RDTR\n    int irow = 1;  // Always 1 for grids\n    if ((gridNumber < 1) || (gridNumber > dmLabel.kcol)) {\n      logWarning(\"bad grid number \" + gridNumber);\n      return -9;\n    }\n    int iprt = getPartNumber(\"GRID\");\n    if (iprt == 0) {\n      logWarning(\"couldn't find part: GRID\");\n      return -10;\n    }\n    // gotta subtract 1 because parts are 1 but List is 0 based\n    DMPart part = parts.get(iprt - 1);\n    // check for valid data type\n    if (part.ktyprt != MDGRID) {\n      logWarning(\"Not a valid type: \"\n              + GempakUtil.getDataType(part.ktyprt));\n      return -21;\n    }\n    int ilenhd = part.klnhdr;\n    int ipoint = dmLabel.kpdata\n            + (irow - 1) * dmLabel.kcol * dmLabel.kprt\n            + (gridNumber - 1) * dmLabel.kprt + (iprt - 1);\n    // From DM_RPKG\n    int istart = DM_RINT(ipoint);\n    if (istart == 0) {\n      return -15;\n    }\n    int length = DM_RINT(istart);\n    int isword = istart + 1;\n    if (length <= ilenhd) {\n      logWarning(\"length (\" + length + \") is less than header length (\"\n              + ilenhd + \")\");\n      return -15;\n    } else if (Math.abs(length) > 10000000) {\n      logWarning(\"length is huge: \" + length);\n      return -34;\n    }\n    int[] header = new int[ilenhd];\n    DM_RINT(isword, header);\n    // int nword = length - ilenhd;\n    isword += ilenhd;\n    // read the data packing type\n    return DM_RINT(isword);\n  }", "code_tokens": ["public", "int", "getGridPackingType", "(", "int", "gridNumber", ")", "throws", "IOException", "{", "// See DM_RDTR", "int", "irow", "=", "1", ";", "// Always 1 for grids", "if", "(", "(", "gridNumber", "<", "1", ")", "||", "(", "gridNumber", ">", "dmLabel", ".", "kcol", ")", ")", "{", "logWarning", "(", "\"bad grid number \"", "+", "gridNumber", ")", ";", "return", "-", "9", ";", "}", "int", "iprt", "=", "getPartNumber", "(", "\"GRID\"", ")", ";", "if", "(", "iprt", "==", "0", ")", "{", "logWarning", "(", "\"couldn't find part: GRID\"", ")", ";", "return", "-", "10", ";", "}", "// gotta subtract 1 because parts are 1 but List is 0 based", "DMPart", "part", "=", "parts", ".", "get", "(", "iprt", "-", "1", ")", ";", "// check for valid data type", "if", "(", "part", ".", "ktyprt", "!=", "MDGRID", ")", "{", "logWarning", "(", "\"Not a valid type: \"", "+", "GempakUtil", ".", "getDataType", "(", "part", ".", "ktyprt", ")", ")", ";", "return", "-", "21", ";", "}", "int", "ilenhd", "=", "part", ".", "klnhdr", ";", "int", "ipoint", "=", "dmLabel", ".", "kpdata", "+", "(", "irow", "-", "1", ")", "*", "dmLabel", ".", "kcol", "*", "dmLabel", ".", "kprt", "+", "(", "gridNumber", "-", "1", ")", "*", "dmLabel", ".", "kprt", "+", "(", "iprt", "-", "1", ")", ";", "// From DM_RPKG", "int", "istart", "=", "DM_RINT", "(", "ipoint", ")", ";", "if", "(", "istart", "==", "0", ")", "{", "return", "-", "15", ";", "}", "int", "length", "=", "DM_RINT", "(", "istart", ")", ";", "int", "isword", "=", "istart", "+", "1", ";", "if", "(", "length", "<=", "ilenhd", ")", "{", "logWarning", "(", "\"length (\"", "+", "length", "+", "\") is less than header length (\"", "+", "ilenhd", "+", "\")\"", ")", ";", "return", "-", "15", ";", "}", "else", "if", "(", "Math", ".", "abs", "(", "length", ")", ">", "10000000", ")", "{", "logWarning", "(", "\"length is huge: \"", "+", "length", ")", ";", "return", "-", "34", ";", "}", "int", "[", "]", "header", "=", "new", "int", "[", "ilenhd", "]", ";", "DM_RINT", "(", "isword", ",", "header", ")", ";", "// int nword = length - ilenhd;", "isword", "+=", "ilenhd", ";", "// read the data packing type", "return", "DM_RINT", "(", "isword", ")", ";", "}"], "docstring": "Get the grid packing type\n\n@param gridNumber grid number\n@return packing type or error number\n@throws IOException problem reading file", "docstring_tokens": ["Get", "the", "grid", "packing", "type"]}
{"code": "int ibit = 1;", "comments": "1 based bit position", "lines": 27, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/gempak/GempakGridReader.java", "func_name": "GempakGridReader.DP_UGRB", "original_string": "private synchronized float[] DP_UGRB(int[] idata, int kxky, int nbits,\n                                       float qmin, float scale,\n                                       boolean misflg, int decimalScale)\n          throws IOException {\n    float scaleFactor = (decimalScale == 0)\n            ? 1.f\n            : (float) Math.pow(10.0, -decimalScale);\n    //\n    //Check for valid input.\n    //\n    float[] grid = new float[kxky];\n    if ((nbits <= 1) || (nbits > 31)) {\n      return grid;\n    }\n    if (scale == 0.) {\n      return grid;\n    }\n\n    //\n    //Compute missing data value.\n    //\n    int imax = (int) (Math.pow(2, nbits) - 1);\n    //\n    //Retrieve data points from buffer.\n    //\n    int iword = 0;\n    int ibit = 1;  // 1 based bit position\n    for (int i = 0; i < kxky; i++) {\n      //\n      //    Get the integer from the buffer.\n      //\n      int jshft = nbits + ibit - 33;\n      int idat = 0;\n      idat = (jshft < 0)\n              ? idata[iword] >>> Math.abs(jshft)\n              : idata[iword] << jshft;\n      idat = idat & imax;\n      //\n      //    Check to see if packed integer overflows into next word. LOOK fishy bit operations\n      //\n      if (jshft > 0) {\n        jshft -= 32;\n        int idat2 = 0;\n        idat2 = idata[iword + 1] >>> Math.abs(jshft);\n        idat = idat | idat2;\n      }\n      //\n      //    Compute value of word.\n      //\n      if ((idat == imax) && misflg) {\n        grid[i] = RMISSD;\n      } else {\n        grid[i] = (qmin + idat * scale) * scaleFactor;\n      }\n      //\n      //    Set location for next word.\n      //\n      ibit += nbits;\n      if (ibit > 32) {\n        ibit -= 32;\n        iword++;\n      }\n            /*\n            if (i < 25) {\n                System.out.println(\"grid[\"+i+\"]: \" + grid[i]);\n            }\n            */\n    }\n    return grid;\n  }", "language": "java", "Allcodes": "private synchronized float[] DP_UGRB(int[] idata, int kxky, int nbits,\n                                       float qmin, float scale,\n                                       boolean misflg, int decimalScale)\n          throws IOException {\n    float scaleFactor = (decimalScale == 0)\n            ? 1.f\n            : (float) Math.pow(10.0, -decimalScale);\n    //\n    //Check for valid input.\n    //\n    float[] grid = new float[kxky];\n    if ((nbits <= 1) || (nbits > 31)) {\n      return grid;\n    }\n    if (scale == 0.) {\n      return grid;\n    }\n\n    //\n    //Compute missing data value.\n    //\n    int imax = (int) (Math.pow(2, nbits) - 1);\n    //\n    //Retrieve data points from buffer.\n    //\n    int iword = 0;\n    int ibit = 1;  // 1 based bit position\n    for (int i = 0; i < kxky; i++) {\n      //\n      //    Get the integer from the buffer.\n      //\n      int jshft = nbits + ibit - 33;\n      int idat = 0;\n      idat = (jshft < 0)\n              ? idata[iword] >>> Math.abs(jshft)\n              : idata[iword] << jshft;\n      idat = idat & imax;\n      //\n      //    Check to see if packed integer overflows into next word. LOOK fishy bit operations\n      //\n      if (jshft > 0) {\n        jshft -= 32;\n        int idat2 = 0;\n        idat2 = idata[iword + 1] >>> Math.abs(jshft);\n        idat = idat | idat2;\n      }\n      //\n      //    Compute value of word.\n      //\n      if ((idat == imax) && misflg) {\n        grid[i] = RMISSD;\n      } else {\n        grid[i] = (qmin + idat * scale) * scaleFactor;\n      }\n      //\n      //    Set location for next word.\n      //\n      ibit += nbits;\n      if (ibit > 32) {\n        ibit -= 32;\n        iword++;\n      }\n            /*\n            if (i < 25) {\n                System.out.println(\"grid[\"+i+\"]: \" + grid[i]);\n            }\n            */\n    }\n    return grid;\n  }", "code_tokens": ["private", "synchronized", "float", "[", "]", "DP_UGRB", "(", "int", "[", "]", "idata", ",", "int", "kxky", ",", "int", "nbits", ",", "float", "qmin", ",", "float", "scale", ",", "boolean", "misflg", ",", "int", "decimalScale", ")", "throws", "IOException", "{", "float", "scaleFactor", "=", "(", "decimalScale", "==", "0", ")", "?", "1.f", ":", "(", "float", ")", "Math", ".", "pow", "(", "10.0", ",", "-", "decimalScale", ")", ";", "//", "//Check for valid input.", "//", "float", "[", "]", "grid", "=", "new", "float", "[", "kxky", "]", ";", "if", "(", "(", "nbits", "<=", "1", ")", "||", "(", "nbits", ">", "31", ")", ")", "{", "return", "grid", ";", "}", "if", "(", "scale", "==", "0.", ")", "{", "return", "grid", ";", "}", "//", "//Compute missing data value.", "//", "int", "imax", "=", "(", "int", ")", "(", "Math", ".", "pow", "(", "2", ",", "nbits", ")", "-", "1", ")", ";", "//", "//Retrieve data points from buffer.", "//", "int", "iword", "=", "0", ";", "int", "ibit", "=", "1", ";", "// 1 based bit position", "for", "(", "int", "i", "=", "0", ";", "i", "<", "kxky", ";", "i", "++", ")", "{", "//", "//    Get the integer from the buffer.", "//", "int", "jshft", "=", "nbits", "+", "ibit", "-", "33", ";", "int", "idat", "=", "0", ";", "idat", "=", "(", "jshft", "<", "0", ")", "?", "idata", "[", "iword", "]", ">>>", "Math", ".", "abs", "(", "jshft", ")", ":", "idata", "[", "iword", "]", "<<", "jshft", ";", "idat", "=", "idat", "&", "imax", ";", "//", "//    Check to see if packed integer overflows into next word. LOOK fishy bit operations", "//", "if", "(", "jshft", ">", "0", ")", "{", "jshft", "-=", "32", ";", "int", "idat2", "=", "0", ";", "idat2", "=", "idata", "[", "iword", "+", "1", "]", ">>>", "Math", ".", "abs", "(", "jshft", ")", ";", "idat", "=", "idat", "|", "idat2", ";", "}", "//", "//    Compute value of word.", "//", "if", "(", "(", "idat", "==", "imax", ")", "&&", "misflg", ")", "{", "grid", "[", "i", "]", "=", "RMISSD", ";", "}", "else", "{", "grid", "[", "i", "]", "=", "(", "qmin", "+", "idat", "*", "scale", ")", "*", "scaleFactor", ";", "}", "//", "//    Set location for next word.", "//", "ibit", "+=", "nbits", ";", "if", "(", "ibit", ">", "32", ")", "{", "ibit", "-=", "32", ";", "iword", "++", ";", "}", "/*\n            if (i < 25) {\n                System.out.println(\"grid[\"+i+\"]: \" + grid[i]);\n            }\n            */", "}", "return", "grid", ";", "}"], "docstring": "Unpack grib data packed into ints\n\n@param idata        int array of packed data\n@param kxky         number of output points\n@param nbits        number of bits per point\n@param qmin         minimum (reference) value\n@param scale        parameter scale\n@param misflg       missing flag\n@param decimalScale scale of value to jive with units\n@return the array of unpacked values\n@throws IOException problem reading from the file", "docstring_tokens": ["Unpack", "grib", "data", "packed", "into", "ints"]}
{"code": "base = ISOChronology.getInstanceUTC();", "comments": "already in UTC", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/time/CalendarDate.java", "func_name": "CalendarDate.of", "original_string": "public static CalendarDate of(Calendar cal, int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) {\r\n    Chronology base = Calendar.getChronology(cal);\r\n    /* if (base == null)\r\n      base = ISOChronology.getInstanceUTC(); // already in UTC\r\n    else\r\n      base = ZonedChronology.getInstance( base, DateTimeZone.UTC); // otherwise wrap it to be in UTC  */\r\n\r\n    DateTime dt = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, base);\r\n    if (!Calendar.isDefaultChronology(cal)) dt = dt.withChronology(Calendar.getChronology(cal));\r\n    dt = dt.withZone(DateTimeZone.UTC);\r\n    return new CalendarDate(cal, dt);\r\n  }", "language": "java", "Allcodes": "public static CalendarDate of(Calendar cal, int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) {\r\n    Chronology base = Calendar.getChronology(cal);\r\n    /* if (base == null)\r\n      base = ISOChronology.getInstanceUTC(); // already in UTC\r\n    else\r\n      base = ZonedChronology.getInstance( base, DateTimeZone.UTC); // otherwise wrap it to be in UTC  */\r\n\r\n    DateTime dt = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, base);\r\n    if (!Calendar.isDefaultChronology(cal)) dt = dt.withChronology(Calendar.getChronology(cal));\r\n    dt = dt.withZone(DateTimeZone.UTC);\r\n    return new CalendarDate(cal, dt);\r\n  }", "code_tokens": ["public", "static", "CalendarDate", "of", "(", "Calendar", "cal", ",", "int", "year", ",", "int", "monthOfYear", ",", "int", "dayOfMonth", ",", "int", "hourOfDay", ",", "int", "minuteOfHour", ",", "int", "secondOfMinute", ")", "{", "Chronology", "base", "=", "Calendar", ".", "getChronology", "(", "cal", ")", ";", "/* if (base == null)\r\n      base = ISOChronology.getInstanceUTC(); // already in UTC\r\n    else\r\n      base = ZonedChronology.getInstance( base, DateTimeZone.UTC); // otherwise wrap it to be in UTC  */", "DateTime", "dt", "=", "new", "DateTime", "(", "year", ",", "monthOfYear", ",", "dayOfMonth", ",", "hourOfDay", ",", "minuteOfHour", ",", "secondOfMinute", ",", "base", ")", ";", "if", "(", "!", "Calendar", ".", "isDefaultChronology", "(", "cal", ")", ")", "dt", "=", "dt", ".", "withChronology", "(", "Calendar", ".", "getChronology", "(", "cal", ")", ")", ";", "dt", "=", "dt", ".", "withZone", "(", "DateTimeZone", ".", "UTC", ")", ";", "return", "new", "CalendarDate", "(", "cal", ",", "dt", ")", ";", "}"], "docstring": "Get Calendar date from fields. Uses UTZ time zone\n@param cal calendar to use, or null for default\n@param year any integer\n@param monthOfYear 1-12\n@param dayOfMonth 1-31\n@param hourOfDay  0-23\n@param minuteOfHour 0-59\n@param secondOfMinute 0-59\n@return CalendarDate", "docstring_tokens": ["Get", "Calendar", "date", "from", "fields", ".", "Uses", "UTZ", "time", "zone"]}
{"code": "base = ZonedChronology.getInstance( base, DateTimeZone.UTC);", "comments": "otherwise wrap it to be in UTC  */", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/time/CalendarDate.java", "func_name": "CalendarDate.of", "original_string": "public static CalendarDate of(Calendar cal, int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) {\r\n    Chronology base = Calendar.getChronology(cal);\r\n    /* if (base == null)\r\n      base = ISOChronology.getInstanceUTC(); // already in UTC\r\n    else\r\n      base = ZonedChronology.getInstance( base, DateTimeZone.UTC); // otherwise wrap it to be in UTC  */\r\n\r\n    DateTime dt = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, base);\r\n    if (!Calendar.isDefaultChronology(cal)) dt = dt.withChronology(Calendar.getChronology(cal));\r\n    dt = dt.withZone(DateTimeZone.UTC);\r\n    return new CalendarDate(cal, dt);\r\n  }", "language": "java", "Allcodes": "public static CalendarDate of(Calendar cal, int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) {\r\n    Chronology base = Calendar.getChronology(cal);\r\n    /* if (base == null)\r\n      base = ISOChronology.getInstanceUTC(); // already in UTC\r\n    else\r\n      base = ZonedChronology.getInstance( base, DateTimeZone.UTC); // otherwise wrap it to be in UTC  */\r\n\r\n    DateTime dt = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, base);\r\n    if (!Calendar.isDefaultChronology(cal)) dt = dt.withChronology(Calendar.getChronology(cal));\r\n    dt = dt.withZone(DateTimeZone.UTC);\r\n    return new CalendarDate(cal, dt);\r\n  }", "code_tokens": ["public", "static", "CalendarDate", "of", "(", "Calendar", "cal", ",", "int", "year", ",", "int", "monthOfYear", ",", "int", "dayOfMonth", ",", "int", "hourOfDay", ",", "int", "minuteOfHour", ",", "int", "secondOfMinute", ")", "{", "Chronology", "base", "=", "Calendar", ".", "getChronology", "(", "cal", ")", ";", "/* if (base == null)\r\n      base = ISOChronology.getInstanceUTC(); // already in UTC\r\n    else\r\n      base = ZonedChronology.getInstance( base, DateTimeZone.UTC); // otherwise wrap it to be in UTC  */", "DateTime", "dt", "=", "new", "DateTime", "(", "year", ",", "monthOfYear", ",", "dayOfMonth", ",", "hourOfDay", ",", "minuteOfHour", ",", "secondOfMinute", ",", "base", ")", ";", "if", "(", "!", "Calendar", ".", "isDefaultChronology", "(", "cal", ")", ")", "dt", "=", "dt", ".", "withChronology", "(", "Calendar", ".", "getChronology", "(", "cal", ")", ")", ";", "dt", "=", "dt", ".", "withZone", "(", "DateTimeZone", ".", "UTC", ")", ";", "return", "new", "CalendarDate", "(", "cal", ",", "dt", ")", ";", "}"], "docstring": "Get Calendar date from fields. Uses UTZ time zone\n@param cal calendar to use, or null for default\n@param year any integer\n@param monthOfYear 1-12\n@param dayOfMonth 1-31\n@param hourOfDay  0-23\n@param minuteOfHour 0-59\n@param secondOfMinute 0-59\n@return CalendarDate", "docstring_tokens": ["Get", "Calendar", "date", "from", "fields", ".", "Uses", "UTZ", "time", "zone"]}
{"code": "return baseDate.add(CalendarPeriod.of( (int) value, periodField));", "comments": "LOOK int vs double", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/time/CalendarDateUnit.java", "func_name": "CalendarDateUnit.makeCalendarDate", "original_string": "public CalendarDate makeCalendarDate(double value) {\r\n    if (isCalendarField)\r\n      return baseDate.add(CalendarPeriod.of( (int) value, periodField));  // LOOK int vs double\r\n    else\r\n      return baseDate.add( value, periodField);\r\n  }", "language": "java", "Allcodes": "public CalendarDate makeCalendarDate(double value) {\r\n    if (isCalendarField)\r\n      return baseDate.add(CalendarPeriod.of( (int) value, periodField));  // LOOK int vs double\r\n    else\r\n      return baseDate.add( value, periodField);\r\n  }", "code_tokens": ["public", "CalendarDate", "makeCalendarDate", "(", "double", "value", ")", "{", "if", "(", "isCalendarField", ")", "return", "baseDate", ".", "add", "(", "CalendarPeriod", ".", "of", "(", "(", "int", ")", "value", ",", "periodField", ")", ")", ";", "// LOOK int vs double\r", "else", "return", "baseDate", ".", "add", "(", "value", ",", "periodField", ")", ";", "}"], "docstring": "inverse of makeOffsetFromRefDate", "docstring_tokens": ["inverse", "of", "makeOffsetFromRefDate"]}
{"code": "String stnName = raf.readString(16);", "comments": "System.out.println(\" stnName=\"+stnName.trim());", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/sigmet/SigmetIOServiceProvider.java", "func_name": "SigmetIOServiceProvider.readStnNames", "original_string": "public java.util.Map<String, String> readStnNames(ucar.unidata.io.RandomAccessFile raf) {\r\n    java.util.Map<String, String> hdrNames = new java.util.HashMap<String, String>();\r\n    try {\r\n      raf.seek(6288);\r\n      String stnName = raf.readString(16);  //System.out.println(\" stnName=\"+stnName.trim());\r\n      raf.seek(6306);\r\n      String stnName_util = raf.readString(16);\r\n      hdrNames.put(\"StationName\", stnName.trim());\r\n      hdrNames.put(\"StationName_SetupUtility\", stnName_util.trim());\r\n    } catch (Exception e) {\r\n      System.out.println(e.toString());\r\n      e.printStackTrace();\r\n    }\r\n    return hdrNames;\r\n  }", "language": "java", "Allcodes": "public java.util.Map<String, String> readStnNames(ucar.unidata.io.RandomAccessFile raf) {\r\n    java.util.Map<String, String> hdrNames = new java.util.HashMap<String, String>();\r\n    try {\r\n      raf.seek(6288);\r\n      String stnName = raf.readString(16);  //System.out.println(\" stnName=\"+stnName.trim());\r\n      raf.seek(6306);\r\n      String stnName_util = raf.readString(16);\r\n      hdrNames.put(\"StationName\", stnName.trim());\r\n      hdrNames.put(\"StationName_SetupUtility\", stnName_util.trim());\r\n    } catch (Exception e) {\r\n      System.out.println(e.toString());\r\n      e.printStackTrace();\r\n    }\r\n    return hdrNames;\r\n  }", "code_tokens": ["public", "java", ".", "util", ".", "Map", "<", "String", ",", "String", ">", "readStnNames", "(", "ucar", ".", "unidata", ".", "io", ".", "RandomAccessFile", "raf", ")", "{", "java", ".", "util", ".", "Map", "<", "String", ",", "String", ">", "hdrNames", "=", "new", "java", ".", "util", ".", "HashMap", "<", "String", ",", "String", ">", "(", ")", ";", "try", "{", "raf", ".", "seek", "(", "6288", ")", ";", "String", "stnName", "=", "raf", ".", "readString", "(", "16", ")", ";", "//System.out.println(\" stnName=\"+stnName.trim());\r", "raf", ".", "seek", "(", "6306", ")", ";", "String", "stnName_util", "=", "raf", ".", "readString", "(", "16", ")", ";", "hdrNames", ".", "put", "(", "\"StationName\"", ",", "stnName", ".", "trim", "(", ")", ")", ";", "hdrNames", ".", "put", "(", "\"StationName_SetupUtility\"", ",", "stnName_util", ".", "trim", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "System", ".", "out", ".", "println", "(", "e", ".", "toString", "(", ")", ")", ";", "e", ".", "printStackTrace", "(", ")", ";", "}", "return", "hdrNames", ";", "}"], "docstring": "Read StationName strings", "docstring_tokens": ["Read", "StationName", "strings"]}
{"code": "short[] coef = {1, 2, 3, 4};", "comments": "MultiPRF modes", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/sigmet/SigmetIOServiceProvider.java", "func_name": "SigmetIOServiceProvider.calcData", "original_string": "static float calcData(Map<String, Number> recHdr, short dty, byte data) {\r\n    short[] coef = {1, 2, 3, 4}; // MultiPRF modes\r\n    short multiprf = recHdr.get(\"multiprf\").shortValue();\r\n    float vNyq = recHdr.get(\"vNyq\").floatValue();\r\n    double temp = -999.99;\r\n    switch (dty) {\r\n      default:        // dty=1,2 -total_power, reflectivity (dBZ)\r\n        if (data != 0) {\r\n          temp = (((int) data & 0xFF) - 64) * 0.5;\r\n        }\r\n        break;\r\n      case 3:        // dty=3 - mean velocity (m/sec)\r\n        if (data != 0) {\r\n          temp = ((((int) data & 0xFF) - 128) / 127.0) * vNyq * coef[multiprf];\r\n        }\r\n        break;\r\n      case 4:        // dty=4 - spectrum width (m/sec)\r\n        if (data != 0) {\r\n          double v = ((((int) data & 0xFF) - 128) / 127.0) * vNyq * coef[multiprf];\r\n          temp = (((int) data & 0xFF) / 256.0) * v;\r\n        }\r\n        break;\r\n      case 5:        // dty=5 - differential reflectivity (dB)\r\n        if (data != 0) {\r\n          temp = ((((int) data & 0xFF) - 128) / 16.0);\r\n        }\r\n        break;\r\n    }\r\n    BigDecimal bd = new BigDecimal(temp);\r\n    BigDecimal result = bd.setScale(2, RoundingMode.HALF_DOWN);\r\n    return result.floatValue();\r\n  }", "language": "java", "Allcodes": "static float calcData(Map<String, Number> recHdr, short dty, byte data) {\r\n    short[] coef = {1, 2, 3, 4}; // MultiPRF modes\r\n    short multiprf = recHdr.get(\"multiprf\").shortValue();\r\n    float vNyq = recHdr.get(\"vNyq\").floatValue();\r\n    double temp = -999.99;\r\n    switch (dty) {\r\n      default:        // dty=1,2 -total_power, reflectivity (dBZ)\r\n        if (data != 0) {\r\n          temp = (((int) data & 0xFF) - 64) * 0.5;\r\n        }\r\n        break;\r\n      case 3:        // dty=3 - mean velocity (m/sec)\r\n        if (data != 0) {\r\n          temp = ((((int) data & 0xFF) - 128) / 127.0) * vNyq * coef[multiprf];\r\n        }\r\n        break;\r\n      case 4:        // dty=4 - spectrum width (m/sec)\r\n        if (data != 0) {\r\n          double v = ((((int) data & 0xFF) - 128) / 127.0) * vNyq * coef[multiprf];\r\n          temp = (((int) data & 0xFF) / 256.0) * v;\r\n        }\r\n        break;\r\n      case 5:        // dty=5 - differential reflectivity (dB)\r\n        if (data != 0) {\r\n          temp = ((((int) data & 0xFF) - 128) / 16.0);\r\n        }\r\n        break;\r\n    }\r\n    BigDecimal bd = new BigDecimal(temp);\r\n    BigDecimal result = bd.setScale(2, RoundingMode.HALF_DOWN);\r\n    return result.floatValue();\r\n  }", "code_tokens": ["static", "float", "calcData", "(", "Map", "<", "String", ",", "Number", ">", "recHdr", ",", "short", "dty", ",", "byte", "data", ")", "{", "short", "[", "]", "coef", "=", "{", "1", ",", "2", ",", "3", ",", "4", "}", ";", "// MultiPRF modes\r", "short", "multiprf", "=", "recHdr", ".", "get", "(", "\"multiprf\"", ")", ".", "shortValue", "(", ")", ";", "float", "vNyq", "=", "recHdr", ".", "get", "(", "\"vNyq\"", ")", ".", "floatValue", "(", ")", ";", "double", "temp", "=", "-", "999.99", ";", "switch", "(", "dty", ")", "{", "default", ":", "// dty=1,2 -total_power, reflectivity (dBZ)\r", "if", "(", "data", "!=", "0", ")", "{", "temp", "=", "(", "(", "(", "int", ")", "data", "&", "0xFF", ")", "-", "64", ")", "*", "0.5", ";", "}", "break", ";", "case", "3", ":", "// dty=3 - mean velocity (m/sec)\r", "if", "(", "data", "!=", "0", ")", "{", "temp", "=", "(", "(", "(", "(", "int", ")", "data", "&", "0xFF", ")", "-", "128", ")", "/", "127.0", ")", "*", "vNyq", "*", "coef", "[", "multiprf", "]", ";", "}", "break", ";", "case", "4", ":", "// dty=4 - spectrum width (m/sec)\r", "if", "(", "data", "!=", "0", ")", "{", "double", "v", "=", "(", "(", "(", "(", "int", ")", "data", "&", "0xFF", ")", "-", "128", ")", "/", "127.0", ")", "*", "vNyq", "*", "coef", "[", "multiprf", "]", ";", "temp", "=", "(", "(", "(", "int", ")", "data", "&", "0xFF", ")", "/", "256.0", ")", "*", "v", ";", "}", "break", ";", "case", "5", ":", "// dty=5 - differential reflectivity (dB)\r", "if", "(", "data", "!=", "0", ")", "{", "temp", "=", "(", "(", "(", "(", "int", ")", "data", "&", "0xFF", ")", "-", "128", ")", "/", "16.0", ")", ";", "}", "break", ";", "}", "BigDecimal", "bd", "=", "new", "BigDecimal", "(", "temp", ")", ";", "BigDecimal", "result", "=", "bd", ".", "setScale", "(", "2", ",", "RoundingMode", ".", "HALF_DOWN", ")", ";", "return", "result", ".", "floatValue", "(", ")", ";", "}"], "docstring": "Calculate data values from raw ingest data\n\n@param recHdr java.util.Map object with values for calculation\n@param dty    type of data ( \"Total_Power\", \"Reflectivity\", \"Velocity\",\n\"Width\", \"Differential_Reflectivity\")\n@param data   1-byte input value\n@return float value with precision of two decimal", "docstring_tokens": ["Calculate", "data", "values", "from", "raw", "ingest", "data"]}
{"code": "tmp = tmp * 0.01;", "comments": "Make it m/sec", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/sigmet/SigmetIOServiceProvider.java", "func_name": "SigmetIOServiceProvider.calcNyquist", "original_string": "static float calcNyquist(int prf, int wave) {\r\n    double tmp = (prf * wave * 0.01) * 0.25;\r\n    tmp = tmp * 0.01;                    //Make it m/sec\r\n    BigDecimal bd = new BigDecimal(tmp);\r\n    BigDecimal result = bd.setScale(2, RoundingMode.HALF_DOWN);\r\n    return result.floatValue();\r\n  }", "language": "java", "Allcodes": "static float calcNyquist(int prf, int wave) {\r\n    double tmp = (prf * wave * 0.01) * 0.25;\r\n    tmp = tmp * 0.01;                    //Make it m/sec\r\n    BigDecimal bd = new BigDecimal(tmp);\r\n    BigDecimal result = bd.setScale(2, RoundingMode.HALF_DOWN);\r\n    return result.floatValue();\r\n  }", "code_tokens": ["static", "float", "calcNyquist", "(", "int", "prf", ",", "int", "wave", ")", "{", "double", "tmp", "=", "(", "prf", "*", "wave", "*", "0.01", ")", "*", "0.25", ";", "tmp", "=", "tmp", "*", "0.01", ";", "//Make it m/sec\r", "BigDecimal", "bd", "=", "new", "BigDecimal", "(", "tmp", ")", ";", "BigDecimal", "result", "=", "bd", ".", "setScale", "(", "2", ",", "RoundingMode", ".", "HALF_DOWN", ")", ";", "return", "result", ".", "floatValue", "(", ")", ";", "}"], "docstring": "Calculate of Nyquist velocity\n\n@param prf  PRF in Hertz\n@param wave wavelength in 1/100 of centimeters\n@return float value of Nyquist velocity in m/sec with precision of two decimal", "docstring_tokens": ["Calculate", "of", "Nyquist", "velocity"]}
{"code": "_readData(record);", "comments": "debug", "lines": 23, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridServiceProvider.java", "func_name": "GridServiceProvider.readXY", "original_string": "private void readXY(Variable v2, int ensIdx, int timeIdx, int levIdx, Range yRange, Range xRange, IndexIterator ii)\n          throws IOException, InvalidRangeException {\n\n    GridVariable pv = (GridVariable) v2.getSPobject();\n    GridHorizCoordSys hsys = pv.getHorizCoordSys();\n    int nx = hsys.getNx();\n    GridRecord record = pv.findRecord(ensIdx, timeIdx, levIdx);\n\n    if (record == null) {\n      Attribute att = v2.findAttribute(\"missing_value\");\n      float missing_value = (att == null) ? -9999.0f : att.getNumericValue().floatValue();\n\n      int xyCount = yRange.length() * xRange.length();\n      for (int j = 0; j < xyCount; j++) {\n        ii.setFloatNext(missing_value);\n      }\n      return;\n    }\n\n    // otherwise read it\n    float[] data = _readData(record);\n    if (data == null) {\n      _readData(record); // debug\n      return;\n    }\n\n    // LOOK can improve with System.copy ??\n    for (int y : yRange) {\n      for (int x : xRange) {\n        int index = y * nx + x;\n        ii.setFloatNext(data[index]);\n      }\n    }\n  }", "language": "java", "Allcodes": "private void readXY(Variable v2, int ensIdx, int timeIdx, int levIdx, Range yRange, Range xRange, IndexIterator ii)\n          throws IOException, InvalidRangeException {\n\n    GridVariable pv = (GridVariable) v2.getSPobject();\n    GridHorizCoordSys hsys = pv.getHorizCoordSys();\n    int nx = hsys.getNx();\n    GridRecord record = pv.findRecord(ensIdx, timeIdx, levIdx);\n\n    if (record == null) {\n      Attribute att = v2.findAttribute(\"missing_value\");\n      float missing_value = (att == null) ? -9999.0f : att.getNumericValue().floatValue();\n\n      int xyCount = yRange.length() * xRange.length();\n      for (int j = 0; j < xyCount; j++) {\n        ii.setFloatNext(missing_value);\n      }\n      return;\n    }\n\n    // otherwise read it\n    float[] data = _readData(record);\n    if (data == null) {\n      _readData(record); // debug\n      return;\n    }\n\n    // LOOK can improve with System.copy ??\n    for (int y : yRange) {\n      for (int x : xRange) {\n        int index = y * nx + x;\n        ii.setFloatNext(data[index]);\n      }\n    }\n  }", "code_tokens": ["private", "void", "readXY", "(", "Variable", "v2", ",", "int", "ensIdx", ",", "int", "timeIdx", ",", "int", "levIdx", ",", "Range", "yRange", ",", "Range", "xRange", ",", "IndexIterator", "ii", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "GridVariable", "pv", "=", "(", "GridVariable", ")", "v2", ".", "getSPobject", "(", ")", ";", "GridHorizCoordSys", "hsys", "=", "pv", ".", "getHorizCoordSys", "(", ")", ";", "int", "nx", "=", "hsys", ".", "getNx", "(", ")", ";", "GridRecord", "record", "=", "pv", ".", "findRecord", "(", "ensIdx", ",", "timeIdx", ",", "levIdx", ")", ";", "if", "(", "record", "==", "null", ")", "{", "Attribute", "att", "=", "v2", ".", "findAttribute", "(", "\"missing_value\"", ")", ";", "float", "missing_value", "=", "(", "att", "==", "null", ")", "?", "-", "9999.0f", ":", "att", ".", "getNumericValue", "(", ")", ".", "floatValue", "(", ")", ";", "int", "xyCount", "=", "yRange", ".", "length", "(", ")", "*", "xRange", ".", "length", "(", ")", ";", "for", "(", "int", "j", "=", "0", ";", "j", "<", "xyCount", ";", "j", "++", ")", "{", "ii", ".", "setFloatNext", "(", "missing_value", ")", ";", "}", "return", ";", "}", "// otherwise read it", "float", "[", "]", "data", "=", "_readData", "(", "record", ")", ";", "if", "(", "data", "==", "null", ")", "{", "_readData", "(", "record", ")", ";", "// debug", "return", ";", "}", "// LOOK can improve with System.copy ??", "for", "(", "int", "y", ":", "yRange", ")", "{", "for", "(", "int", "x", ":", "xRange", ")", "{", "int", "index", "=", "y", "*", "nx", "+", "x", ";", "ii", ".", "setFloatNext", "(", "data", "[", "index", "]", ")", ";", "}", "}", "}"], "docstring": "read one YX array\n\n@param v2      variable to put the data into\n@param ensIdx  ensemble index\n@param timeIdx time index\n@param levIdx  level index\n@param yRange  x range\n@param xRange  y range\n@param ii      index iterator\n@throws IOException           problem reading the file\n@throws InvalidRangeException invalid range", "docstring_tokens": ["read", "one", "YX", "array"]}
{"code": "llbb = new LatLonRect(llpt, new LatLonPointImpl(90.0, 0.0));", "comments": "??? lon=???", "lines": 50, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft2/coverage/adapter/DtCoverageCS.java", "func_name": "DtCoverageCS.getLatLonBoundingBox", "original_string": "public LatLonRect getLatLonBoundingBox() {\n\n    if (llbb == null) {\n\n      if ((getXHorizAxis() instanceof CoordinateAxis2D) && (getYHorizAxis() instanceof CoordinateAxis2D)) {\n        return null;\n      }\n\n      CoordinateAxis horizXaxis = getXHorizAxis();\n      CoordinateAxis horizYaxis = getYHorizAxis();\n      if (isLatLon()) {\n        double startLat = horizYaxis.getMinValue();\n        double startLon = horizXaxis.getMinValue();\n\n        double deltaLat = horizYaxis.getMaxValue() - startLat;\n        double deltaLon = horizXaxis.getMaxValue() - startLon;\n\n        LatLonPoint llpt = new LatLonPointImpl(startLat, startLon);\n        llbb = new LatLonRect(llpt, deltaLat, deltaLon);\n\n      } else {\n        ProjectionImpl dataProjection = getProjection();\n        ProjectionRect bb = getBoundingBox();\n        if (bb != null)\n          llbb = dataProjection.projToLatLonBB(bb);\n      }\n    }\n\n    return llbb;\n\n      /*  // look at all 4 corners of the bounding box\n        LatLonPointImpl llpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getLowerLeftPoint(), new LatLonPointImpl());\n        LatLonPointImpl lrpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getLowerRightPoint(), new LatLonPointImpl());\n        LatLonPointImpl urpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getUpperRightPoint(), new LatLonPointImpl());\n        LatLonPointImpl ulpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getUpperLeftPoint(), new LatLonPointImpl());\n\n        // Check if grid contains poles.\n        boolean includesNorthPole = false;\n        int[] resultNP;\n        resultNP = findXYindexFromLatLon(90.0, 0, null);\n        if (resultNP[0] != -1 && resultNP[1] != -1)\n          includesNorthPole = true;\n        boolean includesSouthPole = false;\n        int[] resultSP;\n        resultSP = findXYindexFromLatLon(-90.0, 0, null);\n        if (resultSP[0] != -1 && resultSP[1] != -1)\n          includesSouthPole = true;\n\n        if (includesNorthPole && !includesSouthPole) {\n          llbb = new LatLonRect(llpt, new LatLonPointImpl(90.0, 0.0)); // ??? lon=???\n          llbb.extend(lrpt);\n          llbb.extend(urpt);\n          llbb.extend(ulpt);\n          // OR\n          //llbb.extend( new LatLonRect( llpt, lrpt ));\n          //llbb.extend( new LatLonRect( lrpt, urpt ) );\n          //llbb.extend( new LatLonRect( urpt, ulpt ) );\n          //llbb.extend( new LatLonRect( ulpt, llpt ) );\n        } else if (includesSouthPole && !includesNorthPole) {\n          llbb = new LatLonRect(llpt, new LatLonPointImpl(-90.0, -180.0)); // ??? lon=???\n          llbb.extend(lrpt);\n          llbb.extend(urpt);\n          llbb.extend(ulpt);\n        } else {\n          double latMin = Math.min(llpt.getLatitude(), lrpt.getLatitude());\n          double latMax = Math.max(ulpt.getLatitude(), urpt.getLatitude());\n\n          // longitude is a bit tricky as usual\n          double lonMin = getMinOrMaxLon(llpt.getLongitude(), ulpt.getLongitude(), true);\n          double lonMax = getMinOrMaxLon(lrpt.getLongitude(), urpt.getLongitude(), false);\n\n          llpt.set(latMin, lonMin);\n          urpt.set(latMax, lonMax);\n\n          llbb = new LatLonRect(llpt, urpt);\n        }\n      }\n    }  */\n\n  }", "language": "java", "Allcodes": "public LatLonRect getLatLonBoundingBox() {\n\n    if (llbb == null) {\n\n      if ((getXHorizAxis() instanceof CoordinateAxis2D) && (getYHorizAxis() instanceof CoordinateAxis2D)) {\n        return null;\n      }\n\n      CoordinateAxis horizXaxis = getXHorizAxis();\n      CoordinateAxis horizYaxis = getYHorizAxis();\n      if (isLatLon()) {\n        double startLat = horizYaxis.getMinValue();\n        double startLon = horizXaxis.getMinValue();\n\n        double deltaLat = horizYaxis.getMaxValue() - startLat;\n        double deltaLon = horizXaxis.getMaxValue() - startLon;\n\n        LatLonPoint llpt = new LatLonPointImpl(startLat, startLon);\n        llbb = new LatLonRect(llpt, deltaLat, deltaLon);\n\n      } else {\n        ProjectionImpl dataProjection = getProjection();\n        ProjectionRect bb = getBoundingBox();\n        if (bb != null)\n          llbb = dataProjection.projToLatLonBB(bb);\n      }\n    }\n\n    return llbb;\n\n      /*  // look at all 4 corners of the bounding box\n        LatLonPointImpl llpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getLowerLeftPoint(), new LatLonPointImpl());\n        LatLonPointImpl lrpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getLowerRightPoint(), new LatLonPointImpl());\n        LatLonPointImpl urpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getUpperRightPoint(), new LatLonPointImpl());\n        LatLonPointImpl ulpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getUpperLeftPoint(), new LatLonPointImpl());\n\n        // Check if grid contains poles.\n        boolean includesNorthPole = false;\n        int[] resultNP;\n        resultNP = findXYindexFromLatLon(90.0, 0, null);\n        if (resultNP[0] != -1 && resultNP[1] != -1)\n          includesNorthPole = true;\n        boolean includesSouthPole = false;\n        int[] resultSP;\n        resultSP = findXYindexFromLatLon(-90.0, 0, null);\n        if (resultSP[0] != -1 && resultSP[1] != -1)\n          includesSouthPole = true;\n\n        if (includesNorthPole && !includesSouthPole) {\n          llbb = new LatLonRect(llpt, new LatLonPointImpl(90.0, 0.0)); // ??? lon=???\n          llbb.extend(lrpt);\n          llbb.extend(urpt);\n          llbb.extend(ulpt);\n          // OR\n          //llbb.extend( new LatLonRect( llpt, lrpt ));\n          //llbb.extend( new LatLonRect( lrpt, urpt ) );\n          //llbb.extend( new LatLonRect( urpt, ulpt ) );\n          //llbb.extend( new LatLonRect( ulpt, llpt ) );\n        } else if (includesSouthPole && !includesNorthPole) {\n          llbb = new LatLonRect(llpt, new LatLonPointImpl(-90.0, -180.0)); // ??? lon=???\n          llbb.extend(lrpt);\n          llbb.extend(urpt);\n          llbb.extend(ulpt);\n        } else {\n          double latMin = Math.min(llpt.getLatitude(), lrpt.getLatitude());\n          double latMax = Math.max(ulpt.getLatitude(), urpt.getLatitude());\n\n          // longitude is a bit tricky as usual\n          double lonMin = getMinOrMaxLon(llpt.getLongitude(), ulpt.getLongitude(), true);\n          double lonMax = getMinOrMaxLon(lrpt.getLongitude(), urpt.getLongitude(), false);\n\n          llpt.set(latMin, lonMin);\n          urpt.set(latMax, lonMax);\n\n          llbb = new LatLonRect(llpt, urpt);\n        }\n      }\n    }  */\n\n  }", "code_tokens": ["public", "LatLonRect", "getLatLonBoundingBox", "(", ")", "{", "if", "(", "llbb", "==", "null", ")", "{", "if", "(", "(", "getXHorizAxis", "(", ")", "instanceof", "CoordinateAxis2D", ")", "&&", "(", "getYHorizAxis", "(", ")", "instanceof", "CoordinateAxis2D", ")", ")", "{", "return", "null", ";", "}", "CoordinateAxis", "horizXaxis", "=", "getXHorizAxis", "(", ")", ";", "CoordinateAxis", "horizYaxis", "=", "getYHorizAxis", "(", ")", ";", "if", "(", "isLatLon", "(", ")", ")", "{", "double", "startLat", "=", "horizYaxis", ".", "getMinValue", "(", ")", ";", "double", "startLon", "=", "horizXaxis", ".", "getMinValue", "(", ")", ";", "double", "deltaLat", "=", "horizYaxis", ".", "getMaxValue", "(", ")", "-", "startLat", ";", "double", "deltaLon", "=", "horizXaxis", ".", "getMaxValue", "(", ")", "-", "startLon", ";", "LatLonPoint", "llpt", "=", "new", "LatLonPointImpl", "(", "startLat", ",", "startLon", ")", ";", "llbb", "=", "new", "LatLonRect", "(", "llpt", ",", "deltaLat", ",", "deltaLon", ")", ";", "}", "else", "{", "ProjectionImpl", "dataProjection", "=", "getProjection", "(", ")", ";", "ProjectionRect", "bb", "=", "getBoundingBox", "(", ")", ";", "if", "(", "bb", "!=", "null", ")", "llbb", "=", "dataProjection", ".", "projToLatLonBB", "(", "bb", ")", ";", "}", "}", "return", "llbb", ";", "/*  // look at all 4 corners of the bounding box\n        LatLonPointImpl llpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getLowerLeftPoint(), new LatLonPointImpl());\n        LatLonPointImpl lrpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getLowerRightPoint(), new LatLonPointImpl());\n        LatLonPointImpl urpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getUpperRightPoint(), new LatLonPointImpl());\n        LatLonPointImpl ulpt = (LatLonPointImpl) dataProjection.projToLatLon(bb.getUpperLeftPoint(), new LatLonPointImpl());\n\n        // Check if grid contains poles.\n        boolean includesNorthPole = false;\n        int[] resultNP;\n        resultNP = findXYindexFromLatLon(90.0, 0, null);\n        if (resultNP[0] != -1 && resultNP[1] != -1)\n          includesNorthPole = true;\n        boolean includesSouthPole = false;\n        int[] resultSP;\n        resultSP = findXYindexFromLatLon(-90.0, 0, null);\n        if (resultSP[0] != -1 && resultSP[1] != -1)\n          includesSouthPole = true;\n\n        if (includesNorthPole && !includesSouthPole) {\n          llbb = new LatLonRect(llpt, new LatLonPointImpl(90.0, 0.0)); // ??? lon=???\n          llbb.extend(lrpt);\n          llbb.extend(urpt);\n          llbb.extend(ulpt);\n          // OR\n          //llbb.extend( new LatLonRect( llpt, lrpt ));\n          //llbb.extend( new LatLonRect( lrpt, urpt ) );\n          //llbb.extend( new LatLonRect( urpt, ulpt ) );\n          //llbb.extend( new LatLonRect( ulpt, llpt ) );\n        } else if (includesSouthPole && !includesNorthPole) {\n          llbb = new LatLonRect(llpt, new LatLonPointImpl(-90.0, -180.0)); // ??? lon=???\n          llbb.extend(lrpt);\n          llbb.extend(urpt);\n          llbb.extend(ulpt);\n        } else {\n          double latMin = Math.min(llpt.getLatitude(), lrpt.getLatitude());\n          double latMax = Math.max(ulpt.getLatitude(), urpt.getLatitude());\n\n          // longitude is a bit tricky as usual\n          double lonMin = getMinOrMaxLon(llpt.getLongitude(), ulpt.getLongitude(), true);\n          double lonMax = getMinOrMaxLon(lrpt.getLongitude(), urpt.getLongitude(), false);\n\n          llpt.set(latMin, lonMin);\n          urpt.set(latMax, lonMax);\n\n          llbb = new LatLonRect(llpt, urpt);\n        }\n      }\n    }  */", "}"], "docstring": "Get horizontal bounding box in lat, lon coordinates.\n\n@return lat, lon bounding box.", "docstring_tokens": ["Get", "horizontal", "bounding", "box", "in", "lat", "lon", "coordinates", "."]}
{"code": "if(this.first == UNDEFINED) this.first = 0;", "comments": "default", "lines": 6, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Slice.java", "func_name": "Slice.finish", "original_string": "public Slice\n    finish()\n            throws DapException\n    {\n        // Attempt to repair undefined values\n        if(this.first == UNDEFINED) this.first = 0;   // default\n        if(this.stride == UNDEFINED) this.stride = 1; // default\n        if(this.stop == UNDEFINED && this.maxsize != UNDEFINED)\n            this.stop = this.maxsize;\n        if(this.stop == UNDEFINED && this.maxsize == UNDEFINED)\n            this.stop = this.first + 1;\n        if(this.maxsize == UNDEFINED && this.stop != UNDEFINED)\n            this.maxsize = this.stop;\n        // else (this.stop != UNDEFINED && this.maxsize != UNDEFINED)\n        assert (this.first != UNDEFINED);\n        assert (this.stride != UNDEFINED);\n        assert (this.stop != UNDEFINED);\n        // sanity checks\n        if(this.first > this.maxsize)\n            throw new DapException(\"Slice: first index > max size\");\n        if(this.stop > (this.maxsize+1))\n            throw new DapException(\"Slice: stop > max size\");\n        if(this.first < 0)\n            throw new DapException(\"Slice: first index < 0\");\n        if(this.stop < 0)\n            throw new DapException(\"Slice: stop index < 0\");\n        if(this.stride <= 0)\n            throw new DapException(\"Slice: stride index <= 0\");\n        if(this.first > this.stop)\n            throw new DapException(\"Slice: first index > last\");\n        return this; // fluent interface\n    }", "language": "java", "Allcodes": "public Slice\n    finish()\n            throws DapException\n    {\n        // Attempt to repair undefined values\n        if(this.first == UNDEFINED) this.first = 0;   // default\n        if(this.stride == UNDEFINED) this.stride = 1; // default\n        if(this.stop == UNDEFINED && this.maxsize != UNDEFINED)\n            this.stop = this.maxsize;\n        if(this.stop == UNDEFINED && this.maxsize == UNDEFINED)\n            this.stop = this.first + 1;\n        if(this.maxsize == UNDEFINED && this.stop != UNDEFINED)\n            this.maxsize = this.stop;\n        // else (this.stop != UNDEFINED && this.maxsize != UNDEFINED)\n        assert (this.first != UNDEFINED);\n        assert (this.stride != UNDEFINED);\n        assert (this.stop != UNDEFINED);\n        // sanity checks\n        if(this.first > this.maxsize)\n            throw new DapException(\"Slice: first index > max size\");\n        if(this.stop > (this.maxsize+1))\n            throw new DapException(\"Slice: stop > max size\");\n        if(this.first < 0)\n            throw new DapException(\"Slice: first index < 0\");\n        if(this.stop < 0)\n            throw new DapException(\"Slice: stop index < 0\");\n        if(this.stride <= 0)\n            throw new DapException(\"Slice: stride index <= 0\");\n        if(this.first > this.stop)\n            throw new DapException(\"Slice: first index > last\");\n        return this; // fluent interface\n    }", "code_tokens": ["public", "Slice", "finish", "(", ")", "throws", "DapException", "{", "// Attempt to repair undefined values", "if", "(", "this", ".", "first", "==", "UNDEFINED", ")", "this", ".", "first", "=", "0", ";", "// default", "if", "(", "this", ".", "stride", "==", "UNDEFINED", ")", "this", ".", "stride", "=", "1", ";", "// default", "if", "(", "this", ".", "stop", "==", "UNDEFINED", "&&", "this", ".", "maxsize", "!=", "UNDEFINED", ")", "this", ".", "stop", "=", "this", ".", "maxsize", ";", "if", "(", "this", ".", "stop", "==", "UNDEFINED", "&&", "this", ".", "maxsize", "==", "UNDEFINED", ")", "this", ".", "stop", "=", "this", ".", "first", "+", "1", ";", "if", "(", "this", ".", "maxsize", "==", "UNDEFINED", "&&", "this", ".", "stop", "!=", "UNDEFINED", ")", "this", ".", "maxsize", "=", "this", ".", "stop", ";", "// else (this.stop != UNDEFINED && this.maxsize != UNDEFINED)", "assert", "(", "this", ".", "first", "!=", "UNDEFINED", ")", ";", "assert", "(", "this", ".", "stride", "!=", "UNDEFINED", ")", ";", "assert", "(", "this", ".", "stop", "!=", "UNDEFINED", ")", ";", "// sanity checks", "if", "(", "this", ".", "first", ">", "this", ".", "maxsize", ")", "throw", "new", "DapException", "(", "\"Slice: first index > max size\"", ")", ";", "if", "(", "this", ".", "stop", ">", "(", "this", ".", "maxsize", "+", "1", ")", ")", "throw", "new", "DapException", "(", "\"Slice: stop > max size\"", ")", ";", "if", "(", "this", ".", "first", "<", "0", ")", "throw", "new", "DapException", "(", "\"Slice: first index < 0\"", ")", ";", "if", "(", "this", ".", "stop", "<", "0", ")", "throw", "new", "DapException", "(", "\"Slice: stop index < 0\"", ")", ";", "if", "(", "this", ".", "stride", "<=", "0", ")", "throw", "new", "DapException", "(", "\"Slice: stride index <= 0\"", ")", ";", "if", "(", "this", ".", "first", ">", "this", ".", "stop", ")", "throw", "new", "DapException", "(", "\"Slice: first index > last\"", ")", ";", "return", "this", ";", "// fluent interface", "}"], "docstring": "Perform sanity checks on a slice and repair where possible.\n\n@return this (fluent interface)\n@throws dap4.core.util.DapException if slice is malformed", "docstring_tokens": ["Perform", "sanity", "checks", "on", "a", "slice", "and", "repair", "where", "possible", "."]}
{"code": "return this;", "comments": "fluent interface", "lines": 31, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Slice.java", "func_name": "Slice.finish", "original_string": "public Slice\n    finish()\n            throws DapException\n    {\n        // Attempt to repair undefined values\n        if(this.first == UNDEFINED) this.first = 0;   // default\n        if(this.stride == UNDEFINED) this.stride = 1; // default\n        if(this.stop == UNDEFINED && this.maxsize != UNDEFINED)\n            this.stop = this.maxsize;\n        if(this.stop == UNDEFINED && this.maxsize == UNDEFINED)\n            this.stop = this.first + 1;\n        if(this.maxsize == UNDEFINED && this.stop != UNDEFINED)\n            this.maxsize = this.stop;\n        // else (this.stop != UNDEFINED && this.maxsize != UNDEFINED)\n        assert (this.first != UNDEFINED);\n        assert (this.stride != UNDEFINED);\n        assert (this.stop != UNDEFINED);\n        // sanity checks\n        if(this.first > this.maxsize)\n            throw new DapException(\"Slice: first index > max size\");\n        if(this.stop > (this.maxsize+1))\n            throw new DapException(\"Slice: stop > max size\");\n        if(this.first < 0)\n            throw new DapException(\"Slice: first index < 0\");\n        if(this.stop < 0)\n            throw new DapException(\"Slice: stop index < 0\");\n        if(this.stride <= 0)\n            throw new DapException(\"Slice: stride index <= 0\");\n        if(this.first > this.stop)\n            throw new DapException(\"Slice: first index > last\");\n        return this; // fluent interface\n    }", "language": "java", "Allcodes": "public Slice\n    finish()\n            throws DapException\n    {\n        // Attempt to repair undefined values\n        if(this.first == UNDEFINED) this.first = 0;   // default\n        if(this.stride == UNDEFINED) this.stride = 1; // default\n        if(this.stop == UNDEFINED && this.maxsize != UNDEFINED)\n            this.stop = this.maxsize;\n        if(this.stop == UNDEFINED && this.maxsize == UNDEFINED)\n            this.stop = this.first + 1;\n        if(this.maxsize == UNDEFINED && this.stop != UNDEFINED)\n            this.maxsize = this.stop;\n        // else (this.stop != UNDEFINED && this.maxsize != UNDEFINED)\n        assert (this.first != UNDEFINED);\n        assert (this.stride != UNDEFINED);\n        assert (this.stop != UNDEFINED);\n        // sanity checks\n        if(this.first > this.maxsize)\n            throw new DapException(\"Slice: first index > max size\");\n        if(this.stop > (this.maxsize+1))\n            throw new DapException(\"Slice: stop > max size\");\n        if(this.first < 0)\n            throw new DapException(\"Slice: first index < 0\");\n        if(this.stop < 0)\n            throw new DapException(\"Slice: stop index < 0\");\n        if(this.stride <= 0)\n            throw new DapException(\"Slice: stride index <= 0\");\n        if(this.first > this.stop)\n            throw new DapException(\"Slice: first index > last\");\n        return this; // fluent interface\n    }", "code_tokens": ["public", "Slice", "finish", "(", ")", "throws", "DapException", "{", "// Attempt to repair undefined values", "if", "(", "this", ".", "first", "==", "UNDEFINED", ")", "this", ".", "first", "=", "0", ";", "// default", "if", "(", "this", ".", "stride", "==", "UNDEFINED", ")", "this", ".", "stride", "=", "1", ";", "// default", "if", "(", "this", ".", "stop", "==", "UNDEFINED", "&&", "this", ".", "maxsize", "!=", "UNDEFINED", ")", "this", ".", "stop", "=", "this", ".", "maxsize", ";", "if", "(", "this", ".", "stop", "==", "UNDEFINED", "&&", "this", ".", "maxsize", "==", "UNDEFINED", ")", "this", ".", "stop", "=", "this", ".", "first", "+", "1", ";", "if", "(", "this", ".", "maxsize", "==", "UNDEFINED", "&&", "this", ".", "stop", "!=", "UNDEFINED", ")", "this", ".", "maxsize", "=", "this", ".", "stop", ";", "// else (this.stop != UNDEFINED && this.maxsize != UNDEFINED)", "assert", "(", "this", ".", "first", "!=", "UNDEFINED", ")", ";", "assert", "(", "this", ".", "stride", "!=", "UNDEFINED", ")", ";", "assert", "(", "this", ".", "stop", "!=", "UNDEFINED", ")", ";", "// sanity checks", "if", "(", "this", ".", "first", ">", "this", ".", "maxsize", ")", "throw", "new", "DapException", "(", "\"Slice: first index > max size\"", ")", ";", "if", "(", "this", ".", "stop", ">", "(", "this", ".", "maxsize", "+", "1", ")", ")", "throw", "new", "DapException", "(", "\"Slice: stop > max size\"", ")", ";", "if", "(", "this", ".", "first", "<", "0", ")", "throw", "new", "DapException", "(", "\"Slice: first index < 0\"", ")", ";", "if", "(", "this", ".", "stop", "<", "0", ")", "throw", "new", "DapException", "(", "\"Slice: stop index < 0\"", ")", ";", "if", "(", "this", ".", "stride", "<=", "0", ")", "throw", "new", "DapException", "(", "\"Slice: stride index <= 0\"", ")", ";", "if", "(", "this", ".", "first", ">", "this", ".", "stop", ")", "throw", "new", "DapException", "(", "\"Slice: first index > last\"", ")", ";", "return", "this", ";", "// fluent interface", "}"], "docstring": "Perform sanity checks on a slice and repair where possible.\n\n@return this (fluent interface)\n@throws dap4.core.util.DapException if slice is malformed", "docstring_tokens": ["Perform", "sanity", "checks", "on", "a", "slice", "and", "repair", "where", "possible", "."]}
{"code": "long sr_last = (target.getLast() < lastx ? target.getLast() : lastx);", "comments": "min(last(),lastx)", "lines": 8, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Slice.java", "func_name": "Slice.compose", "original_string": "static public Slice\n    compose(Slice target, Slice src)\n            throws DapException\n    {\n        long sr_stride = target.getStride() * src.getStride();\n        long sr_first = MAP(target, src.getFirst());\n        long lastx = MAP(target, src.getLast());\n        long sr_last = (target.getLast() < lastx ? target.getLast() : lastx); //min(last(),lastx)\n        return new Slice(sr_first, sr_last + 1, sr_stride, sr_last + 1).finish();\n    }", "language": "java", "Allcodes": "static public Slice\n    compose(Slice target, Slice src)\n            throws DapException\n    {\n        long sr_stride = target.getStride() * src.getStride();\n        long sr_first = MAP(target, src.getFirst());\n        long lastx = MAP(target, src.getLast());\n        long sr_last = (target.getLast() < lastx ? target.getLast() : lastx); //min(last(),lastx)\n        return new Slice(sr_first, sr_last + 1, sr_stride, sr_last + 1).finish();\n    }", "code_tokens": ["static", "public", "Slice", "compose", "(", "Slice", "target", ",", "Slice", "src", ")", "throws", "DapException", "{", "long", "sr_stride", "=", "target", ".", "getStride", "(", ")", "*", "src", ".", "getStride", "(", ")", ";", "long", "sr_first", "=", "MAP", "(", "target", ",", "src", ".", "getFirst", "(", ")", ")", ";", "long", "lastx", "=", "MAP", "(", "target", ",", "src", ".", "getLast", "(", ")", ")", ";", "long", "sr_last", "=", "(", "target", ".", "getLast", "(", ")", "<", "lastx", "?", "target", ".", "getLast", "(", ")", ":", "lastx", ")", ";", "//min(last(),lastx)", "return", "new", "Slice", "(", "sr_first", ",", "sr_last", "+", "1", ",", "sr_stride", ",", "sr_last", "+", "1", ")", ".", "finish", "(", ")", ";", "}"], "docstring": "Take two slices and compose src wrt target\nAssume neither argument is null. This code\nshould match ucar.ma2.Section in thredds\nand dceconstraint.c in the netcdf-c library.\n\n@param target\n@param src\n@return new, composed Range\n@throws DapException", "docstring_tokens": ["Take", "two", "slices", "and", "compose", "src", "wrt", "target", "Assume", "neither", "argument", "is", "null", ".", "This", "code", "should", "match", "ucar", ".", "ma2", ".", "Section", "in", "thredds", "and", "dceconstraint", ".", "c", "in", "the", "netcdf", "-", "c", "library", "."]}
{"code": "buf0.order(ByteOrder.BIG_ENDIAN);", "comments": "must read in network order", "lines": 11, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapDump.java", "func_name": "DapDump.dumpbytes", "original_string": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "language": "java", "Allcodes": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "code_tokens": ["static", "public", "void", "dumpbytes", "(", "ByteBuffer", "buf0", ",", "boolean", "skipdmr", ")", "{", "int", "savepos", "=", "buf0", ".", "position", "(", ")", ";", "int", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "int", "skipcount", "=", "0", ";", "if", "(", "limit0", ">", "MAXLIMIT", ")", "limit0", "=", "MAXLIMIT", ";", "if", "(", "limit0", ">=", "buf0", ".", "limit", "(", ")", ")", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "if", "(", "skipdmr", ")", "{", "ByteOrder", "saveorder", "=", "buf0", ".", "order", "(", ")", ";", "buf0", ".", "order", "(", "ByteOrder", ".", "BIG_ENDIAN", ")", ";", "// must read in network order", "skipcount", "=", "buf0", ".", "getInt", "(", ")", ";", "//dmr count", "buf0", ".", "order", "(", "saveorder", ")", ";", "skipcount", "&=", "0xFFFFFF", ";", "// mask off the flags to get true count", "skipcount", "+=", "4", ";", "// skip the count also", "}", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "(", "limit0", "+", "8", ")", "-", "skipcount", "]", ";", "Arrays", ".", "fill", "(", "bytes", ",", "(", "byte", ")", "0", ")", ";", "buf0", ".", "position", "(", "savepos", "+", "skipcount", ")", ";", "buf0", ".", "get", "(", "bytes", ",", "0", ",", "limit0", "-", "skipcount", ")", ";", "buf0", ".", "position", "(", "savepos", ")", ";", "System", ".", "err", ".", "println", "(", "\"order=\"", "+", "buf0", ".", "order", "(", ")", ")", ";", "ByteBuffer", "buf", "=", "ByteBuffer", ".", "wrap", "(", "bytes", ")", ".", "order", "(", "buf0", ".", "order", "(", ")", ")", ";", "dumpbytes", "(", "buf", ")", ";", "}"], "docstring": "Provide a simple dump of binary data", "docstring_tokens": ["Provide", "a", "simple", "dump", "of", "binary", "data"]}
{"code": "skipcount = buf0.getInt();", "comments": "dmr count", "lines": 12, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapDump.java", "func_name": "DapDump.dumpbytes", "original_string": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "language": "java", "Allcodes": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "code_tokens": ["static", "public", "void", "dumpbytes", "(", "ByteBuffer", "buf0", ",", "boolean", "skipdmr", ")", "{", "int", "savepos", "=", "buf0", ".", "position", "(", ")", ";", "int", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "int", "skipcount", "=", "0", ";", "if", "(", "limit0", ">", "MAXLIMIT", ")", "limit0", "=", "MAXLIMIT", ";", "if", "(", "limit0", ">=", "buf0", ".", "limit", "(", ")", ")", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "if", "(", "skipdmr", ")", "{", "ByteOrder", "saveorder", "=", "buf0", ".", "order", "(", ")", ";", "buf0", ".", "order", "(", "ByteOrder", ".", "BIG_ENDIAN", ")", ";", "// must read in network order", "skipcount", "=", "buf0", ".", "getInt", "(", ")", ";", "//dmr count", "buf0", ".", "order", "(", "saveorder", ")", ";", "skipcount", "&=", "0xFFFFFF", ";", "// mask off the flags to get true count", "skipcount", "+=", "4", ";", "// skip the count also", "}", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "(", "limit0", "+", "8", ")", "-", "skipcount", "]", ";", "Arrays", ".", "fill", "(", "bytes", ",", "(", "byte", ")", "0", ")", ";", "buf0", ".", "position", "(", "savepos", "+", "skipcount", ")", ";", "buf0", ".", "get", "(", "bytes", ",", "0", ",", "limit0", "-", "skipcount", ")", ";", "buf0", ".", "position", "(", "savepos", ")", ";", "System", ".", "err", ".", "println", "(", "\"order=\"", "+", "buf0", ".", "order", "(", ")", ")", ";", "ByteBuffer", "buf", "=", "ByteBuffer", ".", "wrap", "(", "bytes", ")", ".", "order", "(", "buf0", ".", "order", "(", ")", ")", ";", "dumpbytes", "(", "buf", ")", ";", "}"], "docstring": "Provide a simple dump of binary data", "docstring_tokens": ["Provide", "a", "simple", "dump", "of", "binary", "data"]}
{"code": "skipcount &= 0xFFFFFF;", "comments": "mask off the flags to get true count", "lines": 14, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapDump.java", "func_name": "DapDump.dumpbytes", "original_string": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "language": "java", "Allcodes": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "code_tokens": ["static", "public", "void", "dumpbytes", "(", "ByteBuffer", "buf0", ",", "boolean", "skipdmr", ")", "{", "int", "savepos", "=", "buf0", ".", "position", "(", ")", ";", "int", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "int", "skipcount", "=", "0", ";", "if", "(", "limit0", ">", "MAXLIMIT", ")", "limit0", "=", "MAXLIMIT", ";", "if", "(", "limit0", ">=", "buf0", ".", "limit", "(", ")", ")", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "if", "(", "skipdmr", ")", "{", "ByteOrder", "saveorder", "=", "buf0", ".", "order", "(", ")", ";", "buf0", ".", "order", "(", "ByteOrder", ".", "BIG_ENDIAN", ")", ";", "// must read in network order", "skipcount", "=", "buf0", ".", "getInt", "(", ")", ";", "//dmr count", "buf0", ".", "order", "(", "saveorder", ")", ";", "skipcount", "&=", "0xFFFFFF", ";", "// mask off the flags to get true count", "skipcount", "+=", "4", ";", "// skip the count also", "}", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "(", "limit0", "+", "8", ")", "-", "skipcount", "]", ";", "Arrays", ".", "fill", "(", "bytes", ",", "(", "byte", ")", "0", ")", ";", "buf0", ".", "position", "(", "savepos", "+", "skipcount", ")", ";", "buf0", ".", "get", "(", "bytes", ",", "0", ",", "limit0", "-", "skipcount", ")", ";", "buf0", ".", "position", "(", "savepos", ")", ";", "System", ".", "err", ".", "println", "(", "\"order=\"", "+", "buf0", ".", "order", "(", ")", ")", ";", "ByteBuffer", "buf", "=", "ByteBuffer", ".", "wrap", "(", "bytes", ")", ".", "order", "(", "buf0", ".", "order", "(", ")", ")", ";", "dumpbytes", "(", "buf", ")", ";", "}"], "docstring": "Provide a simple dump of binary data", "docstring_tokens": ["Provide", "a", "simple", "dump", "of", "binary", "data"]}
{"code": "skipcount += 4;", "comments": "skip the count also", "lines": 15, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapDump.java", "func_name": "DapDump.dumpbytes", "original_string": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "language": "java", "Allcodes": "static public void\n    dumpbytes(ByteBuffer buf0, boolean skipdmr)\n    {\n        int savepos = buf0.position();\n        int limit0 = buf0.limit();\n        int skipcount = 0;\n        if(limit0 > MAXLIMIT) limit0 = MAXLIMIT;\n        if(limit0 >= buf0.limit()) limit0 = buf0.limit();\n        if(skipdmr) {\n            ByteOrder saveorder = buf0.order();\n            buf0.order(ByteOrder.BIG_ENDIAN); // must read in network order\n            skipcount = buf0.getInt(); //dmr count\n            buf0.order(saveorder);\n            skipcount &= 0xFFFFFF; // mask off the flags to get true count\n            skipcount += 4; // skip the count also\n        }\n        byte[] bytes = new byte[(limit0 + 8) - skipcount];\n        Arrays.fill(bytes, (byte) 0);\n        buf0.position(savepos + skipcount);\n        buf0.get(bytes, 0, limit0 - skipcount);\n        buf0.position(savepos);\n\n        System.err.println(\"order=\"+buf0.order());\n\n        ByteBuffer buf = ByteBuffer.wrap(bytes).order(buf0.order());\n        dumpbytes(buf);\n    }", "code_tokens": ["static", "public", "void", "dumpbytes", "(", "ByteBuffer", "buf0", ",", "boolean", "skipdmr", ")", "{", "int", "savepos", "=", "buf0", ".", "position", "(", ")", ";", "int", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "int", "skipcount", "=", "0", ";", "if", "(", "limit0", ">", "MAXLIMIT", ")", "limit0", "=", "MAXLIMIT", ";", "if", "(", "limit0", ">=", "buf0", ".", "limit", "(", ")", ")", "limit0", "=", "buf0", ".", "limit", "(", ")", ";", "if", "(", "skipdmr", ")", "{", "ByteOrder", "saveorder", "=", "buf0", ".", "order", "(", ")", ";", "buf0", ".", "order", "(", "ByteOrder", ".", "BIG_ENDIAN", ")", ";", "// must read in network order", "skipcount", "=", "buf0", ".", "getInt", "(", ")", ";", "//dmr count", "buf0", ".", "order", "(", "saveorder", ")", ";", "skipcount", "&=", "0xFFFFFF", ";", "// mask off the flags to get true count", "skipcount", "+=", "4", ";", "// skip the count also", "}", "byte", "[", "]", "bytes", "=", "new", "byte", "[", "(", "limit0", "+", "8", ")", "-", "skipcount", "]", ";", "Arrays", ".", "fill", "(", "bytes", ",", "(", "byte", ")", "0", ")", ";", "buf0", ".", "position", "(", "savepos", "+", "skipcount", ")", ";", "buf0", ".", "get", "(", "bytes", ",", "0", ",", "limit0", "-", "skipcount", ")", ";", "buf0", ".", "position", "(", "savepos", ")", ";", "System", ".", "err", ".", "println", "(", "\"order=\"", "+", "buf0", ".", "order", "(", ")", ")", ";", "ByteBuffer", "buf", "=", "ByteBuffer", ".", "wrap", "(", "bytes", ")", ".", "order", "(", "buf0", ".", "order", "(", ")", ")", ";", "dumpbytes", "(", "buf", ")", ";", "}"], "docstring": "Provide a simple dump of binary data", "docstring_tokens": ["Provide", "a", "simple", "dump", "of", "binary", "data"]}
{"code": "Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb);", "comments": "flat array", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamDataCol.java", "func_name": "NcStreamDataCol.decodeVlenData", "original_string": "public Array decodeVlenData(NcStreamProto.DataCol dproto) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // flat array\n    IndexIterator all = alldata.getIndexIterator();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Array[] data = new Array[(int) section.computeSize()];\n\n    // divide the primitive data into variable length arrays\n    int count = 0;\n    for (int len : dproto.getVlensList()) {\n      Array primdata = Array.factory(dataType, new int[]{len});\n      IndexIterator prim = primdata.getIndexIterator();\n      for (int i=0; i<len; i++) {\n        prim.setObjectNext( all.getObjectNext()); // generic\n      }\n      data[count++] = primdata;\n    }\n\n    // return Array.makeObjectArray(dataType, data[0].getClass(), section.getShape(), data);\n    return Array.makeVlenArray(section.getShape(), data);\n  }", "language": "java", "Allcodes": "public Array decodeVlenData(NcStreamProto.DataCol dproto) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // flat array\n    IndexIterator all = alldata.getIndexIterator();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Array[] data = new Array[(int) section.computeSize()];\n\n    // divide the primitive data into variable length arrays\n    int count = 0;\n    for (int len : dproto.getVlensList()) {\n      Array primdata = Array.factory(dataType, new int[]{len});\n      IndexIterator prim = primdata.getIndexIterator();\n      for (int i=0; i<len; i++) {\n        prim.setObjectNext( all.getObjectNext()); // generic\n      }\n      data[count++] = primdata;\n    }\n\n    // return Array.makeObjectArray(dataType, data[0].getClass(), section.getShape(), data);\n    return Array.makeVlenArray(section.getShape(), data);\n  }", "code_tokens": ["public", "Array", "decodeVlenData", "(", "NcStreamProto", ".", "DataCol", "dproto", ")", "throws", "IOException", "{", "DataType", "dataType", "=", "NcStream", ".", "convertDataType", "(", "dproto", ".", "getDataType", "(", ")", ")", ";", "ByteBuffer", "bb", "=", "dproto", ".", "getPrimdata", "(", ")", ".", "asReadOnlyByteBuffer", "(", ")", ";", "ByteOrder", "bo", "=", "dproto", ".", "getBigend", "(", ")", "?", "ByteOrder", ".", "BIG_ENDIAN", ":", "ByteOrder", ".", "LITTLE_ENDIAN", ";", "bb", ".", "order", "(", "bo", ")", ";", "Array", "alldata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "dproto", ".", "getNelems", "(", ")", "}", ",", "bb", ")", ";", "// flat array", "IndexIterator", "all", "=", "alldata", ".", "getIndexIterator", "(", ")", ";", "Section", "section", "=", "NcStream", ".", "decodeSection", "(", "dproto", ".", "getSection", "(", ")", ")", ";", "Array", "[", "]", "data", "=", "new", "Array", "[", "(", "int", ")", "section", ".", "computeSize", "(", ")", "]", ";", "// divide the primitive data into variable length arrays", "int", "count", "=", "0", ";", "for", "(", "int", "len", ":", "dproto", ".", "getVlensList", "(", ")", ")", "{", "Array", "primdata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "len", "}", ")", ";", "IndexIterator", "prim", "=", "primdata", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "prim", ".", "setObjectNext", "(", "all", ".", "getObjectNext", "(", ")", ")", ";", "// generic", "}", "data", "[", "count", "++", "]", "=", "primdata", ";", "}", "// return Array.makeObjectArray(dataType, data[0].getClass(), section.getShape(), data);", "return", "Array", ".", "makeVlenArray", "(", "section", ".", "getShape", "(", ")", ",", "data", ")", ";", "}"], "docstring": "top level vlen", "docstring_tokens": ["top", "level", "vlen"]}
{"code": "prim.setObjectNext( all.getObjectNext());", "comments": "generic", "lines": 18, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamDataCol.java", "func_name": "NcStreamDataCol.decodeVlenData", "original_string": "public Array decodeVlenData(NcStreamProto.DataCol dproto) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // flat array\n    IndexIterator all = alldata.getIndexIterator();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Array[] data = new Array[(int) section.computeSize()];\n\n    // divide the primitive data into variable length arrays\n    int count = 0;\n    for (int len : dproto.getVlensList()) {\n      Array primdata = Array.factory(dataType, new int[]{len});\n      IndexIterator prim = primdata.getIndexIterator();\n      for (int i=0; i<len; i++) {\n        prim.setObjectNext( all.getObjectNext()); // generic\n      }\n      data[count++] = primdata;\n    }\n\n    // return Array.makeObjectArray(dataType, data[0].getClass(), section.getShape(), data);\n    return Array.makeVlenArray(section.getShape(), data);\n  }", "language": "java", "Allcodes": "public Array decodeVlenData(NcStreamProto.DataCol dproto) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // flat array\n    IndexIterator all = alldata.getIndexIterator();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Array[] data = new Array[(int) section.computeSize()];\n\n    // divide the primitive data into variable length arrays\n    int count = 0;\n    for (int len : dproto.getVlensList()) {\n      Array primdata = Array.factory(dataType, new int[]{len});\n      IndexIterator prim = primdata.getIndexIterator();\n      for (int i=0; i<len; i++) {\n        prim.setObjectNext( all.getObjectNext()); // generic\n      }\n      data[count++] = primdata;\n    }\n\n    // return Array.makeObjectArray(dataType, data[0].getClass(), section.getShape(), data);\n    return Array.makeVlenArray(section.getShape(), data);\n  }", "code_tokens": ["public", "Array", "decodeVlenData", "(", "NcStreamProto", ".", "DataCol", "dproto", ")", "throws", "IOException", "{", "DataType", "dataType", "=", "NcStream", ".", "convertDataType", "(", "dproto", ".", "getDataType", "(", ")", ")", ";", "ByteBuffer", "bb", "=", "dproto", ".", "getPrimdata", "(", ")", ".", "asReadOnlyByteBuffer", "(", ")", ";", "ByteOrder", "bo", "=", "dproto", ".", "getBigend", "(", ")", "?", "ByteOrder", ".", "BIG_ENDIAN", ":", "ByteOrder", ".", "LITTLE_ENDIAN", ";", "bb", ".", "order", "(", "bo", ")", ";", "Array", "alldata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "dproto", ".", "getNelems", "(", ")", "}", ",", "bb", ")", ";", "// flat array", "IndexIterator", "all", "=", "alldata", ".", "getIndexIterator", "(", ")", ";", "Section", "section", "=", "NcStream", ".", "decodeSection", "(", "dproto", ".", "getSection", "(", ")", ")", ";", "Array", "[", "]", "data", "=", "new", "Array", "[", "(", "int", ")", "section", ".", "computeSize", "(", ")", "]", ";", "// divide the primitive data into variable length arrays", "int", "count", "=", "0", ";", "for", "(", "int", "len", ":", "dproto", ".", "getVlensList", "(", ")", ")", "{", "Array", "primdata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "len", "}", ")", ";", "IndexIterator", "prim", "=", "primdata", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "prim", ".", "setObjectNext", "(", "all", ".", "getObjectNext", "(", ")", ")", ";", "// generic", "}", "data", "[", "count", "++", "]", "=", "primdata", ";", "}", "// return Array.makeObjectArray(dataType, data[0].getClass(), section.getShape(), data);", "return", "Array", ".", "makeVlenArray", "(", "section", ".", "getShape", "(", ")", ",", "data", ")", ";", "}"], "docstring": "top level vlen", "docstring_tokens": ["top", "level", "vlen"]}
{"code": "Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb);", "comments": "1D array", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamDataCol.java", "func_name": "NcStreamDataCol.decodeVlenData", "original_string": "private Array decodeVlenData(NcStreamProto.DataCol dproto, Section parentSection) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // 1D array\n    IndexIterator all = alldata.getIndexIterator();\n\n    int psize = (int) parentSection.computeSize();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Section vsection = section.removeFirst(parentSection);\n    int vsectionSize = (int) vsection.computeSize(); // the # of varlen Arrays at the inner structure\n    // LOOK check for scalar\n\n    // divide the primitive data into variable length arrays\n    int countInner = 0;\n    Array[] pdata = new Array[psize];\n    for (int pCount=0; pCount<psize; pCount++) {\n      Array[] vdata = new Array[vsectionSize];\n      for (int vCount=0; vCount<vsectionSize; vCount++) {\n        int vlen = dproto.getVlens(countInner++);\n        Array primdata = Array.factory(dataType, new int[]{vlen});\n        IndexIterator prim = primdata.getIndexIterator();\n        for (int i = 0; i < vlen; i++) {\n          prim.setObjectNext(all.getObjectNext()); // generic\n        }\n        vdata[vCount] = primdata;\n      }\n      pdata[pCount] = Array.makeVlenArray(vsection.getShape(), vdata);\n    }\n\n    // ArrayObject(parentShape)\n    return Array.makeVlenArray(parentSection.getShape(), pdata);\n  }", "language": "java", "Allcodes": "private Array decodeVlenData(NcStreamProto.DataCol dproto, Section parentSection) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // 1D array\n    IndexIterator all = alldata.getIndexIterator();\n\n    int psize = (int) parentSection.computeSize();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Section vsection = section.removeFirst(parentSection);\n    int vsectionSize = (int) vsection.computeSize(); // the # of varlen Arrays at the inner structure\n    // LOOK check for scalar\n\n    // divide the primitive data into variable length arrays\n    int countInner = 0;\n    Array[] pdata = new Array[psize];\n    for (int pCount=0; pCount<psize; pCount++) {\n      Array[] vdata = new Array[vsectionSize];\n      for (int vCount=0; vCount<vsectionSize; vCount++) {\n        int vlen = dproto.getVlens(countInner++);\n        Array primdata = Array.factory(dataType, new int[]{vlen});\n        IndexIterator prim = primdata.getIndexIterator();\n        for (int i = 0; i < vlen; i++) {\n          prim.setObjectNext(all.getObjectNext()); // generic\n        }\n        vdata[vCount] = primdata;\n      }\n      pdata[pCount] = Array.makeVlenArray(vsection.getShape(), vdata);\n    }\n\n    // ArrayObject(parentShape)\n    return Array.makeVlenArray(parentSection.getShape(), pdata);\n  }", "code_tokens": ["private", "Array", "decodeVlenData", "(", "NcStreamProto", ".", "DataCol", "dproto", ",", "Section", "parentSection", ")", "throws", "IOException", "{", "DataType", "dataType", "=", "NcStream", ".", "convertDataType", "(", "dproto", ".", "getDataType", "(", ")", ")", ";", "ByteBuffer", "bb", "=", "dproto", ".", "getPrimdata", "(", ")", ".", "asReadOnlyByteBuffer", "(", ")", ";", "ByteOrder", "bo", "=", "dproto", ".", "getBigend", "(", ")", "?", "ByteOrder", ".", "BIG_ENDIAN", ":", "ByteOrder", ".", "LITTLE_ENDIAN", ";", "bb", ".", "order", "(", "bo", ")", ";", "Array", "alldata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "dproto", ".", "getNelems", "(", ")", "}", ",", "bb", ")", ";", "// 1D array", "IndexIterator", "all", "=", "alldata", ".", "getIndexIterator", "(", ")", ";", "int", "psize", "=", "(", "int", ")", "parentSection", ".", "computeSize", "(", ")", ";", "Section", "section", "=", "NcStream", ".", "decodeSection", "(", "dproto", ".", "getSection", "(", ")", ")", ";", "Section", "vsection", "=", "section", ".", "removeFirst", "(", "parentSection", ")", ";", "int", "vsectionSize", "=", "(", "int", ")", "vsection", ".", "computeSize", "(", ")", ";", "// the # of varlen Arrays at the inner structure", "// LOOK check for scalar", "// divide the primitive data into variable length arrays", "int", "countInner", "=", "0", ";", "Array", "[", "]", "pdata", "=", "new", "Array", "[", "psize", "]", ";", "for", "(", "int", "pCount", "=", "0", ";", "pCount", "<", "psize", ";", "pCount", "++", ")", "{", "Array", "[", "]", "vdata", "=", "new", "Array", "[", "vsectionSize", "]", ";", "for", "(", "int", "vCount", "=", "0", ";", "vCount", "<", "vsectionSize", ";", "vCount", "++", ")", "{", "int", "vlen", "=", "dproto", ".", "getVlens", "(", "countInner", "++", ")", ";", "Array", "primdata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "vlen", "}", ")", ";", "IndexIterator", "prim", "=", "primdata", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "vlen", ";", "i", "++", ")", "{", "prim", ".", "setObjectNext", "(", "all", ".", "getObjectNext", "(", ")", ")", ";", "// generic", "}", "vdata", "[", "vCount", "]", "=", "primdata", ";", "}", "pdata", "[", "pCount", "]", "=", "Array", ".", "makeVlenArray", "(", "vsection", ".", "getShape", "(", ")", ",", "vdata", ")", ";", "}", "// ArrayObject(parentShape)", "return", "Array", ".", "makeVlenArray", "(", "parentSection", ".", "getShape", "(", ")", ",", "pdata", ")", ";", "}"], "docstring": "vlen inside a Structure", "docstring_tokens": ["vlen", "inside", "a", "Structure"]}
{"code": "int vsectionSize = (int) vsection.computeSize();", "comments": "the # of varlen Arrays at the inner structure", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamDataCol.java", "func_name": "NcStreamDataCol.decodeVlenData", "original_string": "private Array decodeVlenData(NcStreamProto.DataCol dproto, Section parentSection) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // 1D array\n    IndexIterator all = alldata.getIndexIterator();\n\n    int psize = (int) parentSection.computeSize();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Section vsection = section.removeFirst(parentSection);\n    int vsectionSize = (int) vsection.computeSize(); // the # of varlen Arrays at the inner structure\n    // LOOK check for scalar\n\n    // divide the primitive data into variable length arrays\n    int countInner = 0;\n    Array[] pdata = new Array[psize];\n    for (int pCount=0; pCount<psize; pCount++) {\n      Array[] vdata = new Array[vsectionSize];\n      for (int vCount=0; vCount<vsectionSize; vCount++) {\n        int vlen = dproto.getVlens(countInner++);\n        Array primdata = Array.factory(dataType, new int[]{vlen});\n        IndexIterator prim = primdata.getIndexIterator();\n        for (int i = 0; i < vlen; i++) {\n          prim.setObjectNext(all.getObjectNext()); // generic\n        }\n        vdata[vCount] = primdata;\n      }\n      pdata[pCount] = Array.makeVlenArray(vsection.getShape(), vdata);\n    }\n\n    // ArrayObject(parentShape)\n    return Array.makeVlenArray(parentSection.getShape(), pdata);\n  }", "language": "java", "Allcodes": "private Array decodeVlenData(NcStreamProto.DataCol dproto, Section parentSection) throws IOException {\n    DataType dataType = NcStream.convertDataType(dproto.getDataType());\n    ByteBuffer bb = dproto.getPrimdata().asReadOnlyByteBuffer();\n    ByteOrder bo = dproto.getBigend() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n    bb.order(bo);\n    Array alldata = Array.factory(dataType, new int[]{dproto.getNelems()}, bb); // 1D array\n    IndexIterator all = alldata.getIndexIterator();\n\n    int psize = (int) parentSection.computeSize();\n\n    Section section = NcStream.decodeSection(dproto.getSection());\n    Section vsection = section.removeFirst(parentSection);\n    int vsectionSize = (int) vsection.computeSize(); // the # of varlen Arrays at the inner structure\n    // LOOK check for scalar\n\n    // divide the primitive data into variable length arrays\n    int countInner = 0;\n    Array[] pdata = new Array[psize];\n    for (int pCount=0; pCount<psize; pCount++) {\n      Array[] vdata = new Array[vsectionSize];\n      for (int vCount=0; vCount<vsectionSize; vCount++) {\n        int vlen = dproto.getVlens(countInner++);\n        Array primdata = Array.factory(dataType, new int[]{vlen});\n        IndexIterator prim = primdata.getIndexIterator();\n        for (int i = 0; i < vlen; i++) {\n          prim.setObjectNext(all.getObjectNext()); // generic\n        }\n        vdata[vCount] = primdata;\n      }\n      pdata[pCount] = Array.makeVlenArray(vsection.getShape(), vdata);\n    }\n\n    // ArrayObject(parentShape)\n    return Array.makeVlenArray(parentSection.getShape(), pdata);\n  }", "code_tokens": ["private", "Array", "decodeVlenData", "(", "NcStreamProto", ".", "DataCol", "dproto", ",", "Section", "parentSection", ")", "throws", "IOException", "{", "DataType", "dataType", "=", "NcStream", ".", "convertDataType", "(", "dproto", ".", "getDataType", "(", ")", ")", ";", "ByteBuffer", "bb", "=", "dproto", ".", "getPrimdata", "(", ")", ".", "asReadOnlyByteBuffer", "(", ")", ";", "ByteOrder", "bo", "=", "dproto", ".", "getBigend", "(", ")", "?", "ByteOrder", ".", "BIG_ENDIAN", ":", "ByteOrder", ".", "LITTLE_ENDIAN", ";", "bb", ".", "order", "(", "bo", ")", ";", "Array", "alldata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "dproto", ".", "getNelems", "(", ")", "}", ",", "bb", ")", ";", "// 1D array", "IndexIterator", "all", "=", "alldata", ".", "getIndexIterator", "(", ")", ";", "int", "psize", "=", "(", "int", ")", "parentSection", ".", "computeSize", "(", ")", ";", "Section", "section", "=", "NcStream", ".", "decodeSection", "(", "dproto", ".", "getSection", "(", ")", ")", ";", "Section", "vsection", "=", "section", ".", "removeFirst", "(", "parentSection", ")", ";", "int", "vsectionSize", "=", "(", "int", ")", "vsection", ".", "computeSize", "(", ")", ";", "// the # of varlen Arrays at the inner structure", "// LOOK check for scalar", "// divide the primitive data into variable length arrays", "int", "countInner", "=", "0", ";", "Array", "[", "]", "pdata", "=", "new", "Array", "[", "psize", "]", ";", "for", "(", "int", "pCount", "=", "0", ";", "pCount", "<", "psize", ";", "pCount", "++", ")", "{", "Array", "[", "]", "vdata", "=", "new", "Array", "[", "vsectionSize", "]", ";", "for", "(", "int", "vCount", "=", "0", ";", "vCount", "<", "vsectionSize", ";", "vCount", "++", ")", "{", "int", "vlen", "=", "dproto", ".", "getVlens", "(", "countInner", "++", ")", ";", "Array", "primdata", "=", "Array", ".", "factory", "(", "dataType", ",", "new", "int", "[", "]", "{", "vlen", "}", ")", ";", "IndexIterator", "prim", "=", "primdata", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "vlen", ";", "i", "++", ")", "{", "prim", ".", "setObjectNext", "(", "all", ".", "getObjectNext", "(", ")", ")", ";", "// generic", "}", "vdata", "[", "vCount", "]", "=", "primdata", ";", "}", "pdata", "[", "pCount", "]", "=", "Array", ".", "makeVlenArray", "(", "vsection", ".", "getShape", "(", ")", ",", "vdata", ")", ";", "}", "// ArrayObject(parentShape)", "return", "Array", ".", "makeVlenArray", "(", "parentSection", ".", "getShape", "(", ")", ",", "pdata", ")", ";", "}"], "docstring": "vlen inside a Structure", "docstring_tokens": ["vlen", "inside", "a", "Structure"]}
{"code": "double secs = timeUnit.getValueInSeconds(val);", "comments": "", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/units/DateUnit.java", "func_name": "DateUnit.makeDate", "original_string": "public Date makeDate(double val) {\r\n    if (Double.isNaN(val)) return null;\r\n    double secs = timeUnit.getValueInSeconds(val); //\r\n    return new Date(getDateOrigin().getTime() + (long) (1000 * secs));\r\n  }", "language": "java", "Allcodes": "public Date makeDate(double val) {\r\n    if (Double.isNaN(val)) return null;\r\n    double secs = timeUnit.getValueInSeconds(val); //\r\n    return new Date(getDateOrigin().getTime() + (long) (1000 * secs));\r\n  }", "code_tokens": ["public", "Date", "makeDate", "(", "double", "val", ")", "{", "if", "(", "Double", ".", "isNaN", "(", "val", ")", ")", "return", "null", ";", "double", "secs", "=", "timeUnit", ".", "getValueInSeconds", "(", "val", ")", ";", "//\r", "return", "new", "Date", "(", "getDateOrigin", "(", ")", ".", "getTime", "(", ")", "+", "(", "long", ")", "(", "1000", "*", "secs", ")", ")", ";", "}"], "docstring": "Create a Date from this base unit and the given value.\n\n@param val value in the units of this base unit, eg sec since base date\n@return Date .", "docstring_tokens": ["Create", "a", "Date", "from", "this", "base", "unit", "and", "the", "given", "value", "."]}
{"code": "v.setDimensions(\"\");", "comments": "scalar", "lines": 37, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeProjection", "original_string": "private boolean makeProjection(NetcdfFile ncfile, int projType) {\n    switch (projType) {\n\n      case GridTableLookup.RotatedLatLon:\n        makeRotatedLatLon(ncfile);\n        break;\n\n      case GridTableLookup.PolarStereographic:\n        makePS();\n        break;\n\n      case GridTableLookup.LambertConformal:\n        makeLC();\n        break;\n\n      case GridTableLookup.Mercator:\n        makeMercator();\n        break;\n\n      case GridTableLookup.Orthographic:\n        //makeSpaceViewOrOthographic();\n        makeMSGgeostationary();\n        break;\n\n      case GridTableLookup.Curvilinear:\n        makeCurvilinearAxis( ncfile);\n        break;\n\n      default:\n        throw new UnsupportedOperationException(\"unknown projection = \"\n            + gds.getInt(GridDefRecord.GRID_TYPE));\n    }\n\n    // dummy coordsys variable\n    Variable v = new Variable(ncfile, g, null, grid_name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    char[] data = new char[]{'d'};\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], data);\n    v.setCachedData(dataArray, false);\n\n    for (Attribute att : attributes)\n      v.addAttribute(att);\n\n    // add CF Conventions attributes\n    v.addAttribute(new Attribute(GridCF.EARTH_SHAPE, shape_name));\n\n    // LOOK - spherical earth ??\n    double radius_spherical_earth = gds.getDouble(GridDefRecord.RADIUS_SPHERICAL_EARTH);\n    // have to check both because Grib1 and Grib2 used different names\n    if (Double.isNaN(radius_spherical_earth))\n      radius_spherical_earth = gds.getDouble(\"radius_spherical_earth\");\n\n    if( ! Double.isNaN(radius_spherical_earth) ) {\n      //inconsistent - sometimes in km, sometimes in m.\n      if (radius_spherical_earth < 10000.00) // then its in km\n        radius_spherical_earth *= 1000.0;    // convert to meters\n      v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth)); //this attribute needs to be meters\n\n    } else { // oblate earth\n      double major_axis = gds.getDouble( GridDefRecord.MAJOR_AXIS_EARTH );\n      if (Double.isNaN( major_axis ))\n        major_axis = gds.getDouble(\"major_axis_earth\");\n      double minor_axis = gds.getDouble( GridDefRecord.MINOR_AXIS_EARTH );\n      if (Double.isNaN(minor_axis))\n        minor_axis = gds.getDouble(\"minor_axis_earth\");\n      if ( ! Double.isNaN ( major_axis ) && ! Double.isNaN ( minor_axis )) {\n        v.addAttribute(new Attribute(GridCF.SEMI_MAJOR_AXIS, major_axis));\n        v.addAttribute(new Attribute(GridCF.SEMI_MINOR_AXIS, minor_axis));\n      }\n    }\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n    return true;\n  }", "language": "java", "Allcodes": "private boolean makeProjection(NetcdfFile ncfile, int projType) {\n    switch (projType) {\n\n      case GridTableLookup.RotatedLatLon:\n        makeRotatedLatLon(ncfile);\n        break;\n\n      case GridTableLookup.PolarStereographic:\n        makePS();\n        break;\n\n      case GridTableLookup.LambertConformal:\n        makeLC();\n        break;\n\n      case GridTableLookup.Mercator:\n        makeMercator();\n        break;\n\n      case GridTableLookup.Orthographic:\n        //makeSpaceViewOrOthographic();\n        makeMSGgeostationary();\n        break;\n\n      case GridTableLookup.Curvilinear:\n        makeCurvilinearAxis( ncfile);\n        break;\n\n      default:\n        throw new UnsupportedOperationException(\"unknown projection = \"\n            + gds.getInt(GridDefRecord.GRID_TYPE));\n    }\n\n    // dummy coordsys variable\n    Variable v = new Variable(ncfile, g, null, grid_name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    char[] data = new char[]{'d'};\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], data);\n    v.setCachedData(dataArray, false);\n\n    for (Attribute att : attributes)\n      v.addAttribute(att);\n\n    // add CF Conventions attributes\n    v.addAttribute(new Attribute(GridCF.EARTH_SHAPE, shape_name));\n\n    // LOOK - spherical earth ??\n    double radius_spherical_earth = gds.getDouble(GridDefRecord.RADIUS_SPHERICAL_EARTH);\n    // have to check both because Grib1 and Grib2 used different names\n    if (Double.isNaN(radius_spherical_earth))\n      radius_spherical_earth = gds.getDouble(\"radius_spherical_earth\");\n\n    if( ! Double.isNaN(radius_spherical_earth) ) {\n      //inconsistent - sometimes in km, sometimes in m.\n      if (radius_spherical_earth < 10000.00) // then its in km\n        radius_spherical_earth *= 1000.0;    // convert to meters\n      v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth)); //this attribute needs to be meters\n\n    } else { // oblate earth\n      double major_axis = gds.getDouble( GridDefRecord.MAJOR_AXIS_EARTH );\n      if (Double.isNaN( major_axis ))\n        major_axis = gds.getDouble(\"major_axis_earth\");\n      double minor_axis = gds.getDouble( GridDefRecord.MINOR_AXIS_EARTH );\n      if (Double.isNaN(minor_axis))\n        minor_axis = gds.getDouble(\"minor_axis_earth\");\n      if ( ! Double.isNaN ( major_axis ) && ! Double.isNaN ( minor_axis )) {\n        v.addAttribute(new Attribute(GridCF.SEMI_MAJOR_AXIS, major_axis));\n        v.addAttribute(new Attribute(GridCF.SEMI_MINOR_AXIS, minor_axis));\n      }\n    }\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n    return true;\n  }", "code_tokens": ["private", "boolean", "makeProjection", "(", "NetcdfFile", "ncfile", ",", "int", "projType", ")", "{", "switch", "(", "projType", ")", "{", "case", "GridTableLookup", ".", "RotatedLatLon", ":", "makeRotatedLatLon", "(", "ncfile", ")", ";", "break", ";", "case", "GridTableLookup", ".", "PolarStereographic", ":", "makePS", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "LambertConformal", ":", "makeLC", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Mercator", ":", "makeMercator", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Orthographic", ":", "//makeSpaceViewOrOthographic();", "makeMSGgeostationary", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Curvilinear", ":", "makeCurvilinearAxis", "(", "ncfile", ")", ";", "break", ";", "default", ":", "throw", "new", "UnsupportedOperationException", "(", "\"unknown projection = \"", "+", "gds", ".", "getInt", "(", "GridDefRecord", ".", "GRID_TYPE", ")", ")", ";", "}", "// dummy coordsys variable", "Variable", "v", "=", "new", "Variable", "(", "ncfile", ",", "g", ",", "null", ",", "grid_name", ")", ";", "v", ".", "setDataType", "(", "DataType", ".", "CHAR", ")", ";", "v", ".", "setDimensions", "(", "\"\"", ")", ";", "// scalar", "char", "[", "]", "data", "=", "new", "char", "[", "]", "{", "'", "'", "}", ";", "Array", "dataArray", "=", "Array", ".", "factory", "(", "DataType", ".", "CHAR", ",", "new", "int", "[", "0", "]", ",", "data", ")", ";", "v", ".", "setCachedData", "(", "dataArray", ",", "false", ")", ";", "for", "(", "Attribute", "att", ":", "attributes", ")", "v", ".", "addAttribute", "(", "att", ")", ";", "// add CF Conventions attributes", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "EARTH_SHAPE", ",", "shape_name", ")", ")", ";", "// LOOK - spherical earth ??", "double", "radius_spherical_earth", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "RADIUS_SPHERICAL_EARTH", ")", ";", "// have to check both because Grib1 and Grib2 used different names", "if", "(", "Double", ".", "isNaN", "(", "radius_spherical_earth", ")", ")", "radius_spherical_earth", "=", "gds", ".", "getDouble", "(", "\"radius_spherical_earth\"", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "radius_spherical_earth", ")", ")", "{", "//inconsistent - sometimes in km, sometimes in m.", "if", "(", "radius_spherical_earth", "<", "10000.00", ")", "// then its in km", "radius_spherical_earth", "*=", "1000.0", ";", "// convert to meters", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "EARTH_RADIUS", ",", "radius_spherical_earth", ")", ")", ";", "//this attribute needs to be meters", "}", "else", "{", "// oblate earth", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "major_axis", ")", "&&", "!", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "{", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "SEMI_MAJOR_AXIS", ",", "major_axis", ")", ")", ";", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "SEMI_MINOR_AXIS", ",", "minor_axis", ")", ")", ";", "}", "}", "addGDSparams", "(", "v", ")", ";", "ncfile", ".", "addVariable", "(", "g", ",", "v", ")", ";", "return", "true", ";", "}"], "docstring": "Make a projection and add it to the netCDF file\n\n@param ncfile netCDF file\n@return true if projection was added and coordinates need to be added, false means do nothing", "docstring_tokens": ["Make", "a", "projection", "and", "add", "it", "to", "the", "netCDF", "file"]}
{"code": "radius_spherical_earth *= 1000.0;", "comments": "convert to meters", "lines": 57, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeProjection", "original_string": "private boolean makeProjection(NetcdfFile ncfile, int projType) {\n    switch (projType) {\n\n      case GridTableLookup.RotatedLatLon:\n        makeRotatedLatLon(ncfile);\n        break;\n\n      case GridTableLookup.PolarStereographic:\n        makePS();\n        break;\n\n      case GridTableLookup.LambertConformal:\n        makeLC();\n        break;\n\n      case GridTableLookup.Mercator:\n        makeMercator();\n        break;\n\n      case GridTableLookup.Orthographic:\n        //makeSpaceViewOrOthographic();\n        makeMSGgeostationary();\n        break;\n\n      case GridTableLookup.Curvilinear:\n        makeCurvilinearAxis( ncfile);\n        break;\n\n      default:\n        throw new UnsupportedOperationException(\"unknown projection = \"\n            + gds.getInt(GridDefRecord.GRID_TYPE));\n    }\n\n    // dummy coordsys variable\n    Variable v = new Variable(ncfile, g, null, grid_name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    char[] data = new char[]{'d'};\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], data);\n    v.setCachedData(dataArray, false);\n\n    for (Attribute att : attributes)\n      v.addAttribute(att);\n\n    // add CF Conventions attributes\n    v.addAttribute(new Attribute(GridCF.EARTH_SHAPE, shape_name));\n\n    // LOOK - spherical earth ??\n    double radius_spherical_earth = gds.getDouble(GridDefRecord.RADIUS_SPHERICAL_EARTH);\n    // have to check both because Grib1 and Grib2 used different names\n    if (Double.isNaN(radius_spherical_earth))\n      radius_spherical_earth = gds.getDouble(\"radius_spherical_earth\");\n\n    if( ! Double.isNaN(radius_spherical_earth) ) {\n      //inconsistent - sometimes in km, sometimes in m.\n      if (radius_spherical_earth < 10000.00) // then its in km\n        radius_spherical_earth *= 1000.0;    // convert to meters\n      v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth)); //this attribute needs to be meters\n\n    } else { // oblate earth\n      double major_axis = gds.getDouble( GridDefRecord.MAJOR_AXIS_EARTH );\n      if (Double.isNaN( major_axis ))\n        major_axis = gds.getDouble(\"major_axis_earth\");\n      double minor_axis = gds.getDouble( GridDefRecord.MINOR_AXIS_EARTH );\n      if (Double.isNaN(minor_axis))\n        minor_axis = gds.getDouble(\"minor_axis_earth\");\n      if ( ! Double.isNaN ( major_axis ) && ! Double.isNaN ( minor_axis )) {\n        v.addAttribute(new Attribute(GridCF.SEMI_MAJOR_AXIS, major_axis));\n        v.addAttribute(new Attribute(GridCF.SEMI_MINOR_AXIS, minor_axis));\n      }\n    }\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n    return true;\n  }", "language": "java", "Allcodes": "private boolean makeProjection(NetcdfFile ncfile, int projType) {\n    switch (projType) {\n\n      case GridTableLookup.RotatedLatLon:\n        makeRotatedLatLon(ncfile);\n        break;\n\n      case GridTableLookup.PolarStereographic:\n        makePS();\n        break;\n\n      case GridTableLookup.LambertConformal:\n        makeLC();\n        break;\n\n      case GridTableLookup.Mercator:\n        makeMercator();\n        break;\n\n      case GridTableLookup.Orthographic:\n        //makeSpaceViewOrOthographic();\n        makeMSGgeostationary();\n        break;\n\n      case GridTableLookup.Curvilinear:\n        makeCurvilinearAxis( ncfile);\n        break;\n\n      default:\n        throw new UnsupportedOperationException(\"unknown projection = \"\n            + gds.getInt(GridDefRecord.GRID_TYPE));\n    }\n\n    // dummy coordsys variable\n    Variable v = new Variable(ncfile, g, null, grid_name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    char[] data = new char[]{'d'};\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], data);\n    v.setCachedData(dataArray, false);\n\n    for (Attribute att : attributes)\n      v.addAttribute(att);\n\n    // add CF Conventions attributes\n    v.addAttribute(new Attribute(GridCF.EARTH_SHAPE, shape_name));\n\n    // LOOK - spherical earth ??\n    double radius_spherical_earth = gds.getDouble(GridDefRecord.RADIUS_SPHERICAL_EARTH);\n    // have to check both because Grib1 and Grib2 used different names\n    if (Double.isNaN(radius_spherical_earth))\n      radius_spherical_earth = gds.getDouble(\"radius_spherical_earth\");\n\n    if( ! Double.isNaN(radius_spherical_earth) ) {\n      //inconsistent - sometimes in km, sometimes in m.\n      if (radius_spherical_earth < 10000.00) // then its in km\n        radius_spherical_earth *= 1000.0;    // convert to meters\n      v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth)); //this attribute needs to be meters\n\n    } else { // oblate earth\n      double major_axis = gds.getDouble( GridDefRecord.MAJOR_AXIS_EARTH );\n      if (Double.isNaN( major_axis ))\n        major_axis = gds.getDouble(\"major_axis_earth\");\n      double minor_axis = gds.getDouble( GridDefRecord.MINOR_AXIS_EARTH );\n      if (Double.isNaN(minor_axis))\n        minor_axis = gds.getDouble(\"minor_axis_earth\");\n      if ( ! Double.isNaN ( major_axis ) && ! Double.isNaN ( minor_axis )) {\n        v.addAttribute(new Attribute(GridCF.SEMI_MAJOR_AXIS, major_axis));\n        v.addAttribute(new Attribute(GridCF.SEMI_MINOR_AXIS, minor_axis));\n      }\n    }\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n    return true;\n  }", "code_tokens": ["private", "boolean", "makeProjection", "(", "NetcdfFile", "ncfile", ",", "int", "projType", ")", "{", "switch", "(", "projType", ")", "{", "case", "GridTableLookup", ".", "RotatedLatLon", ":", "makeRotatedLatLon", "(", "ncfile", ")", ";", "break", ";", "case", "GridTableLookup", ".", "PolarStereographic", ":", "makePS", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "LambertConformal", ":", "makeLC", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Mercator", ":", "makeMercator", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Orthographic", ":", "//makeSpaceViewOrOthographic();", "makeMSGgeostationary", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Curvilinear", ":", "makeCurvilinearAxis", "(", "ncfile", ")", ";", "break", ";", "default", ":", "throw", "new", "UnsupportedOperationException", "(", "\"unknown projection = \"", "+", "gds", ".", "getInt", "(", "GridDefRecord", ".", "GRID_TYPE", ")", ")", ";", "}", "// dummy coordsys variable", "Variable", "v", "=", "new", "Variable", "(", "ncfile", ",", "g", ",", "null", ",", "grid_name", ")", ";", "v", ".", "setDataType", "(", "DataType", ".", "CHAR", ")", ";", "v", ".", "setDimensions", "(", "\"\"", ")", ";", "// scalar", "char", "[", "]", "data", "=", "new", "char", "[", "]", "{", "'", "'", "}", ";", "Array", "dataArray", "=", "Array", ".", "factory", "(", "DataType", ".", "CHAR", ",", "new", "int", "[", "0", "]", ",", "data", ")", ";", "v", ".", "setCachedData", "(", "dataArray", ",", "false", ")", ";", "for", "(", "Attribute", "att", ":", "attributes", ")", "v", ".", "addAttribute", "(", "att", ")", ";", "// add CF Conventions attributes", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "EARTH_SHAPE", ",", "shape_name", ")", ")", ";", "// LOOK - spherical earth ??", "double", "radius_spherical_earth", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "RADIUS_SPHERICAL_EARTH", ")", ";", "// have to check both because Grib1 and Grib2 used different names", "if", "(", "Double", ".", "isNaN", "(", "radius_spherical_earth", ")", ")", "radius_spherical_earth", "=", "gds", ".", "getDouble", "(", "\"radius_spherical_earth\"", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "radius_spherical_earth", ")", ")", "{", "//inconsistent - sometimes in km, sometimes in m.", "if", "(", "radius_spherical_earth", "<", "10000.00", ")", "// then its in km", "radius_spherical_earth", "*=", "1000.0", ";", "// convert to meters", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "EARTH_RADIUS", ",", "radius_spherical_earth", ")", ")", ";", "//this attribute needs to be meters", "}", "else", "{", "// oblate earth", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "major_axis", ")", "&&", "!", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "{", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "SEMI_MAJOR_AXIS", ",", "major_axis", ")", ")", ";", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "SEMI_MINOR_AXIS", ",", "minor_axis", ")", ")", ";", "}", "}", "addGDSparams", "(", "v", ")", ";", "ncfile", ".", "addVariable", "(", "g", ",", "v", ")", ";", "return", "true", ";", "}"], "docstring": "Make a projection and add it to the netCDF file\n\n@param ncfile netCDF file\n@return true if projection was added and coordinates need to be added, false means do nothing", "docstring_tokens": ["Make", "a", "projection", "and", "add", "it", "to", "the", "netCDF", "file"]}
{"code": "v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth));", "comments": "this attribute needs to be meters", "lines": 58, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeProjection", "original_string": "private boolean makeProjection(NetcdfFile ncfile, int projType) {\n    switch (projType) {\n\n      case GridTableLookup.RotatedLatLon:\n        makeRotatedLatLon(ncfile);\n        break;\n\n      case GridTableLookup.PolarStereographic:\n        makePS();\n        break;\n\n      case GridTableLookup.LambertConformal:\n        makeLC();\n        break;\n\n      case GridTableLookup.Mercator:\n        makeMercator();\n        break;\n\n      case GridTableLookup.Orthographic:\n        //makeSpaceViewOrOthographic();\n        makeMSGgeostationary();\n        break;\n\n      case GridTableLookup.Curvilinear:\n        makeCurvilinearAxis( ncfile);\n        break;\n\n      default:\n        throw new UnsupportedOperationException(\"unknown projection = \"\n            + gds.getInt(GridDefRecord.GRID_TYPE));\n    }\n\n    // dummy coordsys variable\n    Variable v = new Variable(ncfile, g, null, grid_name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    char[] data = new char[]{'d'};\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], data);\n    v.setCachedData(dataArray, false);\n\n    for (Attribute att : attributes)\n      v.addAttribute(att);\n\n    // add CF Conventions attributes\n    v.addAttribute(new Attribute(GridCF.EARTH_SHAPE, shape_name));\n\n    // LOOK - spherical earth ??\n    double radius_spherical_earth = gds.getDouble(GridDefRecord.RADIUS_SPHERICAL_EARTH);\n    // have to check both because Grib1 and Grib2 used different names\n    if (Double.isNaN(radius_spherical_earth))\n      radius_spherical_earth = gds.getDouble(\"radius_spherical_earth\");\n\n    if( ! Double.isNaN(radius_spherical_earth) ) {\n      //inconsistent - sometimes in km, sometimes in m.\n      if (radius_spherical_earth < 10000.00) // then its in km\n        radius_spherical_earth *= 1000.0;    // convert to meters\n      v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth)); //this attribute needs to be meters\n\n    } else { // oblate earth\n      double major_axis = gds.getDouble( GridDefRecord.MAJOR_AXIS_EARTH );\n      if (Double.isNaN( major_axis ))\n        major_axis = gds.getDouble(\"major_axis_earth\");\n      double minor_axis = gds.getDouble( GridDefRecord.MINOR_AXIS_EARTH );\n      if (Double.isNaN(minor_axis))\n        minor_axis = gds.getDouble(\"minor_axis_earth\");\n      if ( ! Double.isNaN ( major_axis ) && ! Double.isNaN ( minor_axis )) {\n        v.addAttribute(new Attribute(GridCF.SEMI_MAJOR_AXIS, major_axis));\n        v.addAttribute(new Attribute(GridCF.SEMI_MINOR_AXIS, minor_axis));\n      }\n    }\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n    return true;\n  }", "language": "java", "Allcodes": "private boolean makeProjection(NetcdfFile ncfile, int projType) {\n    switch (projType) {\n\n      case GridTableLookup.RotatedLatLon:\n        makeRotatedLatLon(ncfile);\n        break;\n\n      case GridTableLookup.PolarStereographic:\n        makePS();\n        break;\n\n      case GridTableLookup.LambertConformal:\n        makeLC();\n        break;\n\n      case GridTableLookup.Mercator:\n        makeMercator();\n        break;\n\n      case GridTableLookup.Orthographic:\n        //makeSpaceViewOrOthographic();\n        makeMSGgeostationary();\n        break;\n\n      case GridTableLookup.Curvilinear:\n        makeCurvilinearAxis( ncfile);\n        break;\n\n      default:\n        throw new UnsupportedOperationException(\"unknown projection = \"\n            + gds.getInt(GridDefRecord.GRID_TYPE));\n    }\n\n    // dummy coordsys variable\n    Variable v = new Variable(ncfile, g, null, grid_name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    char[] data = new char[]{'d'};\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], data);\n    v.setCachedData(dataArray, false);\n\n    for (Attribute att : attributes)\n      v.addAttribute(att);\n\n    // add CF Conventions attributes\n    v.addAttribute(new Attribute(GridCF.EARTH_SHAPE, shape_name));\n\n    // LOOK - spherical earth ??\n    double radius_spherical_earth = gds.getDouble(GridDefRecord.RADIUS_SPHERICAL_EARTH);\n    // have to check both because Grib1 and Grib2 used different names\n    if (Double.isNaN(radius_spherical_earth))\n      radius_spherical_earth = gds.getDouble(\"radius_spherical_earth\");\n\n    if( ! Double.isNaN(radius_spherical_earth) ) {\n      //inconsistent - sometimes in km, sometimes in m.\n      if (radius_spherical_earth < 10000.00) // then its in km\n        radius_spherical_earth *= 1000.0;    // convert to meters\n      v.addAttribute(new Attribute(GridCF.EARTH_RADIUS, radius_spherical_earth)); //this attribute needs to be meters\n\n    } else { // oblate earth\n      double major_axis = gds.getDouble( GridDefRecord.MAJOR_AXIS_EARTH );\n      if (Double.isNaN( major_axis ))\n        major_axis = gds.getDouble(\"major_axis_earth\");\n      double minor_axis = gds.getDouble( GridDefRecord.MINOR_AXIS_EARTH );\n      if (Double.isNaN(minor_axis))\n        minor_axis = gds.getDouble(\"minor_axis_earth\");\n      if ( ! Double.isNaN ( major_axis ) && ! Double.isNaN ( minor_axis )) {\n        v.addAttribute(new Attribute(GridCF.SEMI_MAJOR_AXIS, major_axis));\n        v.addAttribute(new Attribute(GridCF.SEMI_MINOR_AXIS, minor_axis));\n      }\n    }\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n    return true;\n  }", "code_tokens": ["private", "boolean", "makeProjection", "(", "NetcdfFile", "ncfile", ",", "int", "projType", ")", "{", "switch", "(", "projType", ")", "{", "case", "GridTableLookup", ".", "RotatedLatLon", ":", "makeRotatedLatLon", "(", "ncfile", ")", ";", "break", ";", "case", "GridTableLookup", ".", "PolarStereographic", ":", "makePS", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "LambertConformal", ":", "makeLC", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Mercator", ":", "makeMercator", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Orthographic", ":", "//makeSpaceViewOrOthographic();", "makeMSGgeostationary", "(", ")", ";", "break", ";", "case", "GridTableLookup", ".", "Curvilinear", ":", "makeCurvilinearAxis", "(", "ncfile", ")", ";", "break", ";", "default", ":", "throw", "new", "UnsupportedOperationException", "(", "\"unknown projection = \"", "+", "gds", ".", "getInt", "(", "GridDefRecord", ".", "GRID_TYPE", ")", ")", ";", "}", "// dummy coordsys variable", "Variable", "v", "=", "new", "Variable", "(", "ncfile", ",", "g", ",", "null", ",", "grid_name", ")", ";", "v", ".", "setDataType", "(", "DataType", ".", "CHAR", ")", ";", "v", ".", "setDimensions", "(", "\"\"", ")", ";", "// scalar", "char", "[", "]", "data", "=", "new", "char", "[", "]", "{", "'", "'", "}", ";", "Array", "dataArray", "=", "Array", ".", "factory", "(", "DataType", ".", "CHAR", ",", "new", "int", "[", "0", "]", ",", "data", ")", ";", "v", ".", "setCachedData", "(", "dataArray", ",", "false", ")", ";", "for", "(", "Attribute", "att", ":", "attributes", ")", "v", ".", "addAttribute", "(", "att", ")", ";", "// add CF Conventions attributes", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "EARTH_SHAPE", ",", "shape_name", ")", ")", ";", "// LOOK - spherical earth ??", "double", "radius_spherical_earth", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "RADIUS_SPHERICAL_EARTH", ")", ";", "// have to check both because Grib1 and Grib2 used different names", "if", "(", "Double", ".", "isNaN", "(", "radius_spherical_earth", ")", ")", "radius_spherical_earth", "=", "gds", ".", "getDouble", "(", "\"radius_spherical_earth\"", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "radius_spherical_earth", ")", ")", "{", "//inconsistent - sometimes in km, sometimes in m.", "if", "(", "radius_spherical_earth", "<", "10000.00", ")", "// then its in km", "radius_spherical_earth", "*=", "1000.0", ";", "// convert to meters", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "EARTH_RADIUS", ",", "radius_spherical_earth", ")", ")", ";", "//this attribute needs to be meters", "}", "else", "{", "// oblate earth", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "major_axis", ")", "&&", "!", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "{", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "SEMI_MAJOR_AXIS", ",", "major_axis", ")", ")", ";", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "GridCF", ".", "SEMI_MINOR_AXIS", ",", "minor_axis", ")", ")", ";", "}", "}", "addGDSparams", "(", "v", ")", ";", "ncfile", ".", "addVariable", "(", "g", ",", "v", ")", ";", "return", "true", ";", "}"], "docstring": "Make a projection and add it to the netCDF file\n\n@param ncfile netCDF file\n@return true if projection was added and coordinates need to be added, false means do nothing", "docstring_tokens": ["Make", "a", "projection", "and", "add", "it", "to", "the", "netCDF", "file"]}
{"code": "v.addAttribute(new Attribute(_Coordinate.Transforms, \"\"));", "comments": "to make sure its identified as a Coordinate System Variable", "lines": 9, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.addCoordSystemVariable", "original_string": "private void addCoordSystemVariable(NetcdfFile ncfile, String name, String dims) {\n    Variable v = new Variable(ncfile, g, null, name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], new char[]{'0'});\n    v.setCachedData(dataArray, false);\n    v.addAttribute(new Attribute(_Coordinate.Axes, dims));\n    if (isLatLon())\n      v.addAttribute(new Attribute(_Coordinate.Transforms, \"\")); // to make sure its identified as a Coordinate System Variable\n    else\n      v.addAttribute(new Attribute(_Coordinate.Transforms, getGridName()));\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n  }", "language": "java", "Allcodes": "private void addCoordSystemVariable(NetcdfFile ncfile, String name, String dims) {\n    Variable v = new Variable(ncfile, g, null, name);\n    v.setDataType(DataType.CHAR);\n    v.setDimensions(\"\"); // scalar\n    Array dataArray = Array.factory(DataType.CHAR, new int[0], new char[]{'0'});\n    v.setCachedData(dataArray, false);\n    v.addAttribute(new Attribute(_Coordinate.Axes, dims));\n    if (isLatLon())\n      v.addAttribute(new Attribute(_Coordinate.Transforms, \"\")); // to make sure its identified as a Coordinate System Variable\n    else\n      v.addAttribute(new Attribute(_Coordinate.Transforms, getGridName()));\n    addGDSparams(v);\n    ncfile.addVariable(g, v);\n  }", "code_tokens": ["private", "void", "addCoordSystemVariable", "(", "NetcdfFile", "ncfile", ",", "String", "name", ",", "String", "dims", ")", "{", "Variable", "v", "=", "new", "Variable", "(", "ncfile", ",", "g", ",", "null", ",", "name", ")", ";", "v", ".", "setDataType", "(", "DataType", ".", "CHAR", ")", ";", "v", ".", "setDimensions", "(", "\"\"", ")", ";", "// scalar", "Array", "dataArray", "=", "Array", ".", "factory", "(", "DataType", ".", "CHAR", ",", "new", "int", "[", "0", "]", ",", "new", "char", "[", "]", "{", "'", "'", "}", ")", ";", "v", ".", "setCachedData", "(", "dataArray", ",", "false", ")", ";", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "_Coordinate", ".", "Axes", ",", "dims", ")", ")", ";", "if", "(", "isLatLon", "(", ")", ")", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "_Coordinate", ".", "Transforms", ",", "\"\"", ")", ")", ";", "// to make sure its identified as a Coordinate System Variable", "else", "v", ".", "addAttribute", "(", "new", "Attribute", "(", "_Coordinate", ".", "Transforms", ",", "getGridName", "(", ")", ")", ")", ";", "addGDSparams", "(", "v", ")", ";", "ncfile", ".", "addVariable", "(", "g", ",", "v", ")", ";", "}"], "docstring": "Add coordinate system variable\n\n@param ncfile netCDF file\n@param name   name of the variable\n@param dims   dimensions", "docstring_tokens": ["Add", "coordinate", "system", "variable"]}
{"code": "double Lo1 = gds.getDouble(GridDefRecord.LO1);", "comments": "gds.Lo1;", "lines": 11, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMercator", "original_string": "private void makeMercator() {\n    /**\n     * Construct a Mercator Projection.\n     * @param lon0 longitude of origin (degrees)\n     * @param par standard parallel (degrees). cylinder cuts earth at this latitude.\n     */\n    double Latin = gds.getDouble(GridDefRecord.LAD);\n    // name depends on Grib version 1 or 2\n    if (Double.isNaN(Latin))\n      Latin = gds.getDouble(GridDefRecord.LATIN);\n    double Lo1 = gds.getDouble(GridDefRecord.LO1); //gds.Lo1;\n    double La1 = gds.getDouble(GridDefRecord.LA1); //gds.La1;\n\n    // put longitude origin at first point - doesnt actually matter\n    proj = new Mercator(Lo1, Latin);\n\n    // find out where\n    ProjectionPoint startP = proj.latLonToProj(\n        new LatLonPointImpl(La1, Lo1));\n    startx = startP.getX();\n    starty = startP.getY();\n\n    if (Double.isNaN(getDxInKm())) {\n      setDxDy(startx, starty, proj);\n    }\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"mercator\"));\n    attributes.add(new Attribute(GridCF.STANDARD_PARALLEL, Latin));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lo1));\n\n    if (GridServiceProvider.debugProj) {\n      double Lo2 = gds.getDouble(GridDefRecord.LO2);\n      if (Lo2 < Lo1) Lo2 += 360;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMercator: end at latlon= \" +\n          endLL);\n\n      ProjectionPointImpl endPP = (ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   start at proj coord \" +\n          new ProjectionPointImpl(startx, starty));\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = startx + (getNx() - 1) * getDxInKm();\n      double endy = starty + (getNy() - 1) * getDyInKm();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMercator() {\n    /**\n     * Construct a Mercator Projection.\n     * @param lon0 longitude of origin (degrees)\n     * @param par standard parallel (degrees). cylinder cuts earth at this latitude.\n     */\n    double Latin = gds.getDouble(GridDefRecord.LAD);\n    // name depends on Grib version 1 or 2\n    if (Double.isNaN(Latin))\n      Latin = gds.getDouble(GridDefRecord.LATIN);\n    double Lo1 = gds.getDouble(GridDefRecord.LO1); //gds.Lo1;\n    double La1 = gds.getDouble(GridDefRecord.LA1); //gds.La1;\n\n    // put longitude origin at first point - doesnt actually matter\n    proj = new Mercator(Lo1, Latin);\n\n    // find out where\n    ProjectionPoint startP = proj.latLonToProj(\n        new LatLonPointImpl(La1, Lo1));\n    startx = startP.getX();\n    starty = startP.getY();\n\n    if (Double.isNaN(getDxInKm())) {\n      setDxDy(startx, starty, proj);\n    }\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"mercator\"));\n    attributes.add(new Attribute(GridCF.STANDARD_PARALLEL, Latin));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lo1));\n\n    if (GridServiceProvider.debugProj) {\n      double Lo2 = gds.getDouble(GridDefRecord.LO2);\n      if (Lo2 < Lo1) Lo2 += 360;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMercator: end at latlon= \" +\n          endLL);\n\n      ProjectionPointImpl endPP = (ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   start at proj coord \" +\n          new ProjectionPointImpl(startx, starty));\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = startx + (getNx() - 1) * getDxInKm();\n      double endy = starty + (getNy() - 1) * getDyInKm();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMercator", "(", ")", "{", "/**\n     * Construct a Mercator Projection.\n     * @param lon0 longitude of origin (degrees)\n     * @param par standard parallel (degrees). cylinder cuts earth at this latitude.\n     */", "double", "Latin", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAD", ")", ";", "// name depends on Grib version 1 or 2", "if", "(", "Double", ".", "isNaN", "(", "Latin", ")", ")", "Latin", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LATIN", ")", ";", "double", "Lo1", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO1", ")", ";", "//gds.Lo1;", "double", "La1", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA1", ")", ";", "//gds.La1;", "// put longitude origin at first point - doesnt actually matter", "proj", "=", "new", "Mercator", "(", "Lo1", ",", "Latin", ")", ";", "// find out where", "ProjectionPoint", "startP", "=", "proj", ".", "latLonToProj", "(", "new", "LatLonPointImpl", "(", "La1", ",", "Lo1", ")", ")", ";", "startx", "=", "startP", ".", "getX", "(", ")", ";", "starty", "=", "startP", ".", "getY", "(", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "getDxInKm", "(", ")", ")", ")", "{", "setDxDy", "(", "startx", ",", "starty", ",", "proj", ")", ";", "}", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"mercator\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "STANDARD_PARALLEL", ",", "Latin", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lo1", ")", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", ";", "if", "(", "Lo2", "<", "Lo1", ")", "Lo2", "+=", "360", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMercator: end at latlon= \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   start at proj coord \"", "+", "new", "ProjectionPointImpl", "(", "startx", ",", "starty", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "startx", "+", "(", "getNx", "(", ")", "-", "1", ")", "*", "getDxInKm", "(", ")", ";", "double", "endy", "=", "starty", "+", "(", "getNy", "(", ")", "-", "1", ")", "*", "getDyInKm", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Mercator projection", "docstring_tokens": ["Make", "a", "Mercator", "projection"]}
{"code": "double La1 = gds.getDouble(GridDefRecord.LA1);", "comments": "gds.La1;", "lines": 12, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMercator", "original_string": "private void makeMercator() {\n    /**\n     * Construct a Mercator Projection.\n     * @param lon0 longitude of origin (degrees)\n     * @param par standard parallel (degrees). cylinder cuts earth at this latitude.\n     */\n    double Latin = gds.getDouble(GridDefRecord.LAD);\n    // name depends on Grib version 1 or 2\n    if (Double.isNaN(Latin))\n      Latin = gds.getDouble(GridDefRecord.LATIN);\n    double Lo1 = gds.getDouble(GridDefRecord.LO1); //gds.Lo1;\n    double La1 = gds.getDouble(GridDefRecord.LA1); //gds.La1;\n\n    // put longitude origin at first point - doesnt actually matter\n    proj = new Mercator(Lo1, Latin);\n\n    // find out where\n    ProjectionPoint startP = proj.latLonToProj(\n        new LatLonPointImpl(La1, Lo1));\n    startx = startP.getX();\n    starty = startP.getY();\n\n    if (Double.isNaN(getDxInKm())) {\n      setDxDy(startx, starty, proj);\n    }\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"mercator\"));\n    attributes.add(new Attribute(GridCF.STANDARD_PARALLEL, Latin));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lo1));\n\n    if (GridServiceProvider.debugProj) {\n      double Lo2 = gds.getDouble(GridDefRecord.LO2);\n      if (Lo2 < Lo1) Lo2 += 360;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMercator: end at latlon= \" +\n          endLL);\n\n      ProjectionPointImpl endPP = (ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   start at proj coord \" +\n          new ProjectionPointImpl(startx, starty));\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = startx + (getNx() - 1) * getDxInKm();\n      double endy = starty + (getNy() - 1) * getDyInKm();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMercator() {\n    /**\n     * Construct a Mercator Projection.\n     * @param lon0 longitude of origin (degrees)\n     * @param par standard parallel (degrees). cylinder cuts earth at this latitude.\n     */\n    double Latin = gds.getDouble(GridDefRecord.LAD);\n    // name depends on Grib version 1 or 2\n    if (Double.isNaN(Latin))\n      Latin = gds.getDouble(GridDefRecord.LATIN);\n    double Lo1 = gds.getDouble(GridDefRecord.LO1); //gds.Lo1;\n    double La1 = gds.getDouble(GridDefRecord.LA1); //gds.La1;\n\n    // put longitude origin at first point - doesnt actually matter\n    proj = new Mercator(Lo1, Latin);\n\n    // find out where\n    ProjectionPoint startP = proj.latLonToProj(\n        new LatLonPointImpl(La1, Lo1));\n    startx = startP.getX();\n    starty = startP.getY();\n\n    if (Double.isNaN(getDxInKm())) {\n      setDxDy(startx, starty, proj);\n    }\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"mercator\"));\n    attributes.add(new Attribute(GridCF.STANDARD_PARALLEL, Latin));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lo1));\n\n    if (GridServiceProvider.debugProj) {\n      double Lo2 = gds.getDouble(GridDefRecord.LO2);\n      if (Lo2 < Lo1) Lo2 += 360;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMercator: end at latlon= \" +\n          endLL);\n\n      ProjectionPointImpl endPP = (ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   start at proj coord \" +\n          new ProjectionPointImpl(startx, starty));\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = startx + (getNx() - 1) * getDxInKm();\n      double endy = starty + (getNy() - 1) * getDyInKm();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMercator", "(", ")", "{", "/**\n     * Construct a Mercator Projection.\n     * @param lon0 longitude of origin (degrees)\n     * @param par standard parallel (degrees). cylinder cuts earth at this latitude.\n     */", "double", "Latin", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAD", ")", ";", "// name depends on Grib version 1 or 2", "if", "(", "Double", ".", "isNaN", "(", "Latin", ")", ")", "Latin", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LATIN", ")", ";", "double", "Lo1", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO1", ")", ";", "//gds.Lo1;", "double", "La1", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA1", ")", ";", "//gds.La1;", "// put longitude origin at first point - doesnt actually matter", "proj", "=", "new", "Mercator", "(", "Lo1", ",", "Latin", ")", ";", "// find out where", "ProjectionPoint", "startP", "=", "proj", ".", "latLonToProj", "(", "new", "LatLonPointImpl", "(", "La1", ",", "Lo1", ")", ")", ";", "startx", "=", "startP", ".", "getX", "(", ")", ";", "starty", "=", "startP", ".", "getY", "(", ")", ";", "if", "(", "Double", ".", "isNaN", "(", "getDxInKm", "(", ")", ")", ")", "{", "setDxDy", "(", "startx", ",", "starty", ",", "proj", ")", ";", "}", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"mercator\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "STANDARD_PARALLEL", ",", "Latin", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lo1", ")", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", ";", "if", "(", "Lo2", "<", "Lo1", ")", "Lo2", "+=", "360", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMercator: end at latlon= \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   start at proj coord \"", "+", "new", "ProjectionPointImpl", "(", "startx", ",", "starty", ")", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "startx", "+", "(", "getNx", "(", ")", "-", "1", ")", "*", "getDxInKm", "(", ")", ";", "double", "endy", "=", "starty", "+", "(", "getNy", "(", ")", "-", "1", ")", "*", "getDyInKm", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Mercator projection", "docstring_tokens": ["Make", "a", "Mercator", "projection"]}
{"code": "double Lat0 = gds.getDouble(GridDefRecord.LAP);", "comments": "sub-satellite point lat", "lines": 2, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "double Lon0 = gds.getDouble(GridDefRecord.LOP);", "comments": "sub-satellite point lon", "lines": 3, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "int x_off = gds.getInt(GridDefRecord.XP);", "comments": "sub-satellite point in grid lengths", "lines": 7, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "double dx;", "comments": "= gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "lines": 10, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);", "comments": "m", "lines": 27, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "double nr = gds.getDouble(GridDefRecord.NR) * 1e-6;", "comments": "altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "lines": 35, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "double scale_factor = (nr - 1) * major_axis / 1000;", "comments": "this sets the units of the projection x,y coords in km", "lines": 43, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "double scale_x = scale_factor;", "comments": "LOOK fake neg need scan value", "lines": 44, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/grid/GridHorizCoordSys.java", "func_name": "GridHorizCoordSys.makeMSGgeostationary", "original_string": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "language": "java", "Allcodes": "private void makeMSGgeostationary() {\n    double Lat0 = gds.getDouble(GridDefRecord.LAP);  // sub-satellite point lat\n    double Lon0 = gds.getDouble(GridDefRecord.LOP);  // sub-satellite point lon\n\n    //int nx = gds.getInt(GridDefRecord.NX);\n    int ny = gds.getInt(GridDefRecord.NY);\n    int x_off = gds.getInt(GridDefRecord.XP);  // sub-satellite point in grid lengths\n    int y_off = gds.getInt(GridDefRecord.YP);\n\n    double dx; // = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths\n    double dy = gds.getDouble(GridDefRecord.DY);\n\n    // per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,\n    // we need to \"correct for ellipsoidal earth\"\n    // (Note we should check who the originating center is\n    // \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))\n    // although AFAIK, eumetsat is only one using this projection.\n    if (dy < 2100) {\n      dx = 1207;\n      dy = 1203;\n    } else {\n      dx = 3622;\n      dy = 3610;\n    }\n\n    // have to check both names because Grib1 and Grib2 used different names\n    double major_axis = gds.getDouble(GridDefRecord.MAJOR_AXIS_EARTH);  // m\n    if (Double.isNaN(major_axis))\n      major_axis = gds.getDouble(\"major_axis_earth\");\n\n    double minor_axis = gds.getDouble(GridDefRecord.MINOR_AXIS_EARTH);  // m\n    if (Double.isNaN(minor_axis))\n      minor_axis = gds.getDouble(\"minor_axis_earth\");\n    // Nr = altitude of camera from center, in units of radius\n    double nr = gds.getDouble(GridDefRecord.NR) * 1e-6; // altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius\n\n          // CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }\n    double as = 2 * Math.asin(1.0/nr);\n    double cfac = dx / as;\n    double lfac = dy / as;\n\n    // use km, so scale by the earth radius\n    double scale_factor = (nr - 1) * major_axis / 1000; // this sets the units of the projection x,y coords in km\n    double scale_x = scale_factor; // LOOK fake neg need scan value\n    double scale_y = -scale_factor; // LOOK fake neg need scan value\n    startx = scale_factor * (1 - x_off) / cfac;\n    starty = scale_factor * (y_off - ny) / lfac;\n    incrx = scale_factor/cfac;\n    incry = scale_factor/lfac;\n\n    attributes.add(new Attribute(GridCF.GRID_MAPPING_NAME, \"MSGnavigation\"));\n    attributes.add(new Attribute(GridCF.LONGITUDE_OF_PROJECTION_ORIGIN, Lon0));\n    attributes.add(new Attribute(GridCF.LATITUDE_OF_PROJECTION_ORIGIN, Lat0));\n    //attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));\n    //attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));\n    attributes.add(new Attribute(\"height_from_earth_center\", nr * major_axis));\n    attributes.add(new Attribute(\"scale_x\", scale_x));\n    attributes.add(new Attribute(\"scale_y\", scale_y));\n\n    proj = new MSGnavigation(Lat0, Lon0, major_axis, minor_axis, nr * major_axis, scale_x, scale_y);\n\n    if (GridServiceProvider.debugProj) {\n\n      double Lo2 = gds.getDouble(GridDefRecord.LO2) + 360.0;\n      double La2 = gds.getDouble(GridDefRecord.LA2);\n      LatLonPointImpl endLL = new LatLonPointImpl(La2, Lo2);\n      System.out.println(\"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL);\n\n      ProjectionPointImpl endPP =(ProjectionPointImpl) proj.latLonToProj(endLL);\n      System.out.println(\"   end at proj coord \" + endPP);\n\n      double endx = 1 + getNx();\n      double endy = 1 + getNy();\n      System.out.println(\"   should be x=\" + endx + \" y=\" + endy);\n    }\n  }", "code_tokens": ["private", "void", "makeMSGgeostationary", "(", ")", "{", "double", "Lat0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LAP", ")", ";", "// sub-satellite point lat", "double", "Lon0", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LOP", ")", ";", "// sub-satellite point lon", "//int nx = gds.getInt(GridDefRecord.NX);", "int", "ny", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "NY", ")", ";", "int", "x_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "XP", ")", ";", "// sub-satellite point in grid lengths", "int", "y_off", "=", "gds", ".", "getInt", "(", "GridDefRecord", ".", "YP", ")", ";", "double", "dx", ";", "// = gds.getDouble(GridDefRecord.DX);  // apparent diameter of earth in units of grid lengths", "double", "dy", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "DY", ")", ";", "// per Simon Eliot 1/18/2010, there is a bug in Eumetsat grib files,", "// we need to \"correct for ellipsoidal earth\"", "// (Note we should check who the originating center is", "// \"Originating_center\" = \"EUMETSAT Operation Centre\" in the GRIB id (section 1))", "// although AFAIK, eumetsat is only one using this projection.", "if", "(", "dy", "<", "2100", ")", "{", "dx", "=", "1207", ";", "dy", "=", "1203", ";", "}", "else", "{", "dx", "=", "3622", ";", "dy", "=", "3610", ";", "}", "// have to check both names because Grib1 and Grib2 used different names", "double", "major_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MAJOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "major_axis", ")", ")", "major_axis", "=", "gds", ".", "getDouble", "(", "\"major_axis_earth\"", ")", ";", "double", "minor_axis", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "MINOR_AXIS_EARTH", ")", ";", "// m", "if", "(", "Double", ".", "isNaN", "(", "minor_axis", ")", ")", "minor_axis", "=", "gds", ".", "getDouble", "(", "\"minor_axis_earth\"", ")", ";", "// Nr = altitude of camera from center, in units of radius", "double", "nr", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "NR", ")", "*", "1e-6", ";", "// altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius", "// CFAC = 2^16 / {[2 * arcsine (10^6 / Nr)] / dx }", "double", "as", "=", "2", "*", "Math", ".", "asin", "(", "1.0", "/", "nr", ")", ";", "double", "cfac", "=", "dx", "/", "as", ";", "double", "lfac", "=", "dy", "/", "as", ";", "// use km, so scale by the earth radius", "double", "scale_factor", "=", "(", "nr", "-", "1", ")", "*", "major_axis", "/", "1000", ";", "// this sets the units of the projection x,y coords in km", "double", "scale_x", "=", "scale_factor", ";", "// LOOK fake neg need scan value", "double", "scale_y", "=", "-", "scale_factor", ";", "// LOOK fake neg need scan value", "startx", "=", "scale_factor", "*", "(", "1", "-", "x_off", ")", "/", "cfac", ";", "starty", "=", "scale_factor", "*", "(", "y_off", "-", "ny", ")", "/", "lfac", ";", "incrx", "=", "scale_factor", "/", "cfac", ";", "incry", "=", "scale_factor", "/", "lfac", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "GRID_MAPPING_NAME", ",", "\"MSGnavigation\"", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LONGITUDE_OF_PROJECTION_ORIGIN", ",", "Lon0", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "GridCF", ".", "LATITUDE_OF_PROJECTION_ORIGIN", ",", "Lat0", ")", ")", ";", "//attributes.add(new Attribute(\"semi_major_axis\", new Double(major_axis)));", "//attributes.add(new Attribute(\"semi_minor_axis\", new Double(minor_axis)));", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"height_from_earth_center\"", ",", "nr", "*", "major_axis", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_x\"", ",", "scale_x", ")", ")", ";", "attributes", ".", "add", "(", "new", "Attribute", "(", "\"scale_y\"", ",", "scale_y", ")", ")", ";", "proj", "=", "new", "MSGnavigation", "(", "Lat0", ",", "Lon0", ",", "major_axis", ",", "minor_axis", ",", "nr", "*", "major_axis", ",", "scale_x", ",", "scale_y", ")", ";", "if", "(", "GridServiceProvider", ".", "debugProj", ")", "{", "double", "Lo2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LO2", ")", "+", "360.0", ";", "double", "La2", "=", "gds", ".", "getDouble", "(", "GridDefRecord", ".", "LA2", ")", ";", "LatLonPointImpl", "endLL", "=", "new", "LatLonPointImpl", "(", "La2", ",", "Lo2", ")", ";", "System", ".", "out", ".", "println", "(", "\"GridHorizCoordSys.makeMSGgeostationary end at latlon \"", "+", "endLL", ")", ";", "ProjectionPointImpl", "endPP", "=", "(", "ProjectionPointImpl", ")", "proj", ".", "latLonToProj", "(", "endLL", ")", ";", "System", ".", "out", ".", "println", "(", "\"   end at proj coord \"", "+", "endPP", ")", ";", "double", "endx", "=", "1", "+", "getNx", "(", ")", ";", "double", "endy", "=", "1", "+", "getNy", "(", ")", ";", "System", ".", "out", ".", "println", "(", "\"   should be x=\"", "+", "endx", "+", "\" y=\"", "+", "endy", ")", ";", "}", "}"], "docstring": "Make a Eumetsat MSG \"Normalized Geostationary Projection\" projection.\nFake coordinates for now, then see if this can be generalized.\n\nfrom  FM 92 GRIB-2 doc:\n\nGrid Definition Template 3.90: Space view perspective or orthographic\nOctet Number(s) Contents\n15 Shape of the earth (see Code Table 3.2)\n16 Scale factor of radius of spherical earth\n17-20 Scaled value of radius of spherical earth\n21 Scale factor of major axis of oblate spheroid earth\n22-25 Scaled value of major axis of oblate spheroid earth\n26 Scale factor of minor axis of oblate spheroid earth\n27-30 Scaled value of minor axis of oblate spheroid earth\n31-34 Nx - number of points along X-axis (columns)\n35-38 Ny - number of points along Y-axis (rows or lines)\n39-42 Lap - latitude of sub-satellite point\n43-46 Lop - longitude of sub-satellite point\n47 Resolution and component flags (see Flag Table 3.3)\n48-51 dx - apparent diameter of Earth in grid lengths, in X-direction\n52-55 dy - apparent diameter of Earth in grid lengths, in Y-direction\n56-59 Xp - X-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n60-63 Yp - Y-coordinate of sub-satellite point (in units of 10-3 grid length expressed as an integer)\n64 Scanning mode (flags - see Flag Table 3.4)\n65-68 Orientation of the grid; i.e., the angle between the increasing Y-axis and the meridian of the sub-satellite point in the direction of increasing latitude (see Note 3)\n69-72 Nr - altitude of the camera from the Earths centre, measured in units of the Earth (equatorial) radius multiplied by a scale factor of 10 6 (see Notes 4 and 5)\n73-76 Xo - X-coordinate of origin of sector image\n77-80 Yo - Y-coordinate of origin of sector image\n\nNotes:\n(1) It is assumed that the satellite is at its nominal position, i.e., it is looking directly at its sub-satellite point.\n(2) Octets 69-72 shall be set to all ones (missing) to indicate the orthographic view (from infinite distance)\n(3) It is the angle between the increasing Y-axis and the meridian 180E if the sub-satellite point is the North Pole; or the meridian 0 if the sub-satellite point is the South Pole.\n(4) The apparent angular size of the Earth will be given by 2 * Arcsin (10^6 )/Nr).\n(5) For orthographic view from infinite distance, the value of Nr should be encoded as missing (all bits set to 1).\n(6) The horizontal and vertical angular resolutions of the sensor (Rx and Ry), needed for navigation equation, can be calculated from the following:\nRx = 2 * Arcsin (106 )/Nr)/ dx\nRy = 2 * Arcsin (106 )/Nr)/ dy\n\n=======\n\nfrom  simon.elliott@eumetsat.int\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 83.84333 E-6 = 3622.30, which encoded to the nearest integer is 3622.\nThis is correctly encoded in our products.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dx = 2 * arcsin(10e6/Nr) / 251.52999 E-6 = 1207.43, which encoded to the nearest integer is 1207.\nThis is correctly encoded in our products.\n\nDue to the elliptical shape of the earth, the calculation is a bit different in the y direction (Nr is in multiples of\nthe equatorial radius, but the tangent point is much closer to the polar radius from the earth's centre.\nApproximating that the tangent point is actually at the polar radius from the earth's centre:\nThe sine of the angle subtended by the Earths centre and the tangent point on the equator as seen from the spacecraft\n= Rp / (( Nr * Re) / 10^6) = (Rp * 10^6) / (Re * Nr)\n\nThe angle subtended by the Earth equator as seen by the spacecraft is, by symmetry twice the inverse sine above,\n= 2 * arcsine ((Rp * 10^6) / (Re * Nr))\n\nFor products on a single pixel resolution grid, the scan angle is 83.84333 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 83.84333 E-6 = 3610.06, which encoded to the nearest integer is 3610.\nThis is currently encoded in our products as 3568.\n\nFor products on a 3x3 pixel resolution grid, the scan angle is 3 * 83.84333 E-6 rad = 251.52999 E-6 rad.\nSo dy = 2 * arcsine ((Rp * 10^6) / (Re * Nr)) / 251.52999 E-6 = 1203.35, which encoded to the nearest integer is 1203.\nThis is currently encoded in our products as 1189.\n\nAs you can see the dx and dy values we are using will lead to an error of around 1% in the y direction.\nI will ensure that the values are corrected to those explained here (3610 and 1203) as soon as possible.", "docstring_tokens": ["Make", "a", "Eumetsat", "MSG", "Normalized", "Geostationary", "Projection", "projection", ".", "Fake", "coordinates", "for", "now", "then", "see", "if", "this", "can", "be", "generalized", "."]}
{"code": "continue;", "comments": "skip it", "lines": 28, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/conv/AWIPSConvention.java", "func_name": "AWIPSConvention.breakupLevels", "original_string": "private List<Dimension> breakupLevels(NetcdfDataset ds, Variable levelVar) throws IOException {\r\n    if (debugBreakup) parseInfo.format(\"breakupLevels = %s%n\", levelVar.getShortName());\r\n    List<Dimension> dimList = new ArrayList<>();\r\n\r\n    ArrayChar levelVarData;\r\n    try {\r\n      levelVarData = (ArrayChar) levelVar.read();\r\n    } catch (IOException ioe) {\r\n      return dimList;\r\n    }\r\n\r\n    List<String> values = null;\r\n    String currentUnits = null;\r\n    ArrayChar.StringIterator iter = levelVarData.getStringIterator();\r\n    while (iter.hasNext()) {\r\n      String s = iter.next();\r\n      if (debugBreakup) parseInfo.format(\"   %s%n\", s);\r\n      StringTokenizer stoke = new StringTokenizer(s);\r\n\r\n/* problem with blank string:\r\n   char pvvLevels(levels_35=35, charsPerLevel=10);\r\n\"MB 1000   \", \"MB 975    \", \"MB 950    \", \"MB 925    \", \"MB 900    \", \"MB 875    \", \"MB 850    \", \"MB 825    \", \"MB 800    \", \"MB 775    \", \"MB 750    \",\r\n\"MB 725    \", \"MB 700    \", \"MB 675    \", \"MB 650    \", \"MB 625    \", \"MB 600    \", \"MB 575    \", \"MB 550    \", \"MB 525    \", \"MB 500    \", \"MB 450    \",\r\n\"MB 400    \", \"MB 350    \", \"MB 300    \", \"MB 250    \", \"MB 200    \", \"MB 150    \", \"MB 100    \", \"BL 0 30   \", \"BL 60 90  \", \"BL 90 120 \", \"BL 120 150\",\r\n\"BL 150 180\", \"\"\r\n*/\r\n      if (!stoke.hasMoreTokens())\r\n        continue; // skip it\r\n\r\n      // first token is the unit\r\n      String units = stoke.nextToken().trim();\r\n      if (!units.equals(currentUnits)) {\r\n        if (values != null)\r\n          dimList.add(makeZCoordAxis(ds, values, currentUnits));\r\n        values = new ArrayList<>();\r\n        currentUnits = units;\r\n      }\r\n\r\n      // next token is the value\r\n      if (stoke.hasMoreTokens())\r\n        values.add(stoke.nextToken());\r\n      else\r\n        values.add(\"0\");\r\n    }\r\n    if (values != null)\r\n      dimList.add(makeZCoordAxis(ds, values, currentUnits));\r\n\r\n    if (debugBreakup) parseInfo.format(\"  done breakup%n\");\r\n\r\n    return dimList;\r\n  }", "language": "java", "Allcodes": "private List<Dimension> breakupLevels(NetcdfDataset ds, Variable levelVar) throws IOException {\r\n    if (debugBreakup) parseInfo.format(\"breakupLevels = %s%n\", levelVar.getShortName());\r\n    List<Dimension> dimList = new ArrayList<>();\r\n\r\n    ArrayChar levelVarData;\r\n    try {\r\n      levelVarData = (ArrayChar) levelVar.read();\r\n    } catch (IOException ioe) {\r\n      return dimList;\r\n    }\r\n\r\n    List<String> values = null;\r\n    String currentUnits = null;\r\n    ArrayChar.StringIterator iter = levelVarData.getStringIterator();\r\n    while (iter.hasNext()) {\r\n      String s = iter.next();\r\n      if (debugBreakup) parseInfo.format(\"   %s%n\", s);\r\n      StringTokenizer stoke = new StringTokenizer(s);\r\n\r\n/* problem with blank string:\r\n   char pvvLevels(levels_35=35, charsPerLevel=10);\r\n\"MB 1000   \", \"MB 975    \", \"MB 950    \", \"MB 925    \", \"MB 900    \", \"MB 875    \", \"MB 850    \", \"MB 825    \", \"MB 800    \", \"MB 775    \", \"MB 750    \",\r\n\"MB 725    \", \"MB 700    \", \"MB 675    \", \"MB 650    \", \"MB 625    \", \"MB 600    \", \"MB 575    \", \"MB 550    \", \"MB 525    \", \"MB 500    \", \"MB 450    \",\r\n\"MB 400    \", \"MB 350    \", \"MB 300    \", \"MB 250    \", \"MB 200    \", \"MB 150    \", \"MB 100    \", \"BL 0 30   \", \"BL 60 90  \", \"BL 90 120 \", \"BL 120 150\",\r\n\"BL 150 180\", \"\"\r\n*/\r\n      if (!stoke.hasMoreTokens())\r\n        continue; // skip it\r\n\r\n      // first token is the unit\r\n      String units = stoke.nextToken().trim();\r\n      if (!units.equals(currentUnits)) {\r\n        if (values != null)\r\n          dimList.add(makeZCoordAxis(ds, values, currentUnits));\r\n        values = new ArrayList<>();\r\n        currentUnits = units;\r\n      }\r\n\r\n      // next token is the value\r\n      if (stoke.hasMoreTokens())\r\n        values.add(stoke.nextToken());\r\n      else\r\n        values.add(\"0\");\r\n    }\r\n    if (values != null)\r\n      dimList.add(makeZCoordAxis(ds, values, currentUnits));\r\n\r\n    if (debugBreakup) parseInfo.format(\"  done breakup%n\");\r\n\r\n    return dimList;\r\n  }", "code_tokens": ["private", "List", "<", "Dimension", ">", "breakupLevels", "(", "NetcdfDataset", "ds", ",", "Variable", "levelVar", ")", "throws", "IOException", "{", "if", "(", "debugBreakup", ")", "parseInfo", ".", "format", "(", "\"breakupLevels = %s%n\"", ",", "levelVar", ".", "getShortName", "(", ")", ")", ";", "List", "<", "Dimension", ">", "dimList", "=", "new", "ArrayList", "<>", "(", ")", ";", "ArrayChar", "levelVarData", ";", "try", "{", "levelVarData", "=", "(", "ArrayChar", ")", "levelVar", ".", "read", "(", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "return", "dimList", ";", "}", "List", "<", "String", ">", "values", "=", "null", ";", "String", "currentUnits", "=", "null", ";", "ArrayChar", ".", "StringIterator", "iter", "=", "levelVarData", ".", "getStringIterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "String", "s", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "debugBreakup", ")", "parseInfo", ".", "format", "(", "\"   %s%n\"", ",", "s", ")", ";", "StringTokenizer", "stoke", "=", "new", "StringTokenizer", "(", "s", ")", ";", "/* problem with blank string:\r\n   char pvvLevels(levels_35=35, charsPerLevel=10);\r\n\"MB 1000   \", \"MB 975    \", \"MB 950    \", \"MB 925    \", \"MB 900    \", \"MB 875    \", \"MB 850    \", \"MB 825    \", \"MB 800    \", \"MB 775    \", \"MB 750    \",\r\n\"MB 725    \", \"MB 700    \", \"MB 675    \", \"MB 650    \", \"MB 625    \", \"MB 600    \", \"MB 575    \", \"MB 550    \", \"MB 525    \", \"MB 500    \", \"MB 450    \",\r\n\"MB 400    \", \"MB 350    \", \"MB 300    \", \"MB 250    \", \"MB 200    \", \"MB 150    \", \"MB 100    \", \"BL 0 30   \", \"BL 60 90  \", \"BL 90 120 \", \"BL 120 150\",\r\n\"BL 150 180\", \"\"\r\n*/", "if", "(", "!", "stoke", ".", "hasMoreTokens", "(", ")", ")", "continue", ";", "// skip it\r", "// first token is the unit\r", "String", "units", "=", "stoke", ".", "nextToken", "(", ")", ".", "trim", "(", ")", ";", "if", "(", "!", "units", ".", "equals", "(", "currentUnits", ")", ")", "{", "if", "(", "values", "!=", "null", ")", "dimList", ".", "add", "(", "makeZCoordAxis", "(", "ds", ",", "values", ",", "currentUnits", ")", ")", ";", "values", "=", "new", "ArrayList", "<>", "(", ")", ";", "currentUnits", "=", "units", ";", "}", "// next token is the value\r", "if", "(", "stoke", ".", "hasMoreTokens", "(", ")", ")", "values", ".", "add", "(", "stoke", ".", "nextToken", "(", ")", ")", ";", "else", "values", ".", "add", "(", "\"0\"", ")", ";", "}", "if", "(", "values", "!=", "null", ")", "dimList", ".", "add", "(", "makeZCoordAxis", "(", "ds", ",", "values", ",", "currentUnits", ")", ")", ";", "if", "(", "debugBreakup", ")", "parseInfo", ".", "format", "(", "\"  done breakup%n\"", ")", ";", "return", "dimList", ";", "}"], "docstring": "return the list of Dimensions that were created", "docstring_tokens": ["return", "the", "list", "of", "Dimensions", "that", "were", "created"]}
{"code": "refValue = refArray.getDouble(refArray.getIndex());", "comments": "get the first value", "lines": 7, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/conv/AWIPSConvention.java", "func_name": "AWIPSConvention.makeTimeCoordAxisFromReference", "original_string": "private CoordinateAxis makeTimeCoordAxisFromReference(NetcdfDataset ds, Variable timeVar, Array vals) {\r\n    Variable refVar = ds.findVariable(\"reftime\");\r\n    if (refVar == null) return null;\r\n    double refValue;\r\n    try {\r\n      Array refArray = refVar.read();\r\n      refValue = refArray.getDouble(refArray.getIndex()); // get the first value\r\n    } catch (IOException ioe) {\r\n      return null;\r\n    }\r\n    if (refValue == N3iosp.NC_FILL_DOUBLE)\r\n      return null;\r\n\r\n    // construct the values array - make it a double to be safe\r\n    Array dvals = Array.factory(DataType.DOUBLE, vals.getShape());\r\n    IndexIterator diter = dvals.getIndexIterator();\r\n    IndexIterator iiter = vals.getIndexIterator();\r\n    while (iiter.hasNext())\r\n      diter.setDoubleNext(iiter.getDoubleNext() + refValue); // add reftime to each of the values\r\n\r\n    String units = ds.findAttValueIgnoreCase(refVar, CDM.UNITS, \"seconds since 1970-1-1 00:00:00\");\r\n    units = normalize(units);\r\n    String desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\";\r\n    CoordinateAxis1D timeCoord = new CoordinateAxis1D(ds, null, \"timeCoord\", DataType.DOUBLE, \"record\", units, desc);\r\n\r\n    timeCoord.setCachedData(dvals, true);\r\n\r\n    parseInfo.format(\"Created Time Coordinate Axis From Reference = \");\r\n    timeCoord.getNameAndDimensions(parseInfo, true, false);\r\n    parseInfo.format(\"%n\");\r\n\r\n    return timeCoord;\r\n  }", "language": "java", "Allcodes": "private CoordinateAxis makeTimeCoordAxisFromReference(NetcdfDataset ds, Variable timeVar, Array vals) {\r\n    Variable refVar = ds.findVariable(\"reftime\");\r\n    if (refVar == null) return null;\r\n    double refValue;\r\n    try {\r\n      Array refArray = refVar.read();\r\n      refValue = refArray.getDouble(refArray.getIndex()); // get the first value\r\n    } catch (IOException ioe) {\r\n      return null;\r\n    }\r\n    if (refValue == N3iosp.NC_FILL_DOUBLE)\r\n      return null;\r\n\r\n    // construct the values array - make it a double to be safe\r\n    Array dvals = Array.factory(DataType.DOUBLE, vals.getShape());\r\n    IndexIterator diter = dvals.getIndexIterator();\r\n    IndexIterator iiter = vals.getIndexIterator();\r\n    while (iiter.hasNext())\r\n      diter.setDoubleNext(iiter.getDoubleNext() + refValue); // add reftime to each of the values\r\n\r\n    String units = ds.findAttValueIgnoreCase(refVar, CDM.UNITS, \"seconds since 1970-1-1 00:00:00\");\r\n    units = normalize(units);\r\n    String desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\";\r\n    CoordinateAxis1D timeCoord = new CoordinateAxis1D(ds, null, \"timeCoord\", DataType.DOUBLE, \"record\", units, desc);\r\n\r\n    timeCoord.setCachedData(dvals, true);\r\n\r\n    parseInfo.format(\"Created Time Coordinate Axis From Reference = \");\r\n    timeCoord.getNameAndDimensions(parseInfo, true, false);\r\n    parseInfo.format(\"%n\");\r\n\r\n    return timeCoord;\r\n  }", "code_tokens": ["private", "CoordinateAxis", "makeTimeCoordAxisFromReference", "(", "NetcdfDataset", "ds", ",", "Variable", "timeVar", ",", "Array", "vals", ")", "{", "Variable", "refVar", "=", "ds", ".", "findVariable", "(", "\"reftime\"", ")", ";", "if", "(", "refVar", "==", "null", ")", "return", "null", ";", "double", "refValue", ";", "try", "{", "Array", "refArray", "=", "refVar", ".", "read", "(", ")", ";", "refValue", "=", "refArray", ".", "getDouble", "(", "refArray", ".", "getIndex", "(", ")", ")", ";", "// get the first value\r", "}", "catch", "(", "IOException", "ioe", ")", "{", "return", "null", ";", "}", "if", "(", "refValue", "==", "N3iosp", ".", "NC_FILL_DOUBLE", ")", "return", "null", ";", "// construct the values array - make it a double to be safe\r", "Array", "dvals", "=", "Array", ".", "factory", "(", "DataType", ".", "DOUBLE", ",", "vals", ".", "getShape", "(", ")", ")", ";", "IndexIterator", "diter", "=", "dvals", ".", "getIndexIterator", "(", ")", ";", "IndexIterator", "iiter", "=", "vals", ".", "getIndexIterator", "(", ")", ";", "while", "(", "iiter", ".", "hasNext", "(", ")", ")", "diter", ".", "setDoubleNext", "(", "iiter", ".", "getDoubleNext", "(", ")", "+", "refValue", ")", ";", "// add reftime to each of the values\r", "String", "units", "=", "ds", ".", "findAttValueIgnoreCase", "(", "refVar", ",", "CDM", ".", "UNITS", ",", "\"seconds since 1970-1-1 00:00:00\"", ")", ";", "units", "=", "normalize", "(", "units", ")", ";", "String", "desc", "=", "\"synthesized time coordinate from reftime, valtimeMINUSreftime\"", ";", "CoordinateAxis1D", "timeCoord", "=", "new", "CoordinateAxis1D", "(", "ds", ",", "null", ",", "\"timeCoord\"", ",", "DataType", ".", "DOUBLE", ",", "\"record\"", ",", "units", ",", "desc", ")", ";", "timeCoord", ".", "setCachedData", "(", "dvals", ",", "true", ")", ";", "parseInfo", ".", "format", "(", "\"Created Time Coordinate Axis From Reference = \"", ")", ";", "timeCoord", ".", "getNameAndDimensions", "(", "parseInfo", ",", "true", ",", "false", ")", ";", "parseInfo", ".", "format", "(", "\"%n\"", ")", ";", "return", "timeCoord", ";", "}"], "docstring": "construct time coordinate from reftime variable", "docstring_tokens": ["construct", "time", "coordinate", "from", "reftime", "variable"]}
{"code": "diter.setDoubleNext(iiter.getDoubleNext() + refValue);", "comments": "add reftime to each of the values", "lines": 19, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/conv/AWIPSConvention.java", "func_name": "AWIPSConvention.makeTimeCoordAxisFromReference", "original_string": "private CoordinateAxis makeTimeCoordAxisFromReference(NetcdfDataset ds, Variable timeVar, Array vals) {\r\n    Variable refVar = ds.findVariable(\"reftime\");\r\n    if (refVar == null) return null;\r\n    double refValue;\r\n    try {\r\n      Array refArray = refVar.read();\r\n      refValue = refArray.getDouble(refArray.getIndex()); // get the first value\r\n    } catch (IOException ioe) {\r\n      return null;\r\n    }\r\n    if (refValue == N3iosp.NC_FILL_DOUBLE)\r\n      return null;\r\n\r\n    // construct the values array - make it a double to be safe\r\n    Array dvals = Array.factory(DataType.DOUBLE, vals.getShape());\r\n    IndexIterator diter = dvals.getIndexIterator();\r\n    IndexIterator iiter = vals.getIndexIterator();\r\n    while (iiter.hasNext())\r\n      diter.setDoubleNext(iiter.getDoubleNext() + refValue); // add reftime to each of the values\r\n\r\n    String units = ds.findAttValueIgnoreCase(refVar, CDM.UNITS, \"seconds since 1970-1-1 00:00:00\");\r\n    units = normalize(units);\r\n    String desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\";\r\n    CoordinateAxis1D timeCoord = new CoordinateAxis1D(ds, null, \"timeCoord\", DataType.DOUBLE, \"record\", units, desc);\r\n\r\n    timeCoord.setCachedData(dvals, true);\r\n\r\n    parseInfo.format(\"Created Time Coordinate Axis From Reference = \");\r\n    timeCoord.getNameAndDimensions(parseInfo, true, false);\r\n    parseInfo.format(\"%n\");\r\n\r\n    return timeCoord;\r\n  }", "language": "java", "Allcodes": "private CoordinateAxis makeTimeCoordAxisFromReference(NetcdfDataset ds, Variable timeVar, Array vals) {\r\n    Variable refVar = ds.findVariable(\"reftime\");\r\n    if (refVar == null) return null;\r\n    double refValue;\r\n    try {\r\n      Array refArray = refVar.read();\r\n      refValue = refArray.getDouble(refArray.getIndex()); // get the first value\r\n    } catch (IOException ioe) {\r\n      return null;\r\n    }\r\n    if (refValue == N3iosp.NC_FILL_DOUBLE)\r\n      return null;\r\n\r\n    // construct the values array - make it a double to be safe\r\n    Array dvals = Array.factory(DataType.DOUBLE, vals.getShape());\r\n    IndexIterator diter = dvals.getIndexIterator();\r\n    IndexIterator iiter = vals.getIndexIterator();\r\n    while (iiter.hasNext())\r\n      diter.setDoubleNext(iiter.getDoubleNext() + refValue); // add reftime to each of the values\r\n\r\n    String units = ds.findAttValueIgnoreCase(refVar, CDM.UNITS, \"seconds since 1970-1-1 00:00:00\");\r\n    units = normalize(units);\r\n    String desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\";\r\n    CoordinateAxis1D timeCoord = new CoordinateAxis1D(ds, null, \"timeCoord\", DataType.DOUBLE, \"record\", units, desc);\r\n\r\n    timeCoord.setCachedData(dvals, true);\r\n\r\n    parseInfo.format(\"Created Time Coordinate Axis From Reference = \");\r\n    timeCoord.getNameAndDimensions(parseInfo, true, false);\r\n    parseInfo.format(\"%n\");\r\n\r\n    return timeCoord;\r\n  }", "code_tokens": ["private", "CoordinateAxis", "makeTimeCoordAxisFromReference", "(", "NetcdfDataset", "ds", ",", "Variable", "timeVar", ",", "Array", "vals", ")", "{", "Variable", "refVar", "=", "ds", ".", "findVariable", "(", "\"reftime\"", ")", ";", "if", "(", "refVar", "==", "null", ")", "return", "null", ";", "double", "refValue", ";", "try", "{", "Array", "refArray", "=", "refVar", ".", "read", "(", ")", ";", "refValue", "=", "refArray", ".", "getDouble", "(", "refArray", ".", "getIndex", "(", ")", ")", ";", "// get the first value\r", "}", "catch", "(", "IOException", "ioe", ")", "{", "return", "null", ";", "}", "if", "(", "refValue", "==", "N3iosp", ".", "NC_FILL_DOUBLE", ")", "return", "null", ";", "// construct the values array - make it a double to be safe\r", "Array", "dvals", "=", "Array", ".", "factory", "(", "DataType", ".", "DOUBLE", ",", "vals", ".", "getShape", "(", ")", ")", ";", "IndexIterator", "diter", "=", "dvals", ".", "getIndexIterator", "(", ")", ";", "IndexIterator", "iiter", "=", "vals", ".", "getIndexIterator", "(", ")", ";", "while", "(", "iiter", ".", "hasNext", "(", ")", ")", "diter", ".", "setDoubleNext", "(", "iiter", ".", "getDoubleNext", "(", ")", "+", "refValue", ")", ";", "// add reftime to each of the values\r", "String", "units", "=", "ds", ".", "findAttValueIgnoreCase", "(", "refVar", ",", "CDM", ".", "UNITS", ",", "\"seconds since 1970-1-1 00:00:00\"", ")", ";", "units", "=", "normalize", "(", "units", ")", ";", "String", "desc", "=", "\"synthesized time coordinate from reftime, valtimeMINUSreftime\"", ";", "CoordinateAxis1D", "timeCoord", "=", "new", "CoordinateAxis1D", "(", "ds", ",", "null", ",", "\"timeCoord\"", ",", "DataType", ".", "DOUBLE", ",", "\"record\"", ",", "units", ",", "desc", ")", ";", "timeCoord", ".", "setCachedData", "(", "dvals", ",", "true", ")", ";", "parseInfo", ".", "format", "(", "\"Created Time Coordinate Axis From Reference = \"", ")", ";", "timeCoord", ".", "getNameAndDimensions", "(", "parseInfo", ",", "true", ",", "false", ")", ";", "parseInfo", ".", "format", "(", "\"%n\"", ")", ";", "return", "timeCoord", ";", "}"], "docstring": "construct time coordinate from reftime variable", "docstring_tokens": ["construct", "time", "coordinate", "from", "reftime", "variable"]}
{"code": "if (Float.isNaN(value)) return value;", "comments": "??", "lines": 2, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/writer/GribToNetcdfWriter.java", "func_name": "GribToNetcdfWriter.bitShave", "original_string": "public static float bitShave(float value, int bitMask) {\n    if (Float.isNaN(value)) return value;   // ??\n\n    int bits = Float.floatToRawIntBits(value);\n    int shave = bits & bitMask;\n    return Float.intBitsToFloat(shave);\n  }", "language": "java", "Allcodes": "public static float bitShave(float value, int bitMask) {\n    if (Float.isNaN(value)) return value;   // ??\n\n    int bits = Float.floatToRawIntBits(value);\n    int shave = bits & bitMask;\n    return Float.intBitsToFloat(shave);\n  }", "code_tokens": ["public", "static", "float", "bitShave", "(", "float", "value", ",", "int", "bitMask", ")", "{", "if", "(", "Float", ".", "isNaN", "(", "value", ")", ")", "return", "value", ";", "// ??", "int", "bits", "=", "Float", ".", "floatToRawIntBits", "(", "value", ")", ";", "int", "shave", "=", "bits", "&", "bitMask", ";", "return", "Float", ".", "intBitsToFloat", "(", "shave", ")", ";", "}"], "docstring": "Shave n bits off the float\n@param value    original floating point\n@param bitMask  bitMask from getBitMask()\n@return modified float", "docstring_tokens": ["Shave", "n", "bits", "off", "the", "float"]}
{"code": "if (mfile.getPath().endsWith(\".xml\")) return;", "comments": "eliminate latest.xml  LOOK kludge-o-rama", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/inventory/CollectionManagerCatalog.java", "func_name": "CollectionManagerCatalog.getDataset", "original_string": "@Override\n  public void getDataset(Dataset ds, Object context) {\n    if (ds.hasAccess()) {\n      DataFactory tdataFactory = new DataFactory();\n      Access access = tdataFactory.chooseDatasetAccess(ds.getAccess());\n      if (access == null) throw new IllegalStateException();\n      MFileRemote mfile = new MFileRemote(access);\n      if (mfile.getPath().endsWith(\".xml\")) return; // eliminate latest.xml  LOOK kludge-o-rama\n      mfiles.add(mfile);\n      if (debug) System.out.format(\"add %s %n\", mfile.getPath());\n    }\n  }", "language": "java", "Allcodes": "@Override\n  public void getDataset(Dataset ds, Object context) {\n    if (ds.hasAccess()) {\n      DataFactory tdataFactory = new DataFactory();\n      Access access = tdataFactory.chooseDatasetAccess(ds.getAccess());\n      if (access == null) throw new IllegalStateException();\n      MFileRemote mfile = new MFileRemote(access);\n      if (mfile.getPath().endsWith(\".xml\")) return; // eliminate latest.xml  LOOK kludge-o-rama\n      mfiles.add(mfile);\n      if (debug) System.out.format(\"add %s %n\", mfile.getPath());\n    }\n  }", "code_tokens": ["@", "Override", "public", "void", "getDataset", "(", "Dataset", "ds", ",", "Object", "context", ")", "{", "if", "(", "ds", ".", "hasAccess", "(", ")", ")", "{", "DataFactory", "tdataFactory", "=", "new", "DataFactory", "(", ")", ";", "Access", "access", "=", "tdataFactory", ".", "chooseDatasetAccess", "(", "ds", ".", "getAccess", "(", ")", ")", ";", "if", "(", "access", "==", "null", ")", "throw", "new", "IllegalStateException", "(", ")", ";", "MFileRemote", "mfile", "=", "new", "MFileRemote", "(", "access", ")", ";", "if", "(", "mfile", ".", "getPath", "(", ")", ".", "endsWith", "(", "\".xml\"", ")", ")", "return", ";", "// eliminate latest.xml  LOOK kludge-o-rama", "mfiles", ".", "add", "(", "mfile", ")", ";", "if", "(", "debug", ")", "System", ".", "out", ".", "format", "(", "\"add %s %n\"", ",", "mfile", ".", "getPath", "(", ")", ")", ";", "}", "}"], "docstring": "CatalogCrawler.Listener", "docstring_tokens": ["CatalogCrawler", ".", "Listener"]}
{"code": "List<String> ss = breakupConventionNames(convs);", "comments": "may be a list", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/CoordSysBuilder.java", "func_name": "CoordSysBuilder.buildConventionAttribute", "original_string": "static public String buildConventionAttribute(String mainConv, String... convAtts) {\r\n    List<String> result = new ArrayList<>();\r\n    result.add(mainConv);\r\n    for (String convs : convAtts) {\r\n      if (convs == null) continue;\r\n      List<String> ss = breakupConventionNames(convs); // may be a list\r\n      for (String s : ss) {\r\n        if (matchConvention(s) == null)  // only add extra ones, not ones that compete with mainConv\r\n          result.add(s);\r\n      }\r\n    }\r\n\r\n    // now form comma separated result\r\n    boolean start = true;\r\n    Formatter f = new Formatter();\r\n    for (String s : result) {\r\n      if (start)\r\n        f.format(\"%s\", s);\r\n      else\r\n        f.format(\", %s\", s);\r\n      start = false;\r\n    }\r\n    return f.toString();\r\n  }", "language": "java", "Allcodes": "static public String buildConventionAttribute(String mainConv, String... convAtts) {\r\n    List<String> result = new ArrayList<>();\r\n    result.add(mainConv);\r\n    for (String convs : convAtts) {\r\n      if (convs == null) continue;\r\n      List<String> ss = breakupConventionNames(convs); // may be a list\r\n      for (String s : ss) {\r\n        if (matchConvention(s) == null)  // only add extra ones, not ones that compete with mainConv\r\n          result.add(s);\r\n      }\r\n    }\r\n\r\n    // now form comma separated result\r\n    boolean start = true;\r\n    Formatter f = new Formatter();\r\n    for (String s : result) {\r\n      if (start)\r\n        f.format(\"%s\", s);\r\n      else\r\n        f.format(\", %s\", s);\r\n      start = false;\r\n    }\r\n    return f.toString();\r\n  }", "code_tokens": ["static", "public", "String", "buildConventionAttribute", "(", "String", "mainConv", ",", "String", "...", "convAtts", ")", "{", "List", "<", "String", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "result", ".", "add", "(", "mainConv", ")", ";", "for", "(", "String", "convs", ":", "convAtts", ")", "{", "if", "(", "convs", "==", "null", ")", "continue", ";", "List", "<", "String", ">", "ss", "=", "breakupConventionNames", "(", "convs", ")", ";", "// may be a list\r", "for", "(", "String", "s", ":", "ss", ")", "{", "if", "(", "matchConvention", "(", "s", ")", "==", "null", ")", "// only add extra ones, not ones that compete with mainConv\r", "result", ".", "add", "(", "s", ")", ";", "}", "}", "// now form comma separated result\r", "boolean", "start", "=", "true", ";", "Formatter", "f", "=", "new", "Formatter", "(", ")", ";", "for", "(", "String", "s", ":", "result", ")", "{", "if", "(", "start", ")", "f", ".", "format", "(", "\"%s\"", ",", "s", ")", ";", "else", "f", ".", "format", "(", "\", %s\"", ",", "s", ")", ";", "start", "=", "false", ";", "}", "return", "f", ".", "toString", "(", ")", ";", "}"], "docstring": "Build a list of Conventions\n\n@param mainConv this is the main convention\n@param convAtts list of others, onbly use \"extra\" Conventions\n@return comma separated list of Conventions", "docstring_tokens": ["Build", "a", "list", "of", "Conventions"]}
{"code": "datasets.clear();", "comments": "throw away the rest", "lines": 8, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvCatalogImpl.java", "func_name": "InvCatalogImpl.subset", "original_string": "public void subset(InvDataset ds) {\n    InvDatasetImpl dataset = (InvDatasetImpl) ds;\n\n    // Make all inherited metadata local.\n    dataset.transferMetadata(dataset, true);\n\n    topDataset = dataset;\n    datasets.clear(); // throw away the rest\n    datasets.add(topDataset);\n\n    // parent lookups need to be local\n    //InvService service = dataset.getServiceDefault();\n    //if (service != null) LOOK\n    //  dataset.serviceName = service.getName();\n    dataset.dataType = dataset.getDataType();\n\n    // all properties need to be local\n    // LOOK dataset.setPropertiesLocal( new ArrayList(dataset.getProperties()));\n\n    // next part requires this before it\n    dataset.setCatalog(this);\n    dataset.parent = null;\n\n    // any referenced services need to be local\n    List<InvService> services = new ArrayList<InvService>(dataset.getServicesLocal());\n    findServices(services, dataset);\n    dataset.setServicesLocal(services);\n\n    finish();\n  }", "language": "java", "Allcodes": "public void subset(InvDataset ds) {\n    InvDatasetImpl dataset = (InvDatasetImpl) ds;\n\n    // Make all inherited metadata local.\n    dataset.transferMetadata(dataset, true);\n\n    topDataset = dataset;\n    datasets.clear(); // throw away the rest\n    datasets.add(topDataset);\n\n    // parent lookups need to be local\n    //InvService service = dataset.getServiceDefault();\n    //if (service != null) LOOK\n    //  dataset.serviceName = service.getName();\n    dataset.dataType = dataset.getDataType();\n\n    // all properties need to be local\n    // LOOK dataset.setPropertiesLocal( new ArrayList(dataset.getProperties()));\n\n    // next part requires this before it\n    dataset.setCatalog(this);\n    dataset.parent = null;\n\n    // any referenced services need to be local\n    List<InvService> services = new ArrayList<InvService>(dataset.getServicesLocal());\n    findServices(services, dataset);\n    dataset.setServicesLocal(services);\n\n    finish();\n  }", "code_tokens": ["public", "void", "subset", "(", "InvDataset", "ds", ")", "{", "InvDatasetImpl", "dataset", "=", "(", "InvDatasetImpl", ")", "ds", ";", "// Make all inherited metadata local.", "dataset", ".", "transferMetadata", "(", "dataset", ",", "true", ")", ";", "topDataset", "=", "dataset", ";", "datasets", ".", "clear", "(", ")", ";", "// throw away the rest", "datasets", ".", "add", "(", "topDataset", ")", ";", "// parent lookups need to be local", "//InvService service = dataset.getServiceDefault();", "//if (service != null) LOOK", "//  dataset.serviceName = service.getName();", "dataset", ".", "dataType", "=", "dataset", ".", "getDataType", "(", ")", ";", "// all properties need to be local", "// LOOK dataset.setPropertiesLocal( new ArrayList(dataset.getProperties()));", "// next part requires this before it", "dataset", ".", "setCatalog", "(", "this", ")", ";", "dataset", ".", "parent", "=", "null", ";", "// any referenced services need to be local", "List", "<", "InvService", ">", "services", "=", "new", "ArrayList", "<", "InvService", ">", "(", "dataset", ".", "getServicesLocal", "(", ")", ")", ";", "findServices", "(", "services", ",", "dataset", ")", ";", "dataset", ".", "setServicesLocal", "(", "services", ")", ";", "finish", "(", ")", ";", "}"], "docstring": "Munge this catalog so the given dataset is the top catalog.\n\n@param ds make this top; must be existing dataset in this catalog.\n\n@deprecated in favor of thredds.catalog.util.DeepCopyUtils.subsetCatalogOnDataset", "docstring_tokens": ["Munge", "this", "catalog", "so", "the", "given", "dataset", "is", "the", "top", "catalog", "."]}
{"code": "fac = 30.0 * 24.0;", "comments": "nominal hours in a month", "lines": 26, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib2/table/Grib2Tables.java", "func_name": "Grib2Tables.getForecastTimeIntervalSizeInHours", "original_string": "public double getForecastTimeIntervalSizeInHours(Grib2Pds pds) {\r\n    Grib2Pds.PdsInterval pdsIntv = (Grib2Pds.PdsInterval) pds;\r\n    int timeUnitOrg = pds.getTimeUnit();\r\n\r\n    // calculate total \"range\" in units of timeUnit\r\n    int range = 0;\r\n    for (Grib2Pds.TimeInterval ti : pdsIntv.getTimeIntervals()) {\r\n      if (ti.timeRangeUnit == 255)\r\n        continue;\r\n      if ((ti.timeRangeUnit != timeUnitOrg) || (ti.timeIncrementUnit != timeUnitOrg && ti.timeIncrementUnit != 255 && ti.timeIncrement != 0)) {\r\n        logger.warn(\"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti.timeIncrementUnit);\r\n        throw new RuntimeException(\"TimeInterval(2) has different units\");\r\n      }\r\n\r\n      range += ti.timeRangeLength;\r\n      if (ti.timeIncrementUnit != 255) range += ti.timeIncrement;\r\n    }\r\n\r\n    // now convert that range to units of the requested period.\r\n    CalendarPeriod timeUnitPeriod = Grib2Utils.getCalendarPeriod(convertTimeUnit(timeUnitOrg));\r\n    if (timeUnitPeriod == null) return GribNumbers.UNDEFINEDD;\r\n    if (timeUnitPeriod.equals(CalendarPeriod.Hour)) return range;\r\n\r\n    double fac;\r\n    if (timeUnitPeriod.getField() == CalendarPeriod.Field.Month) {\r\n      fac = 30.0 * 24.0;  // nominal hours in a month\r\n    } else if (timeUnitPeriod.getField() == CalendarPeriod.Field.Year) {\r\n      fac = 365.0 * 24.0; // nominal hours in a year\r\n    } else {\r\n      fac = CalendarPeriod.Hour.getConvertFactor(timeUnitPeriod);\r\n    }\r\n    return fac * range;\r\n  }", "language": "java", "Allcodes": "public double getForecastTimeIntervalSizeInHours(Grib2Pds pds) {\r\n    Grib2Pds.PdsInterval pdsIntv = (Grib2Pds.PdsInterval) pds;\r\n    int timeUnitOrg = pds.getTimeUnit();\r\n\r\n    // calculate total \"range\" in units of timeUnit\r\n    int range = 0;\r\n    for (Grib2Pds.TimeInterval ti : pdsIntv.getTimeIntervals()) {\r\n      if (ti.timeRangeUnit == 255)\r\n        continue;\r\n      if ((ti.timeRangeUnit != timeUnitOrg) || (ti.timeIncrementUnit != timeUnitOrg && ti.timeIncrementUnit != 255 && ti.timeIncrement != 0)) {\r\n        logger.warn(\"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti.timeIncrementUnit);\r\n        throw new RuntimeException(\"TimeInterval(2) has different units\");\r\n      }\r\n\r\n      range += ti.timeRangeLength;\r\n      if (ti.timeIncrementUnit != 255) range += ti.timeIncrement;\r\n    }\r\n\r\n    // now convert that range to units of the requested period.\r\n    CalendarPeriod timeUnitPeriod = Grib2Utils.getCalendarPeriod(convertTimeUnit(timeUnitOrg));\r\n    if (timeUnitPeriod == null) return GribNumbers.UNDEFINEDD;\r\n    if (timeUnitPeriod.equals(CalendarPeriod.Hour)) return range;\r\n\r\n    double fac;\r\n    if (timeUnitPeriod.getField() == CalendarPeriod.Field.Month) {\r\n      fac = 30.0 * 24.0;  // nominal hours in a month\r\n    } else if (timeUnitPeriod.getField() == CalendarPeriod.Field.Year) {\r\n      fac = 365.0 * 24.0; // nominal hours in a year\r\n    } else {\r\n      fac = CalendarPeriod.Hour.getConvertFactor(timeUnitPeriod);\r\n    }\r\n    return fac * range;\r\n  }", "code_tokens": ["public", "double", "getForecastTimeIntervalSizeInHours", "(", "Grib2Pds", "pds", ")", "{", "Grib2Pds", ".", "PdsInterval", "pdsIntv", "=", "(", "Grib2Pds", ".", "PdsInterval", ")", "pds", ";", "int", "timeUnitOrg", "=", "pds", ".", "getTimeUnit", "(", ")", ";", "// calculate total \"range\" in units of timeUnit\r", "int", "range", "=", "0", ";", "for", "(", "Grib2Pds", ".", "TimeInterval", "ti", ":", "pdsIntv", ".", "getTimeIntervals", "(", ")", ")", "{", "if", "(", "ti", ".", "timeRangeUnit", "==", "255", ")", "continue", ";", "if", "(", "(", "ti", ".", "timeRangeUnit", "!=", "timeUnitOrg", ")", "||", "(", "ti", ".", "timeIncrementUnit", "!=", "timeUnitOrg", "&&", "ti", ".", "timeIncrementUnit", "!=", "255", "&&", "ti", ".", "timeIncrement", "!=", "0", ")", ")", "{", "logger", ".", "warn", "(", "\"TimeInterval(2) has different units timeUnit org=\"", "+", "timeUnitOrg", "+", "\" TimeInterval=\"", "+", "ti", ".", "timeIncrementUnit", ")", ";", "throw", "new", "RuntimeException", "(", "\"TimeInterval(2) has different units\"", ")", ";", "}", "range", "+=", "ti", ".", "timeRangeLength", ";", "if", "(", "ti", ".", "timeIncrementUnit", "!=", "255", ")", "range", "+=", "ti", ".", "timeIncrement", ";", "}", "// now convert that range to units of the requested period.\r", "CalendarPeriod", "timeUnitPeriod", "=", "Grib2Utils", ".", "getCalendarPeriod", "(", "convertTimeUnit", "(", "timeUnitOrg", ")", ")", ";", "if", "(", "timeUnitPeriod", "==", "null", ")", "return", "GribNumbers", ".", "UNDEFINEDD", ";", "if", "(", "timeUnitPeriod", ".", "equals", "(", "CalendarPeriod", ".", "Hour", ")", ")", "return", "range", ";", "double", "fac", ";", "if", "(", "timeUnitPeriod", ".", "getField", "(", ")", "==", "CalendarPeriod", ".", "Field", ".", "Month", ")", "{", "fac", "=", "30.0", "*", "24.0", ";", "// nominal hours in a month\r", "}", "else", "if", "(", "timeUnitPeriod", ".", "getField", "(", ")", "==", "CalendarPeriod", ".", "Field", ".", "Year", ")", "{", "fac", "=", "365.0", "*", "24.0", ";", "// nominal hours in a year\r", "}", "else", "{", "fac", "=", "CalendarPeriod", ".", "Hour", ".", "getConvertFactor", "(", "timeUnitPeriod", ")", ";", "}", "return", "fac", "*", "range", ";", "}"], "docstring": "Get interval size in units of hours.\nOnly use in GribVariable to decide on variable identity when intvMerge = false.\n@param pds must be a Grib2Pds.PdsInterval\n@return interval size in units of hours", "docstring_tokens": ["Get", "interval", "size", "in", "units", "of", "hours", ".", "Only", "use", "in", "GribVariable", "to", "decide", "on", "variable", "identity", "when", "intvMerge", "=", "false", "."]}
{"code": "fac = 365.0 * 24.0;", "comments": "nominal hours in a year", "lines": 28, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib2/table/Grib2Tables.java", "func_name": "Grib2Tables.getForecastTimeIntervalSizeInHours", "original_string": "public double getForecastTimeIntervalSizeInHours(Grib2Pds pds) {\r\n    Grib2Pds.PdsInterval pdsIntv = (Grib2Pds.PdsInterval) pds;\r\n    int timeUnitOrg = pds.getTimeUnit();\r\n\r\n    // calculate total \"range\" in units of timeUnit\r\n    int range = 0;\r\n    for (Grib2Pds.TimeInterval ti : pdsIntv.getTimeIntervals()) {\r\n      if (ti.timeRangeUnit == 255)\r\n        continue;\r\n      if ((ti.timeRangeUnit != timeUnitOrg) || (ti.timeIncrementUnit != timeUnitOrg && ti.timeIncrementUnit != 255 && ti.timeIncrement != 0)) {\r\n        logger.warn(\"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti.timeIncrementUnit);\r\n        throw new RuntimeException(\"TimeInterval(2) has different units\");\r\n      }\r\n\r\n      range += ti.timeRangeLength;\r\n      if (ti.timeIncrementUnit != 255) range += ti.timeIncrement;\r\n    }\r\n\r\n    // now convert that range to units of the requested period.\r\n    CalendarPeriod timeUnitPeriod = Grib2Utils.getCalendarPeriod(convertTimeUnit(timeUnitOrg));\r\n    if (timeUnitPeriod == null) return GribNumbers.UNDEFINEDD;\r\n    if (timeUnitPeriod.equals(CalendarPeriod.Hour)) return range;\r\n\r\n    double fac;\r\n    if (timeUnitPeriod.getField() == CalendarPeriod.Field.Month) {\r\n      fac = 30.0 * 24.0;  // nominal hours in a month\r\n    } else if (timeUnitPeriod.getField() == CalendarPeriod.Field.Year) {\r\n      fac = 365.0 * 24.0; // nominal hours in a year\r\n    } else {\r\n      fac = CalendarPeriod.Hour.getConvertFactor(timeUnitPeriod);\r\n    }\r\n    return fac * range;\r\n  }", "language": "java", "Allcodes": "public double getForecastTimeIntervalSizeInHours(Grib2Pds pds) {\r\n    Grib2Pds.PdsInterval pdsIntv = (Grib2Pds.PdsInterval) pds;\r\n    int timeUnitOrg = pds.getTimeUnit();\r\n\r\n    // calculate total \"range\" in units of timeUnit\r\n    int range = 0;\r\n    for (Grib2Pds.TimeInterval ti : pdsIntv.getTimeIntervals()) {\r\n      if (ti.timeRangeUnit == 255)\r\n        continue;\r\n      if ((ti.timeRangeUnit != timeUnitOrg) || (ti.timeIncrementUnit != timeUnitOrg && ti.timeIncrementUnit != 255 && ti.timeIncrement != 0)) {\r\n        logger.warn(\"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti.timeIncrementUnit);\r\n        throw new RuntimeException(\"TimeInterval(2) has different units\");\r\n      }\r\n\r\n      range += ti.timeRangeLength;\r\n      if (ti.timeIncrementUnit != 255) range += ti.timeIncrement;\r\n    }\r\n\r\n    // now convert that range to units of the requested period.\r\n    CalendarPeriod timeUnitPeriod = Grib2Utils.getCalendarPeriod(convertTimeUnit(timeUnitOrg));\r\n    if (timeUnitPeriod == null) return GribNumbers.UNDEFINEDD;\r\n    if (timeUnitPeriod.equals(CalendarPeriod.Hour)) return range;\r\n\r\n    double fac;\r\n    if (timeUnitPeriod.getField() == CalendarPeriod.Field.Month) {\r\n      fac = 30.0 * 24.0;  // nominal hours in a month\r\n    } else if (timeUnitPeriod.getField() == CalendarPeriod.Field.Year) {\r\n      fac = 365.0 * 24.0; // nominal hours in a year\r\n    } else {\r\n      fac = CalendarPeriod.Hour.getConvertFactor(timeUnitPeriod);\r\n    }\r\n    return fac * range;\r\n  }", "code_tokens": ["public", "double", "getForecastTimeIntervalSizeInHours", "(", "Grib2Pds", "pds", ")", "{", "Grib2Pds", ".", "PdsInterval", "pdsIntv", "=", "(", "Grib2Pds", ".", "PdsInterval", ")", "pds", ";", "int", "timeUnitOrg", "=", "pds", ".", "getTimeUnit", "(", ")", ";", "// calculate total \"range\" in units of timeUnit\r", "int", "range", "=", "0", ";", "for", "(", "Grib2Pds", ".", "TimeInterval", "ti", ":", "pdsIntv", ".", "getTimeIntervals", "(", ")", ")", "{", "if", "(", "ti", ".", "timeRangeUnit", "==", "255", ")", "continue", ";", "if", "(", "(", "ti", ".", "timeRangeUnit", "!=", "timeUnitOrg", ")", "||", "(", "ti", ".", "timeIncrementUnit", "!=", "timeUnitOrg", "&&", "ti", ".", "timeIncrementUnit", "!=", "255", "&&", "ti", ".", "timeIncrement", "!=", "0", ")", ")", "{", "logger", ".", "warn", "(", "\"TimeInterval(2) has different units timeUnit org=\"", "+", "timeUnitOrg", "+", "\" TimeInterval=\"", "+", "ti", ".", "timeIncrementUnit", ")", ";", "throw", "new", "RuntimeException", "(", "\"TimeInterval(2) has different units\"", ")", ";", "}", "range", "+=", "ti", ".", "timeRangeLength", ";", "if", "(", "ti", ".", "timeIncrementUnit", "!=", "255", ")", "range", "+=", "ti", ".", "timeIncrement", ";", "}", "// now convert that range to units of the requested period.\r", "CalendarPeriod", "timeUnitPeriod", "=", "Grib2Utils", ".", "getCalendarPeriod", "(", "convertTimeUnit", "(", "timeUnitOrg", ")", ")", ";", "if", "(", "timeUnitPeriod", "==", "null", ")", "return", "GribNumbers", ".", "UNDEFINEDD", ";", "if", "(", "timeUnitPeriod", ".", "equals", "(", "CalendarPeriod", ".", "Hour", ")", ")", "return", "range", ";", "double", "fac", ";", "if", "(", "timeUnitPeriod", ".", "getField", "(", ")", "==", "CalendarPeriod", ".", "Field", ".", "Month", ")", "{", "fac", "=", "30.0", "*", "24.0", ";", "// nominal hours in a month\r", "}", "else", "if", "(", "timeUnitPeriod", ".", "getField", "(", ")", "==", "CalendarPeriod", ".", "Field", ".", "Year", ")", "{", "fac", "=", "365.0", "*", "24.0", ";", "// nominal hours in a year\r", "}", "else", "{", "fac", "=", "CalendarPeriod", ".", "Hour", ".", "getConvertFactor", "(", "timeUnitPeriod", ")", ";", "}", "return", "fac", "*", "range", ";", "}"], "docstring": "Get interval size in units of hours.\nOnly use in GribVariable to decide on variable identity when intvMerge = false.\n@param pds must be a Grib2Pds.PdsInterval\n@return interval size in units of hours", "docstring_tokens": ["Get", "interval", "size", "in", "units", "of", "hours", ".", "Only", "use", "in", "GribVariable", "to", "decide", "on", "variable", "identity", "when", "intvMerge", "=", "false", "."]}
{"code": "return new VertCoordType(code, \"sigma\", null, false);", "comments": "positive?", "lines": 24, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib2/table/Grib2Tables.java", "func_name": "Grib2Tables.getVertUnit", "original_string": "@Override\r\n  public VertCoordType getVertUnit(int code) {\r\n    //     VertCoordType(int code, String desc, String abbrev, String units, String datum, boolean isPositiveUp, boolean isLayer)\r\n    switch (code) {\r\n\r\n      case 11:\r\n      case 12:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      case 20:\r\n        return new VertCoordType(code, \"K\", null, false);\r\n\r\n      case 100:\r\n        return new VertCoordType(code, \"Pa\", null, false);\r\n\r\n      case 102:\r\n        return new VertCoordType(code, \"m\", \"mean sea level\", true);\r\n\r\n      case 103:\r\n        return new VertCoordType(code, \"m\", \"ground\", true);\r\n\r\n      case 104:\r\n      case 105:\r\n        return new VertCoordType(code, \"sigma\", null, false); // positive?\r\n\r\n      case 106:\r\n        return new VertCoordType(code, \"m\", \"land surface\", false);\r\n\r\n      case 107:\r\n        return new VertCoordType(code, \"K\", null, true); // positive?\r\n\r\n      case 108:\r\n        return new VertCoordType(code, \"Pa\", \"ground\", true);\r\n\r\n      case 109:\r\n        return new VertCoordType(code, \"K m2 kg-1 s-1\", null, true); // positive?\r\n\r\n      case 114:\r\n        return new VertCoordType(code, \"numeric\", null, false);\r\n\r\n      case 117:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      case 119:\r\n        return new VertCoordType(code, \"Pa\", null, false); // ??\r\n\r\n      case 160:\r\n        return new VertCoordType(code, \"m\", \"sea level\", false);\r\n\r\n      case 161:\r\n        return new VertCoordType(code, \"m\", \"water surface\", false);\r\n\r\n      // LOOK NCEP specific\r\n      case 235:\r\n        return new VertCoordType(code, \"0.1 C\", null, true);\r\n\r\n      case 237:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      case 238:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      default:\r\n        return new VertCoordType(code, null, null, true);\r\n    }\r\n  }", "language": "java", "Allcodes": "@Override\r\n  public VertCoordType getVertUnit(int code) {\r\n    //     VertCoordType(int code, String desc, String abbrev, String units, String datum, boolean isPositiveUp, boolean isLayer)\r\n    switch (code) {\r\n\r\n      case 11:\r\n      case 12:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      case 20:\r\n        return new VertCoordType(code, \"K\", null, false);\r\n\r\n      case 100:\r\n        return new VertCoordType(code, \"Pa\", null, false);\r\n\r\n      case 102:\r\n        return new VertCoordType(code, \"m\", \"mean sea level\", true);\r\n\r\n      case 103:\r\n        return new VertCoordType(code, \"m\", \"ground\", true);\r\n\r\n      case 104:\r\n      case 105:\r\n        return new VertCoordType(code, \"sigma\", null, false); // positive?\r\n\r\n      case 106:\r\n        return new VertCoordType(code, \"m\", \"land surface\", false);\r\n\r\n      case 107:\r\n        return new VertCoordType(code, \"K\", null, true); // positive?\r\n\r\n      case 108:\r\n        return new VertCoordType(code, \"Pa\", \"ground\", true);\r\n\r\n      case 109:\r\n        return new VertCoordType(code, \"K m2 kg-1 s-1\", null, true); // positive?\r\n\r\n      case 114:\r\n        return new VertCoordType(code, \"numeric\", null, false);\r\n\r\n      case 117:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      case 119:\r\n        return new VertCoordType(code, \"Pa\", null, false); // ??\r\n\r\n      case 160:\r\n        return new VertCoordType(code, \"m\", \"sea level\", false);\r\n\r\n      case 161:\r\n        return new VertCoordType(code, \"m\", \"water surface\", false);\r\n\r\n      // LOOK NCEP specific\r\n      case 235:\r\n        return new VertCoordType(code, \"0.1 C\", null, true);\r\n\r\n      case 237:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      case 238:\r\n        return new VertCoordType(code, \"m\", null, true);\r\n\r\n      default:\r\n        return new VertCoordType(code, null, null, true);\r\n    }\r\n  }", "code_tokens": ["@", "Override", "public", "VertCoordType", "getVertUnit", "(", "int", "code", ")", "{", "//     VertCoordType(int code, String desc, String abbrev, String units, String datum, boolean isPositiveUp, boolean isLayer)\r", "switch", "(", "code", ")", "{", "case", "11", ":", "case", "12", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "null", ",", "true", ")", ";", "case", "20", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"K\"", ",", "null", ",", "false", ")", ";", "case", "100", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"Pa\"", ",", "null", ",", "false", ")", ";", "case", "102", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "\"mean sea level\"", ",", "true", ")", ";", "case", "103", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "\"ground\"", ",", "true", ")", ";", "case", "104", ":", "case", "105", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"sigma\"", ",", "null", ",", "false", ")", ";", "// positive?\r", "case", "106", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "\"land surface\"", ",", "false", ")", ";", "case", "107", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"K\"", ",", "null", ",", "true", ")", ";", "// positive?\r", "case", "108", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"Pa\"", ",", "\"ground\"", ",", "true", ")", ";", "case", "109", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"K m2 kg-1 s-1\"", ",", "null", ",", "true", ")", ";", "// positive?\r", "case", "114", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"numeric\"", ",", "null", ",", "false", ")", ";", "case", "117", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "null", ",", "true", ")", ";", "case", "119", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"Pa\"", ",", "null", ",", "false", ")", ";", "// ??\r", "case", "160", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "\"sea level\"", ",", "false", ")", ";", "case", "161", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "\"water surface\"", ",", "false", ")", ";", "// LOOK NCEP specific\r", "case", "235", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"0.1 C\"", ",", "null", ",", "true", ")", ";", "case", "237", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "null", ",", "true", ")", ";", "case", "238", ":", "return", "new", "VertCoordType", "(", "code", ",", "\"m\"", ",", "null", ",", "true", ")", ";", "default", ":", "return", "new", "VertCoordType", "(", "code", ",", "null", ",", "null", ",", "true", ")", ";", "}", "}"], "docstring": "Unit of vertical coordinate.\nfrom Grib2 code table 4.5.\nOnly levels with units get a dimension added\n\n@param code code from table 4.5\n@return level unit, default is empty unit string", "docstring_tokens": ["Unit", "of", "vertical", "coordinate", ".", "from", "Grib2", "code", "table", "4", ".", "5", ".", "Only", "levels", "with", "units", "get", "a", "dimension", "added"]}
{"code": "if (Math.abs(diff) < MAX_JUMP) return val;", "comments": "common case fast", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/CoordinateAxis2D.java", "func_name": "CoordinateAxis2D.connectLon", "original_string": "static private double connectLon(double connect, double val) {\r\n    if (Double.isNaN(connect)) return val;\r\n    if (Double.isNaN(val)) return val;\r\n\r\n    double diff = val - connect;\r\n    if (Math.abs(diff) < MAX_JUMP) return val; // common case fast\r\n    // we have to add or subtract 360\r\n    double result = diff > 0 ? val - 360 : val + 360;\r\n    double diff2 = connect - result;\r\n    if ((Math.abs(diff2)) < Math.abs(diff))\r\n      val = result;\r\n    return val;\r\n  }", "language": "java", "Allcodes": "static private double connectLon(double connect, double val) {\r\n    if (Double.isNaN(connect)) return val;\r\n    if (Double.isNaN(val)) return val;\r\n\r\n    double diff = val - connect;\r\n    if (Math.abs(diff) < MAX_JUMP) return val; // common case fast\r\n    // we have to add or subtract 360\r\n    double result = diff > 0 ? val - 360 : val + 360;\r\n    double diff2 = connect - result;\r\n    if ((Math.abs(diff2)) < Math.abs(diff))\r\n      val = result;\r\n    return val;\r\n  }", "code_tokens": ["static", "private", "double", "connectLon", "(", "double", "connect", ",", "double", "val", ")", "{", "if", "(", "Double", ".", "isNaN", "(", "connect", ")", ")", "return", "val", ";", "if", "(", "Double", ".", "isNaN", "(", "val", ")", ")", "return", "val", ";", "double", "diff", "=", "val", "-", "connect", ";", "if", "(", "Math", ".", "abs", "(", "diff", ")", "<", "MAX_JUMP", ")", "return", "val", ";", "// common case fast\r", "// we have to add or subtract 360\r", "double", "result", "=", "diff", ">", "0", "?", "val", "-", "360", ":", "val", "+", "360", ";", "double", "diff2", "=", "connect", "-", "result", ";", "if", "(", "(", "Math", ".", "abs", "(", "diff2", ")", ")", "<", "Math", ".", "abs", "(", "diff", ")", ")", "val", "=", "result", ";", "return", "val", ";", "}"], "docstring": "larger than you would ever expect", "docstring_tokens": ["larger", "than", "you", "would", "ever", "expect"]}
{"code": "int range = (max + 1) - min;", "comments": "min..max+1 -> 0..(max+1)-min", "lines": 8, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/RandomValue.java", "func_name": "RandomValue.nextCount", "original_string": "public int\n    nextCount(int max)\n            throws DapException\n    {\n        int min = 1;\n        if(max < min || min < 1)\n            throw new DapException(\"bad range\");\n        int range = (max + 1) - min;  // min..max+1 -> 0..(max+1)-min\n        int n = random.nextInt(range);   //  0..(max+1)-min\n        n = n + min;   // min..(max+1)\n        if(DEBUG)\n            System.err.println(\"RandomValue.nextCount: \" + n);\n        return n;\n    }", "language": "java", "Allcodes": "public int\n    nextCount(int max)\n            throws DapException\n    {\n        int min = 1;\n        if(max < min || min < 1)\n            throw new DapException(\"bad range\");\n        int range = (max + 1) - min;  // min..max+1 -> 0..(max+1)-min\n        int n = random.nextInt(range);   //  0..(max+1)-min\n        n = n + min;   // min..(max+1)\n        if(DEBUG)\n            System.err.println(\"RandomValue.nextCount: \" + n);\n        return n;\n    }", "code_tokens": ["public", "int", "nextCount", "(", "int", "max", ")", "throws", "DapException", "{", "int", "min", "=", "1", ";", "if", "(", "max", "<", "min", "||", "min", "<", "1", ")", "throw", "new", "DapException", "(", "\"bad range\"", ")", ";", "int", "range", "=", "(", "max", "+", "1", ")", "-", "min", ";", "// min..max+1 -> 0..(max+1)-min", "int", "n", "=", "random", ".", "nextInt", "(", "range", ")", ";", "//  0..(max+1)-min", "n", "=", "n", "+", "min", ";", "// min..(max+1)", "if", "(", "DEBUG", ")", "System", ".", "err", ".", "println", "(", "\"RandomValue.nextCount: \"", "+", "n", ")", ";", "return", "n", ";", "}"], "docstring": "Return an integer in range 1..max inclusive.\n\n@param max\n@return random integer in range\n@throws DapException", "docstring_tokens": ["Return", "an", "integer", "in", "range", "1", "..", "max", "inclusive", "."]}
{"code": "int n = random.nextInt(range);", "comments": "0..(max+1)-min", "lines": 9, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/RandomValue.java", "func_name": "RandomValue.nextCount", "original_string": "public int\n    nextCount(int max)\n            throws DapException\n    {\n        int min = 1;\n        if(max < min || min < 1)\n            throw new DapException(\"bad range\");\n        int range = (max + 1) - min;  // min..max+1 -> 0..(max+1)-min\n        int n = random.nextInt(range);   //  0..(max+1)-min\n        n = n + min;   // min..(max+1)\n        if(DEBUG)\n            System.err.println(\"RandomValue.nextCount: \" + n);\n        return n;\n    }", "language": "java", "Allcodes": "public int\n    nextCount(int max)\n            throws DapException\n    {\n        int min = 1;\n        if(max < min || min < 1)\n            throw new DapException(\"bad range\");\n        int range = (max + 1) - min;  // min..max+1 -> 0..(max+1)-min\n        int n = random.nextInt(range);   //  0..(max+1)-min\n        n = n + min;   // min..(max+1)\n        if(DEBUG)\n            System.err.println(\"RandomValue.nextCount: \" + n);\n        return n;\n    }", "code_tokens": ["public", "int", "nextCount", "(", "int", "max", ")", "throws", "DapException", "{", "int", "min", "=", "1", ";", "if", "(", "max", "<", "min", "||", "min", "<", "1", ")", "throw", "new", "DapException", "(", "\"bad range\"", ")", ";", "int", "range", "=", "(", "max", "+", "1", ")", "-", "min", ";", "// min..max+1 -> 0..(max+1)-min", "int", "n", "=", "random", ".", "nextInt", "(", "range", ")", ";", "//  0..(max+1)-min", "n", "=", "n", "+", "min", ";", "// min..(max+1)", "if", "(", "DEBUG", ")", "System", ".", "err", ".", "println", "(", "\"RandomValue.nextCount: \"", "+", "n", ")", ";", "return", "n", ";", "}"], "docstring": "Return an integer in range 1..max inclusive.\n\n@param max\n@return random integer in range\n@throws DapException", "docstring_tokens": ["Return", "an", "integer", "in", "range", "1", "..", "max", "inclusive", "."]}
{"code": "n = n + min;", "comments": "min..(max+1)", "lines": 10, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/RandomValue.java", "func_name": "RandomValue.nextCount", "original_string": "public int\n    nextCount(int max)\n            throws DapException\n    {\n        int min = 1;\n        if(max < min || min < 1)\n            throw new DapException(\"bad range\");\n        int range = (max + 1) - min;  // min..max+1 -> 0..(max+1)-min\n        int n = random.nextInt(range);   //  0..(max+1)-min\n        n = n + min;   // min..(max+1)\n        if(DEBUG)\n            System.err.println(\"RandomValue.nextCount: \" + n);\n        return n;\n    }", "language": "java", "Allcodes": "public int\n    nextCount(int max)\n            throws DapException\n    {\n        int min = 1;\n        if(max < min || min < 1)\n            throw new DapException(\"bad range\");\n        int range = (max + 1) - min;  // min..max+1 -> 0..(max+1)-min\n        int n = random.nextInt(range);   //  0..(max+1)-min\n        n = n + min;   // min..(max+1)\n        if(DEBUG)\n            System.err.println(\"RandomValue.nextCount: \" + n);\n        return n;\n    }", "code_tokens": ["public", "int", "nextCount", "(", "int", "max", ")", "throws", "DapException", "{", "int", "min", "=", "1", ";", "if", "(", "max", "<", "min", "||", "min", "<", "1", ")", "throw", "new", "DapException", "(", "\"bad range\"", ")", ";", "int", "range", "=", "(", "max", "+", "1", ")", "-", "min", ";", "// min..max+1 -> 0..(max+1)-min", "int", "n", "=", "random", ".", "nextInt", "(", "range", ")", ";", "//  0..(max+1)-min", "n", "=", "n", "+", "min", ";", "// min..(max+1)", "if", "(", "DEBUG", ")", "System", ".", "err", ".", "println", "(", "\"RandomValue.nextCount: \"", "+", "n", ")", ";", "return", "n", ";", "}"], "docstring": "Return an integer in range 1..max inclusive.\n\n@param max\n@return random integer in range\n@throws DapException", "docstring_tokens": ["Return", "an", "integer", "in", "range", "1", "..", "max", "inclusive", "."]}
{"code": "ranges = ranges.subList(0, ranges.size() - 1);", "comments": "may produce empty list", "lines": 20, "repo": "Unidata/thredds", "path": "dap4/d4cdm/src/main/java/dap4/cdm/nc2/DapNetcdfFile.java", "func_name": "DapNetcdfFile.readData", "original_string": "@Override\n    protected Array\n    readData(Variable cdmvar, Section section)\n            throws IOException, InvalidRangeException\n    {\n        // The section is applied wrt to the DataDMR, so it\n        // takes into account any constraint used in forming the dataDMR.\n        // We use the Section to produce a view of the underlying variable array.\n\n        assert this.dsp != null;\n        Array result = arraymap.get(cdmvar);\n        if(result == null)\n            throw new IOException(\"No data for variable: \" + cdmvar.getFullName());\n        if(section != null) {\n            if(cdmvar.getRank() != section.getRank())\n                throw new InvalidRangeException(String.format(\"Section rank != %s rank\", cdmvar.getFullName()));\n            List<Range> ranges = section.getRanges();\n            // Case out the possibilities\n            if(CDMUtil.hasVLEN(ranges)) {\n                ranges = ranges.subList(0, ranges.size() - 1);// may produce empty list\n            }\n            if(ranges.size() > 0 && !CDMUtil.isWhole(ranges, cdmvar))\n                result = result.sectionNoReduce(ranges);\n        }\n        return result;\n    }", "language": "java", "Allcodes": "@Override\n    protected Array\n    readData(Variable cdmvar, Section section)\n            throws IOException, InvalidRangeException\n    {\n        // The section is applied wrt to the DataDMR, so it\n        // takes into account any constraint used in forming the dataDMR.\n        // We use the Section to produce a view of the underlying variable array.\n\n        assert this.dsp != null;\n        Array result = arraymap.get(cdmvar);\n        if(result == null)\n            throw new IOException(\"No data for variable: \" + cdmvar.getFullName());\n        if(section != null) {\n            if(cdmvar.getRank() != section.getRank())\n                throw new InvalidRangeException(String.format(\"Section rank != %s rank\", cdmvar.getFullName()));\n            List<Range> ranges = section.getRanges();\n            // Case out the possibilities\n            if(CDMUtil.hasVLEN(ranges)) {\n                ranges = ranges.subList(0, ranges.size() - 1);// may produce empty list\n            }\n            if(ranges.size() > 0 && !CDMUtil.isWhole(ranges, cdmvar))\n                result = result.sectionNoReduce(ranges);\n        }\n        return result;\n    }", "code_tokens": ["@", "Override", "protected", "Array", "readData", "(", "Variable", "cdmvar", ",", "Section", "section", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "// The section is applied wrt to the DataDMR, so it", "// takes into account any constraint used in forming the dataDMR.", "// We use the Section to produce a view of the underlying variable array.", "assert", "this", ".", "dsp", "!=", "null", ";", "Array", "result", "=", "arraymap", ".", "get", "(", "cdmvar", ")", ";", "if", "(", "result", "==", "null", ")", "throw", "new", "IOException", "(", "\"No data for variable: \"", "+", "cdmvar", ".", "getFullName", "(", ")", ")", ";", "if", "(", "section", "!=", "null", ")", "{", "if", "(", "cdmvar", ".", "getRank", "(", ")", "!=", "section", ".", "getRank", "(", ")", ")", "throw", "new", "InvalidRangeException", "(", "String", ".", "format", "(", "\"Section rank != %s rank\"", ",", "cdmvar", ".", "getFullName", "(", ")", ")", ")", ";", "List", "<", "Range", ">", "ranges", "=", "section", ".", "getRanges", "(", ")", ";", "// Case out the possibilities", "if", "(", "CDMUtil", ".", "hasVLEN", "(", "ranges", ")", ")", "{", "ranges", "=", "ranges", ".", "subList", "(", "0", ",", "ranges", ".", "size", "(", ")", "-", "1", ")", ";", "// may produce empty list", "}", "if", "(", "ranges", ".", "size", "(", ")", ">", "0", "&&", "!", "CDMUtil", ".", "isWhole", "(", "ranges", ",", "cdmvar", ")", ")", "result", "=", "result", ".", "sectionNoReduce", "(", "ranges", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Primary read entry point.\nThis is the primary implementor of Variable.read.\n\n@param cdmvar  A top-level variable\n@param section the section of databuffer to read.\nThere must be a Range for each Dimension in the variable,\nin order. Note: no nulls allowed.\n@return An Array object for accessing the databuffer\n@throws IOException           if read error\n@throws InvalidRangeException if invalid section", "docstring_tokens": ["Primary", "read", "entry", "point", ".", "This", "is", "the", "primary", "implementor", "of", "Variable", ".", "read", "."]}
{"code": "result = read(timeInv, gridLite.name, innerSection, openFilesRead);", "comments": "may return null", "lines": 33, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/FmrcDataset.java", "func_name": "ProxyReader2D.reallyRead", "original_string": "@Override\r\n    public Array reallyRead(Variable mainv, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {\r\n      FmrcInvLite.Gridset.Grid gridLite = (FmrcInvLite.Gridset.Grid) mainv.getSPobject();\r\n\r\n      // read the original type - if its been promoted to a new type, the conversion happens after this read\r\n      DataType dtype = (mainv instanceof VariableDS) ? ((VariableDS) mainv).getOriginalDataType() : mainv.getDataType();\r\n\r\n      Array allData = Array.factory(dtype, section.getShape());\r\n      int destPos = 0;\r\n\r\n      // assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r\n      List<Range> ranges = section.getRanges();\r\n      Range runRange = ranges.get(0);\r\n      Range timeRange = ranges.get(1);\r\n      List<Range> innerSection = ranges.subList(2, ranges.size());\r\n\r\n      // keep track of open file - must be local variable for thread safety\r\n      HashMap<String, NetcdfDataset> openFilesRead = new HashMap<>();\r\n      try {\r\n\r\n        // iterate over the desired runs\r\n        for (int runIdx : runRange) {\r\n          //Date runDate = vstate.runTimes.get(runIdx);\r\n\r\n          // iterate over the desired forecast times\r\n          for (int timeIdx : timeRange) {\r\n            Array result = null;\r\n\r\n            // find the inventory for this grid, runtime, and hour\r\n            TimeInventory.Instance timeInv = gridLite.getInstance(runIdx, timeIdx);\r\n            if (timeInv != null) {\r\n              if (debugRead) System.out.printf(\"HIT %d %d \", runIdx, timeIdx);\r\n              result = read(timeInv, gridLite.name, innerSection, openFilesRead); // may return null\r\n              result = MAMath.convert(result, dtype); // just in case it need to be converted\r\n            }\r\n\r\n            // missing data\r\n            if (result == null) {\r\n              int[] shape = new Section(innerSection).getShape();\r\n              result = ((VariableDS) mainv).getMissingDataArray(shape); // fill with missing values\r\n              if (debugRead) System.out.printf(\"MISS %d %d \", runIdx, timeIdx);\r\n            }\r\n\r\n            if (debugRead)\r\n              System.out.printf(\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\",\r\n                      runIdx, timeIdx, mainv.getFullName(), result.getSize(), destPos, allData.getSize());\r\n\r\n            Array.arraycopy(result, 0, allData, destPos, (int) result.getSize());\r\n            destPos += result.getSize();\r\n          }\r\n        }\r\n        return allData;\r\n\r\n      } finally {\r\n        // close any files used during this operation\r\n        closeAll(openFilesRead);\r\n      }\r\n    }", "language": "java", "Allcodes": "@Override\r\n    public Array reallyRead(Variable mainv, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {\r\n      FmrcInvLite.Gridset.Grid gridLite = (FmrcInvLite.Gridset.Grid) mainv.getSPobject();\r\n\r\n      // read the original type - if its been promoted to a new type, the conversion happens after this read\r\n      DataType dtype = (mainv instanceof VariableDS) ? ((VariableDS) mainv).getOriginalDataType() : mainv.getDataType();\r\n\r\n      Array allData = Array.factory(dtype, section.getShape());\r\n      int destPos = 0;\r\n\r\n      // assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r\n      List<Range> ranges = section.getRanges();\r\n      Range runRange = ranges.get(0);\r\n      Range timeRange = ranges.get(1);\r\n      List<Range> innerSection = ranges.subList(2, ranges.size());\r\n\r\n      // keep track of open file - must be local variable for thread safety\r\n      HashMap<String, NetcdfDataset> openFilesRead = new HashMap<>();\r\n      try {\r\n\r\n        // iterate over the desired runs\r\n        for (int runIdx : runRange) {\r\n          //Date runDate = vstate.runTimes.get(runIdx);\r\n\r\n          // iterate over the desired forecast times\r\n          for (int timeIdx : timeRange) {\r\n            Array result = null;\r\n\r\n            // find the inventory for this grid, runtime, and hour\r\n            TimeInventory.Instance timeInv = gridLite.getInstance(runIdx, timeIdx);\r\n            if (timeInv != null) {\r\n              if (debugRead) System.out.printf(\"HIT %d %d \", runIdx, timeIdx);\r\n              result = read(timeInv, gridLite.name, innerSection, openFilesRead); // may return null\r\n              result = MAMath.convert(result, dtype); // just in case it need to be converted\r\n            }\r\n\r\n            // missing data\r\n            if (result == null) {\r\n              int[] shape = new Section(innerSection).getShape();\r\n              result = ((VariableDS) mainv).getMissingDataArray(shape); // fill with missing values\r\n              if (debugRead) System.out.printf(\"MISS %d %d \", runIdx, timeIdx);\r\n            }\r\n\r\n            if (debugRead)\r\n              System.out.printf(\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\",\r\n                      runIdx, timeIdx, mainv.getFullName(), result.getSize(), destPos, allData.getSize());\r\n\r\n            Array.arraycopy(result, 0, allData, destPos, (int) result.getSize());\r\n            destPos += result.getSize();\r\n          }\r\n        }\r\n        return allData;\r\n\r\n      } finally {\r\n        // close any files used during this operation\r\n        closeAll(openFilesRead);\r\n      }\r\n    }", "code_tokens": ["@", "Override", "public", "Array", "reallyRead", "(", "Variable", "mainv", ",", "Section", "section", ",", "CancelTask", "cancelTask", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "FmrcInvLite", ".", "Gridset", ".", "Grid", "gridLite", "=", "(", "FmrcInvLite", ".", "Gridset", ".", "Grid", ")", "mainv", ".", "getSPobject", "(", ")", ";", "// read the original type - if its been promoted to a new type, the conversion happens after this read\r", "DataType", "dtype", "=", "(", "mainv", "instanceof", "VariableDS", ")", "?", "(", "(", "VariableDS", ")", "mainv", ")", ".", "getOriginalDataType", "(", ")", ":", "mainv", ".", "getDataType", "(", ")", ";", "Array", "allData", "=", "Array", ".", "factory", "(", "dtype", ",", "section", ".", "getShape", "(", ")", ")", ";", "int", "destPos", "=", "0", ";", "// assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r", "List", "<", "Range", ">", "ranges", "=", "section", ".", "getRanges", "(", ")", ";", "Range", "runRange", "=", "ranges", ".", "get", "(", "0", ")", ";", "Range", "timeRange", "=", "ranges", ".", "get", "(", "1", ")", ";", "List", "<", "Range", ">", "innerSection", "=", "ranges", ".", "subList", "(", "2", ",", "ranges", ".", "size", "(", ")", ")", ";", "// keep track of open file - must be local variable for thread safety\r", "HashMap", "<", "String", ",", "NetcdfDataset", ">", "openFilesRead", "=", "new", "HashMap", "<>", "(", ")", ";", "try", "{", "// iterate over the desired runs\r", "for", "(", "int", "runIdx", ":", "runRange", ")", "{", "//Date runDate = vstate.runTimes.get(runIdx);\r", "// iterate over the desired forecast times\r", "for", "(", "int", "timeIdx", ":", "timeRange", ")", "{", "Array", "result", "=", "null", ";", "// find the inventory for this grid, runtime, and hour\r", "TimeInventory", ".", "Instance", "timeInv", "=", "gridLite", ".", "getInstance", "(", "runIdx", ",", "timeIdx", ")", ";", "if", "(", "timeInv", "!=", "null", ")", "{", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"HIT %d %d \"", ",", "runIdx", ",", "timeIdx", ")", ";", "result", "=", "read", "(", "timeInv", ",", "gridLite", ".", "name", ",", "innerSection", ",", "openFilesRead", ")", ";", "// may return null\r", "result", "=", "MAMath", ".", "convert", "(", "result", ",", "dtype", ")", ";", "// just in case it need to be converted\r", "}", "// missing data\r", "if", "(", "result", "==", "null", ")", "{", "int", "[", "]", "shape", "=", "new", "Section", "(", "innerSection", ")", ".", "getShape", "(", ")", ";", "result", "=", "(", "(", "VariableDS", ")", "mainv", ")", ".", "getMissingDataArray", "(", "shape", ")", ";", "// fill with missing values\r", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"MISS %d %d \"", ",", "runIdx", ",", "timeIdx", ")", ";", "}", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\"", ",", "runIdx", ",", "timeIdx", ",", "mainv", ".", "getFullName", "(", ")", ",", "result", ".", "getSize", "(", ")", ",", "destPos", ",", "allData", ".", "getSize", "(", ")", ")", ";", "Array", ".", "arraycopy", "(", "result", ",", "0", ",", "allData", ",", "destPos", ",", "(", "int", ")", "result", ".", "getSize", "(", ")", ")", ";", "destPos", "+=", "result", ".", "getSize", "(", ")", ";", "}", "}", "return", "allData", ";", "}", "finally", "{", "// close any files used during this operation\r", "closeAll", "(", "openFilesRead", ")", ";", "}", "}"], "docstring": "here is where agg variables get read", "docstring_tokens": ["here", "is", "where", "agg", "variables", "get", "read"]}
{"code": "result = MAMath.convert(result, dtype);", "comments": "just in case it need to be converted", "lines": 34, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/FmrcDataset.java", "func_name": "ProxyReader2D.reallyRead", "original_string": "@Override\r\n    public Array reallyRead(Variable mainv, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {\r\n      FmrcInvLite.Gridset.Grid gridLite = (FmrcInvLite.Gridset.Grid) mainv.getSPobject();\r\n\r\n      // read the original type - if its been promoted to a new type, the conversion happens after this read\r\n      DataType dtype = (mainv instanceof VariableDS) ? ((VariableDS) mainv).getOriginalDataType() : mainv.getDataType();\r\n\r\n      Array allData = Array.factory(dtype, section.getShape());\r\n      int destPos = 0;\r\n\r\n      // assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r\n      List<Range> ranges = section.getRanges();\r\n      Range runRange = ranges.get(0);\r\n      Range timeRange = ranges.get(1);\r\n      List<Range> innerSection = ranges.subList(2, ranges.size());\r\n\r\n      // keep track of open file - must be local variable for thread safety\r\n      HashMap<String, NetcdfDataset> openFilesRead = new HashMap<>();\r\n      try {\r\n\r\n        // iterate over the desired runs\r\n        for (int runIdx : runRange) {\r\n          //Date runDate = vstate.runTimes.get(runIdx);\r\n\r\n          // iterate over the desired forecast times\r\n          for (int timeIdx : timeRange) {\r\n            Array result = null;\r\n\r\n            // find the inventory for this grid, runtime, and hour\r\n            TimeInventory.Instance timeInv = gridLite.getInstance(runIdx, timeIdx);\r\n            if (timeInv != null) {\r\n              if (debugRead) System.out.printf(\"HIT %d %d \", runIdx, timeIdx);\r\n              result = read(timeInv, gridLite.name, innerSection, openFilesRead); // may return null\r\n              result = MAMath.convert(result, dtype); // just in case it need to be converted\r\n            }\r\n\r\n            // missing data\r\n            if (result == null) {\r\n              int[] shape = new Section(innerSection).getShape();\r\n              result = ((VariableDS) mainv).getMissingDataArray(shape); // fill with missing values\r\n              if (debugRead) System.out.printf(\"MISS %d %d \", runIdx, timeIdx);\r\n            }\r\n\r\n            if (debugRead)\r\n              System.out.printf(\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\",\r\n                      runIdx, timeIdx, mainv.getFullName(), result.getSize(), destPos, allData.getSize());\r\n\r\n            Array.arraycopy(result, 0, allData, destPos, (int) result.getSize());\r\n            destPos += result.getSize();\r\n          }\r\n        }\r\n        return allData;\r\n\r\n      } finally {\r\n        // close any files used during this operation\r\n        closeAll(openFilesRead);\r\n      }\r\n    }", "language": "java", "Allcodes": "@Override\r\n    public Array reallyRead(Variable mainv, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {\r\n      FmrcInvLite.Gridset.Grid gridLite = (FmrcInvLite.Gridset.Grid) mainv.getSPobject();\r\n\r\n      // read the original type - if its been promoted to a new type, the conversion happens after this read\r\n      DataType dtype = (mainv instanceof VariableDS) ? ((VariableDS) mainv).getOriginalDataType() : mainv.getDataType();\r\n\r\n      Array allData = Array.factory(dtype, section.getShape());\r\n      int destPos = 0;\r\n\r\n      // assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r\n      List<Range> ranges = section.getRanges();\r\n      Range runRange = ranges.get(0);\r\n      Range timeRange = ranges.get(1);\r\n      List<Range> innerSection = ranges.subList(2, ranges.size());\r\n\r\n      // keep track of open file - must be local variable for thread safety\r\n      HashMap<String, NetcdfDataset> openFilesRead = new HashMap<>();\r\n      try {\r\n\r\n        // iterate over the desired runs\r\n        for (int runIdx : runRange) {\r\n          //Date runDate = vstate.runTimes.get(runIdx);\r\n\r\n          // iterate over the desired forecast times\r\n          for (int timeIdx : timeRange) {\r\n            Array result = null;\r\n\r\n            // find the inventory for this grid, runtime, and hour\r\n            TimeInventory.Instance timeInv = gridLite.getInstance(runIdx, timeIdx);\r\n            if (timeInv != null) {\r\n              if (debugRead) System.out.printf(\"HIT %d %d \", runIdx, timeIdx);\r\n              result = read(timeInv, gridLite.name, innerSection, openFilesRead); // may return null\r\n              result = MAMath.convert(result, dtype); // just in case it need to be converted\r\n            }\r\n\r\n            // missing data\r\n            if (result == null) {\r\n              int[] shape = new Section(innerSection).getShape();\r\n              result = ((VariableDS) mainv).getMissingDataArray(shape); // fill with missing values\r\n              if (debugRead) System.out.printf(\"MISS %d %d \", runIdx, timeIdx);\r\n            }\r\n\r\n            if (debugRead)\r\n              System.out.printf(\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\",\r\n                      runIdx, timeIdx, mainv.getFullName(), result.getSize(), destPos, allData.getSize());\r\n\r\n            Array.arraycopy(result, 0, allData, destPos, (int) result.getSize());\r\n            destPos += result.getSize();\r\n          }\r\n        }\r\n        return allData;\r\n\r\n      } finally {\r\n        // close any files used during this operation\r\n        closeAll(openFilesRead);\r\n      }\r\n    }", "code_tokens": ["@", "Override", "public", "Array", "reallyRead", "(", "Variable", "mainv", ",", "Section", "section", ",", "CancelTask", "cancelTask", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "FmrcInvLite", ".", "Gridset", ".", "Grid", "gridLite", "=", "(", "FmrcInvLite", ".", "Gridset", ".", "Grid", ")", "mainv", ".", "getSPobject", "(", ")", ";", "// read the original type - if its been promoted to a new type, the conversion happens after this read\r", "DataType", "dtype", "=", "(", "mainv", "instanceof", "VariableDS", ")", "?", "(", "(", "VariableDS", ")", "mainv", ")", ".", "getOriginalDataType", "(", ")", ":", "mainv", ".", "getDataType", "(", ")", ";", "Array", "allData", "=", "Array", ".", "factory", "(", "dtype", ",", "section", ".", "getShape", "(", ")", ")", ";", "int", "destPos", "=", "0", ";", "// assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r", "List", "<", "Range", ">", "ranges", "=", "section", ".", "getRanges", "(", ")", ";", "Range", "runRange", "=", "ranges", ".", "get", "(", "0", ")", ";", "Range", "timeRange", "=", "ranges", ".", "get", "(", "1", ")", ";", "List", "<", "Range", ">", "innerSection", "=", "ranges", ".", "subList", "(", "2", ",", "ranges", ".", "size", "(", ")", ")", ";", "// keep track of open file - must be local variable for thread safety\r", "HashMap", "<", "String", ",", "NetcdfDataset", ">", "openFilesRead", "=", "new", "HashMap", "<>", "(", ")", ";", "try", "{", "// iterate over the desired runs\r", "for", "(", "int", "runIdx", ":", "runRange", ")", "{", "//Date runDate = vstate.runTimes.get(runIdx);\r", "// iterate over the desired forecast times\r", "for", "(", "int", "timeIdx", ":", "timeRange", ")", "{", "Array", "result", "=", "null", ";", "// find the inventory for this grid, runtime, and hour\r", "TimeInventory", ".", "Instance", "timeInv", "=", "gridLite", ".", "getInstance", "(", "runIdx", ",", "timeIdx", ")", ";", "if", "(", "timeInv", "!=", "null", ")", "{", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"HIT %d %d \"", ",", "runIdx", ",", "timeIdx", ")", ";", "result", "=", "read", "(", "timeInv", ",", "gridLite", ".", "name", ",", "innerSection", ",", "openFilesRead", ")", ";", "// may return null\r", "result", "=", "MAMath", ".", "convert", "(", "result", ",", "dtype", ")", ";", "// just in case it need to be converted\r", "}", "// missing data\r", "if", "(", "result", "==", "null", ")", "{", "int", "[", "]", "shape", "=", "new", "Section", "(", "innerSection", ")", ".", "getShape", "(", ")", ";", "result", "=", "(", "(", "VariableDS", ")", "mainv", ")", ".", "getMissingDataArray", "(", "shape", ")", ";", "// fill with missing values\r", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"MISS %d %d \"", ",", "runIdx", ",", "timeIdx", ")", ";", "}", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\"", ",", "runIdx", ",", "timeIdx", ",", "mainv", ".", "getFullName", "(", ")", ",", "result", ".", "getSize", "(", ")", ",", "destPos", ",", "allData", ".", "getSize", "(", ")", ")", ";", "Array", ".", "arraycopy", "(", "result", ",", "0", ",", "allData", ",", "destPos", ",", "(", "int", ")", "result", ".", "getSize", "(", ")", ")", ";", "destPos", "+=", "result", ".", "getSize", "(", ")", ";", "}", "}", "return", "allData", ";", "}", "finally", "{", "// close any files used during this operation\r", "closeAll", "(", "openFilesRead", ")", ";", "}", "}"], "docstring": "here is where agg variables get read", "docstring_tokens": ["here", "is", "where", "agg", "variables", "get", "read"]}
{"code": "result = ((VariableDS) mainv).getMissingDataArray(shape);", "comments": "fill with missing values", "lines": 40, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/FmrcDataset.java", "func_name": "ProxyReader2D.reallyRead", "original_string": "@Override\r\n    public Array reallyRead(Variable mainv, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {\r\n      FmrcInvLite.Gridset.Grid gridLite = (FmrcInvLite.Gridset.Grid) mainv.getSPobject();\r\n\r\n      // read the original type - if its been promoted to a new type, the conversion happens after this read\r\n      DataType dtype = (mainv instanceof VariableDS) ? ((VariableDS) mainv).getOriginalDataType() : mainv.getDataType();\r\n\r\n      Array allData = Array.factory(dtype, section.getShape());\r\n      int destPos = 0;\r\n\r\n      // assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r\n      List<Range> ranges = section.getRanges();\r\n      Range runRange = ranges.get(0);\r\n      Range timeRange = ranges.get(1);\r\n      List<Range> innerSection = ranges.subList(2, ranges.size());\r\n\r\n      // keep track of open file - must be local variable for thread safety\r\n      HashMap<String, NetcdfDataset> openFilesRead = new HashMap<>();\r\n      try {\r\n\r\n        // iterate over the desired runs\r\n        for (int runIdx : runRange) {\r\n          //Date runDate = vstate.runTimes.get(runIdx);\r\n\r\n          // iterate over the desired forecast times\r\n          for (int timeIdx : timeRange) {\r\n            Array result = null;\r\n\r\n            // find the inventory for this grid, runtime, and hour\r\n            TimeInventory.Instance timeInv = gridLite.getInstance(runIdx, timeIdx);\r\n            if (timeInv != null) {\r\n              if (debugRead) System.out.printf(\"HIT %d %d \", runIdx, timeIdx);\r\n              result = read(timeInv, gridLite.name, innerSection, openFilesRead); // may return null\r\n              result = MAMath.convert(result, dtype); // just in case it need to be converted\r\n            }\r\n\r\n            // missing data\r\n            if (result == null) {\r\n              int[] shape = new Section(innerSection).getShape();\r\n              result = ((VariableDS) mainv).getMissingDataArray(shape); // fill with missing values\r\n              if (debugRead) System.out.printf(\"MISS %d %d \", runIdx, timeIdx);\r\n            }\r\n\r\n            if (debugRead)\r\n              System.out.printf(\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\",\r\n                      runIdx, timeIdx, mainv.getFullName(), result.getSize(), destPos, allData.getSize());\r\n\r\n            Array.arraycopy(result, 0, allData, destPos, (int) result.getSize());\r\n            destPos += result.getSize();\r\n          }\r\n        }\r\n        return allData;\r\n\r\n      } finally {\r\n        // close any files used during this operation\r\n        closeAll(openFilesRead);\r\n      }\r\n    }", "language": "java", "Allcodes": "@Override\r\n    public Array reallyRead(Variable mainv, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {\r\n      FmrcInvLite.Gridset.Grid gridLite = (FmrcInvLite.Gridset.Grid) mainv.getSPobject();\r\n\r\n      // read the original type - if its been promoted to a new type, the conversion happens after this read\r\n      DataType dtype = (mainv instanceof VariableDS) ? ((VariableDS) mainv).getOriginalDataType() : mainv.getDataType();\r\n\r\n      Array allData = Array.factory(dtype, section.getShape());\r\n      int destPos = 0;\r\n\r\n      // assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r\n      List<Range> ranges = section.getRanges();\r\n      Range runRange = ranges.get(0);\r\n      Range timeRange = ranges.get(1);\r\n      List<Range> innerSection = ranges.subList(2, ranges.size());\r\n\r\n      // keep track of open file - must be local variable for thread safety\r\n      HashMap<String, NetcdfDataset> openFilesRead = new HashMap<>();\r\n      try {\r\n\r\n        // iterate over the desired runs\r\n        for (int runIdx : runRange) {\r\n          //Date runDate = vstate.runTimes.get(runIdx);\r\n\r\n          // iterate over the desired forecast times\r\n          for (int timeIdx : timeRange) {\r\n            Array result = null;\r\n\r\n            // find the inventory for this grid, runtime, and hour\r\n            TimeInventory.Instance timeInv = gridLite.getInstance(runIdx, timeIdx);\r\n            if (timeInv != null) {\r\n              if (debugRead) System.out.printf(\"HIT %d %d \", runIdx, timeIdx);\r\n              result = read(timeInv, gridLite.name, innerSection, openFilesRead); // may return null\r\n              result = MAMath.convert(result, dtype); // just in case it need to be converted\r\n            }\r\n\r\n            // missing data\r\n            if (result == null) {\r\n              int[] shape = new Section(innerSection).getShape();\r\n              result = ((VariableDS) mainv).getMissingDataArray(shape); // fill with missing values\r\n              if (debugRead) System.out.printf(\"MISS %d %d \", runIdx, timeIdx);\r\n            }\r\n\r\n            if (debugRead)\r\n              System.out.printf(\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\",\r\n                      runIdx, timeIdx, mainv.getFullName(), result.getSize(), destPos, allData.getSize());\r\n\r\n            Array.arraycopy(result, 0, allData, destPos, (int) result.getSize());\r\n            destPos += result.getSize();\r\n          }\r\n        }\r\n        return allData;\r\n\r\n      } finally {\r\n        // close any files used during this operation\r\n        closeAll(openFilesRead);\r\n      }\r\n    }", "code_tokens": ["@", "Override", "public", "Array", "reallyRead", "(", "Variable", "mainv", ",", "Section", "section", ",", "CancelTask", "cancelTask", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "FmrcInvLite", ".", "Gridset", ".", "Grid", "gridLite", "=", "(", "FmrcInvLite", ".", "Gridset", ".", "Grid", ")", "mainv", ".", "getSPobject", "(", ")", ";", "// read the original type - if its been promoted to a new type, the conversion happens after this read\r", "DataType", "dtype", "=", "(", "mainv", "instanceof", "VariableDS", ")", "?", "(", "(", "VariableDS", ")", "mainv", ")", ".", "getOriginalDataType", "(", ")", ":", "mainv", ".", "getDataType", "(", ")", ";", "Array", "allData", "=", "Array", ".", "factory", "(", "dtype", ",", "section", ".", "getShape", "(", ")", ")", ";", "int", "destPos", "=", "0", ";", "// assumes the first two dimensions are runtime and time: LOOK: ensemble ??\r", "List", "<", "Range", ">", "ranges", "=", "section", ".", "getRanges", "(", ")", ";", "Range", "runRange", "=", "ranges", ".", "get", "(", "0", ")", ";", "Range", "timeRange", "=", "ranges", ".", "get", "(", "1", ")", ";", "List", "<", "Range", ">", "innerSection", "=", "ranges", ".", "subList", "(", "2", ",", "ranges", ".", "size", "(", ")", ")", ";", "// keep track of open file - must be local variable for thread safety\r", "HashMap", "<", "String", ",", "NetcdfDataset", ">", "openFilesRead", "=", "new", "HashMap", "<>", "(", ")", ";", "try", "{", "// iterate over the desired runs\r", "for", "(", "int", "runIdx", ":", "runRange", ")", "{", "//Date runDate = vstate.runTimes.get(runIdx);\r", "// iterate over the desired forecast times\r", "for", "(", "int", "timeIdx", ":", "timeRange", ")", "{", "Array", "result", "=", "null", ";", "// find the inventory for this grid, runtime, and hour\r", "TimeInventory", ".", "Instance", "timeInv", "=", "gridLite", ".", "getInstance", "(", "runIdx", ",", "timeIdx", ")", ";", "if", "(", "timeInv", "!=", "null", ")", "{", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"HIT %d %d \"", ",", "runIdx", ",", "timeIdx", ")", ";", "result", "=", "read", "(", "timeInv", ",", "gridLite", ".", "name", ",", "innerSection", ",", "openFilesRead", ")", ";", "// may return null\r", "result", "=", "MAMath", ".", "convert", "(", "result", ",", "dtype", ")", ";", "// just in case it need to be converted\r", "}", "// missing data\r", "if", "(", "result", "==", "null", ")", "{", "int", "[", "]", "shape", "=", "new", "Section", "(", "innerSection", ")", ".", "getShape", "(", ")", ";", "result", "=", "(", "(", "VariableDS", ")", "mainv", ")", ".", "getMissingDataArray", "(", "shape", ")", ";", "// fill with missing values\r", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"MISS %d %d \"", ",", "runIdx", ",", "timeIdx", ")", ";", "}", "if", "(", "debugRead", ")", "System", ".", "out", ".", "printf", "(", "\"%d %d reallyRead %s %d bytes start at %d total size is %d%n\"", ",", "runIdx", ",", "timeIdx", ",", "mainv", ".", "getFullName", "(", ")", ",", "result", ".", "getSize", "(", ")", ",", "destPos", ",", "allData", ".", "getSize", "(", ")", ")", ";", "Array", ".", "arraycopy", "(", "result", ",", "0", ",", "allData", ",", "destPos", ",", "(", "int", ")", "result", ".", "getSize", "(", ")", ")", ";", "destPos", "+=", "result", ".", "getSize", "(", ")", ";", "}", "}", "return", "allData", ";", "}", "finally", "{", "// close any files used during this operation\r", "closeAll", "(", "openFilesRead", ")", ";", "}", "}"], "docstring": "here is where agg variables get read", "docstring_tokens": ["here", "is", "where", "agg", "variables", "get", "read"]}
{"code": "addToMenu( topMenu, store);", "comments": "recursive", "lines": 8, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/util/prefs/ui/Debug.java", "func_name": "Debug.constructMenu", "original_string": "static public void constructMenu(JMenu topMenu) {\n    if (debug) System.out.println(\"Debug.constructMenu \");\n\n    if (topMenu.getItemCount() > 0)\n      topMenu.removeAll();\n\n    try {\n      addToMenu( topMenu, store); // recursive\n    } catch (BackingStoreException e) { }\n\n    topMenu.revalidate();\n  }", "language": "java", "Allcodes": "static public void constructMenu(JMenu topMenu) {\n    if (debug) System.out.println(\"Debug.constructMenu \");\n\n    if (topMenu.getItemCount() > 0)\n      topMenu.removeAll();\n\n    try {\n      addToMenu( topMenu, store); // recursive\n    } catch (BackingStoreException e) { }\n\n    topMenu.revalidate();\n  }", "code_tokens": ["static", "public", "void", "constructMenu", "(", "JMenu", "topMenu", ")", "{", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\"Debug.constructMenu \"", ")", ";", "if", "(", "topMenu", ".", "getItemCount", "(", ")", ">", "0", ")", "topMenu", ".", "removeAll", "(", ")", ";", "try", "{", "addToMenu", "(", "topMenu", ",", "store", ")", ";", "// recursive", "}", "catch", "(", "BackingStoreException", "e", ")", "{", "}", "topMenu", ".", "revalidate", "(", ")", ";", "}"], "docstring": "Construct cascading pull-aside menus using the values of the debug flags\nin the Preferences object.\n@param topMenu attach the menus as children of this one.", "docstring_tokens": ["Construct", "cascading", "pull", "-", "aside", "menus", "using", "the", "values", "of", "the", "debug", "flags", "in", "the", "Preferences", "object", "."]}
{"code": "menu.add(new DebugMenuItem(fullname, key, bval));", "comments": "menu leaf", "lines": 8, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/util/prefs/ui/Debug.java", "func_name": "Debug.addToMenu", "original_string": "static private void addToMenu( JMenu menu, Preferences prefs) throws BackingStoreException {\n    if (debug) System.out.println(\" addMenu \"+ prefs.name());\n\n    String[] keys = prefs.keys();\n    for (String key : keys) {\n      boolean bval = prefs.getBoolean(key, false);\n      String fullname = prefs.absolutePath() + \"/\" + key;\n      menu.add(new DebugMenuItem(fullname, key, bval)); // menu leaf\n      if (debug) System.out.println(\"   leaf= <\" + key + \"><\" + fullname + \">\");\n    }\n\n    String[] kidName = prefs.childrenNames();\n    for (String aKidName : kidName) {\n      Preferences pkid = prefs.node(aKidName);\n      JMenu subMenu = new JMenu(pkid.name());\n      menu.add(subMenu);\n      addToMenu(subMenu, pkid);\n    }\n  }", "language": "java", "Allcodes": "static private void addToMenu( JMenu menu, Preferences prefs) throws BackingStoreException {\n    if (debug) System.out.println(\" addMenu \"+ prefs.name());\n\n    String[] keys = prefs.keys();\n    for (String key : keys) {\n      boolean bval = prefs.getBoolean(key, false);\n      String fullname = prefs.absolutePath() + \"/\" + key;\n      menu.add(new DebugMenuItem(fullname, key, bval)); // menu leaf\n      if (debug) System.out.println(\"   leaf= <\" + key + \"><\" + fullname + \">\");\n    }\n\n    String[] kidName = prefs.childrenNames();\n    for (String aKidName : kidName) {\n      Preferences pkid = prefs.node(aKidName);\n      JMenu subMenu = new JMenu(pkid.name());\n      menu.add(subMenu);\n      addToMenu(subMenu, pkid);\n    }\n  }", "code_tokens": ["static", "private", "void", "addToMenu", "(", "JMenu", "menu", ",", "Preferences", "prefs", ")", "throws", "BackingStoreException", "{", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\" addMenu \"", "+", "prefs", ".", "name", "(", ")", ")", ";", "String", "[", "]", "keys", "=", "prefs", ".", "keys", "(", ")", ";", "for", "(", "String", "key", ":", "keys", ")", "{", "boolean", "bval", "=", "prefs", ".", "getBoolean", "(", "key", ",", "false", ")", ";", "String", "fullname", "=", "prefs", ".", "absolutePath", "(", ")", "+", "\"/\"", "+", "key", ";", "menu", ".", "add", "(", "new", "DebugMenuItem", "(", "fullname", ",", "key", ",", "bval", ")", ")", ";", "// menu leaf", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\"   leaf= <\"", "+", "key", "+", "\"><\"", "+", "fullname", "+", "\">\"", ")", ";", "}", "String", "[", "]", "kidName", "=", "prefs", ".", "childrenNames", "(", ")", ";", "for", "(", "String", "aKidName", ":", "kidName", ")", "{", "Preferences", "pkid", "=", "prefs", ".", "node", "(", "aKidName", ")", ";", "JMenu", "subMenu", "=", "new", "JMenu", "(", "pkid", ".", "name", "(", ")", ")", ";", "menu", ".", "add", "(", "subMenu", ")", ";", "addToMenu", "(", "subMenu", ",", "pkid", ")", ";", "}", "}"], "docstring": "recursive menu adding", "docstring_tokens": ["recursive", "menu", "adding"]}
{"code": "String content = readContents(is);", "comments": "LOOK this is silly - should just read one line at a time", "lines": 6, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/gempak/GempakParameterTable.java", "func_name": "GempakParameterTable.addParameters", "original_string": "public void addParameters(String tbl) throws IOException {\r\n    try (InputStream is = getInputStream(tbl)) {\r\n      if (is == null) {\r\n        throw new IOException(\"Unable to open \" + tbl);\r\n      }\r\n      String content = readContents(is);   // LOOK this is silly - should just read one line at a time\r\n      // List           lines   = StringUtil.split(content, \"\\n\", false);\r\n      String[] lines = content.split(\"\\n\");\r\n      List<String[]> result = new ArrayList<>();\r\n      for (String line : lines) {\r\n        //String line  = (String) lines.get(i);\r\n        String tline = line.trim();\r\n        if (tline.length() == 0) {\r\n          continue;\r\n        }\r\n        if (tline.startsWith(\"!\")) {\r\n          continue;\r\n        }\r\n        String[] words = new String[indices.length];\r\n        for (int idx = 0; idx < indices.length; idx++) {\r\n          if (indices[idx] >= tline.length()) {\r\n            continue;\r\n          }\r\n          if (indices[idx] + lengths[idx] > tline.length()) {\r\n            words[idx] = line.substring(indices[idx]);\r\n          } else {\r\n            words[idx] = line.substring(indices[idx],\r\n                    indices[idx] + lengths[idx]);\r\n          }\r\n          //if (trimWords) {\r\n          words[idx] = words[idx].trim();\r\n          //}\r\n        }\r\n        result.add(words);\r\n      }\r\n      for (String[] aResult : result) {\r\n        GempakParameter p = makeParameter(aResult);\r\n        if (p != null) {\r\n          if (p.getName().contains(\"(\")) {\r\n            templateParamMap.put(p.getName(), p);\r\n          } else {\r\n            paramMap.put(p.getName(), p);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  }", "language": "java", "Allcodes": "public void addParameters(String tbl) throws IOException {\r\n    try (InputStream is = getInputStream(tbl)) {\r\n      if (is == null) {\r\n        throw new IOException(\"Unable to open \" + tbl);\r\n      }\r\n      String content = readContents(is);   // LOOK this is silly - should just read one line at a time\r\n      // List           lines   = StringUtil.split(content, \"\\n\", false);\r\n      String[] lines = content.split(\"\\n\");\r\n      List<String[]> result = new ArrayList<>();\r\n      for (String line : lines) {\r\n        //String line  = (String) lines.get(i);\r\n        String tline = line.trim();\r\n        if (tline.length() == 0) {\r\n          continue;\r\n        }\r\n        if (tline.startsWith(\"!\")) {\r\n          continue;\r\n        }\r\n        String[] words = new String[indices.length];\r\n        for (int idx = 0; idx < indices.length; idx++) {\r\n          if (indices[idx] >= tline.length()) {\r\n            continue;\r\n          }\r\n          if (indices[idx] + lengths[idx] > tline.length()) {\r\n            words[idx] = line.substring(indices[idx]);\r\n          } else {\r\n            words[idx] = line.substring(indices[idx],\r\n                    indices[idx] + lengths[idx]);\r\n          }\r\n          //if (trimWords) {\r\n          words[idx] = words[idx].trim();\r\n          //}\r\n        }\r\n        result.add(words);\r\n      }\r\n      for (String[] aResult : result) {\r\n        GempakParameter p = makeParameter(aResult);\r\n        if (p != null) {\r\n          if (p.getName().contains(\"(\")) {\r\n            templateParamMap.put(p.getName(), p);\r\n          } else {\r\n            paramMap.put(p.getName(), p);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  }", "code_tokens": ["public", "void", "addParameters", "(", "String", "tbl", ")", "throws", "IOException", "{", "try", "(", "InputStream", "is", "=", "getInputStream", "(", "tbl", ")", ")", "{", "if", "(", "is", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"Unable to open \"", "+", "tbl", ")", ";", "}", "String", "content", "=", "readContents", "(", "is", ")", ";", "// LOOK this is silly - should just read one line at a time\r", "// List           lines   = StringUtil.split(content, \"\\n\", false);\r", "String", "[", "]", "lines", "=", "content", ".", "split", "(", "\"\\n\"", ")", ";", "List", "<", "String", "[", "]", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "String", "line", ":", "lines", ")", "{", "//String line  = (String) lines.get(i);\r", "String", "tline", "=", "line", ".", "trim", "(", ")", ";", "if", "(", "tline", ".", "length", "(", ")", "==", "0", ")", "{", "continue", ";", "}", "if", "(", "tline", ".", "startsWith", "(", "\"!\"", ")", ")", "{", "continue", ";", "}", "String", "[", "]", "words", "=", "new", "String", "[", "indices", ".", "length", "]", ";", "for", "(", "int", "idx", "=", "0", ";", "idx", "<", "indices", ".", "length", ";", "idx", "++", ")", "{", "if", "(", "indices", "[", "idx", "]", ">=", "tline", ".", "length", "(", ")", ")", "{", "continue", ";", "}", "if", "(", "indices", "[", "idx", "]", "+", "lengths", "[", "idx", "]", ">", "tline", ".", "length", "(", ")", ")", "{", "words", "[", "idx", "]", "=", "line", ".", "substring", "(", "indices", "[", "idx", "]", ")", ";", "}", "else", "{", "words", "[", "idx", "]", "=", "line", ".", "substring", "(", "indices", "[", "idx", "]", ",", "indices", "[", "idx", "]", "+", "lengths", "[", "idx", "]", ")", ";", "}", "//if (trimWords) {\r", "words", "[", "idx", "]", "=", "words", "[", "idx", "]", ".", "trim", "(", ")", ";", "//}\r", "}", "result", ".", "add", "(", "words", ")", ";", "}", "for", "(", "String", "[", "]", "aResult", ":", "result", ")", "{", "GempakParameter", "p", "=", "makeParameter", "(", "aResult", ")", ";", "if", "(", "p", "!=", "null", ")", "{", "if", "(", "p", ".", "getName", "(", ")", ".", "contains", "(", "\"(\"", ")", ")", "{", "templateParamMap", ".", "put", "(", "p", ".", "getName", "(", ")", ",", "p", ")", ";", "}", "else", "{", "paramMap", ".", "put", "(", "p", ".", "getName", "(", ")", ",", "p", ")", ";", "}", "}", "}", "}", "}"], "docstring": "Add parameters from the table\n\n@param tbl table location\n@throws IOException problem reading table.", "docstring_tokens": ["Add", "parameters", "from", "the", "table"]}
{"code": "AttributeTable table = das.getAttributeTableN(v.getFullName());", "comments": "LOOK this probably doesnt work for nested variables", "lines": 2, "repo": "Unidata/thredds", "path": "opendap/src/main/java/ucar/nc2/dods/DODSNetcdfFile.java", "func_name": "DODSNetcdfFile.getNetcdfStrlenDim", "original_string": "Dimension getNetcdfStrlenDim(DODSVariable v) {\n    AttributeTable table = das.getAttributeTableN(v.getFullName()); // LOOK this probably doesnt work for nested variables\n    if (table == null) return null;\n\n    opendap.dap.Attribute dodsAtt = table.getAttribute(\"DODS\");\n    if (dodsAtt == null) return null;\n\n    AttributeTable dodsTable = dodsAtt.getContainerN();\n    if (dodsTable == null) return null;\n\n    opendap.dap.Attribute att = dodsTable.getAttribute(\"strlen\");\n    if (att == null) return null;\n    String strlen = att.getValueAtN(0);\n\n    opendap.dap.Attribute att2 = dodsTable.getAttribute(\"dimName\");\n    String dimName = (att2 == null) ? null : att2.getValueAtN(0);\n    if (debugCharArray) System.out.println(v.getFullName() + \" has strlen= \" + strlen + \" dimName= \" + dimName);\n\n    int dimLength;\n    try {\n      dimLength = Integer.parseInt(strlen);\n    } catch (NumberFormatException e) {\n      logger.warn(\"DODSNetcdfFile \" + location + \" var = \" + v.getFullName() + \" error on strlen attribute = \" + strlen);\n      return null;\n    }\n\n    if (dimLength <= 0) return null; // LOOK what about unlimited ??\n    return new Dimension(dimName, dimLength, dimName != null);\n  }", "language": "java", "Allcodes": "Dimension getNetcdfStrlenDim(DODSVariable v) {\n    AttributeTable table = das.getAttributeTableN(v.getFullName()); // LOOK this probably doesnt work for nested variables\n    if (table == null) return null;\n\n    opendap.dap.Attribute dodsAtt = table.getAttribute(\"DODS\");\n    if (dodsAtt == null) return null;\n\n    AttributeTable dodsTable = dodsAtt.getContainerN();\n    if (dodsTable == null) return null;\n\n    opendap.dap.Attribute att = dodsTable.getAttribute(\"strlen\");\n    if (att == null) return null;\n    String strlen = att.getValueAtN(0);\n\n    opendap.dap.Attribute att2 = dodsTable.getAttribute(\"dimName\");\n    String dimName = (att2 == null) ? null : att2.getValueAtN(0);\n    if (debugCharArray) System.out.println(v.getFullName() + \" has strlen= \" + strlen + \" dimName= \" + dimName);\n\n    int dimLength;\n    try {\n      dimLength = Integer.parseInt(strlen);\n    } catch (NumberFormatException e) {\n      logger.warn(\"DODSNetcdfFile \" + location + \" var = \" + v.getFullName() + \" error on strlen attribute = \" + strlen);\n      return null;\n    }\n\n    if (dimLength <= 0) return null; // LOOK what about unlimited ??\n    return new Dimension(dimName, dimLength, dimName != null);\n  }", "code_tokens": ["Dimension", "getNetcdfStrlenDim", "(", "DODSVariable", "v", ")", "{", "AttributeTable", "table", "=", "das", ".", "getAttributeTableN", "(", "v", ".", "getFullName", "(", ")", ")", ";", "// LOOK this probably doesnt work for nested variables", "if", "(", "table", "==", "null", ")", "return", "null", ";", "opendap", ".", "dap", ".", "Attribute", "dodsAtt", "=", "table", ".", "getAttribute", "(", "\"DODS\"", ")", ";", "if", "(", "dodsAtt", "==", "null", ")", "return", "null", ";", "AttributeTable", "dodsTable", "=", "dodsAtt", ".", "getContainerN", "(", ")", ";", "if", "(", "dodsTable", "==", "null", ")", "return", "null", ";", "opendap", ".", "dap", ".", "Attribute", "att", "=", "dodsTable", ".", "getAttribute", "(", "\"strlen\"", ")", ";", "if", "(", "att", "==", "null", ")", "return", "null", ";", "String", "strlen", "=", "att", ".", "getValueAtN", "(", "0", ")", ";", "opendap", ".", "dap", ".", "Attribute", "att2", "=", "dodsTable", ".", "getAttribute", "(", "\"dimName\"", ")", ";", "String", "dimName", "=", "(", "att2", "==", "null", ")", "?", "null", ":", "att2", ".", "getValueAtN", "(", "0", ")", ";", "if", "(", "debugCharArray", ")", "System", ".", "out", ".", "println", "(", "v", ".", "getFullName", "(", ")", "+", "\" has strlen= \"", "+", "strlen", "+", "\" dimName= \"", "+", "dimName", ")", ";", "int", "dimLength", ";", "try", "{", "dimLength", "=", "Integer", ".", "parseInt", "(", "strlen", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "logger", ".", "warn", "(", "\"DODSNetcdfFile \"", "+", "location", "+", "\" var = \"", "+", "v", ".", "getFullName", "(", ")", "+", "\" error on strlen attribute = \"", "+", "strlen", ")", ";", "return", "null", ";", "}", "if", "(", "dimLength", "<=", "0", ")", "return", "null", ";", "// LOOK what about unlimited ??", "return", "new", "Dimension", "(", "dimName", ",", "dimLength", ",", "dimName", "!=", "null", ")", ";", "}"], "docstring": "Checks to see if this is netcdf char array.\n\n@param v must be type STRING\n@return string length dimension, else null", "docstring_tokens": ["Checks", "to", "see", "if", "this", "is", "netcdf", "char", "array", "."]}
{"code": "if (dimLength <= 0) return null;", "comments": "LOOK what about unlimited ??", "lines": 27, "repo": "Unidata/thredds", "path": "opendap/src/main/java/ucar/nc2/dods/DODSNetcdfFile.java", "func_name": "DODSNetcdfFile.getNetcdfStrlenDim", "original_string": "Dimension getNetcdfStrlenDim(DODSVariable v) {\n    AttributeTable table = das.getAttributeTableN(v.getFullName()); // LOOK this probably doesnt work for nested variables\n    if (table == null) return null;\n\n    opendap.dap.Attribute dodsAtt = table.getAttribute(\"DODS\");\n    if (dodsAtt == null) return null;\n\n    AttributeTable dodsTable = dodsAtt.getContainerN();\n    if (dodsTable == null) return null;\n\n    opendap.dap.Attribute att = dodsTable.getAttribute(\"strlen\");\n    if (att == null) return null;\n    String strlen = att.getValueAtN(0);\n\n    opendap.dap.Attribute att2 = dodsTable.getAttribute(\"dimName\");\n    String dimName = (att2 == null) ? null : att2.getValueAtN(0);\n    if (debugCharArray) System.out.println(v.getFullName() + \" has strlen= \" + strlen + \" dimName= \" + dimName);\n\n    int dimLength;\n    try {\n      dimLength = Integer.parseInt(strlen);\n    } catch (NumberFormatException e) {\n      logger.warn(\"DODSNetcdfFile \" + location + \" var = \" + v.getFullName() + \" error on strlen attribute = \" + strlen);\n      return null;\n    }\n\n    if (dimLength <= 0) return null; // LOOK what about unlimited ??\n    return new Dimension(dimName, dimLength, dimName != null);\n  }", "language": "java", "Allcodes": "Dimension getNetcdfStrlenDim(DODSVariable v) {\n    AttributeTable table = das.getAttributeTableN(v.getFullName()); // LOOK this probably doesnt work for nested variables\n    if (table == null) return null;\n\n    opendap.dap.Attribute dodsAtt = table.getAttribute(\"DODS\");\n    if (dodsAtt == null) return null;\n\n    AttributeTable dodsTable = dodsAtt.getContainerN();\n    if (dodsTable == null) return null;\n\n    opendap.dap.Attribute att = dodsTable.getAttribute(\"strlen\");\n    if (att == null) return null;\n    String strlen = att.getValueAtN(0);\n\n    opendap.dap.Attribute att2 = dodsTable.getAttribute(\"dimName\");\n    String dimName = (att2 == null) ? null : att2.getValueAtN(0);\n    if (debugCharArray) System.out.println(v.getFullName() + \" has strlen= \" + strlen + \" dimName= \" + dimName);\n\n    int dimLength;\n    try {\n      dimLength = Integer.parseInt(strlen);\n    } catch (NumberFormatException e) {\n      logger.warn(\"DODSNetcdfFile \" + location + \" var = \" + v.getFullName() + \" error on strlen attribute = \" + strlen);\n      return null;\n    }\n\n    if (dimLength <= 0) return null; // LOOK what about unlimited ??\n    return new Dimension(dimName, dimLength, dimName != null);\n  }", "code_tokens": ["Dimension", "getNetcdfStrlenDim", "(", "DODSVariable", "v", ")", "{", "AttributeTable", "table", "=", "das", ".", "getAttributeTableN", "(", "v", ".", "getFullName", "(", ")", ")", ";", "// LOOK this probably doesnt work for nested variables", "if", "(", "table", "==", "null", ")", "return", "null", ";", "opendap", ".", "dap", ".", "Attribute", "dodsAtt", "=", "table", ".", "getAttribute", "(", "\"DODS\"", ")", ";", "if", "(", "dodsAtt", "==", "null", ")", "return", "null", ";", "AttributeTable", "dodsTable", "=", "dodsAtt", ".", "getContainerN", "(", ")", ";", "if", "(", "dodsTable", "==", "null", ")", "return", "null", ";", "opendap", ".", "dap", ".", "Attribute", "att", "=", "dodsTable", ".", "getAttribute", "(", "\"strlen\"", ")", ";", "if", "(", "att", "==", "null", ")", "return", "null", ";", "String", "strlen", "=", "att", ".", "getValueAtN", "(", "0", ")", ";", "opendap", ".", "dap", ".", "Attribute", "att2", "=", "dodsTable", ".", "getAttribute", "(", "\"dimName\"", ")", ";", "String", "dimName", "=", "(", "att2", "==", "null", ")", "?", "null", ":", "att2", ".", "getValueAtN", "(", "0", ")", ";", "if", "(", "debugCharArray", ")", "System", ".", "out", ".", "println", "(", "v", ".", "getFullName", "(", ")", "+", "\" has strlen= \"", "+", "strlen", "+", "\" dimName= \"", "+", "dimName", ")", ";", "int", "dimLength", ";", "try", "{", "dimLength", "=", "Integer", ".", "parseInt", "(", "strlen", ")", ";", "}", "catch", "(", "NumberFormatException", "e", ")", "{", "logger", ".", "warn", "(", "\"DODSNetcdfFile \"", "+", "location", "+", "\" var = \"", "+", "v", ".", "getFullName", "(", ")", "+", "\" error on strlen attribute = \"", "+", "strlen", ")", ";", "return", "null", ";", "}", "if", "(", "dimLength", "<=", "0", ")", "return", "null", ";", "// LOOK what about unlimited ??", "return", "new", "Dimension", "(", "dimName", ",", "dimLength", ",", "dimName", "!=", "null", ")", ";", "}"], "docstring": "Checks to see if this is netcdf char array.\n\n@param v must be type STRING\n@return string length dimension, else null", "docstring_tokens": ["Checks", "to", "see", "if", "this", "is", "netcdf", "char", "array", "."]}
{"code": "dims.add(myd);", "comments": "add it to the list", "lines": 33, "repo": "Unidata/thredds", "path": "opendap/src/main/java/ucar/nc2/dods/DODSNetcdfFile.java", "func_name": "DODSNetcdfFile.constructDimensions", "original_string": "List<Dimension> constructDimensions(Group group, opendap.dap.DArray dodsArray) {\n    if (group == null) group = rootGroup;\n\n    List<Dimension> dims = new ArrayList<Dimension>();\n    Enumeration enumerate = dodsArray.getDimensions();\n    while (enumerate.hasMoreElements()) {\n      opendap.dap.DArrayDimension dad = (opendap.dap.DArrayDimension) enumerate.nextElement();\n      String name = dad.getEncodedName();\n      if (name != null)\n        name = StringUtil2.unescape(name);\n\n      Dimension myd;\n\n      if (name == null) { // if no name, make an anonymous dimension\n        myd = new Dimension(null, dad.getSize(), false);\n\n      } else { // see if shared\n        if (RC.getUseGroups()) {\n          if (name.indexOf('/') >= 0) {// place dimension in proper group\n            group = group.makeRelativeGroup(this, name, true);\n            // change our name\n            name = name.substring(name.lastIndexOf('/') + 1);\n          }\n        }\n        myd = group.findDimension(name);\n        if (myd == null) { // add as shared\n          myd = new Dimension(name, dad.getSize());\n          group.addDimension(myd);\n        } else if (myd.getLength() != dad.getSize()) { // make a non-shared dimension\n          myd = new Dimension(name, dad.getSize(), false);\n        } // else use existing, shared dimension\n      }\n      dims.add(myd); // add it to the list\n    }\n\n    return dims;\n  }", "language": "java", "Allcodes": "List<Dimension> constructDimensions(Group group, opendap.dap.DArray dodsArray) {\n    if (group == null) group = rootGroup;\n\n    List<Dimension> dims = new ArrayList<Dimension>();\n    Enumeration enumerate = dodsArray.getDimensions();\n    while (enumerate.hasMoreElements()) {\n      opendap.dap.DArrayDimension dad = (opendap.dap.DArrayDimension) enumerate.nextElement();\n      String name = dad.getEncodedName();\n      if (name != null)\n        name = StringUtil2.unescape(name);\n\n      Dimension myd;\n\n      if (name == null) { // if no name, make an anonymous dimension\n        myd = new Dimension(null, dad.getSize(), false);\n\n      } else { // see if shared\n        if (RC.getUseGroups()) {\n          if (name.indexOf('/') >= 0) {// place dimension in proper group\n            group = group.makeRelativeGroup(this, name, true);\n            // change our name\n            name = name.substring(name.lastIndexOf('/') + 1);\n          }\n        }\n        myd = group.findDimension(name);\n        if (myd == null) { // add as shared\n          myd = new Dimension(name, dad.getSize());\n          group.addDimension(myd);\n        } else if (myd.getLength() != dad.getSize()) { // make a non-shared dimension\n          myd = new Dimension(name, dad.getSize(), false);\n        } // else use existing, shared dimension\n      }\n      dims.add(myd); // add it to the list\n    }\n\n    return dims;\n  }", "code_tokens": ["List", "<", "Dimension", ">", "constructDimensions", "(", "Group", "group", ",", "opendap", ".", "dap", ".", "DArray", "dodsArray", ")", "{", "if", "(", "group", "==", "null", ")", "group", "=", "rootGroup", ";", "List", "<", "Dimension", ">", "dims", "=", "new", "ArrayList", "<", "Dimension", ">", "(", ")", ";", "Enumeration", "enumerate", "=", "dodsArray", ".", "getDimensions", "(", ")", ";", "while", "(", "enumerate", ".", "hasMoreElements", "(", ")", ")", "{", "opendap", ".", "dap", ".", "DArrayDimension", "dad", "=", "(", "opendap", ".", "dap", ".", "DArrayDimension", ")", "enumerate", ".", "nextElement", "(", ")", ";", "String", "name", "=", "dad", ".", "getEncodedName", "(", ")", ";", "if", "(", "name", "!=", "null", ")", "name", "=", "StringUtil2", ".", "unescape", "(", "name", ")", ";", "Dimension", "myd", ";", "if", "(", "name", "==", "null", ")", "{", "// if no name, make an anonymous dimension", "myd", "=", "new", "Dimension", "(", "null", ",", "dad", ".", "getSize", "(", ")", ",", "false", ")", ";", "}", "else", "{", "// see if shared", "if", "(", "RC", ".", "getUseGroups", "(", ")", ")", "{", "if", "(", "name", ".", "indexOf", "(", "'", "'", ")", ">=", "0", ")", "{", "// place dimension in proper group", "group", "=", "group", ".", "makeRelativeGroup", "(", "this", ",", "name", ",", "true", ")", ";", "// change our name", "name", "=", "name", ".", "substring", "(", "name", ".", "lastIndexOf", "(", "'", "'", ")", "+", "1", ")", ";", "}", "}", "myd", "=", "group", ".", "findDimension", "(", "name", ")", ";", "if", "(", "myd", "==", "null", ")", "{", "// add as shared", "myd", "=", "new", "Dimension", "(", "name", ",", "dad", ".", "getSize", "(", ")", ")", ";", "group", ".", "addDimension", "(", "myd", ")", ";", "}", "else", "if", "(", "myd", ".", "getLength", "(", ")", "!=", "dad", ".", "getSize", "(", ")", ")", "{", "// make a non-shared dimension", "myd", "=", "new", "Dimension", "(", "name", ",", "dad", ".", "getSize", "(", ")", ",", "false", ")", ";", "}", "// else use existing, shared dimension", "}", "dims", ".", "add", "(", "myd", ")", ";", "// add it to the list", "}", "return", "dims", ";", "}"], "docstring": "construct list of dimensions to use", "docstring_tokens": ["construct", "list", "of", "dimensions", "to", "use"]}
{"code": "cbuff[i] = (char) DataType.unsignedByteToShort(byteArray[i]);", "comments": "NOTE: not Unicode !", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/IospHelper.java", "func_name": "IospHelper.convertByteToChar", "original_string": "static public char[] convertByteToChar(byte[] byteArray) {\r\n    int size = byteArray.length;\r\n    char[] cbuff = new char[size];\r\n    for (int i = 0; i < size; i++)\r\n      cbuff[i] = (char) DataType.unsignedByteToShort(byteArray[i]); // NOTE: not Unicode !\r\n    return cbuff;\r\n  }\r\n\r\n  // convert char array to byte array\r\n\r\n  static public byte[] convertCharToByte(char[] from) {\r\n    byte[] to = null;\r\n    if (from != null) {\r\n      int size = from.length;\r\n      to = new byte[size];\r\n      for (int i = 0; i < size; i++)\r\n        to[i] = (byte) from[i]; // LOOK wrong, convert back to unsigned byte ???\r\n    }\r\n    return to;\r\n  }", "language": "java", "Allcodes": "static public char[] convertByteToChar(byte[] byteArray) {\r\n    int size = byteArray.length;\r\n    char[] cbuff = new char[size];\r\n    for (int i = 0; i < size; i++)\r\n      cbuff[i] = (char) DataType.unsignedByteToShort(byteArray[i]); // NOTE: not Unicode !\r\n    return cbuff;\r\n  }\r\n\r\n  // convert char array to byte array\r\n\r\n  static public byte[] convertCharToByte(char[] from) {\r\n    byte[] to = null;\r\n    if (from != null) {\r\n      int size = from.length;\r\n      to = new byte[size];\r\n      for (int i = 0; i < size; i++)\r\n        to[i] = (byte) from[i]; // LOOK wrong, convert back to unsigned byte ???\r\n    }\r\n    return to;\r\n  }", "code_tokens": ["static", "public", "char", "[", "]", "convertByteToChar", "(", "byte", "[", "]", "byteArray", ")", "{", "int", "size", "=", "byteArray", ".", "length", ";", "char", "[", "]", "cbuff", "=", "new", "char", "[", "size", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "size", ";", "i", "++", ")", "cbuff", "[", "i", "]", "=", "(", "char", ")", "DataType", ".", "unsignedByteToShort", "(", "byteArray", "[", "i", "]", ")", ";", "// NOTE: not Unicode !\r", "return", "cbuff", ";", "}", "// convert char array to byte array\r", "static", "public", "byte", "[", "]", "convertCharToByte", "(", "char", "[", "]", "from", ")", "{", "byte", "[", "]", "to", "=", "null", ";", "if", "(", "from", "!=", "null", ")", "{", "int", "size", "=", "from", ".", "length", ";", "to", "=", "new", "byte", "[", "size", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "size", ";", "i", "++", ")", "to", "[", "i", "]", "=", "(", "byte", ")", "from", "[", "i", "]", ";", "// LOOK wrong, convert back to unsigned byte ???\r", "}", "return", "to", ";", "}"], "docstring": "convert byte array to char array", "docstring_tokens": ["convert", "byte", "array", "to", "char", "array"]}
{"code": "to[i] = (byte) from[i];", "comments": "LOOK wrong, convert back to unsigned byte ???", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/IospHelper.java", "func_name": "IospHelper.convertByteToChar", "original_string": "static public char[] convertByteToChar(byte[] byteArray) {\r\n    int size = byteArray.length;\r\n    char[] cbuff = new char[size];\r\n    for (int i = 0; i < size; i++)\r\n      cbuff[i] = (char) DataType.unsignedByteToShort(byteArray[i]); // NOTE: not Unicode !\r\n    return cbuff;\r\n  }\r\n\r\n  // convert char array to byte array\r\n\r\n  static public byte[] convertCharToByte(char[] from) {\r\n    byte[] to = null;\r\n    if (from != null) {\r\n      int size = from.length;\r\n      to = new byte[size];\r\n      for (int i = 0; i < size; i++)\r\n        to[i] = (byte) from[i]; // LOOK wrong, convert back to unsigned byte ???\r\n    }\r\n    return to;\r\n  }", "language": "java", "Allcodes": "static public char[] convertByteToChar(byte[] byteArray) {\r\n    int size = byteArray.length;\r\n    char[] cbuff = new char[size];\r\n    for (int i = 0; i < size; i++)\r\n      cbuff[i] = (char) DataType.unsignedByteToShort(byteArray[i]); // NOTE: not Unicode !\r\n    return cbuff;\r\n  }\r\n\r\n  // convert char array to byte array\r\n\r\n  static public byte[] convertCharToByte(char[] from) {\r\n    byte[] to = null;\r\n    if (from != null) {\r\n      int size = from.length;\r\n      to = new byte[size];\r\n      for (int i = 0; i < size; i++)\r\n        to[i] = (byte) from[i]; // LOOK wrong, convert back to unsigned byte ???\r\n    }\r\n    return to;\r\n  }", "code_tokens": ["static", "public", "char", "[", "]", "convertByteToChar", "(", "byte", "[", "]", "byteArray", ")", "{", "int", "size", "=", "byteArray", ".", "length", ";", "char", "[", "]", "cbuff", "=", "new", "char", "[", "size", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "size", ";", "i", "++", ")", "cbuff", "[", "i", "]", "=", "(", "char", ")", "DataType", ".", "unsignedByteToShort", "(", "byteArray", "[", "i", "]", ")", ";", "// NOTE: not Unicode !\r", "return", "cbuff", ";", "}", "// convert char array to byte array\r", "static", "public", "byte", "[", "]", "convertCharToByte", "(", "char", "[", "]", "from", ")", "{", "byte", "[", "]", "to", "=", "null", ";", "if", "(", "from", "!=", "null", ")", "{", "int", "size", "=", "from", ".", "length", ";", "to", "=", "new", "byte", "[", "size", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "size", ";", "i", "++", ")", "to", "[", "i", "]", "=", "(", "byte", ")", "from", "[", "i", "]", ";", "// LOOK wrong, convert back to unsigned byte ???\r", "}", "return", "to", ";", "}"], "docstring": "convert byte array to char array", "docstring_tokens": ["convert", "byte", "array", "to", "char", "array"]}
{"code": "Structure outerSubset = outer.select(cer.child.v.getShortName());", "comments": "allows IOSPs to optimize for  this case", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/IospHelper.java", "func_name": "IospHelper.readSection", "original_string": "static public ucar.ma2.Array readSection(ParsedSectionSpec cer) throws IOException, InvalidRangeException {\r\n    Variable inner = null;\r\n    List<Range> totalRanges = new ArrayList<>();\r\n    ParsedSectionSpec current = cer;\r\n    while (current != null) {\r\n      totalRanges.addAll(current.section.getRanges());\r\n      inner = current.v;\r\n      current = current.child;\r\n    }\r\n    assert inner != null;\r\n\r\n    Section total = new Section(totalRanges);\r\n    Array result = Array.factory(inner.getDataType(), total.getShape());\r\n\r\n    // must be a Structure\r\n    Structure outer = (Structure) cer.v;\r\n    Structure outerSubset = outer.select(cer.child.v.getShortName()); // allows IOSPs to optimize for  this case\r\n    ArrayStructure outerData = (ArrayStructure) outerSubset.read(cer.section);\r\n    extractSection(cer.child, outerData, result.getIndexIterator());\r\n    return result;\r\n  }", "language": "java", "Allcodes": "static public ucar.ma2.Array readSection(ParsedSectionSpec cer) throws IOException, InvalidRangeException {\r\n    Variable inner = null;\r\n    List<Range> totalRanges = new ArrayList<>();\r\n    ParsedSectionSpec current = cer;\r\n    while (current != null) {\r\n      totalRanges.addAll(current.section.getRanges());\r\n      inner = current.v;\r\n      current = current.child;\r\n    }\r\n    assert inner != null;\r\n\r\n    Section total = new Section(totalRanges);\r\n    Array result = Array.factory(inner.getDataType(), total.getShape());\r\n\r\n    // must be a Structure\r\n    Structure outer = (Structure) cer.v;\r\n    Structure outerSubset = outer.select(cer.child.v.getShortName()); // allows IOSPs to optimize for  this case\r\n    ArrayStructure outerData = (ArrayStructure) outerSubset.read(cer.section);\r\n    extractSection(cer.child, outerData, result.getIndexIterator());\r\n    return result;\r\n  }", "code_tokens": ["static", "public", "ucar", ".", "ma2", ".", "Array", "readSection", "(", "ParsedSectionSpec", "cer", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "Variable", "inner", "=", "null", ";", "List", "<", "Range", ">", "totalRanges", "=", "new", "ArrayList", "<>", "(", ")", ";", "ParsedSectionSpec", "current", "=", "cer", ";", "while", "(", "current", "!=", "null", ")", "{", "totalRanges", ".", "addAll", "(", "current", ".", "section", ".", "getRanges", "(", ")", ")", ";", "inner", "=", "current", ".", "v", ";", "current", "=", "current", ".", "child", ";", "}", "assert", "inner", "!=", "null", ";", "Section", "total", "=", "new", "Section", "(", "totalRanges", ")", ";", "Array", "result", "=", "Array", ".", "factory", "(", "inner", ".", "getDataType", "(", ")", ",", "total", ".", "getShape", "(", ")", ")", ";", "// must be a Structure\r", "Structure", "outer", "=", "(", "Structure", ")", "cer", ".", "v", ";", "Structure", "outerSubset", "=", "outer", ".", "select", "(", "cer", ".", "child", ".", "v", ".", "getShortName", "(", ")", ")", ";", "// allows IOSPs to optimize for  this case\r", "ArrayStructure", "outerData", "=", "(", "ArrayStructure", ")", "outerSubset", ".", "read", "(", "cer", ".", "section", ")", ";", "extractSection", "(", "cer", ".", "child", ",", "outerData", ",", "result", ".", "getIndexIterator", "(", ")", ")", ";", "return", "result", ";", "}"], "docstring": "section reading for member data", "docstring_tokens": ["section", "reading", "for", "member", "data"]}
{"code": "StructureMembers membersw = new StructureMembers(m.getStructureMembers());", "comments": "no data arrays get propagated", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/IospHelper.java", "func_name": "IospHelper.sectionArrayStructure", "original_string": "static private ArrayStructure sectionArrayStructure(ParsedSectionSpec child, ArrayStructure innerData, StructureMembers.Member m) throws IOException, InvalidRangeException {\r\n    StructureMembers membersw = new StructureMembers(m.getStructureMembers()); // no data arrays get propagated\r\n    ArrayStructureW result = new ArrayStructureW(membersw, child.section.getShape());\r\n\r\n    int count = 0;\r\n    Section.Iterator iter = child.section.getIterator(child.v.getShape());\r\n    while (iter.hasNext()) {\r\n      int recno = iter.next(null);\r\n      StructureData sd = innerData.getStructureData(recno);\r\n      result.setStructureData(sd, count++);\r\n    }\r\n\r\n    return result;\r\n  }", "language": "java", "Allcodes": "static private ArrayStructure sectionArrayStructure(ParsedSectionSpec child, ArrayStructure innerData, StructureMembers.Member m) throws IOException, InvalidRangeException {\r\n    StructureMembers membersw = new StructureMembers(m.getStructureMembers()); // no data arrays get propagated\r\n    ArrayStructureW result = new ArrayStructureW(membersw, child.section.getShape());\r\n\r\n    int count = 0;\r\n    Section.Iterator iter = child.section.getIterator(child.v.getShape());\r\n    while (iter.hasNext()) {\r\n      int recno = iter.next(null);\r\n      StructureData sd = innerData.getStructureData(recno);\r\n      result.setStructureData(sd, count++);\r\n    }\r\n\r\n    return result;\r\n  }", "code_tokens": ["static", "private", "ArrayStructure", "sectionArrayStructure", "(", "ParsedSectionSpec", "child", ",", "ArrayStructure", "innerData", ",", "StructureMembers", ".", "Member", "m", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "StructureMembers", "membersw", "=", "new", "StructureMembers", "(", "m", ".", "getStructureMembers", "(", ")", ")", ";", "// no data arrays get propagated\r", "ArrayStructureW", "result", "=", "new", "ArrayStructureW", "(", "membersw", ",", "child", ".", "section", ".", "getShape", "(", ")", ")", ";", "int", "count", "=", "0", ";", "Section", ".", "Iterator", "iter", "=", "child", ".", "section", ".", "getIterator", "(", "child", ".", "v", ".", "getShape", "(", ")", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "int", "recno", "=", "iter", ".", "next", "(", "null", ")", ";", "StructureData", "sd", "=", "innerData", ".", "getStructureData", "(", "recno", ")", ";", "result", ".", "setStructureData", "(", "sd", ",", "count", "++", ")", ";", "}", "return", "result", ";", "}"], "docstring": "LOOK could be used in createView ??", "docstring_tokens": ["LOOK", "could", "be", "used", "in", "createView", "??"]}
{"code": "m.setDataParam(i);", "comments": "So we can index into various lists", "lines": 17, "repo": "Unidata/thredds", "path": "dap4/d4cdm/src/main/java/dap4/cdm/nc2/CDMArrayStructure.java", "func_name": "CDMArrayStructure.computemembers", "original_string": "static StructureMembers\n    computemembers(DapVariable var)\n    {\n        DapStructure ds = (DapStructure)var.getBaseType();\n        StructureMembers sm\n                = new StructureMembers(ds.getShortName());\n        List<DapVariable> fields = ds.getFields();\n        for(int i = 0; i < fields.size(); i++) {\n            DapVariable field = fields.get(i);\n            DapType dt = field.getBaseType();\n            DataType cdmtype = CDMTypeFcns.daptype2cdmtype(dt);\n            StructureMembers.Member m =\n                    sm.addMember(\n                            field.getShortName(), \"\", null,\n                            cdmtype,\n                            CDMUtil.computeEffectiveShape(field.getDimensions()));\n            m.setDataParam(i); // So we can index into various lists\n            // recurse if this field is itself a structure\n            if(dt.getTypeSort().isStructType()) {\n                StructureMembers subsm = computemembers(field);\n                m.setStructureMembers(subsm);\n            }\n        }\n        return sm;\n    }", "language": "java", "Allcodes": "static StructureMembers\n    computemembers(DapVariable var)\n    {\n        DapStructure ds = (DapStructure)var.getBaseType();\n        StructureMembers sm\n                = new StructureMembers(ds.getShortName());\n        List<DapVariable> fields = ds.getFields();\n        for(int i = 0; i < fields.size(); i++) {\n            DapVariable field = fields.get(i);\n            DapType dt = field.getBaseType();\n            DataType cdmtype = CDMTypeFcns.daptype2cdmtype(dt);\n            StructureMembers.Member m =\n                    sm.addMember(\n                            field.getShortName(), \"\", null,\n                            cdmtype,\n                            CDMUtil.computeEffectiveShape(field.getDimensions()));\n            m.setDataParam(i); // So we can index into various lists\n            // recurse if this field is itself a structure\n            if(dt.getTypeSort().isStructType()) {\n                StructureMembers subsm = computemembers(field);\n                m.setStructureMembers(subsm);\n            }\n        }\n        return sm;\n    }", "code_tokens": ["static", "StructureMembers", "computemembers", "(", "DapVariable", "var", ")", "{", "DapStructure", "ds", "=", "(", "DapStructure", ")", "var", ".", "getBaseType", "(", ")", ";", "StructureMembers", "sm", "=", "new", "StructureMembers", "(", "ds", ".", "getShortName", "(", ")", ")", ";", "List", "<", "DapVariable", ">", "fields", "=", "ds", ".", "getFields", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "fields", ".", "size", "(", ")", ";", "i", "++", ")", "{", "DapVariable", "field", "=", "fields", ".", "get", "(", "i", ")", ";", "DapType", "dt", "=", "field", ".", "getBaseType", "(", ")", ";", "DataType", "cdmtype", "=", "CDMTypeFcns", ".", "daptype2cdmtype", "(", "dt", ")", ";", "StructureMembers", ".", "Member", "m", "=", "sm", ".", "addMember", "(", "field", ".", "getShortName", "(", ")", ",", "\"\"", ",", "null", ",", "cdmtype", ",", "CDMUtil", ".", "computeEffectiveShape", "(", "field", ".", "getDimensions", "(", ")", ")", ")", ";", "m", ".", "setDataParam", "(", "i", ")", ";", "// So we can index into various lists", "// recurse if this field is itself a structure", "if", "(", "dt", ".", "getTypeSort", "(", ")", ".", "isStructType", "(", ")", ")", "{", "StructureMembers", "subsm", "=", "computemembers", "(", "field", ")", ";", "m", ".", "setStructureMembers", "(", "subsm", ")", ";", "}", "}", "return", "sm", ";", "}"], "docstring": "Compute the StructureMembers object\nfrom a DapStructure. May need to recurse\nif a field is itself a Structure\n\n@param var The DapVariable to use to construct\na StructureMembers object.\n@return The StructureMembers object for the given DapStructure", "docstring_tokens": ["Compute", "the", "StructureMembers", "object", "from", "a", "DapStructure", ".", "May", "need", "to", "recurse", "if", "a", "field", "is", "itself", "a", "Structure"]}
{"code": "if (type == Type.joinExisting) type = Type.joinExistingOne;", "comments": "tricky", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ncml/Aggregation.java", "func_name": "Aggregation.addDatasetScan", "original_string": "public void addDatasetScan(Element crawlableDatasetElement, String dirName, String suffix,\r\n          String regexpPatternString, String dateFormatMark, Set<NetcdfDataset.Enhance> enhanceMode, String subdirs, String olderThan) {\r\n\r\n    datasetManager.addDirectoryScan(dirName, suffix, regexpPatternString, subdirs, olderThan, enhanceMode);\r\n\r\n    this.dateFormatMark = dateFormatMark;\r\n    if (dateFormatMark != null) {\r\n      isDate = true;\r\n      if (type == Type.joinExisting) type = Type.joinExistingOne; // tricky\r\n      DateExtractor dateExtractor = new DateExtractorFromName(dateFormatMark, true);\r\n      datasetManager.setDateExtractor(dateExtractor);\r\n    }\r\n }", "language": "java", "Allcodes": "public void addDatasetScan(Element crawlableDatasetElement, String dirName, String suffix,\r\n          String regexpPatternString, String dateFormatMark, Set<NetcdfDataset.Enhance> enhanceMode, String subdirs, String olderThan) {\r\n\r\n    datasetManager.addDirectoryScan(dirName, suffix, regexpPatternString, subdirs, olderThan, enhanceMode);\r\n\r\n    this.dateFormatMark = dateFormatMark;\r\n    if (dateFormatMark != null) {\r\n      isDate = true;\r\n      if (type == Type.joinExisting) type = Type.joinExistingOne; // tricky\r\n      DateExtractor dateExtractor = new DateExtractorFromName(dateFormatMark, true);\r\n      datasetManager.setDateExtractor(dateExtractor);\r\n    }\r\n }", "code_tokens": ["public", "void", "addDatasetScan", "(", "Element", "crawlableDatasetElement", ",", "String", "dirName", ",", "String", "suffix", ",", "String", "regexpPatternString", ",", "String", "dateFormatMark", ",", "Set", "<", "NetcdfDataset", ".", "Enhance", ">", "enhanceMode", ",", "String", "subdirs", ",", "String", "olderThan", ")", "{", "datasetManager", ".", "addDirectoryScan", "(", "dirName", ",", "suffix", ",", "regexpPatternString", ",", "subdirs", ",", "olderThan", ",", "enhanceMode", ")", ";", "this", ".", "dateFormatMark", "=", "dateFormatMark", ";", "if", "(", "dateFormatMark", "!=", "null", ")", "{", "isDate", "=", "true", ";", "if", "(", "type", "==", "Type", ".", "joinExisting", ")", "type", "=", "Type", ".", "joinExistingOne", ";", "// tricky\r", "DateExtractor", "dateExtractor", "=", "new", "DateExtractorFromName", "(", "dateFormatMark", ",", "true", ")", ";", "datasetManager", ".", "setDateExtractor", "(", "dateExtractor", ")", ";", "}", "}"], "docstring": "Add a dataset scan\n\n@param crawlableDatasetElement defines a CrawlableDataset, or null\n@param dirName             scan this directory\n@param suffix              filter on this suffix (may be null)\n@param regexpPatternString include if full name matches this regular expression (may be null)\n@param dateFormatMark      create dates from the filename (may be null)\n@param enhanceMode         how should files be enhanced\n@param subdirs             equals \"false\" if should not descend into subdirectories\n@param olderThan           files must be older than this time (now - lastModified >= olderThan); must be a time unit, may ne bull", "docstring_tokens": ["Add", "a", "dataset", "scan"]}
{"code": "datasetManager.scan(true);", "comments": "Make the list of Datasets, by scanning if needed.", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ncml/Aggregation.java", "func_name": "Aggregation.finish", "original_string": "public void finish(CancelTask cancelTask) throws IOException {\r\n    datasetManager.scan(true); // Make the list of Datasets, by scanning if needed.\r\n    cacheDirty = true;\r\n    makeDatasets(cancelTask);\r\n\r\n    //ucar.unidata.io.RandomAccessFile.setDebugAccess( true);\r\n    buildNetcdfDataset(cancelTask);\r\n    //ucar.unidata.io.RandomAccessFile.setDebugAccess( false);\r\n  }", "language": "java", "Allcodes": "public void finish(CancelTask cancelTask) throws IOException {\r\n    datasetManager.scan(true); // Make the list of Datasets, by scanning if needed.\r\n    cacheDirty = true;\r\n    makeDatasets(cancelTask);\r\n\r\n    //ucar.unidata.io.RandomAccessFile.setDebugAccess( true);\r\n    buildNetcdfDataset(cancelTask);\r\n    //ucar.unidata.io.RandomAccessFile.setDebugAccess( false);\r\n  }", "code_tokens": ["public", "void", "finish", "(", "CancelTask", "cancelTask", ")", "throws", "IOException", "{", "datasetManager", ".", "scan", "(", "true", ")", ";", "// Make the list of Datasets, by scanning if needed.\r", "cacheDirty", "=", "true", ";", "makeDatasets", "(", "cancelTask", ")", ";", "//ucar.unidata.io.RandomAccessFile.setDebugAccess( true);\r", "buildNetcdfDataset", "(", "cancelTask", ")", ";", "//ucar.unidata.io.RandomAccessFile.setDebugAccess( false);\r", "}"], "docstring": "all elements are processed, finish construction", "docstring_tokens": ["all", "elements", "are", "processed", "finish", "construction"]}
{"code": "String filename = myf.getName();", "comments": "LOOK operates on name, not path", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ncml/Aggregation.java", "func_name": "Aggregation.makeDatasets", "original_string": "protected void makeDatasets(CancelTask cancelTask) throws IOException {\r\n\r\n    // heres where the results will go\r\n    datasets = new ArrayList<>();\r\n\r\n    for (MFile cd : datasetManager.getFilesSorted()) {\r\n      datasets.add( makeDataset(cd));\r\n    }\r\n\r\n    // sort using Aggregation.Dataset as Comparator.\r\n    // Sort by date if it exists, else filename.\r\n    Collections.sort(datasets);\r\n\r\n      /* optionally extract the date\r\n      String dateCoordS = null;\r\n      if (null != dateFormatMark) {\r\n        String filename = myf.getName(); // LOOK operates on name, not path\r\n        Date dateCoord = DateFromString.getDateUsingDemarkatedCount(filename, dateFormatMark, '#');\r\n        dateCoordS = formatter.toDateTimeStringISO(dateCoord);\r\n        if (debugDateParse) System.out.println(\"  adding \" + myf.getPath() + \" date= \" + dateCoordS);\r\n      } else {\r\n        if (debugDateParse) System.out.println(\"  adding \" + myf.getPath());\r\n      }\r\n\r\n      String location = myf.getPath();\r\n      Aggregation.Dataset ds = makeDataset(location, location, null, null, dateCoordS, null, enhance, null);\r\n      datasets.add(ds);\r\n    }\r\n\r\n    // Sort by date if it exists, else filename.\r\n    Collections.sort(datasets, new Comparator<Aggregation.Dataset>() {\r\n      public int compare(Aggregation.Dataset ds1, Aggregation.Dataset ds2) {\r\n        if(ds1.cd == null)\r\n           return ds1.getLocation().compareTo(ds2.getLocation()) ;\r\n        if (ds1.cd.dateCoord != null) // LOOK can we generalize\r\n          return ds1.cd.dateCoord.compareTo(ds2.cd.dateCoord);\r\n        else\r\n          return ds1.cd.file.getName().compareTo(ds2.cd.file.getName());\r\n      }\r\n    });  */\r\n\r\n    // add the explicit datasets - these need to be kept in order\r\n    // LOOK - should they be before or after scanned? Does it make sense to mix scan and explicit?\r\n    // AggFmrcSingle sets explicit datasets - the scan is empty\r\n    for (Aggregation.Dataset dataset : explicitDatasets) {\r\n      datasets.add(dataset);\r\n    }\r\n\r\n    // Remove unreadable files (i.e. due to permissions) from the aggregation.\r\n    // LOOK: Is this logic we should install \"upstream\", perhaps in MFileCollectionManager?\r\n    // It would affect other collections than just NcML aggregation in that case.\r\n    for (Iterator<Dataset> datasetsIter = datasets.iterator(); datasetsIter.hasNext(); ) {\r\n      Dataset dataset = datasetsIter.next();\r\n\r\n      Path datasetPath;\r\n      if (dataset.getMFile() instanceof MFileOS) {\r\n        datasetPath = ((MFileOS) dataset.getMFile()).getFile().toPath();\r\n      } else if (dataset.getMFile() instanceof MFileOS7) {\r\n        datasetPath = ((MFileOS7) dataset.getMFile()).getNioPath();\r\n      } else {\r\n        continue;\r\n      }\r\n\r\n      if (!Files.isReadable(datasetPath)) {  // File.canRead() is broken on Windows, but the JDK7 methods work.\r\n        logger.warn(\"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath);\r\n        datasetsIter.remove();\r\n      }\r\n    }\r\n\r\n    // check for duplicate location\r\n    Set<String> dset = new HashSet<>( 2 * datasets.size());\r\n    for (Aggregation.Dataset dataset : datasets) {\r\n      if (dset.contains(dataset.cacheLocation))\r\n        logger.warn(\"Duplicate dataset in aggregation = \"+dataset.cacheLocation);\r\n      dset.add(dataset.cacheLocation);\r\n    }\r\n\r\n    if (datasets.size() == 0) {\r\n      throw new IllegalStateException(\"There are no datasets in the aggregation \" + datasetManager);\r\n    }\r\n  }", "language": "java", "Allcodes": "protected void makeDatasets(CancelTask cancelTask) throws IOException {\r\n\r\n    // heres where the results will go\r\n    datasets = new ArrayList<>();\r\n\r\n    for (MFile cd : datasetManager.getFilesSorted()) {\r\n      datasets.add( makeDataset(cd));\r\n    }\r\n\r\n    // sort using Aggregation.Dataset as Comparator.\r\n    // Sort by date if it exists, else filename.\r\n    Collections.sort(datasets);\r\n\r\n      /* optionally extract the date\r\n      String dateCoordS = null;\r\n      if (null != dateFormatMark) {\r\n        String filename = myf.getName(); // LOOK operates on name, not path\r\n        Date dateCoord = DateFromString.getDateUsingDemarkatedCount(filename, dateFormatMark, '#');\r\n        dateCoordS = formatter.toDateTimeStringISO(dateCoord);\r\n        if (debugDateParse) System.out.println(\"  adding \" + myf.getPath() + \" date= \" + dateCoordS);\r\n      } else {\r\n        if (debugDateParse) System.out.println(\"  adding \" + myf.getPath());\r\n      }\r\n\r\n      String location = myf.getPath();\r\n      Aggregation.Dataset ds = makeDataset(location, location, null, null, dateCoordS, null, enhance, null);\r\n      datasets.add(ds);\r\n    }\r\n\r\n    // Sort by date if it exists, else filename.\r\n    Collections.sort(datasets, new Comparator<Aggregation.Dataset>() {\r\n      public int compare(Aggregation.Dataset ds1, Aggregation.Dataset ds2) {\r\n        if(ds1.cd == null)\r\n           return ds1.getLocation().compareTo(ds2.getLocation()) ;\r\n        if (ds1.cd.dateCoord != null) // LOOK can we generalize\r\n          return ds1.cd.dateCoord.compareTo(ds2.cd.dateCoord);\r\n        else\r\n          return ds1.cd.file.getName().compareTo(ds2.cd.file.getName());\r\n      }\r\n    });  */\r\n\r\n    // add the explicit datasets - these need to be kept in order\r\n    // LOOK - should they be before or after scanned? Does it make sense to mix scan and explicit?\r\n    // AggFmrcSingle sets explicit datasets - the scan is empty\r\n    for (Aggregation.Dataset dataset : explicitDatasets) {\r\n      datasets.add(dataset);\r\n    }\r\n\r\n    // Remove unreadable files (i.e. due to permissions) from the aggregation.\r\n    // LOOK: Is this logic we should install \"upstream\", perhaps in MFileCollectionManager?\r\n    // It would affect other collections than just NcML aggregation in that case.\r\n    for (Iterator<Dataset> datasetsIter = datasets.iterator(); datasetsIter.hasNext(); ) {\r\n      Dataset dataset = datasetsIter.next();\r\n\r\n      Path datasetPath;\r\n      if (dataset.getMFile() instanceof MFileOS) {\r\n        datasetPath = ((MFileOS) dataset.getMFile()).getFile().toPath();\r\n      } else if (dataset.getMFile() instanceof MFileOS7) {\r\n        datasetPath = ((MFileOS7) dataset.getMFile()).getNioPath();\r\n      } else {\r\n        continue;\r\n      }\r\n\r\n      if (!Files.isReadable(datasetPath)) {  // File.canRead() is broken on Windows, but the JDK7 methods work.\r\n        logger.warn(\"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath);\r\n        datasetsIter.remove();\r\n      }\r\n    }\r\n\r\n    // check for duplicate location\r\n    Set<String> dset = new HashSet<>( 2 * datasets.size());\r\n    for (Aggregation.Dataset dataset : datasets) {\r\n      if (dset.contains(dataset.cacheLocation))\r\n        logger.warn(\"Duplicate dataset in aggregation = \"+dataset.cacheLocation);\r\n      dset.add(dataset.cacheLocation);\r\n    }\r\n\r\n    if (datasets.size() == 0) {\r\n      throw new IllegalStateException(\"There are no datasets in the aggregation \" + datasetManager);\r\n    }\r\n  }", "code_tokens": ["protected", "void", "makeDatasets", "(", "CancelTask", "cancelTask", ")", "throws", "IOException", "{", "// heres where the results will go\r", "datasets", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "MFile", "cd", ":", "datasetManager", ".", "getFilesSorted", "(", ")", ")", "{", "datasets", ".", "add", "(", "makeDataset", "(", "cd", ")", ")", ";", "}", "// sort using Aggregation.Dataset as Comparator.\r", "// Sort by date if it exists, else filename.\r", "Collections", ".", "sort", "(", "datasets", ")", ";", "/* optionally extract the date\r\n      String dateCoordS = null;\r\n      if (null != dateFormatMark) {\r\n        String filename = myf.getName(); // LOOK operates on name, not path\r\n        Date dateCoord = DateFromString.getDateUsingDemarkatedCount(filename, dateFormatMark, '#');\r\n        dateCoordS = formatter.toDateTimeStringISO(dateCoord);\r\n        if (debugDateParse) System.out.println(\"  adding \" + myf.getPath() + \" date= \" + dateCoordS);\r\n      } else {\r\n        if (debugDateParse) System.out.println(\"  adding \" + myf.getPath());\r\n      }\r\n\r\n      String location = myf.getPath();\r\n      Aggregation.Dataset ds = makeDataset(location, location, null, null, dateCoordS, null, enhance, null);\r\n      datasets.add(ds);\r\n    }\r\n\r\n    // Sort by date if it exists, else filename.\r\n    Collections.sort(datasets, new Comparator<Aggregation.Dataset>() {\r\n      public int compare(Aggregation.Dataset ds1, Aggregation.Dataset ds2) {\r\n        if(ds1.cd == null)\r\n           return ds1.getLocation().compareTo(ds2.getLocation()) ;\r\n        if (ds1.cd.dateCoord != null) // LOOK can we generalize\r\n          return ds1.cd.dateCoord.compareTo(ds2.cd.dateCoord);\r\n        else\r\n          return ds1.cd.file.getName().compareTo(ds2.cd.file.getName());\r\n      }\r\n    });  */", "// add the explicit datasets - these need to be kept in order\r", "// LOOK - should they be before or after scanned? Does it make sense to mix scan and explicit?\r", "// AggFmrcSingle sets explicit datasets - the scan is empty\r", "for", "(", "Aggregation", ".", "Dataset", "dataset", ":", "explicitDatasets", ")", "{", "datasets", ".", "add", "(", "dataset", ")", ";", "}", "// Remove unreadable files (i.e. due to permissions) from the aggregation.\r", "// LOOK: Is this logic we should install \"upstream\", perhaps in MFileCollectionManager?\r", "// It would affect other collections than just NcML aggregation in that case.\r", "for", "(", "Iterator", "<", "Dataset", ">", "datasetsIter", "=", "datasets", ".", "iterator", "(", ")", ";", "datasetsIter", ".", "hasNext", "(", ")", ";", ")", "{", "Dataset", "dataset", "=", "datasetsIter", ".", "next", "(", ")", ";", "Path", "datasetPath", ";", "if", "(", "dataset", ".", "getMFile", "(", ")", "instanceof", "MFileOS", ")", "{", "datasetPath", "=", "(", "(", "MFileOS", ")", "dataset", ".", "getMFile", "(", ")", ")", ".", "getFile", "(", ")", ".", "toPath", "(", ")", ";", "}", "else", "if", "(", "dataset", ".", "getMFile", "(", ")", "instanceof", "MFileOS7", ")", "{", "datasetPath", "=", "(", "(", "MFileOS7", ")", "dataset", ".", "getMFile", "(", ")", ")", ".", "getNioPath", "(", ")", ";", "}", "else", "{", "continue", ";", "}", "if", "(", "!", "Files", ".", "isReadable", "(", "datasetPath", ")", ")", "{", "// File.canRead() is broken on Windows, but the JDK7 methods work.\r", "logger", ".", "warn", "(", "\"Aggregation member isn't readable (permissions issue?). Skipping: \"", "+", "datasetPath", ")", ";", "datasetsIter", ".", "remove", "(", ")", ";", "}", "}", "// check for duplicate location\r", "Set", "<", "String", ">", "dset", "=", "new", "HashSet", "<>", "(", "2", "*", "datasets", ".", "size", "(", ")", ")", ";", "for", "(", "Aggregation", ".", "Dataset", "dataset", ":", "datasets", ")", "{", "if", "(", "dset", ".", "contains", "(", "dataset", ".", "cacheLocation", ")", ")", "logger", ".", "warn", "(", "\"Duplicate dataset in aggregation = \"", "+", "dataset", ".", "cacheLocation", ")", ";", "dset", ".", "add", "(", "dataset", ".", "cacheLocation", ")", ";", "}", "if", "(", "datasets", ".", "size", "(", ")", "==", "0", ")", "{", "throw", "new", "IllegalStateException", "(", "\"There are no datasets in the aggregation \"", "+", "datasetManager", ")", ";", "}", "}"], "docstring": "Make the list of Datasets, from explicit and scans.\n\n@param cancelTask user can cancel\n@throws IOException on i/o error", "docstring_tokens": ["Make", "the", "list", "of", "Datasets", "from", "explicit", "and", "scans", "."]}
{"code": "return new Dataset(cacheName, location, id, enhance, reader);", "comments": "overridden in OuterDim, tiled", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ncml/Aggregation.java", "func_name": "Aggregation.makeDataset", "original_string": "protected Dataset makeDataset(String cacheName, String location, String id, String ncoordS, String coordValueS,\r\n          String sectionSpec, EnumSet<NetcdfDataset.Enhance> enhance, ucar.nc2.util.cache.FileFactory reader) {\r\n    return new Dataset(cacheName, location, id, enhance, reader); // overridden in OuterDim, tiled\r\n  }", "language": "java", "Allcodes": "protected Dataset makeDataset(String cacheName, String location, String id, String ncoordS, String coordValueS,\r\n          String sectionSpec, EnumSet<NetcdfDataset.Enhance> enhance, ucar.nc2.util.cache.FileFactory reader) {\r\n    return new Dataset(cacheName, location, id, enhance, reader); // overridden in OuterDim, tiled\r\n  }", "code_tokens": ["protected", "Dataset", "makeDataset", "(", "String", "cacheName", ",", "String", "location", ",", "String", "id", ",", "String", "ncoordS", ",", "String", "coordValueS", ",", "String", "sectionSpec", ",", "EnumSet", "<", "NetcdfDataset", ".", "Enhance", ">", "enhance", ",", "ucar", ".", "nc2", ".", "util", ".", "cache", ".", "FileFactory", "reader", ")", "{", "return", "new", "Dataset", "(", "cacheName", ",", "location", ",", "id", ",", "enhance", ",", "reader", ")", ";", "// overridden in OuterDim, tiled\r", "}"], "docstring": "Dataset factory, so subclasses can override\n\n@param cacheName   a unique name to use for caching\n@param location    attribute \"location\" on the netcdf element\n@param id          attribute \"id\" on the netcdf element\n@param ncoordS     attribute \"ncoords\" on the netcdf element\n@param coordValueS attribute \"coordValue\" on the netcdf element\n@param sectionSpec attribute \"sectionSpec\" on the netcdf element\n@param enhance     open dataset in enhance mode NOT USED\n@param reader      factory for reading this netcdf dataset\n@return a Aggregation.Dataset", "docstring_tokens": ["Dataset", "factory", "so", "subclasses", "can", "override"]}
{"code": "dim.setUnlimited(true);", "comments": "allow zero length dimension !!", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/hdf4/HdfEos.java", "func_name": "HdfEos.checkUnknownDims", "original_string": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["private", "Dimension", "checkUnknownDims", "(", "String", "wantDim", ",", "List", "<", "Dimension", ">", "unknownDims", ",", "Dimension", "oldDim", ",", "String", "location", ")", "{", "for", "(", "Dimension", "dim", ":", "unknownDims", ")", "{", "if", "(", "dim", ".", "getShortName", "(", ")", ".", "equals", "(", "wantDim", ")", ")", "{", "int", "len", "=", "oldDim", ".", "getLength", "(", ")", ";", "if", "(", "len", "==", "0", ")", "{", "dim", ".", "setUnlimited", "(", "true", ")", ";", "// allow zero length dimension !!\r", "}", "dim", ".", "setLength", "(", "len", ")", ";", "// use existing (anon) dimension\r", "Group", "parent", "=", "dim", ".", "getGroup", "(", ")", ";", "parent", ".", "addDimensionIfNotExists", "(", "dim", ")", ";", "// add to the parent\r", "unknownDims", ".", "remove", "(", "dim", ")", ";", "// remove from list LOOK is this ok?\r", "log", ".", "warn", "(", "\"unknownDim {} length set to {}{}\"", ",", "wantDim", ",", "oldDim", ".", "getLength", "(", ")", ",", "location", ")", ";", "return", "dim", ";", "}", "}", "return", "null", ";", "}"], "docstring": "look if the wanted dimension is in the  unknownDims list.", "docstring_tokens": ["look", "if", "the", "wanted", "dimension", "is", "in", "the", "unknownDims", "list", "."]}
{"code": "dim.setLength(len);", "comments": "use existing (anon) dimension", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/hdf4/HdfEos.java", "func_name": "HdfEos.checkUnknownDims", "original_string": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["private", "Dimension", "checkUnknownDims", "(", "String", "wantDim", ",", "List", "<", "Dimension", ">", "unknownDims", ",", "Dimension", "oldDim", ",", "String", "location", ")", "{", "for", "(", "Dimension", "dim", ":", "unknownDims", ")", "{", "if", "(", "dim", ".", "getShortName", "(", ")", ".", "equals", "(", "wantDim", ")", ")", "{", "int", "len", "=", "oldDim", ".", "getLength", "(", ")", ";", "if", "(", "len", "==", "0", ")", "{", "dim", ".", "setUnlimited", "(", "true", ")", ";", "// allow zero length dimension !!\r", "}", "dim", ".", "setLength", "(", "len", ")", ";", "// use existing (anon) dimension\r", "Group", "parent", "=", "dim", ".", "getGroup", "(", ")", ";", "parent", ".", "addDimensionIfNotExists", "(", "dim", ")", ";", "// add to the parent\r", "unknownDims", ".", "remove", "(", "dim", ")", ";", "// remove from list LOOK is this ok?\r", "log", ".", "warn", "(", "\"unknownDim {} length set to {}{}\"", ",", "wantDim", ",", "oldDim", ".", "getLength", "(", ")", ",", "location", ")", ";", "return", "dim", ";", "}", "}", "return", "null", ";", "}"], "docstring": "look if the wanted dimension is in the  unknownDims list.", "docstring_tokens": ["look", "if", "the", "wanted", "dimension", "is", "in", "the", "unknownDims", "list", "."]}
{"code": "parent.addDimensionIfNotExists(dim);", "comments": "add to the parent", "lines": 10, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/hdf4/HdfEos.java", "func_name": "HdfEos.checkUnknownDims", "original_string": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["private", "Dimension", "checkUnknownDims", "(", "String", "wantDim", ",", "List", "<", "Dimension", ">", "unknownDims", ",", "Dimension", "oldDim", ",", "String", "location", ")", "{", "for", "(", "Dimension", "dim", ":", "unknownDims", ")", "{", "if", "(", "dim", ".", "getShortName", "(", ")", ".", "equals", "(", "wantDim", ")", ")", "{", "int", "len", "=", "oldDim", ".", "getLength", "(", ")", ";", "if", "(", "len", "==", "0", ")", "{", "dim", ".", "setUnlimited", "(", "true", ")", ";", "// allow zero length dimension !!\r", "}", "dim", ".", "setLength", "(", "len", ")", ";", "// use existing (anon) dimension\r", "Group", "parent", "=", "dim", ".", "getGroup", "(", ")", ";", "parent", ".", "addDimensionIfNotExists", "(", "dim", ")", ";", "// add to the parent\r", "unknownDims", ".", "remove", "(", "dim", ")", ";", "// remove from list LOOK is this ok?\r", "log", ".", "warn", "(", "\"unknownDim {} length set to {}{}\"", ",", "wantDim", ",", "oldDim", ".", "getLength", "(", ")", ",", "location", ")", ";", "return", "dim", ";", "}", "}", "return", "null", ";", "}"], "docstring": "look if the wanted dimension is in the  unknownDims list.", "docstring_tokens": ["look", "if", "the", "wanted", "dimension", "is", "in", "the", "unknownDims", "list", "."]}
{"code": "unknownDims.remove(dim);", "comments": "remove from list LOOK is this ok?", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/hdf4/HdfEos.java", "func_name": "HdfEos.checkUnknownDims", "original_string": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "private Dimension checkUnknownDims(String wantDim, List<Dimension> unknownDims, Dimension oldDim, String location) {\r\n    for (Dimension dim : unknownDims) {\r\n      if (dim.getShortName().equals(wantDim)) {\r\n        int len = oldDim.getLength();\r\n        if (len == 0) {\r\n          dim.setUnlimited(true); // allow zero length dimension !!\r\n        }\r\n        dim.setLength(len); // use existing (anon) dimension\r\n        Group parent = dim.getGroup();\r\n        parent.addDimensionIfNotExists(dim);  // add to the parent\r\n        unknownDims.remove(dim); // remove from list LOOK is this ok?\r\n        log.warn(\"unknownDim {} length set to {}{}\", wantDim, oldDim.getLength(), location);\r\n        return dim;\r\n      }\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["private", "Dimension", "checkUnknownDims", "(", "String", "wantDim", ",", "List", "<", "Dimension", ">", "unknownDims", ",", "Dimension", "oldDim", ",", "String", "location", ")", "{", "for", "(", "Dimension", "dim", ":", "unknownDims", ")", "{", "if", "(", "dim", ".", "getShortName", "(", ")", ".", "equals", "(", "wantDim", ")", ")", "{", "int", "len", "=", "oldDim", ".", "getLength", "(", ")", ";", "if", "(", "len", "==", "0", ")", "{", "dim", ".", "setUnlimited", "(", "true", ")", ";", "// allow zero length dimension !!\r", "}", "dim", ".", "setLength", "(", "len", ")", ";", "// use existing (anon) dimension\r", "Group", "parent", "=", "dim", ".", "getGroup", "(", ")", ";", "parent", ".", "addDimensionIfNotExists", "(", "dim", ")", ";", "// add to the parent\r", "unknownDims", ".", "remove", "(", "dim", ")", ";", "// remove from list LOOK is this ok?\r", "log", ".", "warn", "(", "\"unknownDim {} length set to {}{}\"", ",", "wantDim", ",", "oldDim", ".", "getLength", "(", ")", ",", "location", ")", ";", "return", "dim", ";", "}", "}", "return", "null", ";", "}"], "docstring": "look if the wanted dimension is in the  unknownDims list.", "docstring_tokens": ["look", "if", "the", "wanted", "dimension", "is", "in", "the", "unknownDims", "list", "."]}
{"code": "maxRadial = radialUnit.convertTo(maxRadial, SimpleUnit.kmUnit);", "comments": "convert to km", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dt/radial/RadialCoordSys.java", "func_name": "RadialCoordSys.getMaximumRadial", "original_string": "public double getMaximumRadial() {\n    if (maxRadial == 0.0) {\n      try {\n        Array radialData = getRadialAxisDataCached();\n        maxRadial = MAMath.getMaximum( radialData);\n\n        String units = getRadialAxis().getUnitsString();\n        SimpleUnit radialUnit = SimpleUnit.factory(units);\n        maxRadial = radialUnit.convertTo(maxRadial, SimpleUnit.kmUnit); // convert to km\n\n      } catch (IOException e) {\n        e.printStackTrace();\n      } catch (IllegalArgumentException e) {\n        e.printStackTrace();\n      }\n    }\n    return maxRadial;\n  }", "language": "java", "Allcodes": "public double getMaximumRadial() {\n    if (maxRadial == 0.0) {\n      try {\n        Array radialData = getRadialAxisDataCached();\n        maxRadial = MAMath.getMaximum( radialData);\n\n        String units = getRadialAxis().getUnitsString();\n        SimpleUnit radialUnit = SimpleUnit.factory(units);\n        maxRadial = radialUnit.convertTo(maxRadial, SimpleUnit.kmUnit); // convert to km\n\n      } catch (IOException e) {\n        e.printStackTrace();\n      } catch (IllegalArgumentException e) {\n        e.printStackTrace();\n      }\n    }\n    return maxRadial;\n  }", "code_tokens": ["public", "double", "getMaximumRadial", "(", ")", "{", "if", "(", "maxRadial", "==", "0.0", ")", "{", "try", "{", "Array", "radialData", "=", "getRadialAxisDataCached", "(", ")", ";", "maxRadial", "=", "MAMath", ".", "getMaximum", "(", "radialData", ")", ";", "String", "units", "=", "getRadialAxis", "(", ")", ".", "getUnitsString", "(", ")", ";", "SimpleUnit", "radialUnit", "=", "SimpleUnit", ".", "factory", "(", "units", ")", ";", "maxRadial", "=", "radialUnit", ".", "convertTo", "(", "maxRadial", ",", "SimpleUnit", ".", "kmUnit", ")", ";", "// convert to km", "}", "catch", "(", "IOException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}", "return", "maxRadial", ";", "}"], "docstring": "Get the maximum radial distance, in km.", "docstring_tokens": ["Get", "the", "maximum", "radial", "distance", "in", "km", "."]}
{"code": "currentConnection.setRequestMethod(command.toString());", "comments": "GET or HEAD", "lines": 6, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/URLDumpPane.java", "func_name": "URLDumpPane.openURL", "original_string": "private void openURL(String urlString, Command command) {\r\n    try {\r\n      //Open the URLConnection for reading\r\n      URL u = new URL(urlString);\r\n      currentConnection = (HttpURLConnection) u.openConnection();\r\n      currentConnection.setRequestMethod(command.toString()); // GET or HEAD\r\n      currentConnection.setAllowUserInteraction(true);\r\n\r\n      clear();\r\n      appendLine(command + \" request for \" + urlString);\r\n\r\n      // request headers\r\n      Map<String, List<String>> reqs = currentConnection.getRequestProperties();\r\n      for (Map.Entry<String, List<String>> ent : reqs.entrySet()) {\r\n        append(\" \" + ent.getKey() + \": \");\r\n        for (String v : ent.getValue())\r\n          append(v + \" \");\r\n        appendLine(\"\");\r\n      }\r\n      appendLine(\"\");\r\n      appendLine(\"getFollowRedirects=\" + HttpURLConnection.getFollowRedirects());\r\n      appendLine(\"getInstanceFollowRedirects=\" + currentConnection.getInstanceFollowRedirects());\r\n      appendLine(\"AllowUserInteraction=\" + currentConnection.getAllowUserInteraction());\r\n      appendLine(\"\");\r\n\r\n      int code = currentConnection.getResponseCode();\r\n      String response = currentConnection.getResponseMessage();\r\n\r\n      // response headers\r\n      appendLine(\" HTTP/1.x \" + code + \" \" + response);\r\n      appendLine(\" content-length: \" + currentConnection.getContentLength());\r\n      appendLine(\" content-encoding: \" + currentConnection.getContentEncoding());\r\n      appendLine(\" content-type: \" + currentConnection.getContentType());\r\n      appendLine(\"\\nHeaders: \");\r\n\r\n      for (int j = 1; true; j++) {\r\n        String header = currentConnection.getHeaderField(j);\r\n        String key = currentConnection.getHeaderFieldKey(j);\r\n        if (header == null || key == null) break;\r\n        appendLine(\" \" + key + \": \" + header);\r\n      }\r\n\r\n      appendLine(\"\");\r\n      appendLine(\"contents:\");\r\n\r\n      // read it\r\n      java.io.InputStream is = currentConnection.getInputStream();\r\n      ByteArrayOutputStream bout = new ByteArrayOutputStream(200000);\r\n      IO.copy(is, bout);\r\n      is.close();\r\n\r\n      append(new String(bout.toByteArray(), CDM.utf8Charset));\r\n      appendLine(\"end contents\");\r\n\r\n    } catch (MalformedURLException e) {\r\n      append(urlString + \" is not a parseable URL\");\r\n    }\r\n    catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }", "language": "java", "Allcodes": "private void openURL(String urlString, Command command) {\r\n    try {\r\n      //Open the URLConnection for reading\r\n      URL u = new URL(urlString);\r\n      currentConnection = (HttpURLConnection) u.openConnection();\r\n      currentConnection.setRequestMethod(command.toString()); // GET or HEAD\r\n      currentConnection.setAllowUserInteraction(true);\r\n\r\n      clear();\r\n      appendLine(command + \" request for \" + urlString);\r\n\r\n      // request headers\r\n      Map<String, List<String>> reqs = currentConnection.getRequestProperties();\r\n      for (Map.Entry<String, List<String>> ent : reqs.entrySet()) {\r\n        append(\" \" + ent.getKey() + \": \");\r\n        for (String v : ent.getValue())\r\n          append(v + \" \");\r\n        appendLine(\"\");\r\n      }\r\n      appendLine(\"\");\r\n      appendLine(\"getFollowRedirects=\" + HttpURLConnection.getFollowRedirects());\r\n      appendLine(\"getInstanceFollowRedirects=\" + currentConnection.getInstanceFollowRedirects());\r\n      appendLine(\"AllowUserInteraction=\" + currentConnection.getAllowUserInteraction());\r\n      appendLine(\"\");\r\n\r\n      int code = currentConnection.getResponseCode();\r\n      String response = currentConnection.getResponseMessage();\r\n\r\n      // response headers\r\n      appendLine(\" HTTP/1.x \" + code + \" \" + response);\r\n      appendLine(\" content-length: \" + currentConnection.getContentLength());\r\n      appendLine(\" content-encoding: \" + currentConnection.getContentEncoding());\r\n      appendLine(\" content-type: \" + currentConnection.getContentType());\r\n      appendLine(\"\\nHeaders: \");\r\n\r\n      for (int j = 1; true; j++) {\r\n        String header = currentConnection.getHeaderField(j);\r\n        String key = currentConnection.getHeaderFieldKey(j);\r\n        if (header == null || key == null) break;\r\n        appendLine(\" \" + key + \": \" + header);\r\n      }\r\n\r\n      appendLine(\"\");\r\n      appendLine(\"contents:\");\r\n\r\n      // read it\r\n      java.io.InputStream is = currentConnection.getInputStream();\r\n      ByteArrayOutputStream bout = new ByteArrayOutputStream(200000);\r\n      IO.copy(is, bout);\r\n      is.close();\r\n\r\n      append(new String(bout.toByteArray(), CDM.utf8Charset));\r\n      appendLine(\"end contents\");\r\n\r\n    } catch (MalformedURLException e) {\r\n      append(urlString + \" is not a parseable URL\");\r\n    }\r\n    catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }", "code_tokens": ["private", "void", "openURL", "(", "String", "urlString", ",", "Command", "command", ")", "{", "try", "{", "//Open the URLConnection for reading\r", "URL", "u", "=", "new", "URL", "(", "urlString", ")", ";", "currentConnection", "=", "(", "HttpURLConnection", ")", "u", ".", "openConnection", "(", ")", ";", "currentConnection", ".", "setRequestMethod", "(", "command", ".", "toString", "(", ")", ")", ";", "// GET or HEAD\r", "currentConnection", ".", "setAllowUserInteraction", "(", "true", ")", ";", "clear", "(", ")", ";", "appendLine", "(", "command", "+", "\" request for \"", "+", "urlString", ")", ";", "// request headers\r", "Map", "<", "String", ",", "List", "<", "String", ">", ">", "reqs", "=", "currentConnection", ".", "getRequestProperties", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "List", "<", "String", ">", ">", "ent", ":", "reqs", ".", "entrySet", "(", ")", ")", "{", "append", "(", "\" \"", "+", "ent", ".", "getKey", "(", ")", "+", "\": \"", ")", ";", "for", "(", "String", "v", ":", "ent", ".", "getValue", "(", ")", ")", "append", "(", "v", "+", "\" \"", ")", ";", "appendLine", "(", "\"\"", ")", ";", "}", "appendLine", "(", "\"\"", ")", ";", "appendLine", "(", "\"getFollowRedirects=\"", "+", "HttpURLConnection", ".", "getFollowRedirects", "(", ")", ")", ";", "appendLine", "(", "\"getInstanceFollowRedirects=\"", "+", "currentConnection", ".", "getInstanceFollowRedirects", "(", ")", ")", ";", "appendLine", "(", "\"AllowUserInteraction=\"", "+", "currentConnection", ".", "getAllowUserInteraction", "(", ")", ")", ";", "appendLine", "(", "\"\"", ")", ";", "int", "code", "=", "currentConnection", ".", "getResponseCode", "(", ")", ";", "String", "response", "=", "currentConnection", ".", "getResponseMessage", "(", ")", ";", "// response headers\r", "appendLine", "(", "\" HTTP/1.x \"", "+", "code", "+", "\" \"", "+", "response", ")", ";", "appendLine", "(", "\" content-length: \"", "+", "currentConnection", ".", "getContentLength", "(", ")", ")", ";", "appendLine", "(", "\" content-encoding: \"", "+", "currentConnection", ".", "getContentEncoding", "(", ")", ")", ";", "appendLine", "(", "\" content-type: \"", "+", "currentConnection", ".", "getContentType", "(", ")", ")", ";", "appendLine", "(", "\"\\nHeaders: \"", ")", ";", "for", "(", "int", "j", "=", "1", ";", "true", ";", "j", "++", ")", "{", "String", "header", "=", "currentConnection", ".", "getHeaderField", "(", "j", ")", ";", "String", "key", "=", "currentConnection", ".", "getHeaderFieldKey", "(", "j", ")", ";", "if", "(", "header", "==", "null", "||", "key", "==", "null", ")", "break", ";", "appendLine", "(", "\" \"", "+", "key", "+", "\": \"", "+", "header", ")", ";", "}", "appendLine", "(", "\"\"", ")", ";", "appendLine", "(", "\"contents:\"", ")", ";", "// read it\r", "java", ".", "io", ".", "InputStream", "is", "=", "currentConnection", ".", "getInputStream", "(", ")", ";", "ByteArrayOutputStream", "bout", "=", "new", "ByteArrayOutputStream", "(", "200000", ")", ";", "IO", ".", "copy", "(", "is", ",", "bout", ")", ";", "is", ".", "close", "(", ")", ";", "append", "(", "new", "String", "(", "bout", ".", "toByteArray", "(", ")", ",", "CDM", ".", "utf8Charset", ")", ")", ";", "appendLine", "(", "\"end contents\"", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "append", "(", "urlString", "+", "\" is not a parseable URL\"", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "}", "}"], "docstring": "Uses java.net", "docstring_tokens": ["Uses", "java", ".", "net"]}
{"code": "int n = shape[dimIndex];", "comments": "length of extracted array", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/WRFEta.java", "func_name": "WRFEta.addStagger", "original_string": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "language": "java", "Allcodes": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "code_tokens": ["private", "ArrayDouble", ".", "D3", "addStagger", "(", "ArrayDouble", ".", "D3", "array", ",", "int", "dimIndex", ")", "{", "//ADD: assert 0<=dimIndex<=2\r", "int", "[", "]", "shape", "=", "array", ".", "getShape", "(", ")", ";", "int", "[", "]", "newShape", "=", "new", "int", "[", "3", "]", ";", "System", ".", "arraycopy", "(", "shape", ",", "0", ",", "newShape", ",", "0", ",", "3", ")", ";", "newShape", "[", "dimIndex", "]", "++", ";", "int", "ni", "=", "newShape", "[", "0", "]", ";", "int", "nj", "=", "newShape", "[", "1", "]", ";", "int", "nk", "=", "newShape", "[", "2", "]", ";", "ArrayDouble", ".", "D3", "newArray", "=", "new", "ArrayDouble", ".", "D3", "(", "ni", ",", "nj", ",", "nk", ")", ";", "//Index newIndex = newArray.getIndex();\r", "//extract 1d array to be extended\r", "int", "n", "=", "shape", "[", "dimIndex", "]", ";", "//length of extracted array\r", "double", "[", "]", "d", "=", "new", "double", "[", "n", "]", ";", "//tmp array to hold extracted values\r", "int", "[", "]", "eshape", "=", "new", "int", "[", "3", "]", ";", "//shape of extracted array\r", "int", "[", "]", "neweshape", "=", "new", "int", "[", "3", "]", ";", "//shape of new array slice to write into\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "3", ";", "i", "++", ")", "{", "eshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", ":", "1", ";", "neweshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", "+", "1", ":", "1", ";", "}", "int", "[", "]", "origin", "=", "new", "int", "[", "3", "]", ";", "try", "{", "//loop through the other 2 dimensions and \"extrapinterpolate\" the other\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "(", "(", "dimIndex", "==", "0", ")", "?", "1", ":", "ni", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "(", "(", "dimIndex", "==", "1", ")", "?", "1", ":", "nj", ")", ";", "j", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "(", "(", "dimIndex", "==", "2", ")", "?", "1", ":", "nk", ")", ";", "k", "++", ")", "{", "origin", "[", "0", "]", "=", "i", ";", "origin", "[", "1", "]", "=", "j", ";", "origin", "[", "2", "]", "=", "k", ";", "IndexIterator", "it", "=", "array", ".", "section", "(", "origin", ",", "eshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", ";", "l", "++", ")", "{", "d", "[", "l", "]", "=", "it", ".", "getDoubleNext", "(", ")", ";", "//get the original values\r", "}", "double", "[", "]", "d2", "=", "extrapinterpolate", "(", "d", ")", ";", "//compute new values\r", "//define slice of new array to write into\r", "IndexIterator", "newit", "=", "newArray", ".", "section", "(", "origin", ",", "neweshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", "+", "1", ";", "l", "++", ")", "{", "newit", ".", "setDoubleNext", "(", "d2", "[", "l", "]", ")", ";", "}", "}", "}", "}", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "//ADD: report error?\r", "return", "null", ";", "}", "return", "newArray", ";", "}"], "docstring": "Add 1 to the size of the array for the given dimension.\nUse linear average and interpolation to fill in the values.\n\n@param array    use this array\n@param dimIndex use this dimension\n@return new array with stagger", "docstring_tokens": ["Add", "1", "to", "the", "size", "of", "the", "array", "for", "the", "given", "dimension", ".", "Use", "linear", "average", "and", "interpolation", "to", "fill", "in", "the", "values", "."]}
{"code": "double[] d = new double[n];", "comments": "tmp array to hold extracted values", "lines": 18, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/WRFEta.java", "func_name": "WRFEta.addStagger", "original_string": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "language": "java", "Allcodes": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "code_tokens": ["private", "ArrayDouble", ".", "D3", "addStagger", "(", "ArrayDouble", ".", "D3", "array", ",", "int", "dimIndex", ")", "{", "//ADD: assert 0<=dimIndex<=2\r", "int", "[", "]", "shape", "=", "array", ".", "getShape", "(", ")", ";", "int", "[", "]", "newShape", "=", "new", "int", "[", "3", "]", ";", "System", ".", "arraycopy", "(", "shape", ",", "0", ",", "newShape", ",", "0", ",", "3", ")", ";", "newShape", "[", "dimIndex", "]", "++", ";", "int", "ni", "=", "newShape", "[", "0", "]", ";", "int", "nj", "=", "newShape", "[", "1", "]", ";", "int", "nk", "=", "newShape", "[", "2", "]", ";", "ArrayDouble", ".", "D3", "newArray", "=", "new", "ArrayDouble", ".", "D3", "(", "ni", ",", "nj", ",", "nk", ")", ";", "//Index newIndex = newArray.getIndex();\r", "//extract 1d array to be extended\r", "int", "n", "=", "shape", "[", "dimIndex", "]", ";", "//length of extracted array\r", "double", "[", "]", "d", "=", "new", "double", "[", "n", "]", ";", "//tmp array to hold extracted values\r", "int", "[", "]", "eshape", "=", "new", "int", "[", "3", "]", ";", "//shape of extracted array\r", "int", "[", "]", "neweshape", "=", "new", "int", "[", "3", "]", ";", "//shape of new array slice to write into\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "3", ";", "i", "++", ")", "{", "eshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", ":", "1", ";", "neweshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", "+", "1", ":", "1", ";", "}", "int", "[", "]", "origin", "=", "new", "int", "[", "3", "]", ";", "try", "{", "//loop through the other 2 dimensions and \"extrapinterpolate\" the other\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "(", "(", "dimIndex", "==", "0", ")", "?", "1", ":", "ni", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "(", "(", "dimIndex", "==", "1", ")", "?", "1", ":", "nj", ")", ";", "j", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "(", "(", "dimIndex", "==", "2", ")", "?", "1", ":", "nk", ")", ";", "k", "++", ")", "{", "origin", "[", "0", "]", "=", "i", ";", "origin", "[", "1", "]", "=", "j", ";", "origin", "[", "2", "]", "=", "k", ";", "IndexIterator", "it", "=", "array", ".", "section", "(", "origin", ",", "eshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", ";", "l", "++", ")", "{", "d", "[", "l", "]", "=", "it", ".", "getDoubleNext", "(", ")", ";", "//get the original values\r", "}", "double", "[", "]", "d2", "=", "extrapinterpolate", "(", "d", ")", ";", "//compute new values\r", "//define slice of new array to write into\r", "IndexIterator", "newit", "=", "newArray", ".", "section", "(", "origin", ",", "neweshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", "+", "1", ";", "l", "++", ")", "{", "newit", ".", "setDoubleNext", "(", "d2", "[", "l", "]", ")", ";", "}", "}", "}", "}", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "//ADD: report error?\r", "return", "null", ";", "}", "return", "newArray", ";", "}"], "docstring": "Add 1 to the size of the array for the given dimension.\nUse linear average and interpolation to fill in the values.\n\n@param array    use this array\n@param dimIndex use this dimension\n@return new array with stagger", "docstring_tokens": ["Add", "1", "to", "the", "size", "of", "the", "array", "for", "the", "given", "dimension", ".", "Use", "linear", "average", "and", "interpolation", "to", "fill", "in", "the", "values", "."]}
{"code": "int[] eshape = new int[3];", "comments": "shape of extracted array", "lines": 19, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/WRFEta.java", "func_name": "WRFEta.addStagger", "original_string": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "language": "java", "Allcodes": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "code_tokens": ["private", "ArrayDouble", ".", "D3", "addStagger", "(", "ArrayDouble", ".", "D3", "array", ",", "int", "dimIndex", ")", "{", "//ADD: assert 0<=dimIndex<=2\r", "int", "[", "]", "shape", "=", "array", ".", "getShape", "(", ")", ";", "int", "[", "]", "newShape", "=", "new", "int", "[", "3", "]", ";", "System", ".", "arraycopy", "(", "shape", ",", "0", ",", "newShape", ",", "0", ",", "3", ")", ";", "newShape", "[", "dimIndex", "]", "++", ";", "int", "ni", "=", "newShape", "[", "0", "]", ";", "int", "nj", "=", "newShape", "[", "1", "]", ";", "int", "nk", "=", "newShape", "[", "2", "]", ";", "ArrayDouble", ".", "D3", "newArray", "=", "new", "ArrayDouble", ".", "D3", "(", "ni", ",", "nj", ",", "nk", ")", ";", "//Index newIndex = newArray.getIndex();\r", "//extract 1d array to be extended\r", "int", "n", "=", "shape", "[", "dimIndex", "]", ";", "//length of extracted array\r", "double", "[", "]", "d", "=", "new", "double", "[", "n", "]", ";", "//tmp array to hold extracted values\r", "int", "[", "]", "eshape", "=", "new", "int", "[", "3", "]", ";", "//shape of extracted array\r", "int", "[", "]", "neweshape", "=", "new", "int", "[", "3", "]", ";", "//shape of new array slice to write into\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "3", ";", "i", "++", ")", "{", "eshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", ":", "1", ";", "neweshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", "+", "1", ":", "1", ";", "}", "int", "[", "]", "origin", "=", "new", "int", "[", "3", "]", ";", "try", "{", "//loop through the other 2 dimensions and \"extrapinterpolate\" the other\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "(", "(", "dimIndex", "==", "0", ")", "?", "1", ":", "ni", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "(", "(", "dimIndex", "==", "1", ")", "?", "1", ":", "nj", ")", ";", "j", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "(", "(", "dimIndex", "==", "2", ")", "?", "1", ":", "nk", ")", ";", "k", "++", ")", "{", "origin", "[", "0", "]", "=", "i", ";", "origin", "[", "1", "]", "=", "j", ";", "origin", "[", "2", "]", "=", "k", ";", "IndexIterator", "it", "=", "array", ".", "section", "(", "origin", ",", "eshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", ";", "l", "++", ")", "{", "d", "[", "l", "]", "=", "it", ".", "getDoubleNext", "(", ")", ";", "//get the original values\r", "}", "double", "[", "]", "d2", "=", "extrapinterpolate", "(", "d", ")", ";", "//compute new values\r", "//define slice of new array to write into\r", "IndexIterator", "newit", "=", "newArray", ".", "section", "(", "origin", ",", "neweshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", "+", "1", ";", "l", "++", ")", "{", "newit", ".", "setDoubleNext", "(", "d2", "[", "l", "]", ")", ";", "}", "}", "}", "}", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "//ADD: report error?\r", "return", "null", ";", "}", "return", "newArray", ";", "}"], "docstring": "Add 1 to the size of the array for the given dimension.\nUse linear average and interpolation to fill in the values.\n\n@param array    use this array\n@param dimIndex use this dimension\n@return new array with stagger", "docstring_tokens": ["Add", "1", "to", "the", "size", "of", "the", "array", "for", "the", "given", "dimension", ".", "Use", "linear", "average", "and", "interpolation", "to", "fill", "in", "the", "values", "."]}
{"code": "int[] neweshape = new int[3];", "comments": "shape of new array slice to write into", "lines": 20, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/WRFEta.java", "func_name": "WRFEta.addStagger", "original_string": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "language": "java", "Allcodes": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "code_tokens": ["private", "ArrayDouble", ".", "D3", "addStagger", "(", "ArrayDouble", ".", "D3", "array", ",", "int", "dimIndex", ")", "{", "//ADD: assert 0<=dimIndex<=2\r", "int", "[", "]", "shape", "=", "array", ".", "getShape", "(", ")", ";", "int", "[", "]", "newShape", "=", "new", "int", "[", "3", "]", ";", "System", ".", "arraycopy", "(", "shape", ",", "0", ",", "newShape", ",", "0", ",", "3", ")", ";", "newShape", "[", "dimIndex", "]", "++", ";", "int", "ni", "=", "newShape", "[", "0", "]", ";", "int", "nj", "=", "newShape", "[", "1", "]", ";", "int", "nk", "=", "newShape", "[", "2", "]", ";", "ArrayDouble", ".", "D3", "newArray", "=", "new", "ArrayDouble", ".", "D3", "(", "ni", ",", "nj", ",", "nk", ")", ";", "//Index newIndex = newArray.getIndex();\r", "//extract 1d array to be extended\r", "int", "n", "=", "shape", "[", "dimIndex", "]", ";", "//length of extracted array\r", "double", "[", "]", "d", "=", "new", "double", "[", "n", "]", ";", "//tmp array to hold extracted values\r", "int", "[", "]", "eshape", "=", "new", "int", "[", "3", "]", ";", "//shape of extracted array\r", "int", "[", "]", "neweshape", "=", "new", "int", "[", "3", "]", ";", "//shape of new array slice to write into\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "3", ";", "i", "++", ")", "{", "eshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", ":", "1", ";", "neweshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", "+", "1", ":", "1", ";", "}", "int", "[", "]", "origin", "=", "new", "int", "[", "3", "]", ";", "try", "{", "//loop through the other 2 dimensions and \"extrapinterpolate\" the other\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "(", "(", "dimIndex", "==", "0", ")", "?", "1", ":", "ni", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "(", "(", "dimIndex", "==", "1", ")", "?", "1", ":", "nj", ")", ";", "j", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "(", "(", "dimIndex", "==", "2", ")", "?", "1", ":", "nk", ")", ";", "k", "++", ")", "{", "origin", "[", "0", "]", "=", "i", ";", "origin", "[", "1", "]", "=", "j", ";", "origin", "[", "2", "]", "=", "k", ";", "IndexIterator", "it", "=", "array", ".", "section", "(", "origin", ",", "eshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", ";", "l", "++", ")", "{", "d", "[", "l", "]", "=", "it", ".", "getDoubleNext", "(", ")", ";", "//get the original values\r", "}", "double", "[", "]", "d2", "=", "extrapinterpolate", "(", "d", ")", ";", "//compute new values\r", "//define slice of new array to write into\r", "IndexIterator", "newit", "=", "newArray", ".", "section", "(", "origin", ",", "neweshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", "+", "1", ";", "l", "++", ")", "{", "newit", ".", "setDoubleNext", "(", "d2", "[", "l", "]", ")", ";", "}", "}", "}", "}", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "//ADD: report error?\r", "return", "null", ";", "}", "return", "newArray", ";", "}"], "docstring": "Add 1 to the size of the array for the given dimension.\nUse linear average and interpolation to fill in the values.\n\n@param array    use this array\n@param dimIndex use this dimension\n@return new array with stagger", "docstring_tokens": ["Add", "1", "to", "the", "size", "of", "the", "array", "for", "the", "given", "dimension", ".", "Use", "linear", "average", "and", "interpolation", "to", "fill", "in", "the", "values", "."]}
{"code": "d[l] = it.getDoubleNext();", "comments": "get the original values", "lines": 49, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/WRFEta.java", "func_name": "WRFEta.addStagger", "original_string": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "language": "java", "Allcodes": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "code_tokens": ["private", "ArrayDouble", ".", "D3", "addStagger", "(", "ArrayDouble", ".", "D3", "array", ",", "int", "dimIndex", ")", "{", "//ADD: assert 0<=dimIndex<=2\r", "int", "[", "]", "shape", "=", "array", ".", "getShape", "(", ")", ";", "int", "[", "]", "newShape", "=", "new", "int", "[", "3", "]", ";", "System", ".", "arraycopy", "(", "shape", ",", "0", ",", "newShape", ",", "0", ",", "3", ")", ";", "newShape", "[", "dimIndex", "]", "++", ";", "int", "ni", "=", "newShape", "[", "0", "]", ";", "int", "nj", "=", "newShape", "[", "1", "]", ";", "int", "nk", "=", "newShape", "[", "2", "]", ";", "ArrayDouble", ".", "D3", "newArray", "=", "new", "ArrayDouble", ".", "D3", "(", "ni", ",", "nj", ",", "nk", ")", ";", "//Index newIndex = newArray.getIndex();\r", "//extract 1d array to be extended\r", "int", "n", "=", "shape", "[", "dimIndex", "]", ";", "//length of extracted array\r", "double", "[", "]", "d", "=", "new", "double", "[", "n", "]", ";", "//tmp array to hold extracted values\r", "int", "[", "]", "eshape", "=", "new", "int", "[", "3", "]", ";", "//shape of extracted array\r", "int", "[", "]", "neweshape", "=", "new", "int", "[", "3", "]", ";", "//shape of new array slice to write into\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "3", ";", "i", "++", ")", "{", "eshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", ":", "1", ";", "neweshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", "+", "1", ":", "1", ";", "}", "int", "[", "]", "origin", "=", "new", "int", "[", "3", "]", ";", "try", "{", "//loop through the other 2 dimensions and \"extrapinterpolate\" the other\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "(", "(", "dimIndex", "==", "0", ")", "?", "1", ":", "ni", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "(", "(", "dimIndex", "==", "1", ")", "?", "1", ":", "nj", ")", ";", "j", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "(", "(", "dimIndex", "==", "2", ")", "?", "1", ":", "nk", ")", ";", "k", "++", ")", "{", "origin", "[", "0", "]", "=", "i", ";", "origin", "[", "1", "]", "=", "j", ";", "origin", "[", "2", "]", "=", "k", ";", "IndexIterator", "it", "=", "array", ".", "section", "(", "origin", ",", "eshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", ";", "l", "++", ")", "{", "d", "[", "l", "]", "=", "it", ".", "getDoubleNext", "(", ")", ";", "//get the original values\r", "}", "double", "[", "]", "d2", "=", "extrapinterpolate", "(", "d", ")", ";", "//compute new values\r", "//define slice of new array to write into\r", "IndexIterator", "newit", "=", "newArray", ".", "section", "(", "origin", ",", "neweshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", "+", "1", ";", "l", "++", ")", "{", "newit", ".", "setDoubleNext", "(", "d2", "[", "l", "]", ")", ";", "}", "}", "}", "}", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "//ADD: report error?\r", "return", "null", ";", "}", "return", "newArray", ";", "}"], "docstring": "Add 1 to the size of the array for the given dimension.\nUse linear average and interpolation to fill in the values.\n\n@param array    use this array\n@param dimIndex use this dimension\n@return new array with stagger", "docstring_tokens": ["Add", "1", "to", "the", "size", "of", "the", "array", "for", "the", "given", "dimension", ".", "Use", "linear", "average", "and", "interpolation", "to", "fill", "in", "the", "values", "."]}
{"code": "double[] d2 = extrapinterpolate(d);", "comments": "compute new values", "lines": 51, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/WRFEta.java", "func_name": "WRFEta.addStagger", "original_string": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "language": "java", "Allcodes": "private ArrayDouble.D3 addStagger(ArrayDouble.D3 array, int dimIndex) {\r\n\r\n    //ADD: assert 0<=dimIndex<=2\r\n\r\n    int[] shape = array.getShape();\r\n    int[] newShape = new int[3];\r\n    System.arraycopy(shape, 0, newShape, 0, 3);\r\n\r\n    newShape[dimIndex]++;\r\n    int ni = newShape[0];\r\n    int nj = newShape[1];\r\n    int nk = newShape[2];\r\n    ArrayDouble.D3 newArray = new ArrayDouble.D3(ni, nj, nk);\r\n    //Index newIndex = newArray.getIndex();\r\n\r\n    //extract 1d array to be extended\r\n    int n = shape[dimIndex];  //length of extracted array\r\n    double[] d = new double[n];  //tmp array to hold extracted values\r\n    int[] eshape = new int[3];       //shape of extracted array\r\n    int[] neweshape = new int[3];  //shape of new array slice to write into\r\n    for (int i = 0; i < 3; i++) {\r\n      eshape[i] = (i == dimIndex)\r\n          ? n\r\n          : 1;\r\n      neweshape[i] = (i == dimIndex)\r\n          ? n + 1\r\n          : 1;\r\n    }\r\n    int[] origin = new int[3];\r\n\r\n    try {\r\n\r\n      //loop through the other 2 dimensions and \"extrapinterpolate\" the other\r\n      for (int i = 0; i < ((dimIndex == 0)\r\n          ? 1\r\n          : ni); i++) {\r\n        for (int j = 0; j < ((dimIndex == 1)\r\n            ? 1\r\n            : nj); j++) {\r\n          for (int k = 0; k < ((dimIndex == 2)\r\n              ? 1\r\n              : nk); k++) {\r\n            origin[0] = i;\r\n            origin[1] = j;\r\n            origin[2] = k;\r\n            IndexIterator it = array.section(origin,\r\n                eshape).getIndexIterator();\r\n            for (int l = 0; l < n; l++) {\r\n              d[l] = it.getDoubleNext();  //get the original values\r\n            }\r\n            double[] d2 = extrapinterpolate(d);  //compute new values\r\n            //define slice of new array to write into\r\n            IndexIterator newit =\r\n                newArray.section(origin,\r\n                    neweshape).getIndexIterator();\r\n            for (int l = 0; l < n + 1; l++) {\r\n              newit.setDoubleNext(d2[l]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (InvalidRangeException e) {\r\n      //ADD: report error?\r\n      return null;\r\n    }\r\n\r\n    return newArray;\r\n  }", "code_tokens": ["private", "ArrayDouble", ".", "D3", "addStagger", "(", "ArrayDouble", ".", "D3", "array", ",", "int", "dimIndex", ")", "{", "//ADD: assert 0<=dimIndex<=2\r", "int", "[", "]", "shape", "=", "array", ".", "getShape", "(", ")", ";", "int", "[", "]", "newShape", "=", "new", "int", "[", "3", "]", ";", "System", ".", "arraycopy", "(", "shape", ",", "0", ",", "newShape", ",", "0", ",", "3", ")", ";", "newShape", "[", "dimIndex", "]", "++", ";", "int", "ni", "=", "newShape", "[", "0", "]", ";", "int", "nj", "=", "newShape", "[", "1", "]", ";", "int", "nk", "=", "newShape", "[", "2", "]", ";", "ArrayDouble", ".", "D3", "newArray", "=", "new", "ArrayDouble", ".", "D3", "(", "ni", ",", "nj", ",", "nk", ")", ";", "//Index newIndex = newArray.getIndex();\r", "//extract 1d array to be extended\r", "int", "n", "=", "shape", "[", "dimIndex", "]", ";", "//length of extracted array\r", "double", "[", "]", "d", "=", "new", "double", "[", "n", "]", ";", "//tmp array to hold extracted values\r", "int", "[", "]", "eshape", "=", "new", "int", "[", "3", "]", ";", "//shape of extracted array\r", "int", "[", "]", "neweshape", "=", "new", "int", "[", "3", "]", ";", "//shape of new array slice to write into\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "3", ";", "i", "++", ")", "{", "eshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", ":", "1", ";", "neweshape", "[", "i", "]", "=", "(", "i", "==", "dimIndex", ")", "?", "n", "+", "1", ":", "1", ";", "}", "int", "[", "]", "origin", "=", "new", "int", "[", "3", "]", ";", "try", "{", "//loop through the other 2 dimensions and \"extrapinterpolate\" the other\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "(", "(", "dimIndex", "==", "0", ")", "?", "1", ":", "ni", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "(", "(", "dimIndex", "==", "1", ")", "?", "1", ":", "nj", ")", ";", "j", "++", ")", "{", "for", "(", "int", "k", "=", "0", ";", "k", "<", "(", "(", "dimIndex", "==", "2", ")", "?", "1", ":", "nk", ")", ";", "k", "++", ")", "{", "origin", "[", "0", "]", "=", "i", ";", "origin", "[", "1", "]", "=", "j", ";", "origin", "[", "2", "]", "=", "k", ";", "IndexIterator", "it", "=", "array", ".", "section", "(", "origin", ",", "eshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", ";", "l", "++", ")", "{", "d", "[", "l", "]", "=", "it", ".", "getDoubleNext", "(", ")", ";", "//get the original values\r", "}", "double", "[", "]", "d2", "=", "extrapinterpolate", "(", "d", ")", ";", "//compute new values\r", "//define slice of new array to write into\r", "IndexIterator", "newit", "=", "newArray", ".", "section", "(", "origin", ",", "neweshape", ")", ".", "getIndexIterator", "(", ")", ";", "for", "(", "int", "l", "=", "0", ";", "l", "<", "n", "+", "1", ";", "l", "++", ")", "{", "newit", ".", "setDoubleNext", "(", "d2", "[", "l", "]", ")", ";", "}", "}", "}", "}", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "//ADD: report error?\r", "return", "null", ";", "}", "return", "newArray", ";", "}"], "docstring": "Add 1 to the size of the array for the given dimension.\nUse linear average and interpolation to fill in the values.\n\n@param array    use this array\n@param dimIndex use this dimension\n@return new array with stagger", "docstring_tokens": ["Add", "1", "to", "the", "size", "of", "the", "array", "for", "the", "given", "dimension", ".", "Use", "linear", "average", "and", "interpolation", "to", "fill", "in", "the", "values", "."]}
{"code": "return dmr;", "comments": "return the DMR", "lines": 57, "repo": "Unidata/thredds", "path": "dap4/d4lib/src/main/java/dap4/dap4lib/ChunkInputStream.java", "func_name": "ChunkInputStream.readDMR", "original_string": "public String\n    readDMR()\n            throws DapException\n    {\n        try {\n            if(state != State.INITIAL)\n                throw new DapException(\"Attempt to read DMR twice\");\n\n            byte[] dmr8 = null;\n\n            if(requestmode == RequestMode.DMR) {\n                // The whole buffer is the dmr;\n                // but we do not know the length\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int c;\n                while((c = input.read()) >= 0) {\n                    baos.write(c);\n                }\n                baos.close();\n                dmr8 = baos.toByteArray();\n            } else if(requestmode == RequestMode.DAP) {\n                // Pull in the DMR chunk header\n                if(!readHeader(input))\n                    throw new DapException(\"Malformed chunk count\");\n                // Read the DMR databuffer\n                dmr8 = new byte[this.chunksize];\n                int red = read(dmr8, 0, this.chunksize);\n                if(red < this.chunksize)\n                    throw new DapException(\"Short chunk\");\n            } else\n                assert false : \"Internal error\";\n\n            // Convert DMR to a string\n            String dmr = new String(dmr8, DapUtil.UTF8);\n            // Clean it up\n            dmr = dmr.trim();\n            // Make sure it has trailing \\r\\n\"\n            if(dmr.endsWith(\"\\r\\n\")) {\n                // do nothing\n            } else if(dmr.endsWith(\"\\n\"))\n                dmr = dmr.substring(0,dmr.length()-2) + \"\\r\\n\";\n            else\n                dmr = dmr + \"\\r\\n\";\n\n            // Figure out the endian-ness of the response\n            this.remoteorder = (flags & DapUtil.CHUNK_LITTLE_ENDIAN) == 0 ? ByteOrder.BIG_ENDIAN\n                    : ByteOrder.LITTLE_ENDIAN;\n            this.nochecksum = (flags & DapUtil.CHUNK_NOCHECKSUM) != 0;\n\n            // Set the state\n            if((flags & DapUtil.CHUNK_ERROR) != 0)\n                state = State.ERROR;\n            else if((flags & DapUtil.CHUNK_END) != 0)\n                state = State.END;\n            else\n                state = State.DATA;\n            return dmr; //return the DMR\n\n        } catch (IOException ioe) {\n            throw new DapException(ioe.getMessage());\n        }\n    }", "language": "java", "Allcodes": "public String\n    readDMR()\n            throws DapException\n    {\n        try {\n            if(state != State.INITIAL)\n                throw new DapException(\"Attempt to read DMR twice\");\n\n            byte[] dmr8 = null;\n\n            if(requestmode == RequestMode.DMR) {\n                // The whole buffer is the dmr;\n                // but we do not know the length\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int c;\n                while((c = input.read()) >= 0) {\n                    baos.write(c);\n                }\n                baos.close();\n                dmr8 = baos.toByteArray();\n            } else if(requestmode == RequestMode.DAP) {\n                // Pull in the DMR chunk header\n                if(!readHeader(input))\n                    throw new DapException(\"Malformed chunk count\");\n                // Read the DMR databuffer\n                dmr8 = new byte[this.chunksize];\n                int red = read(dmr8, 0, this.chunksize);\n                if(red < this.chunksize)\n                    throw new DapException(\"Short chunk\");\n            } else\n                assert false : \"Internal error\";\n\n            // Convert DMR to a string\n            String dmr = new String(dmr8, DapUtil.UTF8);\n            // Clean it up\n            dmr = dmr.trim();\n            // Make sure it has trailing \\r\\n\"\n            if(dmr.endsWith(\"\\r\\n\")) {\n                // do nothing\n            } else if(dmr.endsWith(\"\\n\"))\n                dmr = dmr.substring(0,dmr.length()-2) + \"\\r\\n\";\n            else\n                dmr = dmr + \"\\r\\n\";\n\n            // Figure out the endian-ness of the response\n            this.remoteorder = (flags & DapUtil.CHUNK_LITTLE_ENDIAN) == 0 ? ByteOrder.BIG_ENDIAN\n                    : ByteOrder.LITTLE_ENDIAN;\n            this.nochecksum = (flags & DapUtil.CHUNK_NOCHECKSUM) != 0;\n\n            // Set the state\n            if((flags & DapUtil.CHUNK_ERROR) != 0)\n                state = State.ERROR;\n            else if((flags & DapUtil.CHUNK_END) != 0)\n                state = State.END;\n            else\n                state = State.DATA;\n            return dmr; //return the DMR\n\n        } catch (IOException ioe) {\n            throw new DapException(ioe.getMessage());\n        }\n    }", "code_tokens": ["public", "String", "readDMR", "(", ")", "throws", "DapException", "{", "try", "{", "if", "(", "state", "!=", "State", ".", "INITIAL", ")", "throw", "new", "DapException", "(", "\"Attempt to read DMR twice\"", ")", ";", "byte", "[", "]", "dmr8", "=", "null", ";", "if", "(", "requestmode", "==", "RequestMode", ".", "DMR", ")", "{", "// The whole buffer is the dmr;", "// but we do not know the length", "ByteArrayOutputStream", "baos", "=", "new", "ByteArrayOutputStream", "(", ")", ";", "int", "c", ";", "while", "(", "(", "c", "=", "input", ".", "read", "(", ")", ")", ">=", "0", ")", "{", "baos", ".", "write", "(", "c", ")", ";", "}", "baos", ".", "close", "(", ")", ";", "dmr8", "=", "baos", ".", "toByteArray", "(", ")", ";", "}", "else", "if", "(", "requestmode", "==", "RequestMode", ".", "DAP", ")", "{", "// Pull in the DMR chunk header", "if", "(", "!", "readHeader", "(", "input", ")", ")", "throw", "new", "DapException", "(", "\"Malformed chunk count\"", ")", ";", "// Read the DMR databuffer", "dmr8", "=", "new", "byte", "[", "this", ".", "chunksize", "]", ";", "int", "red", "=", "read", "(", "dmr8", ",", "0", ",", "this", ".", "chunksize", ")", ";", "if", "(", "red", "<", "this", ".", "chunksize", ")", "throw", "new", "DapException", "(", "\"Short chunk\"", ")", ";", "}", "else", "assert", "false", ":", "\"Internal error\"", ";", "// Convert DMR to a string", "String", "dmr", "=", "new", "String", "(", "dmr8", ",", "DapUtil", ".", "UTF8", ")", ";", "// Clean it up", "dmr", "=", "dmr", ".", "trim", "(", ")", ";", "// Make sure it has trailing \\r\\n\"", "if", "(", "dmr", ".", "endsWith", "(", "\"\\r\\n\"", ")", ")", "{", "// do nothing", "}", "else", "if", "(", "dmr", ".", "endsWith", "(", "\"\\n\"", ")", ")", "dmr", "=", "dmr", ".", "substring", "(", "0", ",", "dmr", ".", "length", "(", ")", "-", "2", ")", "+", "\"\\r\\n\"", ";", "else", "dmr", "=", "dmr", "+", "\"\\r\\n\"", ";", "// Figure out the endian-ness of the response", "this", ".", "remoteorder", "=", "(", "flags", "&", "DapUtil", ".", "CHUNK_LITTLE_ENDIAN", ")", "==", "0", "?", "ByteOrder", ".", "BIG_ENDIAN", ":", "ByteOrder", ".", "LITTLE_ENDIAN", ";", "this", ".", "nochecksum", "=", "(", "flags", "&", "DapUtil", ".", "CHUNK_NOCHECKSUM", ")", "!=", "0", ";", "// Set the state", "if", "(", "(", "flags", "&", "DapUtil", ".", "CHUNK_ERROR", ")", "!=", "0", ")", "state", "=", "State", ".", "ERROR", ";", "else", "if", "(", "(", "flags", "&", "DapUtil", ".", "CHUNK_END", ")", "!=", "0", ")", "state", "=", "State", ".", "END", ";", "else", "state", "=", "State", ".", "DATA", ";", "return", "dmr", ";", "//return the DMR", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "DapException", "(", "ioe", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "docstring": "Read the DMR, trimmed.\n\n@return the DMR as a Java String", "docstring_tokens": ["Read", "the", "DMR", "trimmed", "."]}
{"code": "throw new IndexOutOfBoundsException();", "comments": "Runtime", "lines": 7, "repo": "Unidata/thredds", "path": "dap4/d4lib/src/main/java/dap4/dap4lib/ChunkInputStream.java", "func_name": "ChunkInputStream.read", "original_string": "public int\n    read(byte[] buf, int off, int len)\n            throws IOException\n    {\n        // Sanity check\n        if(off < 0 || len < 0)\n            throw new IndexOutOfBoundsException();// Runtime\n        if(off >= buf.length || buf.length < (off + len))\n            throw new IndexOutOfBoundsException(); //Runtime\n        if(requestmode == RequestMode.DMR)\n            throw new UnsupportedOperationException(\"Attempt to read databuffer when DMR only\"); // Runtime\n\n        // Attempt to read len bytes out of a sequence of chunks\n        int count = len;\n        int pos = off;\n        while(count > 0) {\n            if(avail <= 0) {\n                if((flags & DapUtil.CHUNK_END) != 0\n                        || !readHeader(input))\n                    return (len - count); // return # databuffer read\n                // See if we have an error chunk,\n                // and if so, turn it into an exception\n                if((flags & DapUtil.CHUNK_ERROR) != 0) {\n                    String document = readError();\n                    throwError(document);\n                }\n            } else {\n                int actual = (this.avail < count ? this.avail : count);\n                int red = input.read(buf, pos, actual);\n                if(red < 0)\n                    throw new IOException(\"Unexpected EOF\");\n                pos += red;\n                count -= red;\n                this.avail -= red;\n            }\n        }\n        return len;\n    }", "language": "java", "Allcodes": "public int\n    read(byte[] buf, int off, int len)\n            throws IOException\n    {\n        // Sanity check\n        if(off < 0 || len < 0)\n            throw new IndexOutOfBoundsException();// Runtime\n        if(off >= buf.length || buf.length < (off + len))\n            throw new IndexOutOfBoundsException(); //Runtime\n        if(requestmode == RequestMode.DMR)\n            throw new UnsupportedOperationException(\"Attempt to read databuffer when DMR only\"); // Runtime\n\n        // Attempt to read len bytes out of a sequence of chunks\n        int count = len;\n        int pos = off;\n        while(count > 0) {\n            if(avail <= 0) {\n                if((flags & DapUtil.CHUNK_END) != 0\n                        || !readHeader(input))\n                    return (len - count); // return # databuffer read\n                // See if we have an error chunk,\n                // and if so, turn it into an exception\n                if((flags & DapUtil.CHUNK_ERROR) != 0) {\n                    String document = readError();\n                    throwError(document);\n                }\n            } else {\n                int actual = (this.avail < count ? this.avail : count);\n                int red = input.read(buf, pos, actual);\n                if(red < 0)\n                    throw new IOException(\"Unexpected EOF\");\n                pos += red;\n                count -= red;\n                this.avail -= red;\n            }\n        }\n        return len;\n    }", "code_tokens": ["public", "int", "read", "(", "byte", "[", "]", "buf", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Sanity check", "if", "(", "off", "<", "0", "||", "len", "<", "0", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "// Runtime", "if", "(", "off", ">=", "buf", ".", "length", "||", "buf", ".", "length", "<", "(", "off", "+", "len", ")", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "//Runtime", "if", "(", "requestmode", "==", "RequestMode", ".", "DMR", ")", "throw", "new", "UnsupportedOperationException", "(", "\"Attempt to read databuffer when DMR only\"", ")", ";", "// Runtime", "// Attempt to read len bytes out of a sequence of chunks", "int", "count", "=", "len", ";", "int", "pos", "=", "off", ";", "while", "(", "count", ">", "0", ")", "{", "if", "(", "avail", "<=", "0", ")", "{", "if", "(", "(", "flags", "&", "DapUtil", ".", "CHUNK_END", ")", "!=", "0", "||", "!", "readHeader", "(", "input", ")", ")", "return", "(", "len", "-", "count", ")", ";", "// return # databuffer read", "// See if we have an error chunk,", "// and if so, turn it into an exception", "if", "(", "(", "flags", "&", "DapUtil", ".", "CHUNK_ERROR", ")", "!=", "0", ")", "{", "String", "document", "=", "readError", "(", ")", ";", "throwError", "(", "document", ")", ";", "}", "}", "else", "{", "int", "actual", "=", "(", "this", ".", "avail", "<", "count", "?", "this", ".", "avail", ":", "count", ")", ";", "int", "red", "=", "input", ".", "read", "(", "buf", ",", "pos", ",", "actual", ")", ";", "if", "(", "red", "<", "0", ")", "throw", "new", "IOException", "(", "\"Unexpected EOF\"", ")", ";", "pos", "+=", "red", ";", "count", "-=", "red", ";", "this", ".", "avail", "-=", "red", ";", "}", "}", "return", "len", ";", "}"], "docstring": "Reads up to len databuffer of databuffer from the input stream into an\narray of databuffer. An attempt is made to read as many as len\ndatabuffer, but a smaller number may be read. The number of databuffer\nactually read is returned as an integer.\n\n@param buf the byte array into which databuffer is read\n@param off the offset in the byte array at which to write\n@param len the amount to read\n@return the actual number of databuffer read\n@throws IOException", "docstring_tokens": ["Reads", "up", "to", "len", "databuffer", "of", "databuffer", "from", "the", "input", "stream", "into", "an", "array", "of", "databuffer", ".", "An", "attempt", "is", "made", "to", "read", "as", "many", "as", "len", "databuffer", "but", "a", "smaller", "number", "may", "be", "read", ".", "The", "number", "of", "databuffer", "actually", "read", "is", "returned", "as", "an", "integer", "."]}
{"code": "return (len - count);", "comments": "return # databuffer read", "lines": 20, "repo": "Unidata/thredds", "path": "dap4/d4lib/src/main/java/dap4/dap4lib/ChunkInputStream.java", "func_name": "ChunkInputStream.read", "original_string": "public int\n    read(byte[] buf, int off, int len)\n            throws IOException\n    {\n        // Sanity check\n        if(off < 0 || len < 0)\n            throw new IndexOutOfBoundsException();// Runtime\n        if(off >= buf.length || buf.length < (off + len))\n            throw new IndexOutOfBoundsException(); //Runtime\n        if(requestmode == RequestMode.DMR)\n            throw new UnsupportedOperationException(\"Attempt to read databuffer when DMR only\"); // Runtime\n\n        // Attempt to read len bytes out of a sequence of chunks\n        int count = len;\n        int pos = off;\n        while(count > 0) {\n            if(avail <= 0) {\n                if((flags & DapUtil.CHUNK_END) != 0\n                        || !readHeader(input))\n                    return (len - count); // return # databuffer read\n                // See if we have an error chunk,\n                // and if so, turn it into an exception\n                if((flags & DapUtil.CHUNK_ERROR) != 0) {\n                    String document = readError();\n                    throwError(document);\n                }\n            } else {\n                int actual = (this.avail < count ? this.avail : count);\n                int red = input.read(buf, pos, actual);\n                if(red < 0)\n                    throw new IOException(\"Unexpected EOF\");\n                pos += red;\n                count -= red;\n                this.avail -= red;\n            }\n        }\n        return len;\n    }", "language": "java", "Allcodes": "public int\n    read(byte[] buf, int off, int len)\n            throws IOException\n    {\n        // Sanity check\n        if(off < 0 || len < 0)\n            throw new IndexOutOfBoundsException();// Runtime\n        if(off >= buf.length || buf.length < (off + len))\n            throw new IndexOutOfBoundsException(); //Runtime\n        if(requestmode == RequestMode.DMR)\n            throw new UnsupportedOperationException(\"Attempt to read databuffer when DMR only\"); // Runtime\n\n        // Attempt to read len bytes out of a sequence of chunks\n        int count = len;\n        int pos = off;\n        while(count > 0) {\n            if(avail <= 0) {\n                if((flags & DapUtil.CHUNK_END) != 0\n                        || !readHeader(input))\n                    return (len - count); // return # databuffer read\n                // See if we have an error chunk,\n                // and if so, turn it into an exception\n                if((flags & DapUtil.CHUNK_ERROR) != 0) {\n                    String document = readError();\n                    throwError(document);\n                }\n            } else {\n                int actual = (this.avail < count ? this.avail : count);\n                int red = input.read(buf, pos, actual);\n                if(red < 0)\n                    throw new IOException(\"Unexpected EOF\");\n                pos += red;\n                count -= red;\n                this.avail -= red;\n            }\n        }\n        return len;\n    }", "code_tokens": ["public", "int", "read", "(", "byte", "[", "]", "buf", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Sanity check", "if", "(", "off", "<", "0", "||", "len", "<", "0", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "// Runtime", "if", "(", "off", ">=", "buf", ".", "length", "||", "buf", ".", "length", "<", "(", "off", "+", "len", ")", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "//Runtime", "if", "(", "requestmode", "==", "RequestMode", ".", "DMR", ")", "throw", "new", "UnsupportedOperationException", "(", "\"Attempt to read databuffer when DMR only\"", ")", ";", "// Runtime", "// Attempt to read len bytes out of a sequence of chunks", "int", "count", "=", "len", ";", "int", "pos", "=", "off", ";", "while", "(", "count", ">", "0", ")", "{", "if", "(", "avail", "<=", "0", ")", "{", "if", "(", "(", "flags", "&", "DapUtil", ".", "CHUNK_END", ")", "!=", "0", "||", "!", "readHeader", "(", "input", ")", ")", "return", "(", "len", "-", "count", ")", ";", "// return # databuffer read", "// See if we have an error chunk,", "// and if so, turn it into an exception", "if", "(", "(", "flags", "&", "DapUtil", ".", "CHUNK_ERROR", ")", "!=", "0", ")", "{", "String", "document", "=", "readError", "(", ")", ";", "throwError", "(", "document", ")", ";", "}", "}", "else", "{", "int", "actual", "=", "(", "this", ".", "avail", "<", "count", "?", "this", ".", "avail", ":", "count", ")", ";", "int", "red", "=", "input", ".", "read", "(", "buf", ",", "pos", ",", "actual", ")", ";", "if", "(", "red", "<", "0", ")", "throw", "new", "IOException", "(", "\"Unexpected EOF\"", ")", ";", "pos", "+=", "red", ";", "count", "-=", "red", ";", "this", ".", "avail", "-=", "red", ";", "}", "}", "return", "len", ";", "}"], "docstring": "Reads up to len databuffer of databuffer from the input stream into an\narray of databuffer. An attempt is made to read as many as len\ndatabuffer, but a smaller number may be read. The number of databuffer\nactually read is returned as an integer.\n\n@param buf the byte array into which databuffer is read\n@param off the offset in the byte array at which to write\n@param len the amount to read\n@return the actual number of databuffer read\n@throws IOException", "docstring_tokens": ["Reads", "up", "to", "len", "databuffer", "of", "databuffer", "from", "the", "input", "stream", "into", "an", "array", "of", "databuffer", ".", "An", "attempt", "is", "made", "to", "read", "as", "many", "as", "len", "databuffer", "but", "a", "smaller", "number", "may", "be", "read", ".", "The", "number", "of", "databuffer", "actually", "read", "is", "returned", "as", "an", "integer", "."]}
{"code": "this.flags = ((int) bytehdr[0]) & 0xFF;", "comments": "Keep unsigned", "lines": 10, "repo": "Unidata/thredds", "path": "dap4/d4lib/src/main/java/dap4/dap4lib/ChunkInputStream.java", "func_name": "ChunkInputStream.readHeader", "original_string": "boolean\n    readHeader(InputStream input)\n            throws IOException\n    {\n        byte[] bytehdr = new byte[4];\n        int red = input.read(bytehdr);\n        if(red == -1) return false;\n        if(red < 4)\n            throw new IOException(\"Short binary chunk count\");\n        this.flags = ((int) bytehdr[0]) & 0xFF; // Keep unsigned\n        bytehdr[0] = 0;\n        ByteBuffer buf = ByteBuffer.wrap(bytehdr).order(ByteOrder.BIG_ENDIAN);\n        this.chunksize = buf.getInt();\n        this.avail = this.chunksize;\n        return true;\n    }", "language": "java", "Allcodes": "boolean\n    readHeader(InputStream input)\n            throws IOException\n    {\n        byte[] bytehdr = new byte[4];\n        int red = input.read(bytehdr);\n        if(red == -1) return false;\n        if(red < 4)\n            throw new IOException(\"Short binary chunk count\");\n        this.flags = ((int) bytehdr[0]) & 0xFF; // Keep unsigned\n        bytehdr[0] = 0;\n        ByteBuffer buf = ByteBuffer.wrap(bytehdr).order(ByteOrder.BIG_ENDIAN);\n        this.chunksize = buf.getInt();\n        this.avail = this.chunksize;\n        return true;\n    }", "code_tokens": ["boolean", "readHeader", "(", "InputStream", "input", ")", "throws", "IOException", "{", "byte", "[", "]", "bytehdr", "=", "new", "byte", "[", "4", "]", ";", "int", "red", "=", "input", ".", "read", "(", "bytehdr", ")", ";", "if", "(", "red", "==", "-", "1", ")", "return", "false", ";", "if", "(", "red", "<", "4", ")", "throw", "new", "IOException", "(", "\"Short binary chunk count\"", ")", ";", "this", ".", "flags", "=", "(", "(", "int", ")", "bytehdr", "[", "0", "]", ")", "&", "0xFF", ";", "// Keep unsigned", "bytehdr", "[", "0", "]", "=", "0", ";", "ByteBuffer", "buf", "=", "ByteBuffer", ".", "wrap", "(", "bytehdr", ")", ".", "order", "(", "ByteOrder", ".", "BIG_ENDIAN", ")", ";", "this", ".", "chunksize", "=", "buf", ".", "getInt", "(", ")", ";", "this", ".", "avail", "=", "this", ".", "chunksize", ";", "return", "true", ";", "}"], "docstring": "Read the size+flags header from the input stream and use it to\ninitialize the chunk state\n\n@param input The input streamfrom which to read\n@return true if header read false if immediate eof encountered", "docstring_tokens": ["Read", "the", "size", "+", "flags", "header", "from", "the", "input", "stream", "and", "use", "it", "to", "initialize", "the", "chunk", "state"]}
{"code": "boolean unlimitedOK = true;", "comments": "LOOK why not allowed?", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/DatasetConstructor.java", "func_name": "DatasetConstructor.transferGroup", "original_string": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "language": "java", "Allcodes": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "code_tokens": ["static", "private", "void", "transferGroup", "(", "NetcdfFile", "ds", ",", "NetcdfDataset", "targetDs", ",", "Group", "src", ",", "Group", "targetGroup", ",", "ReplaceVariableCheck", "replaceCheck", ")", "{", "boolean", "unlimitedOK", "=", "true", ";", "// LOOK why not allowed?", "// group attributes", "transferGroupAttributes", "(", "src", ",", "targetGroup", ")", ";", "// dimensions", "for", "(", "Dimension", "d", ":", "src", ".", "getDimensions", "(", ")", ")", "{", "if", "(", "null", "==", "targetGroup", ".", "findDimensionLocal", "(", "d", ".", "getShortName", "(", ")", ")", ")", "{", "Dimension", "newd", "=", "new", "Dimension", "(", "d", ".", "getShortName", "(", ")", ",", "d", ".", "getLength", "(", ")", ",", "d", ".", "isShared", "(", ")", ",", "unlimitedOK", "&&", "d", ".", "isUnlimited", "(", ")", ",", "d", ".", "isVariableLength", "(", ")", ")", ";", "targetGroup", ".", "addDimension", "(", "newd", ")", ";", "}", "}", "// variables", "for", "(", "Variable", "v", ":", "src", ".", "getVariables", "(", ")", ")", "{", "Variable", "targetV", "=", "targetGroup", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "VariableEnhanced", "targetVe", "=", "(", "VariableEnhanced", ")", "targetV", ";", "boolean", "replace", "=", "(", "replaceCheck", "!=", "null", ")", "&&", "replaceCheck", ".", "replace", "(", "v", ")", ";", "// replaceCheck not currently used", "if", "(", "replace", "||", "(", "null", "==", "targetV", ")", ")", "{", "// replace it", "if", "(", "(", "v", "instanceof", "Structure", ")", "&&", "!", "(", "v", "instanceof", "StructureDS", ")", ")", "{", "v", "=", "new", "StructureDS", "(", "targetGroup", ",", "(", "Structure", ")", "v", ")", ";", "// else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm", "}", "else", "if", "(", "!", "(", "v", "instanceof", "VariableDS", ")", ")", "{", "v", "=", "new", "VariableDS", "(", "targetGroup", ",", "v", ",", "false", ")", ";", "// enhancement done by original variable, this is just to reparent to target dataset.", "}", "if", "(", "null", "!=", "targetV", ")", "targetGroup", ".", "remove", "(", "targetV", ")", ";", "targetGroup", ".", "addVariable", "(", "v", ")", ";", "// reparent group", "v", ".", "resetDimensions", "(", ")", ";", "// dimensions will be different", "}", "else", "if", "(", "!", "targetV", ".", "hasCachedData", "(", ")", "&&", "(", "targetVe", ".", "getOriginalVariable", "(", ")", "==", "null", ")", ")", "{", "// this is the case where we defined the variable, but didnt set its data. we now set it with the first nested", "// dataset that has a variable with the same name", "targetVe", ".", "setOriginalVariable", "(", "v", ")", ";", "}", "}", "// nested groups - check if target already has it", "for", "(", "Group", "srcNested", ":", "src", ".", "getGroups", "(", ")", ")", "{", "Group", "nested", "=", "targetGroup", ".", "findGroup", "(", "srcNested", ".", "getShortName", "(", ")", ")", ";", "if", "(", "null", "==", "nested", ")", "{", "nested", "=", "new", "Group", "(", "ds", ",", "targetGroup", ",", "srcNested", ".", "getShortName", "(", ")", ")", ";", "targetGroup", ".", "addGroup", "(", "nested", ")", ";", "}", "transferGroup", "(", "ds", ",", "targetDs", ",", "srcNested", ",", "nested", ",", "replaceCheck", ")", ";", "}", "}"], "docstring": "transfer the objects in src group to the target group", "docstring_tokens": ["transfer", "the", "objects", "in", "src", "group", "to", "the", "target", "group"]}
{"code": "boolean replace = (replaceCheck != null) && replaceCheck.replace(v);", "comments": "replaceCheck not currently used", "lines": 19, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/DatasetConstructor.java", "func_name": "DatasetConstructor.transferGroup", "original_string": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "language": "java", "Allcodes": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "code_tokens": ["static", "private", "void", "transferGroup", "(", "NetcdfFile", "ds", ",", "NetcdfDataset", "targetDs", ",", "Group", "src", ",", "Group", "targetGroup", ",", "ReplaceVariableCheck", "replaceCheck", ")", "{", "boolean", "unlimitedOK", "=", "true", ";", "// LOOK why not allowed?", "// group attributes", "transferGroupAttributes", "(", "src", ",", "targetGroup", ")", ";", "// dimensions", "for", "(", "Dimension", "d", ":", "src", ".", "getDimensions", "(", ")", ")", "{", "if", "(", "null", "==", "targetGroup", ".", "findDimensionLocal", "(", "d", ".", "getShortName", "(", ")", ")", ")", "{", "Dimension", "newd", "=", "new", "Dimension", "(", "d", ".", "getShortName", "(", ")", ",", "d", ".", "getLength", "(", ")", ",", "d", ".", "isShared", "(", ")", ",", "unlimitedOK", "&&", "d", ".", "isUnlimited", "(", ")", ",", "d", ".", "isVariableLength", "(", ")", ")", ";", "targetGroup", ".", "addDimension", "(", "newd", ")", ";", "}", "}", "// variables", "for", "(", "Variable", "v", ":", "src", ".", "getVariables", "(", ")", ")", "{", "Variable", "targetV", "=", "targetGroup", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "VariableEnhanced", "targetVe", "=", "(", "VariableEnhanced", ")", "targetV", ";", "boolean", "replace", "=", "(", "replaceCheck", "!=", "null", ")", "&&", "replaceCheck", ".", "replace", "(", "v", ")", ";", "// replaceCheck not currently used", "if", "(", "replace", "||", "(", "null", "==", "targetV", ")", ")", "{", "// replace it", "if", "(", "(", "v", "instanceof", "Structure", ")", "&&", "!", "(", "v", "instanceof", "StructureDS", ")", ")", "{", "v", "=", "new", "StructureDS", "(", "targetGroup", ",", "(", "Structure", ")", "v", ")", ";", "// else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm", "}", "else", "if", "(", "!", "(", "v", "instanceof", "VariableDS", ")", ")", "{", "v", "=", "new", "VariableDS", "(", "targetGroup", ",", "v", ",", "false", ")", ";", "// enhancement done by original variable, this is just to reparent to target dataset.", "}", "if", "(", "null", "!=", "targetV", ")", "targetGroup", ".", "remove", "(", "targetV", ")", ";", "targetGroup", ".", "addVariable", "(", "v", ")", ";", "// reparent group", "v", ".", "resetDimensions", "(", ")", ";", "// dimensions will be different", "}", "else", "if", "(", "!", "targetV", ".", "hasCachedData", "(", ")", "&&", "(", "targetVe", ".", "getOriginalVariable", "(", ")", "==", "null", ")", ")", "{", "// this is the case where we defined the variable, but didnt set its data. we now set it with the first nested", "// dataset that has a variable with the same name", "targetVe", ".", "setOriginalVariable", "(", "v", ")", ";", "}", "}", "// nested groups - check if target already has it", "for", "(", "Group", "srcNested", ":", "src", ".", "getGroups", "(", ")", ")", "{", "Group", "nested", "=", "targetGroup", ".", "findGroup", "(", "srcNested", ".", "getShortName", "(", ")", ")", ";", "if", "(", "null", "==", "nested", ")", "{", "nested", "=", "new", "Group", "(", "ds", ",", "targetGroup", ",", "srcNested", ".", "getShortName", "(", ")", ")", ";", "targetGroup", ".", "addGroup", "(", "nested", ")", ";", "}", "transferGroup", "(", "ds", ",", "targetDs", ",", "srcNested", ",", "nested", ",", "replaceCheck", ")", ";", "}", "}"], "docstring": "transfer the objects in src group to the target group", "docstring_tokens": ["transfer", "the", "objects", "in", "src", "group", "to", "the", "target", "group"]}
{"code": "v = new VariableDS(targetGroup, v, false);", "comments": "enhancement done by original variable, this is just to reparent to target dataset.", "lines": 27, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/DatasetConstructor.java", "func_name": "DatasetConstructor.transferGroup", "original_string": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "language": "java", "Allcodes": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "code_tokens": ["static", "private", "void", "transferGroup", "(", "NetcdfFile", "ds", ",", "NetcdfDataset", "targetDs", ",", "Group", "src", ",", "Group", "targetGroup", ",", "ReplaceVariableCheck", "replaceCheck", ")", "{", "boolean", "unlimitedOK", "=", "true", ";", "// LOOK why not allowed?", "// group attributes", "transferGroupAttributes", "(", "src", ",", "targetGroup", ")", ";", "// dimensions", "for", "(", "Dimension", "d", ":", "src", ".", "getDimensions", "(", ")", ")", "{", "if", "(", "null", "==", "targetGroup", ".", "findDimensionLocal", "(", "d", ".", "getShortName", "(", ")", ")", ")", "{", "Dimension", "newd", "=", "new", "Dimension", "(", "d", ".", "getShortName", "(", ")", ",", "d", ".", "getLength", "(", ")", ",", "d", ".", "isShared", "(", ")", ",", "unlimitedOK", "&&", "d", ".", "isUnlimited", "(", ")", ",", "d", ".", "isVariableLength", "(", ")", ")", ";", "targetGroup", ".", "addDimension", "(", "newd", ")", ";", "}", "}", "// variables", "for", "(", "Variable", "v", ":", "src", ".", "getVariables", "(", ")", ")", "{", "Variable", "targetV", "=", "targetGroup", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "VariableEnhanced", "targetVe", "=", "(", "VariableEnhanced", ")", "targetV", ";", "boolean", "replace", "=", "(", "replaceCheck", "!=", "null", ")", "&&", "replaceCheck", ".", "replace", "(", "v", ")", ";", "// replaceCheck not currently used", "if", "(", "replace", "||", "(", "null", "==", "targetV", ")", ")", "{", "// replace it", "if", "(", "(", "v", "instanceof", "Structure", ")", "&&", "!", "(", "v", "instanceof", "StructureDS", ")", ")", "{", "v", "=", "new", "StructureDS", "(", "targetGroup", ",", "(", "Structure", ")", "v", ")", ";", "// else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm", "}", "else", "if", "(", "!", "(", "v", "instanceof", "VariableDS", ")", ")", "{", "v", "=", "new", "VariableDS", "(", "targetGroup", ",", "v", ",", "false", ")", ";", "// enhancement done by original variable, this is just to reparent to target dataset.", "}", "if", "(", "null", "!=", "targetV", ")", "targetGroup", ".", "remove", "(", "targetV", ")", ";", "targetGroup", ".", "addVariable", "(", "v", ")", ";", "// reparent group", "v", ".", "resetDimensions", "(", ")", ";", "// dimensions will be different", "}", "else", "if", "(", "!", "targetV", ".", "hasCachedData", "(", ")", "&&", "(", "targetVe", ".", "getOriginalVariable", "(", ")", "==", "null", ")", ")", "{", "// this is the case where we defined the variable, but didnt set its data. we now set it with the first nested", "// dataset that has a variable with the same name", "targetVe", ".", "setOriginalVariable", "(", "v", ")", ";", "}", "}", "// nested groups - check if target already has it", "for", "(", "Group", "srcNested", ":", "src", ".", "getGroups", "(", ")", ")", "{", "Group", "nested", "=", "targetGroup", ".", "findGroup", "(", "srcNested", ".", "getShortName", "(", ")", ")", ";", "if", "(", "null", "==", "nested", ")", "{", "nested", "=", "new", "Group", "(", "ds", ",", "targetGroup", ",", "srcNested", ".", "getShortName", "(", ")", ")", ";", "targetGroup", ".", "addGroup", "(", "nested", ")", ";", "}", "transferGroup", "(", "ds", ",", "targetDs", ",", "srcNested", ",", "nested", ",", "replaceCheck", ")", ";", "}", "}"], "docstring": "transfer the objects in src group to the target group", "docstring_tokens": ["transfer", "the", "objects", "in", "src", "group", "to", "the", "target", "group"]}
{"code": "targetGroup.addVariable(v);", "comments": "reparent group", "lines": 31, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/DatasetConstructor.java", "func_name": "DatasetConstructor.transferGroup", "original_string": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "language": "java", "Allcodes": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "code_tokens": ["static", "private", "void", "transferGroup", "(", "NetcdfFile", "ds", ",", "NetcdfDataset", "targetDs", ",", "Group", "src", ",", "Group", "targetGroup", ",", "ReplaceVariableCheck", "replaceCheck", ")", "{", "boolean", "unlimitedOK", "=", "true", ";", "// LOOK why not allowed?", "// group attributes", "transferGroupAttributes", "(", "src", ",", "targetGroup", ")", ";", "// dimensions", "for", "(", "Dimension", "d", ":", "src", ".", "getDimensions", "(", ")", ")", "{", "if", "(", "null", "==", "targetGroup", ".", "findDimensionLocal", "(", "d", ".", "getShortName", "(", ")", ")", ")", "{", "Dimension", "newd", "=", "new", "Dimension", "(", "d", ".", "getShortName", "(", ")", ",", "d", ".", "getLength", "(", ")", ",", "d", ".", "isShared", "(", ")", ",", "unlimitedOK", "&&", "d", ".", "isUnlimited", "(", ")", ",", "d", ".", "isVariableLength", "(", ")", ")", ";", "targetGroup", ".", "addDimension", "(", "newd", ")", ";", "}", "}", "// variables", "for", "(", "Variable", "v", ":", "src", ".", "getVariables", "(", ")", ")", "{", "Variable", "targetV", "=", "targetGroup", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "VariableEnhanced", "targetVe", "=", "(", "VariableEnhanced", ")", "targetV", ";", "boolean", "replace", "=", "(", "replaceCheck", "!=", "null", ")", "&&", "replaceCheck", ".", "replace", "(", "v", ")", ";", "// replaceCheck not currently used", "if", "(", "replace", "||", "(", "null", "==", "targetV", ")", ")", "{", "// replace it", "if", "(", "(", "v", "instanceof", "Structure", ")", "&&", "!", "(", "v", "instanceof", "StructureDS", ")", ")", "{", "v", "=", "new", "StructureDS", "(", "targetGroup", ",", "(", "Structure", ")", "v", ")", ";", "// else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm", "}", "else", "if", "(", "!", "(", "v", "instanceof", "VariableDS", ")", ")", "{", "v", "=", "new", "VariableDS", "(", "targetGroup", ",", "v", ",", "false", ")", ";", "// enhancement done by original variable, this is just to reparent to target dataset.", "}", "if", "(", "null", "!=", "targetV", ")", "targetGroup", ".", "remove", "(", "targetV", ")", ";", "targetGroup", ".", "addVariable", "(", "v", ")", ";", "// reparent group", "v", ".", "resetDimensions", "(", ")", ";", "// dimensions will be different", "}", "else", "if", "(", "!", "targetV", ".", "hasCachedData", "(", ")", "&&", "(", "targetVe", ".", "getOriginalVariable", "(", ")", "==", "null", ")", ")", "{", "// this is the case where we defined the variable, but didnt set its data. we now set it with the first nested", "// dataset that has a variable with the same name", "targetVe", ".", "setOriginalVariable", "(", "v", ")", ";", "}", "}", "// nested groups - check if target already has it", "for", "(", "Group", "srcNested", ":", "src", ".", "getGroups", "(", ")", ")", "{", "Group", "nested", "=", "targetGroup", ".", "findGroup", "(", "srcNested", ".", "getShortName", "(", ")", ")", ";", "if", "(", "null", "==", "nested", ")", "{", "nested", "=", "new", "Group", "(", "ds", ",", "targetGroup", ",", "srcNested", ".", "getShortName", "(", ")", ")", ";", "targetGroup", ".", "addGroup", "(", "nested", ")", ";", "}", "transferGroup", "(", "ds", ",", "targetDs", ",", "srcNested", ",", "nested", ",", "replaceCheck", ")", ";", "}", "}"], "docstring": "transfer the objects in src group to the target group", "docstring_tokens": ["transfer", "the", "objects", "in", "src", "group", "to", "the", "target", "group"]}
{"code": "v.resetDimensions();", "comments": "dimensions will be different", "lines": 32, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/DatasetConstructor.java", "func_name": "DatasetConstructor.transferGroup", "original_string": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "language": "java", "Allcodes": "static private void transferGroup(NetcdfFile ds, NetcdfDataset targetDs, Group src, Group targetGroup, ReplaceVariableCheck replaceCheck) {\n    boolean unlimitedOK = true; // LOOK why not allowed?\n\n    // group attributes\n    transferGroupAttributes(src, targetGroup);\n\n    // dimensions\n    for (Dimension d : src.getDimensions()) {\n      if (null == targetGroup.findDimensionLocal(d.getShortName())) {\n        Dimension newd = new Dimension(d.getShortName(), d.getLength(), d.isShared(), unlimitedOK && d.isUnlimited(), d.isVariableLength());\n        targetGroup.addDimension(newd);\n      }\n    }\n\n    // variables\n    for (Variable v : src.getVariables()) {\n      Variable targetV = targetGroup.findVariable(v.getShortName());\n      VariableEnhanced targetVe = (VariableEnhanced) targetV;\n      boolean replace = (replaceCheck != null) && replaceCheck.replace(v); // replaceCheck not currently used\n\n      if (replace || (null == targetV)) { // replace it\n        if ((v instanceof Structure) && !(v instanceof StructureDS)) {\n           v = new StructureDS(targetGroup, (Structure) v);\n\n          // else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm\n        } else if (!(v instanceof VariableDS)) {\n          v = new VariableDS(targetGroup, v, false);  // enhancement done by original variable, this is just to reparent to target dataset.\n        }\n\n        if (null != targetV) targetGroup.remove(targetV);\n        targetGroup.addVariable(v); // reparent group\n        v.resetDimensions(); // dimensions will be different\n\n      } else if (!targetV.hasCachedData() && (targetVe.getOriginalVariable() == null)) {\n        // this is the case where we defined the variable, but didnt set its data. we now set it with the first nested\n        // dataset that has a variable with the same name\n        targetVe.setOriginalVariable(v);\n      }\n    }\n\n    // nested groups - check if target already has it\n    for (Group srcNested : src.getGroups()) {\n      Group nested = targetGroup.findGroup(srcNested.getShortName());\n      if (null == nested) {\n        nested = new Group(ds, targetGroup, srcNested.getShortName());\n        targetGroup.addGroup(nested);\n      }\n      transferGroup(ds, targetDs, srcNested, nested, replaceCheck);\n    }\n  }", "code_tokens": ["static", "private", "void", "transferGroup", "(", "NetcdfFile", "ds", ",", "NetcdfDataset", "targetDs", ",", "Group", "src", ",", "Group", "targetGroup", ",", "ReplaceVariableCheck", "replaceCheck", ")", "{", "boolean", "unlimitedOK", "=", "true", ";", "// LOOK why not allowed?", "// group attributes", "transferGroupAttributes", "(", "src", ",", "targetGroup", ")", ";", "// dimensions", "for", "(", "Dimension", "d", ":", "src", ".", "getDimensions", "(", ")", ")", "{", "if", "(", "null", "==", "targetGroup", ".", "findDimensionLocal", "(", "d", ".", "getShortName", "(", ")", ")", ")", "{", "Dimension", "newd", "=", "new", "Dimension", "(", "d", ".", "getShortName", "(", ")", ",", "d", ".", "getLength", "(", ")", ",", "d", ".", "isShared", "(", ")", ",", "unlimitedOK", "&&", "d", ".", "isUnlimited", "(", ")", ",", "d", ".", "isVariableLength", "(", ")", ")", ";", "targetGroup", ".", "addDimension", "(", "newd", ")", ";", "}", "}", "// variables", "for", "(", "Variable", "v", ":", "src", ".", "getVariables", "(", ")", ")", "{", "Variable", "targetV", "=", "targetGroup", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "VariableEnhanced", "targetVe", "=", "(", "VariableEnhanced", ")", "targetV", ";", "boolean", "replace", "=", "(", "replaceCheck", "!=", "null", ")", "&&", "replaceCheck", ".", "replace", "(", "v", ")", ";", "// replaceCheck not currently used", "if", "(", "replace", "||", "(", "null", "==", "targetV", ")", ")", "{", "// replace it", "if", "(", "(", "v", "instanceof", "Structure", ")", "&&", "!", "(", "v", "instanceof", "StructureDS", ")", ")", "{", "v", "=", "new", "StructureDS", "(", "targetGroup", ",", "(", "Structure", ")", "v", ")", ";", "// else if (!(v instanceof VariableDS) && !(v instanceof StructureDS)) Doug Lindolm", "}", "else", "if", "(", "!", "(", "v", "instanceof", "VariableDS", ")", ")", "{", "v", "=", "new", "VariableDS", "(", "targetGroup", ",", "v", ",", "false", ")", ";", "// enhancement done by original variable, this is just to reparent to target dataset.", "}", "if", "(", "null", "!=", "targetV", ")", "targetGroup", ".", "remove", "(", "targetV", ")", ";", "targetGroup", ".", "addVariable", "(", "v", ")", ";", "// reparent group", "v", ".", "resetDimensions", "(", ")", ";", "// dimensions will be different", "}", "else", "if", "(", "!", "targetV", ".", "hasCachedData", "(", ")", "&&", "(", "targetVe", ".", "getOriginalVariable", "(", ")", "==", "null", ")", ")", "{", "// this is the case where we defined the variable, but didnt set its data. we now set it with the first nested", "// dataset that has a variable with the same name", "targetVe", ".", "setOriginalVariable", "(", "v", ")", ";", "}", "}", "// nested groups - check if target already has it", "for", "(", "Group", "srcNested", ":", "src", ".", "getGroups", "(", ")", ")", "{", "Group", "nested", "=", "targetGroup", ".", "findGroup", "(", "srcNested", ".", "getShortName", "(", ")", ")", ";", "if", "(", "null", "==", "nested", ")", "{", "nested", "=", "new", "Group", "(", "ds", ",", "targetGroup", ",", "srcNested", ".", "getShortName", "(", ")", ")", ";", "targetGroup", ".", "addGroup", "(", "nested", ")", ";", "}", "transferGroup", "(", "ds", ",", "targetDs", ",", "srcNested", ",", "nested", ",", "replaceCheck", ")", ";", "}", "}"], "docstring": "transfer the objects in src group to the target group", "docstring_tokens": ["transfer", "the", "objects", "in", "src", "group", "to", "the", "target", "group"]}
{"code": "MFile indexFileForRuntime = GribCollectionMutable.makeIndexMFile(gcname, directory);", "comments": "not using disk cache LOOK why ?", "lines": 25, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribCollectionBuilder.java", "func_name": "GribCollectionBuilder.createAllRuntimeCollections", "original_string": "private boolean createAllRuntimeCollections(Formatter errlog) throws IOException {\n    long start = System.currentTimeMillis();\n    this.type =  GribCollectionImmutable.Type.SRC;\n    boolean ok = true;\n\n    List<MFile> files = new ArrayList<>();\n    List<? extends Group> groups = makeGroups(files, true, errlog);\n    List<MFile> allFiles = Collections.unmodifiableList(files);\n\n    // gather into collections with a single runtime\n    Map<Long, List<Group>> runGroups = new HashMap<>();\n    for (Group g : groups) {\n      List<Group> runGroup = runGroups\n          .computeIfAbsent(g.getRuntime().getMillis(), k -> new ArrayList<>());\n      runGroup.add(g);\n    }\n\n    // write each rungroup separately\n    boolean multipleRuntimes = runGroups.values().size() > 1;\n    List<MFile> partitions = new ArrayList<>();\n    for (List<Group> runGroupList : runGroups.values()) {\n      Group g = runGroupList.get(0);\n      // if multiple Runtimes, we will write a partition. otherwise, we need to use the standard name (without runtime) so we know the filename from the collection\n      String gcname = multipleRuntimes ? GribCollectionMutable.makeName(this.name, g.getRuntime()) : this.name;\n      MFile indexFileForRuntime = GribCollectionMutable.makeIndexMFile(gcname, directory); // not using disk cache LOOK why ?\n      partitions.add(indexFileForRuntime);\n\n     // create the master runtimes, consisting of the single runtime\n      List<Long> runtimes = new ArrayList<>(1);\n      runtimes.add(g.getRuntime().getMillis());\n      CoordinateRuntime masterRuntimes = new CoordinateRuntime(runtimes, null);\n\n      CalendarDateRange calendarDateRangeAll = null;\n      for (Coordinate coord : g.getCoordinates()) {\n        if (coord instanceof CoordinateTimeAbstract) {\n          CalendarDateRange calendarDateRange = ((CoordinateTimeAbstract) coord).makeCalendarDateRange(null);\n          if (calendarDateRangeAll == null) calendarDateRangeAll = calendarDateRange;\n          else calendarDateRangeAll = calendarDateRangeAll.extend(calendarDateRange);\n        }\n      }\n      assert calendarDateRangeAll != null;\n\n      // for each Group write an index file\n      ok &= writeIndex(gcname, indexFileForRuntime.getPath(), masterRuntimes, runGroupList, allFiles, calendarDateRangeAll);\n      logger.info(\"GribCollectionBuilder write {} ok={}\", indexFileForRuntime.getPath(), ok);\n    }\n\n    // if theres more than one runtime, create a partition collection to collect all the runtimes together\n    if (multipleRuntimes) {\n      Collections.sort(partitions); // ??\n      PartitionManager part = new PartitionManagerFromIndexList(dcm, partitions, logger);\n      part.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, dcm.getAuxInfo(FeatureCollectionConfig.AUX_CONFIG));\n      ok &= GribCdmIndex.updateGribCollectionFromPCollection(isGrib1, part, CollectionUpdateType.always, errlog, logger);\n    }\n\n    long took = System.currentTimeMillis() - start;\n    logger.debug(\"That took {} msecs\", took);\n    return ok;\n  }", "language": "java", "Allcodes": "private boolean createAllRuntimeCollections(Formatter errlog) throws IOException {\n    long start = System.currentTimeMillis();\n    this.type =  GribCollectionImmutable.Type.SRC;\n    boolean ok = true;\n\n    List<MFile> files = new ArrayList<>();\n    List<? extends Group> groups = makeGroups(files, true, errlog);\n    List<MFile> allFiles = Collections.unmodifiableList(files);\n\n    // gather into collections with a single runtime\n    Map<Long, List<Group>> runGroups = new HashMap<>();\n    for (Group g : groups) {\n      List<Group> runGroup = runGroups\n          .computeIfAbsent(g.getRuntime().getMillis(), k -> new ArrayList<>());\n      runGroup.add(g);\n    }\n\n    // write each rungroup separately\n    boolean multipleRuntimes = runGroups.values().size() > 1;\n    List<MFile> partitions = new ArrayList<>();\n    for (List<Group> runGroupList : runGroups.values()) {\n      Group g = runGroupList.get(0);\n      // if multiple Runtimes, we will write a partition. otherwise, we need to use the standard name (without runtime) so we know the filename from the collection\n      String gcname = multipleRuntimes ? GribCollectionMutable.makeName(this.name, g.getRuntime()) : this.name;\n      MFile indexFileForRuntime = GribCollectionMutable.makeIndexMFile(gcname, directory); // not using disk cache LOOK why ?\n      partitions.add(indexFileForRuntime);\n\n     // create the master runtimes, consisting of the single runtime\n      List<Long> runtimes = new ArrayList<>(1);\n      runtimes.add(g.getRuntime().getMillis());\n      CoordinateRuntime masterRuntimes = new CoordinateRuntime(runtimes, null);\n\n      CalendarDateRange calendarDateRangeAll = null;\n      for (Coordinate coord : g.getCoordinates()) {\n        if (coord instanceof CoordinateTimeAbstract) {\n          CalendarDateRange calendarDateRange = ((CoordinateTimeAbstract) coord).makeCalendarDateRange(null);\n          if (calendarDateRangeAll == null) calendarDateRangeAll = calendarDateRange;\n          else calendarDateRangeAll = calendarDateRangeAll.extend(calendarDateRange);\n        }\n      }\n      assert calendarDateRangeAll != null;\n\n      // for each Group write an index file\n      ok &= writeIndex(gcname, indexFileForRuntime.getPath(), masterRuntimes, runGroupList, allFiles, calendarDateRangeAll);\n      logger.info(\"GribCollectionBuilder write {} ok={}\", indexFileForRuntime.getPath(), ok);\n    }\n\n    // if theres more than one runtime, create a partition collection to collect all the runtimes together\n    if (multipleRuntimes) {\n      Collections.sort(partitions); // ??\n      PartitionManager part = new PartitionManagerFromIndexList(dcm, partitions, logger);\n      part.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, dcm.getAuxInfo(FeatureCollectionConfig.AUX_CONFIG));\n      ok &= GribCdmIndex.updateGribCollectionFromPCollection(isGrib1, part, CollectionUpdateType.always, errlog, logger);\n    }\n\n    long took = System.currentTimeMillis() - start;\n    logger.debug(\"That took {} msecs\", took);\n    return ok;\n  }", "code_tokens": ["private", "boolean", "createAllRuntimeCollections", "(", "Formatter", "errlog", ")", "throws", "IOException", "{", "long", "start", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "this", ".", "type", "=", "GribCollectionImmutable", ".", "Type", ".", "SRC", ";", "boolean", "ok", "=", "true", ";", "List", "<", "MFile", ">", "files", "=", "new", "ArrayList", "<>", "(", ")", ";", "List", "<", "?", "extends", "Group", ">", "groups", "=", "makeGroups", "(", "files", ",", "true", ",", "errlog", ")", ";", "List", "<", "MFile", ">", "allFiles", "=", "Collections", ".", "unmodifiableList", "(", "files", ")", ";", "// gather into collections with a single runtime", "Map", "<", "Long", ",", "List", "<", "Group", ">", ">", "runGroups", "=", "new", "HashMap", "<>", "(", ")", ";", "for", "(", "Group", "g", ":", "groups", ")", "{", "List", "<", "Group", ">", "runGroup", "=", "runGroups", ".", "computeIfAbsent", "(", "g", ".", "getRuntime", "(", ")", ".", "getMillis", "(", ")", ",", "k", "->", "new", "ArrayList", "<>", "(", ")", ")", ";", "runGroup", ".", "add", "(", "g", ")", ";", "}", "// write each rungroup separately", "boolean", "multipleRuntimes", "=", "runGroups", ".", "values", "(", ")", ".", "size", "(", ")", ">", "1", ";", "List", "<", "MFile", ">", "partitions", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "List", "<", "Group", ">", "runGroupList", ":", "runGroups", ".", "values", "(", ")", ")", "{", "Group", "g", "=", "runGroupList", ".", "get", "(", "0", ")", ";", "// if multiple Runtimes, we will write a partition. otherwise, we need to use the standard name (without runtime) so we know the filename from the collection", "String", "gcname", "=", "multipleRuntimes", "?", "GribCollectionMutable", ".", "makeName", "(", "this", ".", "name", ",", "g", ".", "getRuntime", "(", ")", ")", ":", "this", ".", "name", ";", "MFile", "indexFileForRuntime", "=", "GribCollectionMutable", ".", "makeIndexMFile", "(", "gcname", ",", "directory", ")", ";", "// not using disk cache LOOK why ?", "partitions", ".", "add", "(", "indexFileForRuntime", ")", ";", "// create the master runtimes, consisting of the single runtime", "List", "<", "Long", ">", "runtimes", "=", "new", "ArrayList", "<>", "(", "1", ")", ";", "runtimes", ".", "add", "(", "g", ".", "getRuntime", "(", ")", ".", "getMillis", "(", ")", ")", ";", "CoordinateRuntime", "masterRuntimes", "=", "new", "CoordinateRuntime", "(", "runtimes", ",", "null", ")", ";", "CalendarDateRange", "calendarDateRangeAll", "=", "null", ";", "for", "(", "Coordinate", "coord", ":", "g", ".", "getCoordinates", "(", ")", ")", "{", "if", "(", "coord", "instanceof", "CoordinateTimeAbstract", ")", "{", "CalendarDateRange", "calendarDateRange", "=", "(", "(", "CoordinateTimeAbstract", ")", "coord", ")", ".", "makeCalendarDateRange", "(", "null", ")", ";", "if", "(", "calendarDateRangeAll", "==", "null", ")", "calendarDateRangeAll", "=", "calendarDateRange", ";", "else", "calendarDateRangeAll", "=", "calendarDateRangeAll", ".", "extend", "(", "calendarDateRange", ")", ";", "}", "}", "assert", "calendarDateRangeAll", "!=", "null", ";", "// for each Group write an index file", "ok", "&=", "writeIndex", "(", "gcname", ",", "indexFileForRuntime", ".", "getPath", "(", ")", ",", "masterRuntimes", ",", "runGroupList", ",", "allFiles", ",", "calendarDateRangeAll", ")", ";", "logger", ".", "info", "(", "\"GribCollectionBuilder write {} ok={}\"", ",", "indexFileForRuntime", ".", "getPath", "(", ")", ",", "ok", ")", ";", "}", "// if theres more than one runtime, create a partition collection to collect all the runtimes together", "if", "(", "multipleRuntimes", ")", "{", "Collections", ".", "sort", "(", "partitions", ")", ";", "// ??", "PartitionManager", "part", "=", "new", "PartitionManagerFromIndexList", "(", "dcm", ",", "partitions", ",", "logger", ")", ";", "part", ".", "putAuxInfo", "(", "FeatureCollectionConfig", ".", "AUX_CONFIG", ",", "dcm", ".", "getAuxInfo", "(", "FeatureCollectionConfig", ".", "AUX_CONFIG", ")", ")", ";", "ok", "&=", "GribCdmIndex", ".", "updateGribCollectionFromPCollection", "(", "isGrib1", ",", "part", ",", "CollectionUpdateType", ".", "always", ",", "errlog", ",", "logger", ")", ";", "}", "long", "took", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "start", ";", "logger", ".", "debug", "(", "\"That took {} msecs\"", ",", "took", ")", ";", "return", "ok", ";", "}"], "docstring": "creates seperate collection and index for each runtime.", "docstring_tokens": ["creates", "seperate", "collection", "and", "index", "for", "each", "runtime", "."]}
{"code": "DodsV dodsV = findDodsV(tableName, false);", "comments": "short name matches the table name", "lines": 15, "repo": "Unidata/thredds", "path": "opendap/src/main/java/ucar/nc2/dods/DodsV.java", "func_name": "DodsV.parseDAS", "original_string": "void parseDAS(DAS das) throws IOException {\r\n    Enumeration tableNames = das.getNames();\r\n    while (tableNames.hasMoreElements()) {\r\n      String tableName = (String) tableNames.nextElement();\r\n      AttributeTable attTable = das.getAttributeTableN(tableName);\r\n\r\n      if (tableName.equals(\"NC_GLOBAL\") || tableName.equals(\"HDF_GLOBAL\")) {\r\n        addAttributeTable(this, attTable, tableName, true);\r\n\r\n      } else if (tableName.equals(\"DODS_EXTRA\") || tableName.equals(\"EXTRA_DIMENSION\")) {\r\n        // handled seperately in DODSNetcdfFile\r\n        continue;\r\n\r\n      } else {\r\n        DodsV dodsV = findDodsV(tableName, false); // short name matches the table name\r\n        if (dodsV != null) {\r\n          addAttributeTable(dodsV, attTable, tableName, true);\r\n        } else {\r\n          dodsV = findTableDotDelimited(tableName);\r\n          if (dodsV != null) {\r\n            addAttributeTable(dodsV, attTable, tableName, true);\r\n          } else {\r\n            if (debugAttributes) System.out.println(\"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\");\r\n            addAttributeTable(this, attTable, tableName, false);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }", "language": "java", "Allcodes": "void parseDAS(DAS das) throws IOException {\r\n    Enumeration tableNames = das.getNames();\r\n    while (tableNames.hasMoreElements()) {\r\n      String tableName = (String) tableNames.nextElement();\r\n      AttributeTable attTable = das.getAttributeTableN(tableName);\r\n\r\n      if (tableName.equals(\"NC_GLOBAL\") || tableName.equals(\"HDF_GLOBAL\")) {\r\n        addAttributeTable(this, attTable, tableName, true);\r\n\r\n      } else if (tableName.equals(\"DODS_EXTRA\") || tableName.equals(\"EXTRA_DIMENSION\")) {\r\n        // handled seperately in DODSNetcdfFile\r\n        continue;\r\n\r\n      } else {\r\n        DodsV dodsV = findDodsV(tableName, false); // short name matches the table name\r\n        if (dodsV != null) {\r\n          addAttributeTable(dodsV, attTable, tableName, true);\r\n        } else {\r\n          dodsV = findTableDotDelimited(tableName);\r\n          if (dodsV != null) {\r\n            addAttributeTable(dodsV, attTable, tableName, true);\r\n          } else {\r\n            if (debugAttributes) System.out.println(\"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\");\r\n            addAttributeTable(this, attTable, tableName, false);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }", "code_tokens": ["void", "parseDAS", "(", "DAS", "das", ")", "throws", "IOException", "{", "Enumeration", "tableNames", "=", "das", ".", "getNames", "(", ")", ";", "while", "(", "tableNames", ".", "hasMoreElements", "(", ")", ")", "{", "String", "tableName", "=", "(", "String", ")", "tableNames", ".", "nextElement", "(", ")", ";", "AttributeTable", "attTable", "=", "das", ".", "getAttributeTableN", "(", "tableName", ")", ";", "if", "(", "tableName", ".", "equals", "(", "\"NC_GLOBAL\"", ")", "||", "tableName", ".", "equals", "(", "\"HDF_GLOBAL\"", ")", ")", "{", "addAttributeTable", "(", "this", ",", "attTable", ",", "tableName", ",", "true", ")", ";", "}", "else", "if", "(", "tableName", ".", "equals", "(", "\"DODS_EXTRA\"", ")", "||", "tableName", ".", "equals", "(", "\"EXTRA_DIMENSION\"", ")", ")", "{", "// handled seperately in DODSNetcdfFile\r", "continue", ";", "}", "else", "{", "DodsV", "dodsV", "=", "findDodsV", "(", "tableName", ",", "false", ")", ";", "// short name matches the table name\r", "if", "(", "dodsV", "!=", "null", ")", "{", "addAttributeTable", "(", "dodsV", ",", "attTable", ",", "tableName", ",", "true", ")", ";", "}", "else", "{", "dodsV", "=", "findTableDotDelimited", "(", "tableName", ")", ";", "if", "(", "dodsV", "!=", "null", ")", "{", "addAttributeTable", "(", "dodsV", ",", "attTable", ",", "tableName", ",", "true", ")", ";", "}", "else", "{", "if", "(", "debugAttributes", ")", "System", ".", "out", ".", "println", "(", "\"DODSNetcdf getAttributes CANT find <\"", "+", "tableName", "+", "\"> add to globals\"", ")", ";", "addAttributeTable", "(", "this", ",", "attTable", ",", "tableName", ",", "false", ")", ";", "}", "}", "}", "}", "}"], "docstring": "Parse the DAS, assign attribute tables to the DodsV objects.\nNested attribute tables are supposed to follow the tree we construct with dodsV, so its easy to assign to correct dodsV.\n\n@param das parse this DAS\n@throws IOException on io error", "docstring_tokens": ["Parse", "the", "DAS", "assign", "attribute", "tables", "to", "the", "DodsV", "objects", ".", "Nested", "attribute", "tables", "are", "supposed", "to", "follow", "the", "tree", "we", "construct", "with", "dodsV", "so", "its", "easy", "to", "assign", "to", "correct", "dodsV", "."]}
{"code": "if (useDone && dodsV.isDone) continue;", "comments": "LOOK useDone ??", "lines": 3, "repo": "Unidata/thredds", "path": "opendap/src/main/java/ucar/nc2/dods/DodsV.java", "func_name": "DodsV.findDodsV", "original_string": "DodsV findDodsV(String name, boolean useDone) {\r\n    for (DodsV dodsV : children) {\r\n      if (useDone && dodsV.isDone) continue; // LOOK useDone ??\r\n      if ((name == null) || (dodsV == null) || (dodsV.bt == null)) {\r\n        logger.warn(\"Corrupted structure\");\r\n        continue;\r\n      }\r\n      if (name.equals(dodsV.bt.getEncodedName()))\r\n        return dodsV;\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "DodsV findDodsV(String name, boolean useDone) {\r\n    for (DodsV dodsV : children) {\r\n      if (useDone && dodsV.isDone) continue; // LOOK useDone ??\r\n      if ((name == null) || (dodsV == null) || (dodsV.bt == null)) {\r\n        logger.warn(\"Corrupted structure\");\r\n        continue;\r\n      }\r\n      if (name.equals(dodsV.bt.getEncodedName()))\r\n        return dodsV;\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["DodsV", "findDodsV", "(", "String", "name", ",", "boolean", "useDone", ")", "{", "for", "(", "DodsV", "dodsV", ":", "children", ")", "{", "if", "(", "useDone", "&&", "dodsV", ".", "isDone", ")", "continue", ";", "// LOOK useDone ??\r", "if", "(", "(", "name", "==", "null", ")", "||", "(", "dodsV", "==", "null", ")", "||", "(", "dodsV", ".", "bt", "==", "null", ")", ")", "{", "logger", ".", "warn", "(", "\"Corrupted structure\"", ")", ";", "continue", ";", "}", "if", "(", "name", ".", "equals", "(", "dodsV", ".", "bt", ".", "getEncodedName", "(", ")", ")", ")", "return", "dodsV", ";", "}", "return", "null", ";", "}"], "docstring": "Search the immediate children for a BaseType with given name.\n\n@param name    look for this name\n@param useDone\n@return child that matches if found, else null", "docstring_tokens": ["Search", "the", "immediate", "children", "for", "a", "BaseType", "with", "given", "name", "."]}
{"code": "list.add( Range.EMPTY);", "comments": "LOOK empty not named", "lines": 10, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable.getShapeAsSection", "original_string": "public Section getShapeAsSection() {\n    if (shapeAsSection == null) {\n      try {\n        List<Range> list = new ArrayList<>();\n        for (Dimension d : dimensions) {\n          int len = d.getLength();\n          if (len > 0)\n            list.add(new Range(d.getShortName(), 0, len - 1));\n          else if (len == 0)\n            list.add( Range.EMPTY); // LOOK empty not named\n          else {\n            assert d.isVariableLength();\n            list.add( Range.VLEN); // LOOK vlen not named\n          }\n        }\n        shapeAsSection = new Section(list).makeImmutable();\n\n      } catch (InvalidRangeException e) {\n        log.error(\"Bad shape in variable \" + getFullName(), e);\n        throw new IllegalStateException(e.getMessage());\n      }\n    }\n    return shapeAsSection;\n  }", "language": "java", "Allcodes": "public Section getShapeAsSection() {\n    if (shapeAsSection == null) {\n      try {\n        List<Range> list = new ArrayList<>();\n        for (Dimension d : dimensions) {\n          int len = d.getLength();\n          if (len > 0)\n            list.add(new Range(d.getShortName(), 0, len - 1));\n          else if (len == 0)\n            list.add( Range.EMPTY); // LOOK empty not named\n          else {\n            assert d.isVariableLength();\n            list.add( Range.VLEN); // LOOK vlen not named\n          }\n        }\n        shapeAsSection = new Section(list).makeImmutable();\n\n      } catch (InvalidRangeException e) {\n        log.error(\"Bad shape in variable \" + getFullName(), e);\n        throw new IllegalStateException(e.getMessage());\n      }\n    }\n    return shapeAsSection;\n  }", "code_tokens": ["public", "Section", "getShapeAsSection", "(", ")", "{", "if", "(", "shapeAsSection", "==", "null", ")", "{", "try", "{", "List", "<", "Range", ">", "list", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Dimension", "d", ":", "dimensions", ")", "{", "int", "len", "=", "d", ".", "getLength", "(", ")", ";", "if", "(", "len", ">", "0", ")", "list", ".", "add", "(", "new", "Range", "(", "d", ".", "getShortName", "(", ")", ",", "0", ",", "len", "-", "1", ")", ")", ";", "else", "if", "(", "len", "==", "0", ")", "list", ".", "add", "(", "Range", ".", "EMPTY", ")", ";", "// LOOK empty not named", "else", "{", "assert", "d", ".", "isVariableLength", "(", ")", ";", "list", ".", "add", "(", "Range", ".", "VLEN", ")", ";", "// LOOK vlen not named", "}", "}", "shapeAsSection", "=", "new", "Section", "(", "list", ")", ".", "makeImmutable", "(", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "log", ".", "error", "(", "\"Bad shape in variable \"", "+", "getFullName", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "return", "shapeAsSection", ";", "}"], "docstring": "Get shape as a Section object.\n\n@return Section containing List<Range>, one for each Dimension.", "docstring_tokens": ["Get", "shape", "as", "a", "Section", "object", "."]}
{"code": "list.add( Range.VLEN);", "comments": "LOOK vlen not named", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable.getShapeAsSection", "original_string": "public Section getShapeAsSection() {\n    if (shapeAsSection == null) {\n      try {\n        List<Range> list = new ArrayList<>();\n        for (Dimension d : dimensions) {\n          int len = d.getLength();\n          if (len > 0)\n            list.add(new Range(d.getShortName(), 0, len - 1));\n          else if (len == 0)\n            list.add( Range.EMPTY); // LOOK empty not named\n          else {\n            assert d.isVariableLength();\n            list.add( Range.VLEN); // LOOK vlen not named\n          }\n        }\n        shapeAsSection = new Section(list).makeImmutable();\n\n      } catch (InvalidRangeException e) {\n        log.error(\"Bad shape in variable \" + getFullName(), e);\n        throw new IllegalStateException(e.getMessage());\n      }\n    }\n    return shapeAsSection;\n  }", "language": "java", "Allcodes": "public Section getShapeAsSection() {\n    if (shapeAsSection == null) {\n      try {\n        List<Range> list = new ArrayList<>();\n        for (Dimension d : dimensions) {\n          int len = d.getLength();\n          if (len > 0)\n            list.add(new Range(d.getShortName(), 0, len - 1));\n          else if (len == 0)\n            list.add( Range.EMPTY); // LOOK empty not named\n          else {\n            assert d.isVariableLength();\n            list.add( Range.VLEN); // LOOK vlen not named\n          }\n        }\n        shapeAsSection = new Section(list).makeImmutable();\n\n      } catch (InvalidRangeException e) {\n        log.error(\"Bad shape in variable \" + getFullName(), e);\n        throw new IllegalStateException(e.getMessage());\n      }\n    }\n    return shapeAsSection;\n  }", "code_tokens": ["public", "Section", "getShapeAsSection", "(", ")", "{", "if", "(", "shapeAsSection", "==", "null", ")", "{", "try", "{", "List", "<", "Range", ">", "list", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Dimension", "d", ":", "dimensions", ")", "{", "int", "len", "=", "d", ".", "getLength", "(", ")", ";", "if", "(", "len", ">", "0", ")", "list", ".", "add", "(", "new", "Range", "(", "d", ".", "getShortName", "(", ")", ",", "0", ",", "len", "-", "1", ")", ")", ";", "else", "if", "(", "len", "==", "0", ")", "list", ".", "add", "(", "Range", ".", "EMPTY", ")", ";", "// LOOK empty not named", "else", "{", "assert", "d", ".", "isVariableLength", "(", ")", ";", "list", ".", "add", "(", "Range", ".", "VLEN", ")", ";", "// LOOK vlen not named", "}", "}", "shapeAsSection", "=", "new", "Section", "(", "list", ")", ".", "makeImmutable", "(", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "log", ".", "error", "(", "\"Bad shape in variable \"", "+", "getFullName", "(", ")", ",", "e", ")", ";", "throw", "new", "IllegalStateException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "return", "shapeAsSection", ";", "}"], "docstring": "Get shape as a Section object.\n\n@return Section containing List<Range>, one for each Dimension.", "docstring_tokens": ["Get", "shape", "as", "a", "Section", "object", "."]}
{"code": "Variable sliceV = copy();", "comments": "subclasses must override", "lines": 19, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable.slice", "original_string": "public Variable slice(int dim, int value) throws InvalidRangeException {\n    if ((dim < 0) || (dim >= shape.length))\n      throw new InvalidRangeException(\"Slice dim invalid= \" + dim);\n\n    // ok to make slice of record dimension with length 0\n    boolean recordSliceOk = false;\n    if ((dim == 0) && (value == 0)) {\n      Dimension d = getDimension(0);\n      recordSliceOk = d.isUnlimited();\n    }\n\n    // otherwise check slice in range\n    if (!recordSliceOk) {\n      if ((value < 0) || (value >= shape[dim]))\n        throw new InvalidRangeException(\"Slice value invalid= \" + value + \" for dimension \" + dim);\n    }\n\n    // create a copy of this variable with a proxy reader\n    Variable sliceV = copy(); // subclasses must override\n    Section slice = new Section(getShapeAsSection());\n    slice.replaceRange(dim, new Range(value, value)).makeImmutable();\n    sliceV.setProxyReader(new SliceReader(this, dim, slice));\n    sliceV.createNewCache(); // dont share the cache\n    sliceV.setCaching(false); // dont cache\n\n    // remove that dimension - reduce rank\n    sliceV.dimensions.remove(dim);\n    sliceV.resetShape();\n    return sliceV;\n  }", "language": "java", "Allcodes": "public Variable slice(int dim, int value) throws InvalidRangeException {\n    if ((dim < 0) || (dim >= shape.length))\n      throw new InvalidRangeException(\"Slice dim invalid= \" + dim);\n\n    // ok to make slice of record dimension with length 0\n    boolean recordSliceOk = false;\n    if ((dim == 0) && (value == 0)) {\n      Dimension d = getDimension(0);\n      recordSliceOk = d.isUnlimited();\n    }\n\n    // otherwise check slice in range\n    if (!recordSliceOk) {\n      if ((value < 0) || (value >= shape[dim]))\n        throw new InvalidRangeException(\"Slice value invalid= \" + value + \" for dimension \" + dim);\n    }\n\n    // create a copy of this variable with a proxy reader\n    Variable sliceV = copy(); // subclasses must override\n    Section slice = new Section(getShapeAsSection());\n    slice.replaceRange(dim, new Range(value, value)).makeImmutable();\n    sliceV.setProxyReader(new SliceReader(this, dim, slice));\n    sliceV.createNewCache(); // dont share the cache\n    sliceV.setCaching(false); // dont cache\n\n    // remove that dimension - reduce rank\n    sliceV.dimensions.remove(dim);\n    sliceV.resetShape();\n    return sliceV;\n  }", "code_tokens": ["public", "Variable", "slice", "(", "int", "dim", ",", "int", "value", ")", "throws", "InvalidRangeException", "{", "if", "(", "(", "dim", "<", "0", ")", "||", "(", "dim", ">=", "shape", ".", "length", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Slice dim invalid= \"", "+", "dim", ")", ";", "// ok to make slice of record dimension with length 0", "boolean", "recordSliceOk", "=", "false", ";", "if", "(", "(", "dim", "==", "0", ")", "&&", "(", "value", "==", "0", ")", ")", "{", "Dimension", "d", "=", "getDimension", "(", "0", ")", ";", "recordSliceOk", "=", "d", ".", "isUnlimited", "(", ")", ";", "}", "// otherwise check slice in range", "if", "(", "!", "recordSliceOk", ")", "{", "if", "(", "(", "value", "<", "0", ")", "||", "(", "value", ">=", "shape", "[", "dim", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Slice value invalid= \"", "+", "value", "+", "\" for dimension \"", "+", "dim", ")", ";", "}", "// create a copy of this variable with a proxy reader", "Variable", "sliceV", "=", "copy", "(", ")", ";", "// subclasses must override", "Section", "slice", "=", "new", "Section", "(", "getShapeAsSection", "(", ")", ")", ";", "slice", ".", "replaceRange", "(", "dim", ",", "new", "Range", "(", "value", ",", "value", ")", ")", ".", "makeImmutable", "(", ")", ";", "sliceV", ".", "setProxyReader", "(", "new", "SliceReader", "(", "this", ",", "dim", ",", "slice", ")", ")", ";", "sliceV", ".", "createNewCache", "(", ")", ";", "// dont share the cache", "sliceV", ".", "setCaching", "(", "false", ")", ";", "// dont cache", "// remove that dimension - reduce rank", "sliceV", ".", "dimensions", ".", "remove", "(", "dim", ")", ";", "sliceV", ".", "resetShape", "(", ")", ";", "return", "sliceV", ";", "}"], "docstring": "Create a new Variable that is a logical slice of this Variable, by\nfixing the specified dimension at the specified index value. This reduces rank by 1.\nNo data is read until a read method is called on it.\n\n@param dim   which dimension to fix\n@param value at what index value\n@return a new Variable which is a logical slice of this Variable.\n@throws InvalidRangeException if dimension or value is illegal", "docstring_tokens": ["Create", "a", "new", "Variable", "that", "is", "a", "logical", "slice", "of", "this", "Variable", "by", "fixing", "the", "specified", "dimension", "at", "the", "specified", "index", "value", ".", "This", "reduces", "rank", "by", "1", ".", "No", "data", "is", "read", "until", "a", "read", "method", "is", "called", "on", "it", "."]}
{"code": "sliceV.createNewCache();", "comments": "dont share the cache", "lines": 23, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable.slice", "original_string": "public Variable slice(int dim, int value) throws InvalidRangeException {\n    if ((dim < 0) || (dim >= shape.length))\n      throw new InvalidRangeException(\"Slice dim invalid= \" + dim);\n\n    // ok to make slice of record dimension with length 0\n    boolean recordSliceOk = false;\n    if ((dim == 0) && (value == 0)) {\n      Dimension d = getDimension(0);\n      recordSliceOk = d.isUnlimited();\n    }\n\n    // otherwise check slice in range\n    if (!recordSliceOk) {\n      if ((value < 0) || (value >= shape[dim]))\n        throw new InvalidRangeException(\"Slice value invalid= \" + value + \" for dimension \" + dim);\n    }\n\n    // create a copy of this variable with a proxy reader\n    Variable sliceV = copy(); // subclasses must override\n    Section slice = new Section(getShapeAsSection());\n    slice.replaceRange(dim, new Range(value, value)).makeImmutable();\n    sliceV.setProxyReader(new SliceReader(this, dim, slice));\n    sliceV.createNewCache(); // dont share the cache\n    sliceV.setCaching(false); // dont cache\n\n    // remove that dimension - reduce rank\n    sliceV.dimensions.remove(dim);\n    sliceV.resetShape();\n    return sliceV;\n  }", "language": "java", "Allcodes": "public Variable slice(int dim, int value) throws InvalidRangeException {\n    if ((dim < 0) || (dim >= shape.length))\n      throw new InvalidRangeException(\"Slice dim invalid= \" + dim);\n\n    // ok to make slice of record dimension with length 0\n    boolean recordSliceOk = false;\n    if ((dim == 0) && (value == 0)) {\n      Dimension d = getDimension(0);\n      recordSliceOk = d.isUnlimited();\n    }\n\n    // otherwise check slice in range\n    if (!recordSliceOk) {\n      if ((value < 0) || (value >= shape[dim]))\n        throw new InvalidRangeException(\"Slice value invalid= \" + value + \" for dimension \" + dim);\n    }\n\n    // create a copy of this variable with a proxy reader\n    Variable sliceV = copy(); // subclasses must override\n    Section slice = new Section(getShapeAsSection());\n    slice.replaceRange(dim, new Range(value, value)).makeImmutable();\n    sliceV.setProxyReader(new SliceReader(this, dim, slice));\n    sliceV.createNewCache(); // dont share the cache\n    sliceV.setCaching(false); // dont cache\n\n    // remove that dimension - reduce rank\n    sliceV.dimensions.remove(dim);\n    sliceV.resetShape();\n    return sliceV;\n  }", "code_tokens": ["public", "Variable", "slice", "(", "int", "dim", ",", "int", "value", ")", "throws", "InvalidRangeException", "{", "if", "(", "(", "dim", "<", "0", ")", "||", "(", "dim", ">=", "shape", ".", "length", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Slice dim invalid= \"", "+", "dim", ")", ";", "// ok to make slice of record dimension with length 0", "boolean", "recordSliceOk", "=", "false", ";", "if", "(", "(", "dim", "==", "0", ")", "&&", "(", "value", "==", "0", ")", ")", "{", "Dimension", "d", "=", "getDimension", "(", "0", ")", ";", "recordSliceOk", "=", "d", ".", "isUnlimited", "(", ")", ";", "}", "// otherwise check slice in range", "if", "(", "!", "recordSliceOk", ")", "{", "if", "(", "(", "value", "<", "0", ")", "||", "(", "value", ">=", "shape", "[", "dim", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Slice value invalid= \"", "+", "value", "+", "\" for dimension \"", "+", "dim", ")", ";", "}", "// create a copy of this variable with a proxy reader", "Variable", "sliceV", "=", "copy", "(", ")", ";", "// subclasses must override", "Section", "slice", "=", "new", "Section", "(", "getShapeAsSection", "(", ")", ")", ";", "slice", ".", "replaceRange", "(", "dim", ",", "new", "Range", "(", "value", ",", "value", ")", ")", ".", "makeImmutable", "(", ")", ";", "sliceV", ".", "setProxyReader", "(", "new", "SliceReader", "(", "this", ",", "dim", ",", "slice", ")", ")", ";", "sliceV", ".", "createNewCache", "(", ")", ";", "// dont share the cache", "sliceV", ".", "setCaching", "(", "false", ")", ";", "// dont cache", "// remove that dimension - reduce rank", "sliceV", ".", "dimensions", ".", "remove", "(", "dim", ")", ";", "sliceV", ".", "resetShape", "(", ")", ";", "return", "sliceV", ";", "}"], "docstring": "Create a new Variable that is a logical slice of this Variable, by\nfixing the specified dimension at the specified index value. This reduces rank by 1.\nNo data is read until a read method is called on it.\n\n@param dim   which dimension to fix\n@param value at what index value\n@return a new Variable which is a logical slice of this Variable.\n@throws InvalidRangeException if dimension or value is illegal", "docstring_tokens": ["Create", "a", "new", "Variable", "that", "is", "a", "logical", "slice", "of", "this", "Variable", "by", "fixing", "the", "specified", "dimension", "at", "the", "specified", "index", "value", ".", "This", "reduces", "rank", "by", "1", ".", "No", "data", "is", "read", "until", "a", "read", "method", "is", "called", "on", "it", "."]}
{"code": "sliceV.setCaching(false);", "comments": "dont cache", "lines": 24, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable.slice", "original_string": "public Variable slice(int dim, int value) throws InvalidRangeException {\n    if ((dim < 0) || (dim >= shape.length))\n      throw new InvalidRangeException(\"Slice dim invalid= \" + dim);\n\n    // ok to make slice of record dimension with length 0\n    boolean recordSliceOk = false;\n    if ((dim == 0) && (value == 0)) {\n      Dimension d = getDimension(0);\n      recordSliceOk = d.isUnlimited();\n    }\n\n    // otherwise check slice in range\n    if (!recordSliceOk) {\n      if ((value < 0) || (value >= shape[dim]))\n        throw new InvalidRangeException(\"Slice value invalid= \" + value + \" for dimension \" + dim);\n    }\n\n    // create a copy of this variable with a proxy reader\n    Variable sliceV = copy(); // subclasses must override\n    Section slice = new Section(getShapeAsSection());\n    slice.replaceRange(dim, new Range(value, value)).makeImmutable();\n    sliceV.setProxyReader(new SliceReader(this, dim, slice));\n    sliceV.createNewCache(); // dont share the cache\n    sliceV.setCaching(false); // dont cache\n\n    // remove that dimension - reduce rank\n    sliceV.dimensions.remove(dim);\n    sliceV.resetShape();\n    return sliceV;\n  }", "language": "java", "Allcodes": "public Variable slice(int dim, int value) throws InvalidRangeException {\n    if ((dim < 0) || (dim >= shape.length))\n      throw new InvalidRangeException(\"Slice dim invalid= \" + dim);\n\n    // ok to make slice of record dimension with length 0\n    boolean recordSliceOk = false;\n    if ((dim == 0) && (value == 0)) {\n      Dimension d = getDimension(0);\n      recordSliceOk = d.isUnlimited();\n    }\n\n    // otherwise check slice in range\n    if (!recordSliceOk) {\n      if ((value < 0) || (value >= shape[dim]))\n        throw new InvalidRangeException(\"Slice value invalid= \" + value + \" for dimension \" + dim);\n    }\n\n    // create a copy of this variable with a proxy reader\n    Variable sliceV = copy(); // subclasses must override\n    Section slice = new Section(getShapeAsSection());\n    slice.replaceRange(dim, new Range(value, value)).makeImmutable();\n    sliceV.setProxyReader(new SliceReader(this, dim, slice));\n    sliceV.createNewCache(); // dont share the cache\n    sliceV.setCaching(false); // dont cache\n\n    // remove that dimension - reduce rank\n    sliceV.dimensions.remove(dim);\n    sliceV.resetShape();\n    return sliceV;\n  }", "code_tokens": ["public", "Variable", "slice", "(", "int", "dim", ",", "int", "value", ")", "throws", "InvalidRangeException", "{", "if", "(", "(", "dim", "<", "0", ")", "||", "(", "dim", ">=", "shape", ".", "length", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Slice dim invalid= \"", "+", "dim", ")", ";", "// ok to make slice of record dimension with length 0", "boolean", "recordSliceOk", "=", "false", ";", "if", "(", "(", "dim", "==", "0", ")", "&&", "(", "value", "==", "0", ")", ")", "{", "Dimension", "d", "=", "getDimension", "(", "0", ")", ";", "recordSliceOk", "=", "d", ".", "isUnlimited", "(", ")", ";", "}", "// otherwise check slice in range", "if", "(", "!", "recordSliceOk", ")", "{", "if", "(", "(", "value", "<", "0", ")", "||", "(", "value", ">=", "shape", "[", "dim", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Slice value invalid= \"", "+", "value", "+", "\" for dimension \"", "+", "dim", ")", ";", "}", "// create a copy of this variable with a proxy reader", "Variable", "sliceV", "=", "copy", "(", ")", ";", "// subclasses must override", "Section", "slice", "=", "new", "Section", "(", "getShapeAsSection", "(", ")", ")", ";", "slice", ".", "replaceRange", "(", "dim", ",", "new", "Range", "(", "value", ",", "value", ")", ")", ".", "makeImmutable", "(", ")", ";", "sliceV", ".", "setProxyReader", "(", "new", "SliceReader", "(", "this", ",", "dim", ",", "slice", ")", ")", ";", "sliceV", ".", "createNewCache", "(", ")", ";", "// dont share the cache", "sliceV", ".", "setCaching", "(", "false", ")", ";", "// dont cache", "// remove that dimension - reduce rank", "sliceV", ".", "dimensions", ".", "remove", "(", "dim", ")", ";", "sliceV", ".", "resetShape", "(", ")", ";", "return", "sliceV", ";", "}"], "docstring": "Create a new Variable that is a logical slice of this Variable, by\nfixing the specified dimension at the specified index value. This reduces rank by 1.\nNo data is read until a read method is called on it.\n\n@param dim   which dimension to fix\n@param value at what index value\n@return a new Variable which is a logical slice of this Variable.\n@throws InvalidRangeException if dimension or value is illegal", "docstring_tokens": ["Create", "a", "new", "Variable", "that", "is", "a", "logical", "slice", "of", "this", "Variable", "by", "fixing", "the", "specified", "dimension", "at", "the", "specified", "index", "value", ".", "This", "reduces", "rank", "by", "1", ".", "No", "data", "is", "read", "until", "a", "read", "method", "is", "called", "on", "it", "."]}
{"code": "return cache.data.copy();", "comments": "dont let users get their nasty hands on cached data", "lines": 15, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable._read", "original_string": "protected Array _read() throws IOException {\n    // caching overrides the proxyReader\n    // check if already cached\n    if (cache.data != null) {\n      if (debugCaching) System.out.println(\"got data from cache \" + getFullName());\n      return cache.data.copy();\n    }\n\n    Array data = proxyReader.reallyRead(this, null);\n\n    // optionally cache it\n    if (isCaching()) {\n      setCachedData(data);\n      if (debugCaching) System.out.println(\"cache \" + getFullName());\n      return cache.data.copy(); // dont let users get their nasty hands on cached data\n    } else {\n      return data;\n    }\n  }", "language": "java", "Allcodes": "protected Array _read() throws IOException {\n    // caching overrides the proxyReader\n    // check if already cached\n    if (cache.data != null) {\n      if (debugCaching) System.out.println(\"got data from cache \" + getFullName());\n      return cache.data.copy();\n    }\n\n    Array data = proxyReader.reallyRead(this, null);\n\n    // optionally cache it\n    if (isCaching()) {\n      setCachedData(data);\n      if (debugCaching) System.out.println(\"cache \" + getFullName());\n      return cache.data.copy(); // dont let users get their nasty hands on cached data\n    } else {\n      return data;\n    }\n  }", "code_tokens": ["protected", "Array", "_read", "(", ")", "throws", "IOException", "{", "// caching overrides the proxyReader", "// check if already cached", "if", "(", "cache", ".", "data", "!=", "null", ")", "{", "if", "(", "debugCaching", ")", "System", ".", "out", ".", "println", "(", "\"got data from cache \"", "+", "getFullName", "(", ")", ")", ";", "return", "cache", ".", "data", ".", "copy", "(", ")", ";", "}", "Array", "data", "=", "proxyReader", ".", "reallyRead", "(", "this", ",", "null", ")", ";", "// optionally cache it", "if", "(", "isCaching", "(", ")", ")", "{", "setCachedData", "(", "data", ")", ";", "if", "(", "debugCaching", ")", "System", ".", "out", ".", "println", "(", "\"cache \"", "+", "getFullName", "(", ")", ")", ";", "return", "cache", ".", "data", ".", "copy", "(", ")", ";", "// dont let users get their nasty hands on cached data", "}", "else", "{", "return", "data", ";", "}", "}"], "docstring": "non-structure-member Variables.", "docstring_tokens": ["non", "-", "structure", "-", "member", "Variables", "."]}
{"code": "setCachedData(_read());", "comments": "read and cache entire array", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable._read", "original_string": "protected Array _read(Section section) throws IOException, InvalidRangeException {\n    // check if its really a full read\n    if ((null == section) || section.computeSize() == getSize())\n      return _read();\n\n    // full read was cached\n    if (isCaching()) {\n      if (cache.data == null) {\n        setCachedData(_read()); // read and cache entire array\n        if (debugCaching) System.out.println(\"cache \" + getFullName());\n      }\n      if (debugCaching) System.out.println(\"got data from cache \" + getFullName());\n      return cache.data.sectionNoReduce(section.getRanges()).copy(); // subset it, return copy\n    }\n\n    return proxyReader.reallyRead(this, section, null);\n  }", "language": "java", "Allcodes": "protected Array _read(Section section) throws IOException, InvalidRangeException {\n    // check if its really a full read\n    if ((null == section) || section.computeSize() == getSize())\n      return _read();\n\n    // full read was cached\n    if (isCaching()) {\n      if (cache.data == null) {\n        setCachedData(_read()); // read and cache entire array\n        if (debugCaching) System.out.println(\"cache \" + getFullName());\n      }\n      if (debugCaching) System.out.println(\"got data from cache \" + getFullName());\n      return cache.data.sectionNoReduce(section.getRanges()).copy(); // subset it, return copy\n    }\n\n    return proxyReader.reallyRead(this, section, null);\n  }", "code_tokens": ["protected", "Array", "_read", "(", "Section", "section", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "// check if its really a full read", "if", "(", "(", "null", "==", "section", ")", "||", "section", ".", "computeSize", "(", ")", "==", "getSize", "(", ")", ")", "return", "_read", "(", ")", ";", "// full read was cached", "if", "(", "isCaching", "(", ")", ")", "{", "if", "(", "cache", ".", "data", "==", "null", ")", "{", "setCachedData", "(", "_read", "(", ")", ")", ";", "// read and cache entire array", "if", "(", "debugCaching", ")", "System", ".", "out", ".", "println", "(", "\"cache \"", "+", "getFullName", "(", ")", ")", ";", "}", "if", "(", "debugCaching", ")", "System", ".", "out", ".", "println", "(", "\"got data from cache \"", "+", "getFullName", "(", ")", ")", ";", "return", "cache", ".", "data", ".", "sectionNoReduce", "(", "section", ".", "getRanges", "(", ")", ")", ".", "copy", "(", ")", ";", "// subset it, return copy", "}", "return", "proxyReader", ".", "reallyRead", "(", "this", ",", "section", ",", "null", ")", ";", "}"], "docstring": "assume filled, validated Section", "docstring_tokens": ["assume", "filled", "validated", "Section"]}
{"code": "return cache.data.sectionNoReduce(section.getRanges()).copy();", "comments": "subset it, return copy", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable._read", "original_string": "protected Array _read(Section section) throws IOException, InvalidRangeException {\n    // check if its really a full read\n    if ((null == section) || section.computeSize() == getSize())\n      return _read();\n\n    // full read was cached\n    if (isCaching()) {\n      if (cache.data == null) {\n        setCachedData(_read()); // read and cache entire array\n        if (debugCaching) System.out.println(\"cache \" + getFullName());\n      }\n      if (debugCaching) System.out.println(\"got data from cache \" + getFullName());\n      return cache.data.sectionNoReduce(section.getRanges()).copy(); // subset it, return copy\n    }\n\n    return proxyReader.reallyRead(this, section, null);\n  }", "language": "java", "Allcodes": "protected Array _read(Section section) throws IOException, InvalidRangeException {\n    // check if its really a full read\n    if ((null == section) || section.computeSize() == getSize())\n      return _read();\n\n    // full read was cached\n    if (isCaching()) {\n      if (cache.data == null) {\n        setCachedData(_read()); // read and cache entire array\n        if (debugCaching) System.out.println(\"cache \" + getFullName());\n      }\n      if (debugCaching) System.out.println(\"got data from cache \" + getFullName());\n      return cache.data.sectionNoReduce(section.getRanges()).copy(); // subset it, return copy\n    }\n\n    return proxyReader.reallyRead(this, section, null);\n  }", "code_tokens": ["protected", "Array", "_read", "(", "Section", "section", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "// check if its really a full read", "if", "(", "(", "null", "==", "section", ")", "||", "section", ".", "computeSize", "(", ")", "==", "getSize", "(", ")", ")", "return", "_read", "(", ")", ";", "// full read was cached", "if", "(", "isCaching", "(", ")", ")", "{", "if", "(", "cache", ".", "data", "==", "null", ")", "{", "setCachedData", "(", "_read", "(", ")", ")", ";", "// read and cache entire array", "if", "(", "debugCaching", ")", "System", ".", "out", ".", "println", "(", "\"cache \"", "+", "getFullName", "(", ")", ")", ";", "}", "if", "(", "debugCaching", ")", "System", ".", "out", ".", "println", "(", "\"got data from cache \"", "+", "getFullName", "(", ")", ")", ";", "return", "cache", ".", "data", ".", "sectionNoReduce", "(", "section", ".", "getRanges", "(", ")", ")", ".", "copy", "(", ")", ";", "// subset it, return copy", "}", "return", "proxyReader", ".", "reallyRead", "(", "this", ",", "section", ",", "null", ")", ";", "}"], "docstring": "assume filled, validated Section", "docstring_tokens": ["assume", "filled", "validated", "Section"]}
{"code": "this.shapeAsSection = null;", "comments": "recalc next time its asked for", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Variable.java", "func_name": "Variable.resetShape", "original_string": "public void resetShape() {\n    // if (immutable) throw new IllegalStateException(\"Cant modify\");  LOOK allow this for unlimited dimension updating\n    this.shape = new int[dimensions.size()];\n    for (int i = 0; i < dimensions.size(); i++) {\n      Dimension dim = dimensions.get(i);\n      shape[i] = dim.getLength();\n      //shape[i] = Math.max(dim.getLength(), 0); // LOOK\n      // if (dim.isUnlimited() && (i != 0)) // LOOK only true for Netcdf-3\n      //   throw new IllegalArgumentException(\"Unlimited dimension must be outermost\");\n      if (dim.isVariableLength()) {\n        //if (dimensions.size() != 1)\n        //  throw new IllegalArgumentException(\"Unknown dimension can only be used in 1 dim array\");\n        //else\n        isVariableLength = true;\n      }\n    }\n    this.shapeAsSection = null; // recalc next time its asked for\n  }", "language": "java", "Allcodes": "public void resetShape() {\n    // if (immutable) throw new IllegalStateException(\"Cant modify\");  LOOK allow this for unlimited dimension updating\n    this.shape = new int[dimensions.size()];\n    for (int i = 0; i < dimensions.size(); i++) {\n      Dimension dim = dimensions.get(i);\n      shape[i] = dim.getLength();\n      //shape[i] = Math.max(dim.getLength(), 0); // LOOK\n      // if (dim.isUnlimited() && (i != 0)) // LOOK only true for Netcdf-3\n      //   throw new IllegalArgumentException(\"Unlimited dimension must be outermost\");\n      if (dim.isVariableLength()) {\n        //if (dimensions.size() != 1)\n        //  throw new IllegalArgumentException(\"Unknown dimension can only be used in 1 dim array\");\n        //else\n        isVariableLength = true;\n      }\n    }\n    this.shapeAsSection = null; // recalc next time its asked for\n  }", "code_tokens": ["public", "void", "resetShape", "(", ")", "{", "// if (immutable) throw new IllegalStateException(\"Cant modify\");  LOOK allow this for unlimited dimension updating", "this", ".", "shape", "=", "new", "int", "[", "dimensions", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "dimensions", ".", "size", "(", ")", ";", "i", "++", ")", "{", "Dimension", "dim", "=", "dimensions", ".", "get", "(", "i", ")", ";", "shape", "[", "i", "]", "=", "dim", ".", "getLength", "(", ")", ";", "//shape[i] = Math.max(dim.getLength(), 0); // LOOK", "// if (dim.isUnlimited() && (i != 0)) // LOOK only true for Netcdf-3", "//   throw new IllegalArgumentException(\"Unlimited dimension must be outermost\");", "if", "(", "dim", ".", "isVariableLength", "(", ")", ")", "{", "//if (dimensions.size() != 1)", "//  throw new IllegalArgumentException(\"Unknown dimension can only be used in 1 dim array\");", "//else", "isVariableLength", "=", "true", ";", "}", "}", "this", ".", "shapeAsSection", "=", "null", ";", "// recalc next time its asked for", "}"], "docstring": "Use when dimensions have changed, to recalculate the shape.", "docstring_tokens": ["Use", "when", "dimensions", "have", "changed", "to", "recalculate", "the", "shape", "."]}
{"code": "buildseqtypes(field);", "comments": "recurse for inner vlen dims", "lines": 14, "repo": "Unidata/thredds", "path": "dap4/d4cdm/src/main/java/dap4/cdm/dsp/CDMDSP.java", "func_name": "CDMDSP.buildseqtypes", "original_string": "protected void\n    buildseqtypes(Variable cdmvar)\n            throws DapException\n    {\n        if (CDMUtil.hasVLEN(cdmvar)) {\n            buildseqtype(cdmvar);\n        }\n        if (cdmvar.getDataType() == DataType.STRUCTURE\n                || cdmvar.getDataType() == DataType.SEQUENCE) {\n            Structure struct = (Structure) cdmvar;\n            List<Variable> fields = struct.getVariables();\n            for (int i = 0; i < fields.size(); i++) {\n                Variable field = fields.get(i);\n                buildseqtypes(field); // recurse for inner vlen dims\n            }\n        }\n    }", "language": "java", "Allcodes": "protected void\n    buildseqtypes(Variable cdmvar)\n            throws DapException\n    {\n        if (CDMUtil.hasVLEN(cdmvar)) {\n            buildseqtype(cdmvar);\n        }\n        if (cdmvar.getDataType() == DataType.STRUCTURE\n                || cdmvar.getDataType() == DataType.SEQUENCE) {\n            Structure struct = (Structure) cdmvar;\n            List<Variable> fields = struct.getVariables();\n            for (int i = 0; i < fields.size(); i++) {\n                Variable field = fields.get(i);\n                buildseqtypes(field); // recurse for inner vlen dims\n            }\n        }\n    }", "code_tokens": ["protected", "void", "buildseqtypes", "(", "Variable", "cdmvar", ")", "throws", "DapException", "{", "if", "(", "CDMUtil", ".", "hasVLEN", "(", "cdmvar", ")", ")", "{", "buildseqtype", "(", "cdmvar", ")", ";", "}", "if", "(", "cdmvar", ".", "getDataType", "(", ")", "==", "DataType", ".", "STRUCTURE", "||", "cdmvar", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "{", "Structure", "struct", "=", "(", "Structure", ")", "cdmvar", ";", "List", "<", "Variable", ">", "fields", "=", "struct", ".", "getVariables", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "fields", ".", "size", "(", ")", ";", "i", "++", ")", "{", "Variable", "field", "=", "fields", ".", "get", "(", "i", ")", ";", "buildseqtypes", "(", "field", ")", ";", "// recurse for inner vlen dims", "}", "}", "}"], "docstring": "Walk this variable, including fields, to construct sequence types\nfor any contained vlen dimensions\n\n@param cdmvar variable to walk", "docstring_tokens": ["Walk", "this", "variable", "including", "fields", "to", "construct", "sequence", "types", "for", "any", "contained", "vlen", "dimensions"]}
{"code": "boolean match = true;", "comments": "until otherwise shown", "lines": 21, "repo": "Unidata/thredds", "path": "dap4/d4cdm/src/main/java/dap4/cdm/dsp/CDMDSP.java", "func_name": "CDMDSP.findMatchingEnum", "original_string": "protected EnumTypedef\n    findMatchingEnum(EnumTypedef varenum)\n            throws DapException\n    {\n        List<EnumTypedef> candidates = new ArrayList<>();\n        for (Map.Entry<DapNode, CDMNode> entry : this.nodemap.getCDMMap().entrySet()) {\n            CDMNode cdmnode = entry.getValue();\n            if (cdmnode.getSort() != CDMSort.ENUMERATION)\n                continue;\n            // Compare the enumeration (note names will differ)\n            EnumTypedef target = (EnumTypedef) cdmnode;\n            /* Ideally, we should test the types of the enums,\n               but, unfortunately, the var enum is always enum4.\n            if(target.getBaseType() != varenum.getBaseType())\n                continue;\n            */\n            Map<Integer, String> targetmap = target.getMap();\n            Map<Integer, String> varmap = varenum.getMap();\n            if (targetmap.size() != varmap.size())\n                continue;\n            boolean match = true; // until otherwise shown\n            for (Map.Entry<Integer, String> tpair : targetmap.entrySet()) {\n                String tname = tpair.getValue();\n                int value = (int) tpair.getKey();\n                boolean found = false;\n                for (Map.Entry<Integer, String> vpair : varmap.entrySet()) {\n                    if (tname.equals(vpair.getValue()) && value == (int) vpair.getKey()) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    match = false;\n                    break;\n                }\n            }\n            if (!match)\n                continue;\n\n            // Save it unless it is shadowed by a closer enum\n            boolean shadowed = false;\n            for (EnumTypedef etd : candidates) {\n                if (shadows(etd.getGroup(), target.getGroup())) {\n                    shadowed = true;\n                    break;\n                }\n            }\n            if (!shadowed)\n                candidates.add(target);\n        }\n\n        switch (candidates.size()) {\n            case 0:\n                throw new DapException(\"CDMDSP: No matching enum type decl: \" + varenum.getShortName());\n            case 1:\n                break;\n            default:\n                throw new DapException(\"CDMDSP: Multiple matching enum type decls: \" + varenum.getShortName());\n        }\n        return candidates.get(0);\n    }", "language": "java", "Allcodes": "protected EnumTypedef\n    findMatchingEnum(EnumTypedef varenum)\n            throws DapException\n    {\n        List<EnumTypedef> candidates = new ArrayList<>();\n        for (Map.Entry<DapNode, CDMNode> entry : this.nodemap.getCDMMap().entrySet()) {\n            CDMNode cdmnode = entry.getValue();\n            if (cdmnode.getSort() != CDMSort.ENUMERATION)\n                continue;\n            // Compare the enumeration (note names will differ)\n            EnumTypedef target = (EnumTypedef) cdmnode;\n            /* Ideally, we should test the types of the enums,\n               but, unfortunately, the var enum is always enum4.\n            if(target.getBaseType() != varenum.getBaseType())\n                continue;\n            */\n            Map<Integer, String> targetmap = target.getMap();\n            Map<Integer, String> varmap = varenum.getMap();\n            if (targetmap.size() != varmap.size())\n                continue;\n            boolean match = true; // until otherwise shown\n            for (Map.Entry<Integer, String> tpair : targetmap.entrySet()) {\n                String tname = tpair.getValue();\n                int value = (int) tpair.getKey();\n                boolean found = false;\n                for (Map.Entry<Integer, String> vpair : varmap.entrySet()) {\n                    if (tname.equals(vpair.getValue()) && value == (int) vpair.getKey()) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    match = false;\n                    break;\n                }\n            }\n            if (!match)\n                continue;\n\n            // Save it unless it is shadowed by a closer enum\n            boolean shadowed = false;\n            for (EnumTypedef etd : candidates) {\n                if (shadows(etd.getGroup(), target.getGroup())) {\n                    shadowed = true;\n                    break;\n                }\n            }\n            if (!shadowed)\n                candidates.add(target);\n        }\n\n        switch (candidates.size()) {\n            case 0:\n                throw new DapException(\"CDMDSP: No matching enum type decl: \" + varenum.getShortName());\n            case 1:\n                break;\n            default:\n                throw new DapException(\"CDMDSP: Multiple matching enum type decls: \" + varenum.getShortName());\n        }\n        return candidates.get(0);\n    }", "code_tokens": ["protected", "EnumTypedef", "findMatchingEnum", "(", "EnumTypedef", "varenum", ")", "throws", "DapException", "{", "List", "<", "EnumTypedef", ">", "candidates", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "DapNode", ",", "CDMNode", ">", "entry", ":", "this", ".", "nodemap", ".", "getCDMMap", "(", ")", ".", "entrySet", "(", ")", ")", "{", "CDMNode", "cdmnode", "=", "entry", ".", "getValue", "(", ")", ";", "if", "(", "cdmnode", ".", "getSort", "(", ")", "!=", "CDMSort", ".", "ENUMERATION", ")", "continue", ";", "// Compare the enumeration (note names will differ)", "EnumTypedef", "target", "=", "(", "EnumTypedef", ")", "cdmnode", ";", "/* Ideally, we should test the types of the enums,\n               but, unfortunately, the var enum is always enum4.\n            if(target.getBaseType() != varenum.getBaseType())\n                continue;\n            */", "Map", "<", "Integer", ",", "String", ">", "targetmap", "=", "target", ".", "getMap", "(", ")", ";", "Map", "<", "Integer", ",", "String", ">", "varmap", "=", "varenum", ".", "getMap", "(", ")", ";", "if", "(", "targetmap", ".", "size", "(", ")", "!=", "varmap", ".", "size", "(", ")", ")", "continue", ";", "boolean", "match", "=", "true", ";", "// until otherwise shown", "for", "(", "Map", ".", "Entry", "<", "Integer", ",", "String", ">", "tpair", ":", "targetmap", ".", "entrySet", "(", ")", ")", "{", "String", "tname", "=", "tpair", ".", "getValue", "(", ")", ";", "int", "value", "=", "(", "int", ")", "tpair", ".", "getKey", "(", ")", ";", "boolean", "found", "=", "false", ";", "for", "(", "Map", ".", "Entry", "<", "Integer", ",", "String", ">", "vpair", ":", "varmap", ".", "entrySet", "(", ")", ")", "{", "if", "(", "tname", ".", "equals", "(", "vpair", ".", "getValue", "(", ")", ")", "&&", "value", "==", "(", "int", ")", "vpair", ".", "getKey", "(", ")", ")", "{", "found", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "found", ")", "{", "match", "=", "false", ";", "break", ";", "}", "}", "if", "(", "!", "match", ")", "continue", ";", "// Save it unless it is shadowed by a closer enum", "boolean", "shadowed", "=", "false", ";", "for", "(", "EnumTypedef", "etd", ":", "candidates", ")", "{", "if", "(", "shadows", "(", "etd", ".", "getGroup", "(", ")", ",", "target", ".", "getGroup", "(", ")", ")", ")", "{", "shadowed", "=", "true", ";", "break", ";", "}", "}", "if", "(", "!", "shadowed", ")", "candidates", ".", "add", "(", "target", ")", ";", "}", "switch", "(", "candidates", ".", "size", "(", ")", ")", "{", "case", "0", ":", "throw", "new", "DapException", "(", "\"CDMDSP: No matching enum type decl: \"", "+", "varenum", ".", "getShortName", "(", ")", ")", ";", "case", "1", ":", "break", ";", "default", ":", "throw", "new", "DapException", "(", "\"CDMDSP: Multiple matching enum type decls: \"", "+", "varenum", ".", "getShortName", "(", ")", ")", ";", "}", "return", "candidates", ".", "get", "(", "0", ")", ";", "}"], "docstring": "Unfortunately, the CDM Iosp does not\nactually use the declared enums. Rather,\nfor every enum type'd variable, a new\nenum decl is defined. So, we need\nto find the original enum decl that matches\nthe variable's enum.", "docstring_tokens": ["Unfortunately", "the", "CDM", "Iosp", "does", "not", "actually", "use", "the", "declared", "enums", ".", "Rather", "for", "every", "enum", "type", "d", "variable", "a", "new", "enum", "decl", "is", "defined", ".", "So", "we", "need", "to", "find", "the", "original", "enum", "decl", "that", "matches", "the", "variable", "s", "enum", "."]}
{"code": "upload.setSizeMax(this.cdmValidatorContext.getMaxFileUploadSize());", "comments": "maximum bytes before a FileUploadException will be thrown", "lines": 16, "repo": "Unidata/thredds", "path": "cdmvalidator/src/main/java/thredds/server/cdmvalidator/CdmValidatorController.java", "func_name": "CdmValidatorController.doPost", "original_string": "public void doPost(HttpServletRequest req, HttpServletResponse res)\n          throws ServletException, IOException {\n\n    log.info(\"doPost(): \" + UsageLog.setupRequestContext(req));\n\n    // Check that we have a file upload request\n    boolean isMultipart = ServletFileUpload.isMultipartContent(req);\n    if (!isMultipart) {\n      log.info(\"doPost(): \" + UsageLog.closingMessageForRequestContext(HttpServletResponse.SC_BAD_REQUEST, 0));\n      res.sendError(HttpServletResponse.SC_BAD_REQUEST);\n      return;\n    }\n\n    //Create a new file upload handler\n    ServletFileUpload upload = new ServletFileUpload(this.cdmValidatorContext.getFileuploadFileItemFactory());\n    upload.setSizeMax(this.cdmValidatorContext.getMaxFileUploadSize());  // maximum bytes before a FileUploadException will be thrown\n\n    List<FileItem> fileItems;\n    try {\n      fileItems = (List<FileItem>) upload.parseRequest(req);\n    } catch (FileUploadException e) {\n      log.info(\"doPost(): Validator FileUploadException\", e);\n      log.info(\"doPost(): \" + UsageLog.closingMessageForRequestContext(HttpServletResponse.SC_BAD_REQUEST, 0));\n      if (!res.isCommitted()) res.sendError(HttpServletResponse.SC_BAD_REQUEST);\n      return;\n    }\n\n    //Process the uploaded items\n    String username = null;\n    boolean wantXml = false;\n    for (FileItem item : fileItems) {\n      if (item.isFormField()) {\n        if (\"username\".equals(item.getFieldName()))\n          username = item.getString();\n        if (\"xml\".equals(item.getFieldName()))\n          wantXml = item.getString().equals(\"true\");\n      }\n    }\n\n    for (FileItem item : fileItems) {\n      if (!item.isFormField()) {\n        try {\n          processUploadedFile(req, res, (DiskFileItem) item, username, wantXml);\n          return;\n        } catch (Exception e) {\n          log.info(\"doPost(): Validator processUploadedFile\", e);\n          log.info(\"doPost(): \" + UsageLog.closingMessageForRequestContext(HttpServletResponse.SC_BAD_REQUEST, 0));\n          res.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n        }\n      }\n    }\n\n  }", "language": "java", "Allcodes": "public void doPost(HttpServletRequest req, HttpServletResponse res)\n          throws ServletException, IOException {\n\n    log.info(\"doPost(): \" + UsageLog.setupRequestContext(req));\n\n    // Check that we have a file upload request\n    boolean isMultipart = ServletFileUpload.isMultipartContent(req);\n    if (!isMultipart) {\n      log.info(\"doPost(): \" + UsageLog.closingMessageForRequestContext(HttpServletResponse.SC_BAD_REQUEST, 0));\n      res.sendError(HttpServletResponse.SC_BAD_REQUEST);\n      return;\n    }\n\n    //Create a new file upload handler\n    ServletFileUpload upload = new ServletFileUpload(this.cdmValidatorContext.getFileuploadFileItemFactory());\n    upload.setSizeMax(this.cdmValidatorContext.getMaxFileUploadSize());  // maximum bytes before a FileUploadException will be thrown\n\n    List<FileItem> fileItems;\n    try {\n      fileItems = (List<FileItem>) upload.parseRequest(req);\n    } catch (FileUploadException e) {\n      log.info(\"doPost(): Validator FileUploadException\", e);\n      log.info(\"doPost(): \" + UsageLog.closingMessageForRequestContext(HttpServletResponse.SC_BAD_REQUEST, 0));\n      if (!res.isCommitted()) res.sendError(HttpServletResponse.SC_BAD_REQUEST);\n      return;\n    }\n\n    //Process the uploaded items\n    String username = null;\n    boolean wantXml = false;\n    for (FileItem item : fileItems) {\n      if (item.isFormField()) {\n        if (\"username\".equals(item.getFieldName()))\n          username = item.getString();\n        if (\"xml\".equals(item.getFieldName()))\n          wantXml = item.getString().equals(\"true\");\n      }\n    }\n\n    for (FileItem item : fileItems) {\n      if (!item.isFormField()) {\n        try {\n          processUploadedFile(req, res, (DiskFileItem) item, username, wantXml);\n          return;\n        } catch (Exception e) {\n          log.info(\"doPost(): Validator processUploadedFile\", e);\n          log.info(\"doPost(): \" + UsageLog.closingMessageForRequestContext(HttpServletResponse.SC_BAD_REQUEST, 0));\n          res.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n        }\n      }\n    }\n\n  }", "code_tokens": ["public", "void", "doPost", "(", "HttpServletRequest", "req", ",", "HttpServletResponse", "res", ")", "throws", "ServletException", ",", "IOException", "{", "log", ".", "info", "(", "\"doPost(): \"", "+", "UsageLog", ".", "setupRequestContext", "(", "req", ")", ")", ";", "// Check that we have a file upload request", "boolean", "isMultipart", "=", "ServletFileUpload", ".", "isMultipartContent", "(", "req", ")", ";", "if", "(", "!", "isMultipart", ")", "{", "log", ".", "info", "(", "\"doPost(): \"", "+", "UsageLog", ".", "closingMessageForRequestContext", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ",", "0", ")", ")", ";", "res", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "//Create a new file upload handler", "ServletFileUpload", "upload", "=", "new", "ServletFileUpload", "(", "this", ".", "cdmValidatorContext", ".", "getFileuploadFileItemFactory", "(", ")", ")", ";", "upload", ".", "setSizeMax", "(", "this", ".", "cdmValidatorContext", ".", "getMaxFileUploadSize", "(", ")", ")", ";", "// maximum bytes before a FileUploadException will be thrown", "List", "<", "FileItem", ">", "fileItems", ";", "try", "{", "fileItems", "=", "(", "List", "<", "FileItem", ">", ")", "upload", ".", "parseRequest", "(", "req", ")", ";", "}", "catch", "(", "FileUploadException", "e", ")", "{", "log", ".", "info", "(", "\"doPost(): Validator FileUploadException\"", ",", "e", ")", ";", "log", ".", "info", "(", "\"doPost(): \"", "+", "UsageLog", ".", "closingMessageForRequestContext", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ",", "0", ")", ")", ";", "if", "(", "!", "res", ".", "isCommitted", "(", ")", ")", "res", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "return", ";", "}", "//Process the uploaded items", "String", "username", "=", "null", ";", "boolean", "wantXml", "=", "false", ";", "for", "(", "FileItem", "item", ":", "fileItems", ")", "{", "if", "(", "item", ".", "isFormField", "(", ")", ")", "{", "if", "(", "\"username\"", ".", "equals", "(", "item", ".", "getFieldName", "(", ")", ")", ")", "username", "=", "item", ".", "getString", "(", ")", ";", "if", "(", "\"xml\"", ".", "equals", "(", "item", ".", "getFieldName", "(", ")", ")", ")", "wantXml", "=", "item", ".", "getString", "(", ")", ".", "equals", "(", "\"true\"", ")", ";", "}", "}", "for", "(", "FileItem", "item", ":", "fileItems", ")", "{", "if", "(", "!", "item", ".", "isFormField", "(", ")", ")", "{", "try", "{", "processUploadedFile", "(", "req", ",", "res", ",", "(", "DiskFileItem", ")", "item", ",", "username", ",", "wantXml", ")", ";", "return", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "info", "(", "\"doPost(): Validator processUploadedFile\"", ",", "e", ")", ";", "log", ".", "info", "(", "\"doPost(): \"", "+", "UsageLog", ".", "closingMessageForRequestContext", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ",", "0", ")", ")", ";", "res", ".", "sendError", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "}"], "docstring": "POST handles uploaded files\n\n@param req request\n@param res response\n@throws ServletException\n@throws IOException", "docstring_tokens": ["POST", "handles", "uploaded", "files"]}
{"code": "getMapArea( bb);", "comments": "current world bounding box", "lines": 2, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/Navigation.java", "func_name": "Navigation.wantRotate", "original_string": "public boolean wantRotate(double displayWidth, double displayHeight) {\n    getMapArea( bb); // current world bounding box\n    boolean aspectDisplay = displayHeight < displayWidth;\n    boolean aspectWorldBB = bb.getHeight() < bb.getWidth();\n    return (aspectDisplay ^ aspectWorldBB); // aspects are different\n }", "language": "java", "Allcodes": "public boolean wantRotate(double displayWidth, double displayHeight) {\n    getMapArea( bb); // current world bounding box\n    boolean aspectDisplay = displayHeight < displayWidth;\n    boolean aspectWorldBB = bb.getHeight() < bb.getWidth();\n    return (aspectDisplay ^ aspectWorldBB); // aspects are different\n }", "code_tokens": ["public", "boolean", "wantRotate", "(", "double", "displayWidth", ",", "double", "displayHeight", ")", "{", "getMapArea", "(", "bb", ")", ";", "// current world bounding box", "boolean", "aspectDisplay", "=", "displayHeight", "<", "displayWidth", ";", "boolean", "aspectWorldBB", "=", "bb", ".", "getHeight", "(", ")", "<", "bb", ".", "getWidth", "(", ")", ";", "return", "(", "aspectDisplay", "^", "aspectWorldBB", ")", ";", "// aspects are different", "}"], "docstring": "calculate if we want to rotate based on aspect ratio", "docstring_tokens": ["calculate", "if", "we", "want", "to", "rotate", "based", "on", "aspect", "ratio"]}
{"code": "return (aspectDisplay ^ aspectWorldBB);", "comments": "aspects are different", "lines": 5, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/Navigation.java", "func_name": "Navigation.wantRotate", "original_string": "public boolean wantRotate(double displayWidth, double displayHeight) {\n    getMapArea( bb); // current world bounding box\n    boolean aspectDisplay = displayHeight < displayWidth;\n    boolean aspectWorldBB = bb.getHeight() < bb.getWidth();\n    return (aspectDisplay ^ aspectWorldBB); // aspects are different\n }", "language": "java", "Allcodes": "public boolean wantRotate(double displayWidth, double displayHeight) {\n    getMapArea( bb); // current world bounding box\n    boolean aspectDisplay = displayHeight < displayWidth;\n    boolean aspectWorldBB = bb.getHeight() < bb.getWidth();\n    return (aspectDisplay ^ aspectWorldBB); // aspects are different\n }", "code_tokens": ["public", "boolean", "wantRotate", "(", "double", "displayWidth", ",", "double", "displayHeight", ")", "{", "getMapArea", "(", "bb", ")", ";", "// current world bounding box", "boolean", "aspectDisplay", "=", "displayHeight", "<", "displayWidth", ";", "boolean", "aspectWorldBB", "=", "bb", ".", "getHeight", "(", ")", "<", "bb", ".", "getWidth", "(", ")", ";", "return", "(", "aspectDisplay", "^", "aspectWorldBB", ")", ";", "// aspects are different", "}"], "docstring": "calculate if we want to rotate based on aspect ratio", "docstring_tokens": ["calculate", "if", "we", "want", "to", "rotate", "based", "on", "aspect", "ratio"]}
{"code": "width, height);", "comments": "width, height", "lines": 13, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/Navigation.java", "func_name": "Navigation.getMapArea", "original_string": "public ProjectionRect getMapArea(ProjectionRect rect) {\n    if (rect == null)\n      rect = new ProjectionRect();\n\n    double width = pwidth/pix_per_world;\n    double height = pheight/pix_per_world;\n\n        // center point\n    double wx0 = (pwidth/2-pix_x0)/pix_per_world;\n    double wy0 = (pix_y0-pheight/2)/pix_per_world;\n\n    rect.setRect(wx0-width/2, wy0-height/2,             // minx, miny\n             width, height);                            // width, height\n\n    return rect;\n  }", "language": "java", "Allcodes": "public ProjectionRect getMapArea(ProjectionRect rect) {\n    if (rect == null)\n      rect = new ProjectionRect();\n\n    double width = pwidth/pix_per_world;\n    double height = pheight/pix_per_world;\n\n        // center point\n    double wx0 = (pwidth/2-pix_x0)/pix_per_world;\n    double wy0 = (pix_y0-pheight/2)/pix_per_world;\n\n    rect.setRect(wx0-width/2, wy0-height/2,             // minx, miny\n             width, height);                            // width, height\n\n    return rect;\n  }", "code_tokens": ["public", "ProjectionRect", "getMapArea", "(", "ProjectionRect", "rect", ")", "{", "if", "(", "rect", "==", "null", ")", "rect", "=", "new", "ProjectionRect", "(", ")", ";", "double", "width", "=", "pwidth", "/", "pix_per_world", ";", "double", "height", "=", "pheight", "/", "pix_per_world", ";", "// center point", "double", "wx0", "=", "(", "pwidth", "/", "2", "-", "pix_x0", ")", "/", "pix_per_world", ";", "double", "wy0", "=", "(", "pix_y0", "-", "pheight", "/", "2", ")", "/", "pix_per_world", ";", "rect", ".", "setRect", "(", "wx0", "-", "width", "/", "2", ",", "wy0", "-", "height", "/", "2", ",", "// minx, miny", "width", ",", "height", ")", ";", "// width, height", "return", "rect", ";", "}"], "docstring": "Get current MapArea .\n@param rect : place results here, or null to create new Object", "docstring_tokens": ["Get", "current", "MapArea", "."]}
{"code": "throw new RuntimeException(e.getCause());", "comments": "pass exception to the caller of sendEvent()", "lines": 22, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/ListenerManager.java", "func_name": "ListenerManager.sendEvent", "original_string": "public synchronized void sendEvent(java.util.EventObject event) {\n    if (!hasListeners || !enabled)\n      return;\n\n    Object[] args = new Object[1];\n    args[0] = event;\n\n    // send event to all listeners\n    ListIterator iter = listeners.listIterator();\n    while (iter.hasNext()) {\n      Object client = iter.next();\n      try {\n        method.invoke(client, args);\n      } catch (IllegalAccessException e) {\n        logger.error(\"ListenerManager IllegalAccessException\", e);\n        iter.remove();\n      } catch (IllegalArgumentException e) {\n        logger.error(\"ListenerManager IllegalArgumentException\", e);\n        iter.remove();\n      } catch (InvocationTargetException e) {\n        // logger.error(\"ListenerManager InvocationTargetException on \" + method+ \" threw exception \" + e.getTargetException(), e);\n        throw new RuntimeException(e.getCause()); // pass exception to the caller of sendEvent()\n      }\n    }\n  }", "language": "java", "Allcodes": "public synchronized void sendEvent(java.util.EventObject event) {\n    if (!hasListeners || !enabled)\n      return;\n\n    Object[] args = new Object[1];\n    args[0] = event;\n\n    // send event to all listeners\n    ListIterator iter = listeners.listIterator();\n    while (iter.hasNext()) {\n      Object client = iter.next();\n      try {\n        method.invoke(client, args);\n      } catch (IllegalAccessException e) {\n        logger.error(\"ListenerManager IllegalAccessException\", e);\n        iter.remove();\n      } catch (IllegalArgumentException e) {\n        logger.error(\"ListenerManager IllegalArgumentException\", e);\n        iter.remove();\n      } catch (InvocationTargetException e) {\n        // logger.error(\"ListenerManager InvocationTargetException on \" + method+ \" threw exception \" + e.getTargetException(), e);\n        throw new RuntimeException(e.getCause()); // pass exception to the caller of sendEvent()\n      }\n    }\n  }", "code_tokens": ["public", "synchronized", "void", "sendEvent", "(", "java", ".", "util", ".", "EventObject", "event", ")", "{", "if", "(", "!", "hasListeners", "||", "!", "enabled", ")", "return", ";", "Object", "[", "]", "args", "=", "new", "Object", "[", "1", "]", ";", "args", "[", "0", "]", "=", "event", ";", "// send event to all listeners", "ListIterator", "iter", "=", "listeners", ".", "listIterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "Object", "client", "=", "iter", ".", "next", "(", ")", ";", "try", "{", "method", ".", "invoke", "(", "client", ",", "args", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "logger", ".", "error", "(", "\"ListenerManager IllegalAccessException\"", ",", "e", ")", ";", "iter", ".", "remove", "(", ")", ";", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "logger", ".", "error", "(", "\"ListenerManager IllegalArgumentException\"", ",", "e", ")", ";", "iter", ".", "remove", "(", ")", ";", "}", "catch", "(", "InvocationTargetException", "e", ")", "{", "// logger.error(\"ListenerManager InvocationTargetException on \" + method+ \" threw exception \" + e.getTargetException(), e);", "throw", "new", "RuntimeException", "(", "e", ".", "getCause", "(", ")", ")", ";", "// pass exception to the caller of sendEvent()", "}", "}", "}"], "docstring": "Send an event to all registered listeners. If an exception is thrown, remove\nthe Listener from the list\n\n@param event the event to be sent: public void method_name( event_class event)", "docstring_tokens": ["Send", "an", "event", "to", "all", "registered", "listeners", ".", "If", "an", "exception", "is", "thrown", "remove", "the", "Listener", "from", "the", "list"]}
{"code": "bitBuf &= 0xff >> (8 - bitPos);", "comments": "mask off consumed bits", "lines": 10, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/BitReader.java", "func_name": "BitReader.setBitOffset", "original_string": "public void setBitOffset(int bitOffset) throws IOException {\r\n    if (bitOffset % 8 == 0) {\r\n      raf.seek(startPos + bitOffset / 8);\r\n      bitPos = 0;\r\n      bitBuf = 0;\r\n    } else {\r\n      raf.seek(startPos + bitOffset / 8);\r\n      bitPos = 8 - (bitOffset % 8);\r\n      bitBuf = (byte) raf.read();\r\n      bitBuf &= 0xff >> (8 - bitPos);   // mask off consumed bits      \r\n    }\r\n  }", "language": "java", "Allcodes": "public void setBitOffset(int bitOffset) throws IOException {\r\n    if (bitOffset % 8 == 0) {\r\n      raf.seek(startPos + bitOffset / 8);\r\n      bitPos = 0;\r\n      bitBuf = 0;\r\n    } else {\r\n      raf.seek(startPos + bitOffset / 8);\r\n      bitPos = 8 - (bitOffset % 8);\r\n      bitBuf = (byte) raf.read();\r\n      bitBuf &= 0xff >> (8 - bitPos);   // mask off consumed bits      \r\n    }\r\n  }", "code_tokens": ["public", "void", "setBitOffset", "(", "int", "bitOffset", ")", "throws", "IOException", "{", "if", "(", "bitOffset", "%", "8", "==", "0", ")", "{", "raf", ".", "seek", "(", "startPos", "+", "bitOffset", "/", "8", ")", ";", "bitPos", "=", "0", ";", "bitBuf", "=", "0", ";", "}", "else", "{", "raf", ".", "seek", "(", "startPos", "+", "bitOffset", "/", "8", ")", ";", "bitPos", "=", "8", "-", "(", "bitOffset", "%", "8", ")", ";", "bitBuf", "=", "(", "byte", ")", "raf", ".", "read", "(", ")", ";", "bitBuf", "&=", "0xff", ">>", "(", "8", "-", "bitPos", ")", ";", "// mask off consumed bits      \r", "}", "}"], "docstring": "Position file at bitOffset from startPos\n\n@param bitOffset bit offset from starting position\n@throws IOException on io error", "docstring_tokens": ["Position", "file", "at", "bitOffset", "from", "startPos"]}
{"code": "return ce;", "comments": "escaping will happen elsewhere", "lines": 50, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/DConnect2.java", "func_name": "DConnect2.getCompleteCE", "original_string": "private String getCompleteCE(String CE)\n    {\n        String localProjString = null;\n        String localSelString = null;\n        if(CE == null)\n            return \"\";\n        //remove any leading '?'\n        if(CE.startsWith(\"?\")) CE = CE.substring(1);\n        int selIndex = CE.indexOf('&');\n        if(selIndex == 0) {\n            localProjString = \"\";\n            localSelString = CE;\n        } else if(selIndex > 0) {\n            localSelString = CE.substring(selIndex);\n            localProjString = CE.substring(0, selIndex);\n        } else {// selIndex < 0\n            localProjString = CE;\n            localSelString = \"\";\n        }\n\n        String ce = projString;\n\n        if(!localProjString.equals(\"\")) {\n            if(!ce.equals(\"\") && localProjString.indexOf(',') != 0)\n                ce += \",\";\n            ce += localProjString;\n        }\n\n        if(!selString.equals(\"\")) {\n            if(selString.indexOf('&') != 0)\n                ce += \"&\";\n            ce += selString;\n        }\n\n        if(!localSelString.equals(\"\")) {\n            if(localSelString.indexOf('&') != 0)\n                ce += \"&\";\n            ce += localSelString;\n        }\n\n        if(ce.length() > 0) ce = \"?\" + ce;\n\n        if(false) {\n            DAPNode.log.debug(\"projString: '\" + projString + \"'\");\n            DAPNode.log.debug(\"localProjString: '\" + localProjString + \"'\");\n            DAPNode.log.debug(\"selString: '\" + selString + \"'\");\n            DAPNode.log.debug(\"localSelString: '\" + localSelString + \"'\");\n            DAPNode.log.debug(\"Complete CE: \" + ce);\n        }\n        return ce;   // escaping will happen elsewhere\n    }", "language": "java", "Allcodes": "private String getCompleteCE(String CE)\n    {\n        String localProjString = null;\n        String localSelString = null;\n        if(CE == null)\n            return \"\";\n        //remove any leading '?'\n        if(CE.startsWith(\"?\")) CE = CE.substring(1);\n        int selIndex = CE.indexOf('&');\n        if(selIndex == 0) {\n            localProjString = \"\";\n            localSelString = CE;\n        } else if(selIndex > 0) {\n            localSelString = CE.substring(selIndex);\n            localProjString = CE.substring(0, selIndex);\n        } else {// selIndex < 0\n            localProjString = CE;\n            localSelString = \"\";\n        }\n\n        String ce = projString;\n\n        if(!localProjString.equals(\"\")) {\n            if(!ce.equals(\"\") && localProjString.indexOf(',') != 0)\n                ce += \",\";\n            ce += localProjString;\n        }\n\n        if(!selString.equals(\"\")) {\n            if(selString.indexOf('&') != 0)\n                ce += \"&\";\n            ce += selString;\n        }\n\n        if(!localSelString.equals(\"\")) {\n            if(localSelString.indexOf('&') != 0)\n                ce += \"&\";\n            ce += localSelString;\n        }\n\n        if(ce.length() > 0) ce = \"?\" + ce;\n\n        if(false) {\n            DAPNode.log.debug(\"projString: '\" + projString + \"'\");\n            DAPNode.log.debug(\"localProjString: '\" + localProjString + \"'\");\n            DAPNode.log.debug(\"selString: '\" + selString + \"'\");\n            DAPNode.log.debug(\"localSelString: '\" + localSelString + \"'\");\n            DAPNode.log.debug(\"Complete CE: \" + ce);\n        }\n        return ce;   // escaping will happen elsewhere\n    }", "code_tokens": ["private", "String", "getCompleteCE", "(", "String", "CE", ")", "{", "String", "localProjString", "=", "null", ";", "String", "localSelString", "=", "null", ";", "if", "(", "CE", "==", "null", ")", "return", "\"\"", ";", "//remove any leading '?'", "if", "(", "CE", ".", "startsWith", "(", "\"?\"", ")", ")", "CE", "=", "CE", ".", "substring", "(", "1", ")", ";", "int", "selIndex", "=", "CE", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "selIndex", "==", "0", ")", "{", "localProjString", "=", "\"\"", ";", "localSelString", "=", "CE", ";", "}", "else", "if", "(", "selIndex", ">", "0", ")", "{", "localSelString", "=", "CE", ".", "substring", "(", "selIndex", ")", ";", "localProjString", "=", "CE", ".", "substring", "(", "0", ",", "selIndex", ")", ";", "}", "else", "{", "// selIndex < 0", "localProjString", "=", "CE", ";", "localSelString", "=", "\"\"", ";", "}", "String", "ce", "=", "projString", ";", "if", "(", "!", "localProjString", ".", "equals", "(", "\"\"", ")", ")", "{", "if", "(", "!", "ce", ".", "equals", "(", "\"\"", ")", "&&", "localProjString", ".", "indexOf", "(", "'", "'", ")", "!=", "0", ")", "ce", "+=", "\",\"", ";", "ce", "+=", "localProjString", ";", "}", "if", "(", "!", "selString", ".", "equals", "(", "\"\"", ")", ")", "{", "if", "(", "selString", ".", "indexOf", "(", "'", "'", ")", "!=", "0", ")", "ce", "+=", "\"&\"", ";", "ce", "+=", "selString", ";", "}", "if", "(", "!", "localSelString", ".", "equals", "(", "\"\"", ")", ")", "{", "if", "(", "localSelString", ".", "indexOf", "(", "'", "'", ")", "!=", "0", ")", "ce", "+=", "\"&\"", ";", "ce", "+=", "localSelString", ";", "}", "if", "(", "ce", ".", "length", "(", ")", ">", "0", ")", "ce", "=", "\"?\"", "+", "ce", ";", "if", "(", "false", ")", "{", "DAPNode", ".", "log", ".", "debug", "(", "\"projString: '\"", "+", "projString", "+", "\"'\"", ")", ";", "DAPNode", ".", "log", ".", "debug", "(", "\"localProjString: '\"", "+", "localProjString", "+", "\"'\"", ")", ";", "DAPNode", ".", "log", ".", "debug", "(", "\"selString: '\"", "+", "selString", "+", "\"'\"", ")", ";", "DAPNode", ".", "log", ".", "debug", "(", "\"localSelString: '\"", "+", "localSelString", "+", "\"'\"", ")", ";", "DAPNode", ".", "log", ".", "debug", "(", "\"Complete CE: \"", "+", "ce", ")", ";", "}", "return", "ce", ";", "// escaping will happen elsewhere", "}"], "docstring": "Use some sense when assembling the CE. Since this DConnect\nobject may have constructed using a CE, any new CE will\nhave to be integrated into it for subsequent requests.\nTry to do this in a sensible manner!\n\n@param CE The new CE from the client.\n@return The complete CE (the one this object was built\nwith integrated with the clients)", "docstring_tokens": ["Use", "some", "sense", "when", "assembling", "the", "CE", ".", "Since", "this", "DConnect", "object", "may", "have", "constructed", "using", "a", "CE", "any", "new", "CE", "will", "have", "to", "be", "integrated", "into", "it", "for", "subsequent", "requests", ".", "Try", "to", "do", "this", "in", "a", "sensible", "manner!"]}
{"code": "toLon_r = Math.toRadians(centMeridian);", "comments": "if lat == +- pi/2, set lon = centMeridian (Snyder 248)", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/projection/Sinusoidal.java", "func_name": "Sinusoidal.projToLatLon", "original_string": "@Override\r\n    public LatLonPoint projToLatLon(ProjectionPoint world, LatLonPointImpl result) {\r\n        double fromX = world.getX() - falseEasting;\r\n        double fromY = world.getY() - falseNorthing;\r\n\r\n        double toLat_r = fromY / earthRadius;\r\n        double toLon_r;\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLat_r), PI_OVER_2, 1e-10)) {\r\n            toLat_r = toLat_r < 0 ? -PI_OVER_2 : +PI_OVER_2;\r\n            toLon_r = Math.toRadians(centMeridian);  // if lat == +- pi/2, set lon = centMeridian (Snyder 248)\r\n        } else if (Math.abs(toLat_r) < PI_OVER_2) {\r\n            toLon_r = Math.toRadians(centMeridian) + fromX / (earthRadius * Math.cos(toLat_r));\r\n        } else {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLon_r), PI, 1e-10)) {\r\n            toLon_r = toLon_r < 0 ? -PI : +PI;\r\n        } else if (Math.abs(toLon_r) > PI) {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        result.setLatitude(Math.toDegrees(toLat_r));\r\n        result.setLongitude(Math.toDegrees(toLon_r));\r\n        return result;\r\n    }", "language": "java", "Allcodes": "@Override\r\n    public LatLonPoint projToLatLon(ProjectionPoint world, LatLonPointImpl result) {\r\n        double fromX = world.getX() - falseEasting;\r\n        double fromY = world.getY() - falseNorthing;\r\n\r\n        double toLat_r = fromY / earthRadius;\r\n        double toLon_r;\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLat_r), PI_OVER_2, 1e-10)) {\r\n            toLat_r = toLat_r < 0 ? -PI_OVER_2 : +PI_OVER_2;\r\n            toLon_r = Math.toRadians(centMeridian);  // if lat == +- pi/2, set lon = centMeridian (Snyder 248)\r\n        } else if (Math.abs(toLat_r) < PI_OVER_2) {\r\n            toLon_r = Math.toRadians(centMeridian) + fromX / (earthRadius * Math.cos(toLat_r));\r\n        } else {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLon_r), PI, 1e-10)) {\r\n            toLon_r = toLon_r < 0 ? -PI : +PI;\r\n        } else if (Math.abs(toLon_r) > PI) {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        result.setLatitude(Math.toDegrees(toLat_r));\r\n        result.setLongitude(Math.toDegrees(toLon_r));\r\n        return result;\r\n    }", "code_tokens": ["@", "Override", "public", "LatLonPoint", "projToLatLon", "(", "ProjectionPoint", "world", ",", "LatLonPointImpl", "result", ")", "{", "double", "fromX", "=", "world", ".", "getX", "(", ")", "-", "falseEasting", ";", "double", "fromY", "=", "world", ".", "getY", "(", ")", "-", "falseNorthing", ";", "double", "toLat_r", "=", "fromY", "/", "earthRadius", ";", "double", "toLon_r", ";", "if", "(", "Misc", ".", "nearlyEquals", "(", "Math", ".", "abs", "(", "toLat_r", ")", ",", "PI_OVER_2", ",", "1e-10", ")", ")", "{", "toLat_r", "=", "toLat_r", "<", "0", "?", "-", "PI_OVER_2", ":", "+", "PI_OVER_2", ";", "toLon_r", "=", "Math", ".", "toRadians", "(", "centMeridian", ")", ";", "// if lat == +- pi/2, set lon = centMeridian (Snyder 248)\r", "}", "else", "if", "(", "Math", ".", "abs", "(", "toLat_r", ")", "<", "PI_OVER_2", ")", "{", "toLon_r", "=", "Math", ".", "toRadians", "(", "centMeridian", ")", "+", "fromX", "/", "(", "earthRadius", "*", "Math", ".", "cos", "(", "toLat_r", ")", ")", ";", "}", "else", "{", "return", "INVALID", ";", "// Projection point is off the map.\r", "}", "if", "(", "Misc", ".", "nearlyEquals", "(", "Math", ".", "abs", "(", "toLon_r", ")", ",", "PI", ",", "1e-10", ")", ")", "{", "toLon_r", "=", "toLon_r", "<", "0", "?", "-", "PI", ":", "+", "PI", ";", "}", "else", "if", "(", "Math", ".", "abs", "(", "toLon_r", ")", ">", "PI", ")", "{", "return", "INVALID", ";", "// Projection point is off the map.\r", "}", "result", ".", "setLatitude", "(", "Math", ".", "toDegrees", "(", "toLat_r", ")", ")", ";", "result", ".", "setLongitude", "(", "Math", ".", "toDegrees", "(", "toLon_r", ")", ")", ";", "return", "result", ";", "}"], "docstring": "Convert projection coordinates to a LatLonPoint\n\n@param world  convert from these projection coordinates\n@param result the object to write to\n@return LatLonPoint the lat/lon coordinates", "docstring_tokens": ["Convert", "projection", "coordinates", "to", "a", "LatLonPoint"]}
{"code": "return INVALID;", "comments": "Projection point is off the map.", "lines": 15, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/projection/Sinusoidal.java", "func_name": "Sinusoidal.projToLatLon", "original_string": "@Override\r\n    public LatLonPoint projToLatLon(ProjectionPoint world, LatLonPointImpl result) {\r\n        double fromX = world.getX() - falseEasting;\r\n        double fromY = world.getY() - falseNorthing;\r\n\r\n        double toLat_r = fromY / earthRadius;\r\n        double toLon_r;\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLat_r), PI_OVER_2, 1e-10)) {\r\n            toLat_r = toLat_r < 0 ? -PI_OVER_2 : +PI_OVER_2;\r\n            toLon_r = Math.toRadians(centMeridian);  // if lat == +- pi/2, set lon = centMeridian (Snyder 248)\r\n        } else if (Math.abs(toLat_r) < PI_OVER_2) {\r\n            toLon_r = Math.toRadians(centMeridian) + fromX / (earthRadius * Math.cos(toLat_r));\r\n        } else {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLon_r), PI, 1e-10)) {\r\n            toLon_r = toLon_r < 0 ? -PI : +PI;\r\n        } else if (Math.abs(toLon_r) > PI) {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        result.setLatitude(Math.toDegrees(toLat_r));\r\n        result.setLongitude(Math.toDegrees(toLon_r));\r\n        return result;\r\n    }", "language": "java", "Allcodes": "@Override\r\n    public LatLonPoint projToLatLon(ProjectionPoint world, LatLonPointImpl result) {\r\n        double fromX = world.getX() - falseEasting;\r\n        double fromY = world.getY() - falseNorthing;\r\n\r\n        double toLat_r = fromY / earthRadius;\r\n        double toLon_r;\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLat_r), PI_OVER_2, 1e-10)) {\r\n            toLat_r = toLat_r < 0 ? -PI_OVER_2 : +PI_OVER_2;\r\n            toLon_r = Math.toRadians(centMeridian);  // if lat == +- pi/2, set lon = centMeridian (Snyder 248)\r\n        } else if (Math.abs(toLat_r) < PI_OVER_2) {\r\n            toLon_r = Math.toRadians(centMeridian) + fromX / (earthRadius * Math.cos(toLat_r));\r\n        } else {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        if (Misc.nearlyEquals(Math.abs(toLon_r), PI, 1e-10)) {\r\n            toLon_r = toLon_r < 0 ? -PI : +PI;\r\n        } else if (Math.abs(toLon_r) > PI) {\r\n            return INVALID;  // Projection point is off the map.\r\n        }\r\n\r\n        result.setLatitude(Math.toDegrees(toLat_r));\r\n        result.setLongitude(Math.toDegrees(toLon_r));\r\n        return result;\r\n    }", "code_tokens": ["@", "Override", "public", "LatLonPoint", "projToLatLon", "(", "ProjectionPoint", "world", ",", "LatLonPointImpl", "result", ")", "{", "double", "fromX", "=", "world", ".", "getX", "(", ")", "-", "falseEasting", ";", "double", "fromY", "=", "world", ".", "getY", "(", ")", "-", "falseNorthing", ";", "double", "toLat_r", "=", "fromY", "/", "earthRadius", ";", "double", "toLon_r", ";", "if", "(", "Misc", ".", "nearlyEquals", "(", "Math", ".", "abs", "(", "toLat_r", ")", ",", "PI_OVER_2", ",", "1e-10", ")", ")", "{", "toLat_r", "=", "toLat_r", "<", "0", "?", "-", "PI_OVER_2", ":", "+", "PI_OVER_2", ";", "toLon_r", "=", "Math", ".", "toRadians", "(", "centMeridian", ")", ";", "// if lat == +- pi/2, set lon = centMeridian (Snyder 248)\r", "}", "else", "if", "(", "Math", ".", "abs", "(", "toLat_r", ")", "<", "PI_OVER_2", ")", "{", "toLon_r", "=", "Math", ".", "toRadians", "(", "centMeridian", ")", "+", "fromX", "/", "(", "earthRadius", "*", "Math", ".", "cos", "(", "toLat_r", ")", ")", ";", "}", "else", "{", "return", "INVALID", ";", "// Projection point is off the map.\r", "}", "if", "(", "Misc", ".", "nearlyEquals", "(", "Math", ".", "abs", "(", "toLon_r", ")", ",", "PI", ",", "1e-10", ")", ")", "{", "toLon_r", "=", "toLon_r", "<", "0", "?", "-", "PI", ":", "+", "PI", ";", "}", "else", "if", "(", "Math", ".", "abs", "(", "toLon_r", ")", ">", "PI", ")", "{", "return", "INVALID", ";", "// Projection point is off the map.\r", "}", "result", ".", "setLatitude", "(", "Math", ".", "toDegrees", "(", "toLat_r", ")", ")", ";", "result", ".", "setLongitude", "(", "Math", ".", "toDegrees", "(", "toLon_r", ")", ")", ";", "return", "result", ";", "}"], "docstring": "Convert projection coordinates to a LatLonPoint\n\n@param world  convert from these projection coordinates\n@param result the object to write to\n@return LatLonPoint the lat/lon coordinates", "docstring_tokens": ["Convert", "projection", "coordinates", "to", "a", "LatLonPoint"]}
{"code": "byte[] out = new byte[utf8.length];", "comments": "Should be max we need", "lines": 8, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/Escape.java", "func_name": "Escape.xunescapeString", "original_string": "private static String xunescapeString(String in, char escape, boolean spaceplus)\n    {\n        try {\n            if(in == null) return null;\n\n            byte[] utf8 = in.getBytes(utf8Charset);\n            byte escape8 = (byte) escape;\n            byte[] out = new byte[utf8.length]; // Should be max we need\n\n            int index8 = 0;\n            for(int i = 0; i < utf8.length; ) {\n                byte b = utf8[i++];\n                if(b == plus && spaceplus) {\n                    out[index8++] = blank;\n                } else if(b == escape8) {\n                    // check to see if there are enough characters left\n                    if(i + 2 <= utf8.length) {\n                        b = (byte) (fromHex(utf8[i]) << 4 | fromHex(utf8[i + 1]));\n                        i += 2;\n                    }\n                }\n                out[index8++] = b;\n            }\n            return new String(out, 0, index8, utf8Charset);\n        } catch (Exception e) {\n            return in;\n        }\n\n    }", "language": "java", "Allcodes": "private static String xunescapeString(String in, char escape, boolean spaceplus)\n    {\n        try {\n            if(in == null) return null;\n\n            byte[] utf8 = in.getBytes(utf8Charset);\n            byte escape8 = (byte) escape;\n            byte[] out = new byte[utf8.length]; // Should be max we need\n\n            int index8 = 0;\n            for(int i = 0; i < utf8.length; ) {\n                byte b = utf8[i++];\n                if(b == plus && spaceplus) {\n                    out[index8++] = blank;\n                } else if(b == escape8) {\n                    // check to see if there are enough characters left\n                    if(i + 2 <= utf8.length) {\n                        b = (byte) (fromHex(utf8[i]) << 4 | fromHex(utf8[i + 1]));\n                        i += 2;\n                    }\n                }\n                out[index8++] = b;\n            }\n            return new String(out, 0, index8, utf8Charset);\n        } catch (Exception e) {\n            return in;\n        }\n\n    }", "code_tokens": ["private", "static", "String", "xunescapeString", "(", "String", "in", ",", "char", "escape", ",", "boolean", "spaceplus", ")", "{", "try", "{", "if", "(", "in", "==", "null", ")", "return", "null", ";", "byte", "[", "]", "utf8", "=", "in", ".", "getBytes", "(", "utf8Charset", ")", ";", "byte", "escape8", "=", "(", "byte", ")", "escape", ";", "byte", "[", "]", "out", "=", "new", "byte", "[", "utf8", ".", "length", "]", ";", "// Should be max we need", "int", "index8", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "utf8", ".", "length", ";", ")", "{", "byte", "b", "=", "utf8", "[", "i", "++", "]", ";", "if", "(", "b", "==", "plus", "&&", "spaceplus", ")", "{", "out", "[", "index8", "++", "]", "=", "blank", ";", "}", "else", "if", "(", "b", "==", "escape8", ")", "{", "// check to see if there are enough characters left", "if", "(", "i", "+", "2", "<=", "utf8", ".", "length", ")", "{", "b", "=", "(", "byte", ")", "(", "fromHex", "(", "utf8", "[", "i", "]", ")", "<<", "4", "|", "fromHex", "(", "utf8", "[", "i", "+", "1", "]", ")", ")", ";", "i", "+=", "2", ";", "}", "}", "out", "[", "index8", "++", "]", "=", "b", ";", "}", "return", "new", "String", "(", "out", ",", "0", ",", "index8", ",", "utf8Charset", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "return", "in", ";", "}", "}"], "docstring": "Given a string that contains WWW escape sequences, translate those escape\nsequences back into ASCII characters. Return the modified string.\n\n@param in        The string to modify.\n@param escape    The character used to signal the begining of an escape sequence.\nparam except If there is some escape code that should not be removed by\nthis call (e.g., you might not want to remove spaces, %20) use this\nparameter to specify that code. The function will then transform all\nescapes except that one.\n@param spaceplus True if spaces should be replaced by '+'.\n@return The modified string.", "docstring_tokens": ["Given", "a", "string", "that", "contains", "WWW", "escape", "sequences", "translate", "those", "escape", "sequences", "back", "into", "ASCII", "characters", ".", "Return", "the", "modified", "string", "."]}
{"code": "if (a == 0) return s;", "comments": "per R. Signell, USGS", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/vertical/OceanS.java", "func_name": "OceanS.makeC", "original_string": "private Array makeC(Array s, double a, double b) {\r\n    int nz = (int) s.getSize();\r\n    Index sIndex = s.getIndex();\r\n    if (a == 0) return s;  // per R. Signell, USGS\r\n\r\n    ArrayDouble.D1 c = new ArrayDouble.D1(nz);\r\n\r\n    double fac1 = 1.0 - b;\r\n    double denom1 = 1.0 / Math.sinh(a);\r\n    double denom2 = 1.0 / (2.0 * Math.tanh(0.5 * a));\r\n\r\n    for (int i = 0; i < nz; i++) {\r\n      double sz = s.getDouble(sIndex.set(i));\r\n      double term1 = fac1 * Math.sinh(a * sz) * denom1;\r\n      double term2 = b * (Math.tanh(a * (sz + 0.5))\r\n          * denom2 - 0.5);\r\n      c.set(i, term1 + term2);\r\n    }\r\n\r\n    return c;\r\n  }", "language": "java", "Allcodes": "private Array makeC(Array s, double a, double b) {\r\n    int nz = (int) s.getSize();\r\n    Index sIndex = s.getIndex();\r\n    if (a == 0) return s;  // per R. Signell, USGS\r\n\r\n    ArrayDouble.D1 c = new ArrayDouble.D1(nz);\r\n\r\n    double fac1 = 1.0 - b;\r\n    double denom1 = 1.0 / Math.sinh(a);\r\n    double denom2 = 1.0 / (2.0 * Math.tanh(0.5 * a));\r\n\r\n    for (int i = 0; i < nz; i++) {\r\n      double sz = s.getDouble(sIndex.set(i));\r\n      double term1 = fac1 * Math.sinh(a * sz) * denom1;\r\n      double term2 = b * (Math.tanh(a * (sz + 0.5))\r\n          * denom2 - 0.5);\r\n      c.set(i, term1 + term2);\r\n    }\r\n\r\n    return c;\r\n  }", "code_tokens": ["private", "Array", "makeC", "(", "Array", "s", ",", "double", "a", ",", "double", "b", ")", "{", "int", "nz", "=", "(", "int", ")", "s", ".", "getSize", "(", ")", ";", "Index", "sIndex", "=", "s", ".", "getIndex", "(", ")", ";", "if", "(", "a", "==", "0", ")", "return", "s", ";", "// per R. Signell, USGS\r", "ArrayDouble", ".", "D1", "c", "=", "new", "ArrayDouble", ".", "D1", "(", "nz", ")", ";", "double", "fac1", "=", "1.0", "-", "b", ";", "double", "denom1", "=", "1.0", "/", "Math", ".", "sinh", "(", "a", ")", ";", "double", "denom2", "=", "1.0", "/", "(", "2.0", "*", "Math", ".", "tanh", "(", "0.5", "*", "a", ")", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nz", ";", "i", "++", ")", "{", "double", "sz", "=", "s", ".", "getDouble", "(", "sIndex", ".", "set", "(", "i", ")", ")", ";", "double", "term1", "=", "fac1", "*", "Math", ".", "sinh", "(", "a", "*", "sz", ")", "*", "denom1", ";", "double", "term2", "=", "b", "*", "(", "Math", ".", "tanh", "(", "a", "*", "(", "sz", "+", "0.5", ")", ")", "*", "denom2", "-", "0.5", ")", ";", "c", ".", "set", "(", "i", ",", "term1", "+", "term2", ")", ";", "}", "return", "c", ";", "}"], "docstring": "Make the C array\n\n@param s s Array\n@param a \"a\" value\n@param b \"b\" value\n@return the C array", "docstring_tokens": ["Make", "the", "C", "array"]}
{"code": "duration /= 1000 * 60;", "comments": "minutes", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/DiskCache2.java", "func_name": "DiskCache2.cleanCache", "original_string": "public void cleanCache(File dir, Formatter sbuff, boolean isRoot) {\n    long now = System.currentTimeMillis();\n    File[] files = dir.listFiles();\n    if (files == null) {\n      throw new IllegalStateException( \"DiskCache2: not a directory or I/O error on dir=\"+dir.getAbsolutePath());\n    }\n\n    // check for empty directory\n    if (!isRoot && (files.length == 0)) {\n      long duration = now - dir.lastModified();\n      duration /= 1000 * 60; // minutes\n      if (duration > persistMinutes) {\n        boolean ok = dir.delete();\n        if (!ok)\n          cacheLog.error(\"Unable to delete file \" + dir.getAbsolutePath());\n        if (sbuff != null)\n          sbuff.format(\" deleted %s %s lastModified= %s%n\", ok, dir.getPath(), CalendarDate.of(dir.lastModified()));\n      }\n      return;\n    }\n\n    // check for expired files\n    for (File file : files) {\n      if (file.isDirectory()) {\n        cleanCache(file, sbuff, false);\n      } else {\n        long duration = now - file.lastModified();\n        duration /= 1000 * 60; // minutes\n        if (duration > persistMinutes) {\n          boolean ok = file.delete();\n          if (!ok)\n            cacheLog.error(\"Unable to delete file \" + file.getAbsolutePath());\n          if (sbuff != null)\n            sbuff.format(\" deleted %s %s lastModified= %s%n\", ok, file.getPath(), CalendarDate.of(file.lastModified()));\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "public void cleanCache(File dir, Formatter sbuff, boolean isRoot) {\n    long now = System.currentTimeMillis();\n    File[] files = dir.listFiles();\n    if (files == null) {\n      throw new IllegalStateException( \"DiskCache2: not a directory or I/O error on dir=\"+dir.getAbsolutePath());\n    }\n\n    // check for empty directory\n    if (!isRoot && (files.length == 0)) {\n      long duration = now - dir.lastModified();\n      duration /= 1000 * 60; // minutes\n      if (duration > persistMinutes) {\n        boolean ok = dir.delete();\n        if (!ok)\n          cacheLog.error(\"Unable to delete file \" + dir.getAbsolutePath());\n        if (sbuff != null)\n          sbuff.format(\" deleted %s %s lastModified= %s%n\", ok, dir.getPath(), CalendarDate.of(dir.lastModified()));\n      }\n      return;\n    }\n\n    // check for expired files\n    for (File file : files) {\n      if (file.isDirectory()) {\n        cleanCache(file, sbuff, false);\n      } else {\n        long duration = now - file.lastModified();\n        duration /= 1000 * 60; // minutes\n        if (duration > persistMinutes) {\n          boolean ok = file.delete();\n          if (!ok)\n            cacheLog.error(\"Unable to delete file \" + file.getAbsolutePath());\n          if (sbuff != null)\n            sbuff.format(\" deleted %s %s lastModified= %s%n\", ok, file.getPath(), CalendarDate.of(file.lastModified()));\n        }\n      }\n    }\n  }", "code_tokens": ["public", "void", "cleanCache", "(", "File", "dir", ",", "Formatter", "sbuff", ",", "boolean", "isRoot", ")", "{", "long", "now", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "File", "[", "]", "files", "=", "dir", ".", "listFiles", "(", ")", ";", "if", "(", "files", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", "\"DiskCache2: not a directory or I/O error on dir=\"", "+", "dir", ".", "getAbsolutePath", "(", ")", ")", ";", "}", "// check for empty directory", "if", "(", "!", "isRoot", "&&", "(", "files", ".", "length", "==", "0", ")", ")", "{", "long", "duration", "=", "now", "-", "dir", ".", "lastModified", "(", ")", ";", "duration", "/=", "1000", "*", "60", ";", "// minutes", "if", "(", "duration", ">", "persistMinutes", ")", "{", "boolean", "ok", "=", "dir", ".", "delete", "(", ")", ";", "if", "(", "!", "ok", ")", "cacheLog", ".", "error", "(", "\"Unable to delete file \"", "+", "dir", ".", "getAbsolutePath", "(", ")", ")", ";", "if", "(", "sbuff", "!=", "null", ")", "sbuff", ".", "format", "(", "\" deleted %s %s lastModified= %s%n\"", ",", "ok", ",", "dir", ".", "getPath", "(", ")", ",", "CalendarDate", ".", "of", "(", "dir", ".", "lastModified", "(", ")", ")", ")", ";", "}", "return", ";", "}", "// check for expired files", "for", "(", "File", "file", ":", "files", ")", "{", "if", "(", "file", ".", "isDirectory", "(", ")", ")", "{", "cleanCache", "(", "file", ",", "sbuff", ",", "false", ")", ";", "}", "else", "{", "long", "duration", "=", "now", "-", "file", ".", "lastModified", "(", ")", ";", "duration", "/=", "1000", "*", "60", ";", "// minutes", "if", "(", "duration", ">", "persistMinutes", ")", "{", "boolean", "ok", "=", "file", ".", "delete", "(", ")", ";", "if", "(", "!", "ok", ")", "cacheLog", ".", "error", "(", "\"Unable to delete file \"", "+", "file", ".", "getAbsolutePath", "(", ")", ")", ";", "if", "(", "sbuff", "!=", "null", ")", "sbuff", ".", "format", "(", "\" deleted %s %s lastModified= %s%n\"", ",", "ok", ",", "file", ".", "getPath", "(", ")", ",", "CalendarDate", ".", "of", "(", "file", ".", "lastModified", "(", ")", ")", ")", ";", "}", "}", "}", "}"], "docstring": "Remove any files or directories whose last modified time greater than persistMinutes\n@param dir clean starting here\n@param sbuff status messages here, may be null\n@param isRoot delete empty directories, bit not root directory", "docstring_tokens": ["Remove", "any", "files", "or", "directories", "whose", "last", "modified", "time", "greater", "than", "persistMinutes"]}
{"code": "reader = (ImageReader) i.next();", "comments": "grab the first one", "lines": 14, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/image/SourcePicture.java", "func_name": "SourcePicture.loadPicture", "original_string": "public void loadPicture() {\n\t\tTools.log(\"SourcePicture.loadPicture: \" + imageUrl.toString() + \" loaded into SourcePicture object: \" + Integer.toString(this.hashCode()) );\n\t\t//Tools.freeMem();\n\t\t\t\t\t\t\n\t\tsetStatus( LOADING, \"Loading: \" + imageUrl.toString() );\n\t\tabortFlag = false;\n\n\t\ttry {\n\t\t\t\n\t\t\t// Java 1.4 way with a Listener\n\t\t\tImageInputStream iis = ImageIO.createImageInputStream( imageUrl.openStream() );\n\t\t\tIterator i = ImageIO.getImageReaders( iis );\n\t\t\tif ( ! i.hasNext() ) { throw new IOException (\"No Readers Available!\"); }\n\t\t\treader = (ImageReader) i.next();  // grab the first one\n\t\t\t\n\t\t\treader.addIIOReadProgressListener( imageProgressListener );\n\t\t\treader.setInput( iis );\n\t\t\tsourcePictureBufferedImage = null;\n\t\t\t// try {\n\t\t\t\tsourcePictureBufferedImage = reader.read( 0 ); // just get the first image\n\t\t\t/* } catch ( OutOfMemoryError e ) {\n\t\t\t\tTools.log(\"SourcePicture caught an OutOfMemoryError while loading an image.\" );\n\n\t\t\t\tiis.close();\n\t\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t\treader.dispose();\n\n\t\t\t\tsetStatus(ERROR, \"Out of Memory Error while reading \" + imageUrl.toString());\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t\t// PictureCache.clear();\n\n\t\t\t\tJOptionPane.showMessageDialog( null,  //deliberately null or it swaps the window\n\t\t\t\t\t\"outOfMemoryError\",\n\t\t\t\t\t\"genericError\",\n\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\n\t\t\t\tSystem.gc();\n\t\t\t\tSystem.runFinalization();\n\n\t\t\t\tTools.log(\"JPO has now run a garbage collection and finalization.\");\n\t\t\t\treturn;\n\t\t\t} */\n\n\t\t\tiis.close();\n\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t//Tools.log(\"!!dispose being called!!\");\n\t\t\treader.dispose();\n\n\t\t\tif ( ! abortFlag ) {\n\t\t\t\n\t\t\t\tif ( rotation != 0 ) {\n\t\t\t\t\tsetStatus( ROTATING, \"Rotating: \" + imageUrl.toString() );\n\t\t\t\t\tint xRot = sourcePictureBufferedImage.getWidth() / 2;\n\t\t\t\t\tint yRot = sourcePictureBufferedImage.getHeight() / 2;\n\t\t\t\t\tAffineTransform rotateAf = AffineTransform.getRotateInstance( Math.toRadians( rotation ), xRot, yRot );\n\t\t\t\t\tAffineTransformOp op = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tRectangle2D newBounds = op.getBounds2D( sourcePictureBufferedImage );\n\t\t\t\t\t// a simple AffineTransform would give negative top left coordinates -->\n\t\t\t\t\t// do another transform to get 0,0 as top coordinates again.\n\t\t\t\t\tdouble minX = newBounds.getMinX();\n\t\t\t\t\tdouble minY = newBounds.getMinY();\n\t\t\t\t\t\n\t\t\t\t\tAffineTransform translateAf = AffineTransform.getTranslateInstance( minX * (-1), minY * (-1) );\n\t\t\t\t\trotateAf.preConcatenate( translateAf );\n\t\t\t\t\top = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tnewBounds = op.getBounds2D( sourcePictureBufferedImage );\n\n\t\t\t\t\t// this piece of code is so essential!!! Otherwise the internal image format\n\t\t\t\t\t// is totally altered and either the AffineTransformOp decides it doesn't\n\t\t\t\t\t// want to rotate the image or web browsers can't read the resulting image.\n\t\t\t\t\tBufferedImage targetImage = new BufferedImage(\n\t\t\t\t\t\t(int) newBounds.getWidth(),\n\t\t\t\t\t\t(int) newBounds.getHeight(),\n\t\t\t\t\t\tBufferedImage.TYPE_3BYTE_BGR );\n\t\t\t\t\t\n\t\t\t\t\tsourcePictureBufferedImage = op.filter( sourcePictureBufferedImage, targetImage );\n\t\t\t\t}\n\n\t\t\t\tsetStatus( READY, \"Loaded: \" + imageUrl.toString() );\n\t\t\t\tPictureCache.add( imageUrl, (SourcePicture) this.clone() );\n\t\t\t} else {\n\t\t\t\tsetStatus( ERROR, \"Aborted: \" + imageUrl.toString() );\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t}\n\t\t} catch ( IOException e ) {\n\t\t\tsetStatus(ERROR, \"Error while reading \" + imageUrl.toString());\n\t\t\tsourcePictureBufferedImage = null; \n\t\t}\n\n\t}", "language": "java", "Allcodes": "public void loadPicture() {\n\t\tTools.log(\"SourcePicture.loadPicture: \" + imageUrl.toString() + \" loaded into SourcePicture object: \" + Integer.toString(this.hashCode()) );\n\t\t//Tools.freeMem();\n\t\t\t\t\t\t\n\t\tsetStatus( LOADING, \"Loading: \" + imageUrl.toString() );\n\t\tabortFlag = false;\n\n\t\ttry {\n\t\t\t\n\t\t\t// Java 1.4 way with a Listener\n\t\t\tImageInputStream iis = ImageIO.createImageInputStream( imageUrl.openStream() );\n\t\t\tIterator i = ImageIO.getImageReaders( iis );\n\t\t\tif ( ! i.hasNext() ) { throw new IOException (\"No Readers Available!\"); }\n\t\t\treader = (ImageReader) i.next();  // grab the first one\n\t\t\t\n\t\t\treader.addIIOReadProgressListener( imageProgressListener );\n\t\t\treader.setInput( iis );\n\t\t\tsourcePictureBufferedImage = null;\n\t\t\t// try {\n\t\t\t\tsourcePictureBufferedImage = reader.read( 0 ); // just get the first image\n\t\t\t/* } catch ( OutOfMemoryError e ) {\n\t\t\t\tTools.log(\"SourcePicture caught an OutOfMemoryError while loading an image.\" );\n\n\t\t\t\tiis.close();\n\t\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t\treader.dispose();\n\n\t\t\t\tsetStatus(ERROR, \"Out of Memory Error while reading \" + imageUrl.toString());\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t\t// PictureCache.clear();\n\n\t\t\t\tJOptionPane.showMessageDialog( null,  //deliberately null or it swaps the window\n\t\t\t\t\t\"outOfMemoryError\",\n\t\t\t\t\t\"genericError\",\n\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\n\t\t\t\tSystem.gc();\n\t\t\t\tSystem.runFinalization();\n\n\t\t\t\tTools.log(\"JPO has now run a garbage collection and finalization.\");\n\t\t\t\treturn;\n\t\t\t} */\n\n\t\t\tiis.close();\n\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t//Tools.log(\"!!dispose being called!!\");\n\t\t\treader.dispose();\n\n\t\t\tif ( ! abortFlag ) {\n\t\t\t\n\t\t\t\tif ( rotation != 0 ) {\n\t\t\t\t\tsetStatus( ROTATING, \"Rotating: \" + imageUrl.toString() );\n\t\t\t\t\tint xRot = sourcePictureBufferedImage.getWidth() / 2;\n\t\t\t\t\tint yRot = sourcePictureBufferedImage.getHeight() / 2;\n\t\t\t\t\tAffineTransform rotateAf = AffineTransform.getRotateInstance( Math.toRadians( rotation ), xRot, yRot );\n\t\t\t\t\tAffineTransformOp op = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tRectangle2D newBounds = op.getBounds2D( sourcePictureBufferedImage );\n\t\t\t\t\t// a simple AffineTransform would give negative top left coordinates -->\n\t\t\t\t\t// do another transform to get 0,0 as top coordinates again.\n\t\t\t\t\tdouble minX = newBounds.getMinX();\n\t\t\t\t\tdouble minY = newBounds.getMinY();\n\t\t\t\t\t\n\t\t\t\t\tAffineTransform translateAf = AffineTransform.getTranslateInstance( minX * (-1), minY * (-1) );\n\t\t\t\t\trotateAf.preConcatenate( translateAf );\n\t\t\t\t\top = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tnewBounds = op.getBounds2D( sourcePictureBufferedImage );\n\n\t\t\t\t\t// this piece of code is so essential!!! Otherwise the internal image format\n\t\t\t\t\t// is totally altered and either the AffineTransformOp decides it doesn't\n\t\t\t\t\t// want to rotate the image or web browsers can't read the resulting image.\n\t\t\t\t\tBufferedImage targetImage = new BufferedImage(\n\t\t\t\t\t\t(int) newBounds.getWidth(),\n\t\t\t\t\t\t(int) newBounds.getHeight(),\n\t\t\t\t\t\tBufferedImage.TYPE_3BYTE_BGR );\n\t\t\t\t\t\n\t\t\t\t\tsourcePictureBufferedImage = op.filter( sourcePictureBufferedImage, targetImage );\n\t\t\t\t}\n\n\t\t\t\tsetStatus( READY, \"Loaded: \" + imageUrl.toString() );\n\t\t\t\tPictureCache.add( imageUrl, (SourcePicture) this.clone() );\n\t\t\t} else {\n\t\t\t\tsetStatus( ERROR, \"Aborted: \" + imageUrl.toString() );\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t}\n\t\t} catch ( IOException e ) {\n\t\t\tsetStatus(ERROR, \"Error while reading \" + imageUrl.toString());\n\t\t\tsourcePictureBufferedImage = null; \n\t\t}\n\n\t}", "code_tokens": ["public", "void", "loadPicture", "(", ")", "{", "Tools", ".", "log", "(", "\"SourcePicture.loadPicture: \"", "+", "imageUrl", ".", "toString", "(", ")", "+", "\" loaded into SourcePicture object: \"", "+", "Integer", ".", "toString", "(", "this", ".", "hashCode", "(", ")", ")", ")", ";", "//Tools.freeMem();", "setStatus", "(", "LOADING", ",", "\"Loading: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "abortFlag", "=", "false", ";", "try", "{", "// Java 1.4 way with a Listener", "ImageInputStream", "iis", "=", "ImageIO", ".", "createImageInputStream", "(", "imageUrl", ".", "openStream", "(", ")", ")", ";", "Iterator", "i", "=", "ImageIO", ".", "getImageReaders", "(", "iis", ")", ";", "if", "(", "!", "i", ".", "hasNext", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"No Readers Available!\"", ")", ";", "}", "reader", "=", "(", "ImageReader", ")", "i", ".", "next", "(", ")", ";", "// grab the first one", "reader", ".", "addIIOReadProgressListener", "(", "imageProgressListener", ")", ";", "reader", ".", "setInput", "(", "iis", ")", ";", "sourcePictureBufferedImage", "=", "null", ";", "// try {", "sourcePictureBufferedImage", "=", "reader", ".", "read", "(", "0", ")", ";", "// just get the first image", "/* } catch ( OutOfMemoryError e ) {\n\t\t\t\tTools.log(\"SourcePicture caught an OutOfMemoryError while loading an image.\" );\n\n\t\t\t\tiis.close();\n\t\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t\treader.dispose();\n\n\t\t\t\tsetStatus(ERROR, \"Out of Memory Error while reading \" + imageUrl.toString());\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t\t// PictureCache.clear();\n\n\t\t\t\tJOptionPane.showMessageDialog( null,  //deliberately null or it swaps the window\n\t\t\t\t\t\"outOfMemoryError\",\n\t\t\t\t\t\"genericError\",\n\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\n\t\t\t\tSystem.gc();\n\t\t\t\tSystem.runFinalization();\n\n\t\t\t\tTools.log(\"JPO has now run a garbage collection and finalization.\");\n\t\t\t\treturn;\n\t\t\t} */", "iis", ".", "close", "(", ")", ";", "reader", ".", "removeIIOReadProgressListener", "(", "imageProgressListener", ")", ";", "//Tools.log(\"!!dispose being called!!\");", "reader", ".", "dispose", "(", ")", ";", "if", "(", "!", "abortFlag", ")", "{", "if", "(", "rotation", "!=", "0", ")", "{", "setStatus", "(", "ROTATING", ",", "\"Rotating: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "int", "xRot", "=", "sourcePictureBufferedImage", ".", "getWidth", "(", ")", "/", "2", ";", "int", "yRot", "=", "sourcePictureBufferedImage", ".", "getHeight", "(", ")", "/", "2", ";", "AffineTransform", "rotateAf", "=", "AffineTransform", ".", "getRotateInstance", "(", "Math", ".", "toRadians", "(", "rotation", ")", ",", "xRot", ",", "yRot", ")", ";", "AffineTransformOp", "op", "=", "new", "AffineTransformOp", "(", "rotateAf", ",", "AffineTransformOp", ".", "TYPE_BILINEAR", ")", ";", "Rectangle2D", "newBounds", "=", "op", ".", "getBounds2D", "(", "sourcePictureBufferedImage", ")", ";", "// a simple AffineTransform would give negative top left coordinates -->", "// do another transform to get 0,0 as top coordinates again.", "double", "minX", "=", "newBounds", ".", "getMinX", "(", ")", ";", "double", "minY", "=", "newBounds", ".", "getMinY", "(", ")", ";", "AffineTransform", "translateAf", "=", "AffineTransform", ".", "getTranslateInstance", "(", "minX", "*", "(", "-", "1", ")", ",", "minY", "*", "(", "-", "1", ")", ")", ";", "rotateAf", ".", "preConcatenate", "(", "translateAf", ")", ";", "op", "=", "new", "AffineTransformOp", "(", "rotateAf", ",", "AffineTransformOp", ".", "TYPE_BILINEAR", ")", ";", "newBounds", "=", "op", ".", "getBounds2D", "(", "sourcePictureBufferedImage", ")", ";", "// this piece of code is so essential!!! Otherwise the internal image format", "// is totally altered and either the AffineTransformOp decides it doesn't", "// want to rotate the image or web browsers can't read the resulting image.", "BufferedImage", "targetImage", "=", "new", "BufferedImage", "(", "(", "int", ")", "newBounds", ".", "getWidth", "(", ")", ",", "(", "int", ")", "newBounds", ".", "getHeight", "(", ")", ",", "BufferedImage", ".", "TYPE_3BYTE_BGR", ")", ";", "sourcePictureBufferedImage", "=", "op", ".", "filter", "(", "sourcePictureBufferedImage", ",", "targetImage", ")", ";", "}", "setStatus", "(", "READY", ",", "\"Loaded: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "PictureCache", ".", "add", "(", "imageUrl", ",", "(", "SourcePicture", ")", "this", ".", "clone", "(", ")", ")", ";", "}", "else", "{", "setStatus", "(", "ERROR", ",", "\"Aborted: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "sourcePictureBufferedImage", "=", "null", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "setStatus", "(", "ERROR", ",", "\"Error while reading \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "sourcePictureBufferedImage", "=", "null", ";", "}", "}"], "docstring": "loads a picture from the URL in the imageUrl object into the sourcePictureBufferedImage\nobject and updates the status when done or failed.", "docstring_tokens": ["loads", "a", "picture", "from", "the", "URL", "in", "the", "imageUrl", "object", "into", "the", "sourcePictureBufferedImage", "object", "and", "updates", "the", "status", "when", "done", "or", "failed", "."]}
{"code": "sourcePictureBufferedImage = reader.read( 0 );", "comments": "just get the first image", "lines": 20, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/image/SourcePicture.java", "func_name": "SourcePicture.loadPicture", "original_string": "public void loadPicture() {\n\t\tTools.log(\"SourcePicture.loadPicture: \" + imageUrl.toString() + \" loaded into SourcePicture object: \" + Integer.toString(this.hashCode()) );\n\t\t//Tools.freeMem();\n\t\t\t\t\t\t\n\t\tsetStatus( LOADING, \"Loading: \" + imageUrl.toString() );\n\t\tabortFlag = false;\n\n\t\ttry {\n\t\t\t\n\t\t\t// Java 1.4 way with a Listener\n\t\t\tImageInputStream iis = ImageIO.createImageInputStream( imageUrl.openStream() );\n\t\t\tIterator i = ImageIO.getImageReaders( iis );\n\t\t\tif ( ! i.hasNext() ) { throw new IOException (\"No Readers Available!\"); }\n\t\t\treader = (ImageReader) i.next();  // grab the first one\n\t\t\t\n\t\t\treader.addIIOReadProgressListener( imageProgressListener );\n\t\t\treader.setInput( iis );\n\t\t\tsourcePictureBufferedImage = null;\n\t\t\t// try {\n\t\t\t\tsourcePictureBufferedImage = reader.read( 0 ); // just get the first image\n\t\t\t/* } catch ( OutOfMemoryError e ) {\n\t\t\t\tTools.log(\"SourcePicture caught an OutOfMemoryError while loading an image.\" );\n\n\t\t\t\tiis.close();\n\t\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t\treader.dispose();\n\n\t\t\t\tsetStatus(ERROR, \"Out of Memory Error while reading \" + imageUrl.toString());\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t\t// PictureCache.clear();\n\n\t\t\t\tJOptionPane.showMessageDialog( null,  //deliberately null or it swaps the window\n\t\t\t\t\t\"outOfMemoryError\",\n\t\t\t\t\t\"genericError\",\n\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\n\t\t\t\tSystem.gc();\n\t\t\t\tSystem.runFinalization();\n\n\t\t\t\tTools.log(\"JPO has now run a garbage collection and finalization.\");\n\t\t\t\treturn;\n\t\t\t} */\n\n\t\t\tiis.close();\n\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t//Tools.log(\"!!dispose being called!!\");\n\t\t\treader.dispose();\n\n\t\t\tif ( ! abortFlag ) {\n\t\t\t\n\t\t\t\tif ( rotation != 0 ) {\n\t\t\t\t\tsetStatus( ROTATING, \"Rotating: \" + imageUrl.toString() );\n\t\t\t\t\tint xRot = sourcePictureBufferedImage.getWidth() / 2;\n\t\t\t\t\tint yRot = sourcePictureBufferedImage.getHeight() / 2;\n\t\t\t\t\tAffineTransform rotateAf = AffineTransform.getRotateInstance( Math.toRadians( rotation ), xRot, yRot );\n\t\t\t\t\tAffineTransformOp op = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tRectangle2D newBounds = op.getBounds2D( sourcePictureBufferedImage );\n\t\t\t\t\t// a simple AffineTransform would give negative top left coordinates -->\n\t\t\t\t\t// do another transform to get 0,0 as top coordinates again.\n\t\t\t\t\tdouble minX = newBounds.getMinX();\n\t\t\t\t\tdouble minY = newBounds.getMinY();\n\t\t\t\t\t\n\t\t\t\t\tAffineTransform translateAf = AffineTransform.getTranslateInstance( minX * (-1), minY * (-1) );\n\t\t\t\t\trotateAf.preConcatenate( translateAf );\n\t\t\t\t\top = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tnewBounds = op.getBounds2D( sourcePictureBufferedImage );\n\n\t\t\t\t\t// this piece of code is so essential!!! Otherwise the internal image format\n\t\t\t\t\t// is totally altered and either the AffineTransformOp decides it doesn't\n\t\t\t\t\t// want to rotate the image or web browsers can't read the resulting image.\n\t\t\t\t\tBufferedImage targetImage = new BufferedImage(\n\t\t\t\t\t\t(int) newBounds.getWidth(),\n\t\t\t\t\t\t(int) newBounds.getHeight(),\n\t\t\t\t\t\tBufferedImage.TYPE_3BYTE_BGR );\n\t\t\t\t\t\n\t\t\t\t\tsourcePictureBufferedImage = op.filter( sourcePictureBufferedImage, targetImage );\n\t\t\t\t}\n\n\t\t\t\tsetStatus( READY, \"Loaded: \" + imageUrl.toString() );\n\t\t\t\tPictureCache.add( imageUrl, (SourcePicture) this.clone() );\n\t\t\t} else {\n\t\t\t\tsetStatus( ERROR, \"Aborted: \" + imageUrl.toString() );\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t}\n\t\t} catch ( IOException e ) {\n\t\t\tsetStatus(ERROR, \"Error while reading \" + imageUrl.toString());\n\t\t\tsourcePictureBufferedImage = null; \n\t\t}\n\n\t}", "language": "java", "Allcodes": "public void loadPicture() {\n\t\tTools.log(\"SourcePicture.loadPicture: \" + imageUrl.toString() + \" loaded into SourcePicture object: \" + Integer.toString(this.hashCode()) );\n\t\t//Tools.freeMem();\n\t\t\t\t\t\t\n\t\tsetStatus( LOADING, \"Loading: \" + imageUrl.toString() );\n\t\tabortFlag = false;\n\n\t\ttry {\n\t\t\t\n\t\t\t// Java 1.4 way with a Listener\n\t\t\tImageInputStream iis = ImageIO.createImageInputStream( imageUrl.openStream() );\n\t\t\tIterator i = ImageIO.getImageReaders( iis );\n\t\t\tif ( ! i.hasNext() ) { throw new IOException (\"No Readers Available!\"); }\n\t\t\treader = (ImageReader) i.next();  // grab the first one\n\t\t\t\n\t\t\treader.addIIOReadProgressListener( imageProgressListener );\n\t\t\treader.setInput( iis );\n\t\t\tsourcePictureBufferedImage = null;\n\t\t\t// try {\n\t\t\t\tsourcePictureBufferedImage = reader.read( 0 ); // just get the first image\n\t\t\t/* } catch ( OutOfMemoryError e ) {\n\t\t\t\tTools.log(\"SourcePicture caught an OutOfMemoryError while loading an image.\" );\n\n\t\t\t\tiis.close();\n\t\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t\treader.dispose();\n\n\t\t\t\tsetStatus(ERROR, \"Out of Memory Error while reading \" + imageUrl.toString());\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t\t// PictureCache.clear();\n\n\t\t\t\tJOptionPane.showMessageDialog( null,  //deliberately null or it swaps the window\n\t\t\t\t\t\"outOfMemoryError\",\n\t\t\t\t\t\"genericError\",\n\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\n\t\t\t\tSystem.gc();\n\t\t\t\tSystem.runFinalization();\n\n\t\t\t\tTools.log(\"JPO has now run a garbage collection and finalization.\");\n\t\t\t\treturn;\n\t\t\t} */\n\n\t\t\tiis.close();\n\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t//Tools.log(\"!!dispose being called!!\");\n\t\t\treader.dispose();\n\n\t\t\tif ( ! abortFlag ) {\n\t\t\t\n\t\t\t\tif ( rotation != 0 ) {\n\t\t\t\t\tsetStatus( ROTATING, \"Rotating: \" + imageUrl.toString() );\n\t\t\t\t\tint xRot = sourcePictureBufferedImage.getWidth() / 2;\n\t\t\t\t\tint yRot = sourcePictureBufferedImage.getHeight() / 2;\n\t\t\t\t\tAffineTransform rotateAf = AffineTransform.getRotateInstance( Math.toRadians( rotation ), xRot, yRot );\n\t\t\t\t\tAffineTransformOp op = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tRectangle2D newBounds = op.getBounds2D( sourcePictureBufferedImage );\n\t\t\t\t\t// a simple AffineTransform would give negative top left coordinates -->\n\t\t\t\t\t// do another transform to get 0,0 as top coordinates again.\n\t\t\t\t\tdouble minX = newBounds.getMinX();\n\t\t\t\t\tdouble minY = newBounds.getMinY();\n\t\t\t\t\t\n\t\t\t\t\tAffineTransform translateAf = AffineTransform.getTranslateInstance( minX * (-1), minY * (-1) );\n\t\t\t\t\trotateAf.preConcatenate( translateAf );\n\t\t\t\t\top = new AffineTransformOp( rotateAf, AffineTransformOp.TYPE_BILINEAR );\n\t\t\t\t\tnewBounds = op.getBounds2D( sourcePictureBufferedImage );\n\n\t\t\t\t\t// this piece of code is so essential!!! Otherwise the internal image format\n\t\t\t\t\t// is totally altered and either the AffineTransformOp decides it doesn't\n\t\t\t\t\t// want to rotate the image or web browsers can't read the resulting image.\n\t\t\t\t\tBufferedImage targetImage = new BufferedImage(\n\t\t\t\t\t\t(int) newBounds.getWidth(),\n\t\t\t\t\t\t(int) newBounds.getHeight(),\n\t\t\t\t\t\tBufferedImage.TYPE_3BYTE_BGR );\n\t\t\t\t\t\n\t\t\t\t\tsourcePictureBufferedImage = op.filter( sourcePictureBufferedImage, targetImage );\n\t\t\t\t}\n\n\t\t\t\tsetStatus( READY, \"Loaded: \" + imageUrl.toString() );\n\t\t\t\tPictureCache.add( imageUrl, (SourcePicture) this.clone() );\n\t\t\t} else {\n\t\t\t\tsetStatus( ERROR, \"Aborted: \" + imageUrl.toString() );\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t}\n\t\t} catch ( IOException e ) {\n\t\t\tsetStatus(ERROR, \"Error while reading \" + imageUrl.toString());\n\t\t\tsourcePictureBufferedImage = null; \n\t\t}\n\n\t}", "code_tokens": ["public", "void", "loadPicture", "(", ")", "{", "Tools", ".", "log", "(", "\"SourcePicture.loadPicture: \"", "+", "imageUrl", ".", "toString", "(", ")", "+", "\" loaded into SourcePicture object: \"", "+", "Integer", ".", "toString", "(", "this", ".", "hashCode", "(", ")", ")", ")", ";", "//Tools.freeMem();", "setStatus", "(", "LOADING", ",", "\"Loading: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "abortFlag", "=", "false", ";", "try", "{", "// Java 1.4 way with a Listener", "ImageInputStream", "iis", "=", "ImageIO", ".", "createImageInputStream", "(", "imageUrl", ".", "openStream", "(", ")", ")", ";", "Iterator", "i", "=", "ImageIO", ".", "getImageReaders", "(", "iis", ")", ";", "if", "(", "!", "i", ".", "hasNext", "(", ")", ")", "{", "throw", "new", "IOException", "(", "\"No Readers Available!\"", ")", ";", "}", "reader", "=", "(", "ImageReader", ")", "i", ".", "next", "(", ")", ";", "// grab the first one", "reader", ".", "addIIOReadProgressListener", "(", "imageProgressListener", ")", ";", "reader", ".", "setInput", "(", "iis", ")", ";", "sourcePictureBufferedImage", "=", "null", ";", "// try {", "sourcePictureBufferedImage", "=", "reader", ".", "read", "(", "0", ")", ";", "// just get the first image", "/* } catch ( OutOfMemoryError e ) {\n\t\t\t\tTools.log(\"SourcePicture caught an OutOfMemoryError while loading an image.\" );\n\n\t\t\t\tiis.close();\n\t\t\t\treader.removeIIOReadProgressListener( imageProgressListener );\n\t\t\t\treader.dispose();\n\n\t\t\t\tsetStatus(ERROR, \"Out of Memory Error while reading \" + imageUrl.toString());\n\t\t\t\tsourcePictureBufferedImage = null; \n\t\t\t\t// PictureCache.clear();\n\n\t\t\t\tJOptionPane.showMessageDialog( null,  //deliberately null or it swaps the window\n\t\t\t\t\t\"outOfMemoryError\",\n\t\t\t\t\t\"genericError\",\n\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\n\t\t\t\tSystem.gc();\n\t\t\t\tSystem.runFinalization();\n\n\t\t\t\tTools.log(\"JPO has now run a garbage collection and finalization.\");\n\t\t\t\treturn;\n\t\t\t} */", "iis", ".", "close", "(", ")", ";", "reader", ".", "removeIIOReadProgressListener", "(", "imageProgressListener", ")", ";", "//Tools.log(\"!!dispose being called!!\");", "reader", ".", "dispose", "(", ")", ";", "if", "(", "!", "abortFlag", ")", "{", "if", "(", "rotation", "!=", "0", ")", "{", "setStatus", "(", "ROTATING", ",", "\"Rotating: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "int", "xRot", "=", "sourcePictureBufferedImage", ".", "getWidth", "(", ")", "/", "2", ";", "int", "yRot", "=", "sourcePictureBufferedImage", ".", "getHeight", "(", ")", "/", "2", ";", "AffineTransform", "rotateAf", "=", "AffineTransform", ".", "getRotateInstance", "(", "Math", ".", "toRadians", "(", "rotation", ")", ",", "xRot", ",", "yRot", ")", ";", "AffineTransformOp", "op", "=", "new", "AffineTransformOp", "(", "rotateAf", ",", "AffineTransformOp", ".", "TYPE_BILINEAR", ")", ";", "Rectangle2D", "newBounds", "=", "op", ".", "getBounds2D", "(", "sourcePictureBufferedImage", ")", ";", "// a simple AffineTransform would give negative top left coordinates -->", "// do another transform to get 0,0 as top coordinates again.", "double", "minX", "=", "newBounds", ".", "getMinX", "(", ")", ";", "double", "minY", "=", "newBounds", ".", "getMinY", "(", ")", ";", "AffineTransform", "translateAf", "=", "AffineTransform", ".", "getTranslateInstance", "(", "minX", "*", "(", "-", "1", ")", ",", "minY", "*", "(", "-", "1", ")", ")", ";", "rotateAf", ".", "preConcatenate", "(", "translateAf", ")", ";", "op", "=", "new", "AffineTransformOp", "(", "rotateAf", ",", "AffineTransformOp", ".", "TYPE_BILINEAR", ")", ";", "newBounds", "=", "op", ".", "getBounds2D", "(", "sourcePictureBufferedImage", ")", ";", "// this piece of code is so essential!!! Otherwise the internal image format", "// is totally altered and either the AffineTransformOp decides it doesn't", "// want to rotate the image or web browsers can't read the resulting image.", "BufferedImage", "targetImage", "=", "new", "BufferedImage", "(", "(", "int", ")", "newBounds", ".", "getWidth", "(", ")", ",", "(", "int", ")", "newBounds", ".", "getHeight", "(", ")", ",", "BufferedImage", ".", "TYPE_3BYTE_BGR", ")", ";", "sourcePictureBufferedImage", "=", "op", ".", "filter", "(", "sourcePictureBufferedImage", ",", "targetImage", ")", ";", "}", "setStatus", "(", "READY", ",", "\"Loaded: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "PictureCache", ".", "add", "(", "imageUrl", ",", "(", "SourcePicture", ")", "this", ".", "clone", "(", ")", ")", ";", "}", "else", "{", "setStatus", "(", "ERROR", ",", "\"Aborted: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "sourcePictureBufferedImage", "=", "null", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "setStatus", "(", "ERROR", ",", "\"Error while reading \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "sourcePictureBufferedImage", "=", "null", ";", "}", "}"], "docstring": "loads a picture from the URL in the imageUrl object into the sourcePictureBufferedImage\nobject and updates the status when done or failed.", "docstring_tokens": ["loads", "a", "picture", "from", "the", "URL", "in", "the", "imageUrl", "object", "into", "the", "sourcePictureBufferedImage", "object", "and", "updates", "the", "status", "when", "done", "or", "failed", "."]}
{"code": "return;", "comments": "SourcePicture has never been used yet", "lines": 3, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/image/SourcePicture.java", "func_name": "SourcePicture.stopLoading", "original_string": "public void stopLoading() {\n\t\tif ( imageUrl == null ) \n\t\t\treturn; // SourcePicture has never been used yet\n\t\n\t\tTools.log(\"SourcePicture.stopLoading: called on \" + imageUrl );\n\t\tif ( pictureStatusCode == LOADING ) {\n\t\t\treader.abort();\n\t\t\tabortFlag = true;\n\t\t\t//reader.dispose();\n\t\t\t//setStatus( ERROR, \"Cache Loading was stopped \" + imageUrl.toString() );\n\t\t\t//sourcePictureBufferedImage = null; \n\t\t\t// actually the thread reading the image continues\n\t\t}\n\t}", "language": "java", "Allcodes": "public void stopLoading() {\n\t\tif ( imageUrl == null ) \n\t\t\treturn; // SourcePicture has never been used yet\n\t\n\t\tTools.log(\"SourcePicture.stopLoading: called on \" + imageUrl );\n\t\tif ( pictureStatusCode == LOADING ) {\n\t\t\treader.abort();\n\t\t\tabortFlag = true;\n\t\t\t//reader.dispose();\n\t\t\t//setStatus( ERROR, \"Cache Loading was stopped \" + imageUrl.toString() );\n\t\t\t//sourcePictureBufferedImage = null; \n\t\t\t// actually the thread reading the image continues\n\t\t}\n\t}", "code_tokens": ["public", "void", "stopLoading", "(", ")", "{", "if", "(", "imageUrl", "==", "null", ")", "return", ";", "// SourcePicture has never been used yet", "Tools", ".", "log", "(", "\"SourcePicture.stopLoading: called on \"", "+", "imageUrl", ")", ";", "if", "(", "pictureStatusCode", "==", "LOADING", ")", "{", "reader", ".", "abort", "(", ")", ";", "abortFlag", "=", "true", ";", "//reader.dispose();", "//setStatus( ERROR, \"Cache Loading was stopped \" + imageUrl.toString() );", "//sourcePictureBufferedImage = null; ", "// actually the thread reading the image continues", "}", "}"], "docstring": "this method can be invoked to stop the current reader", "docstring_tokens": ["this", "method", "can", "be", "invoked", "to", "stop", "the", "current", "reader"]}
{"code": "return false;", "comments": "has never been used yet", "lines": 3, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/image/SourcePicture.java", "func_name": "SourcePicture.stopLoadingExcept", "original_string": "public boolean stopLoadingExcept( URL exemptionURL ) {\n\t\tif ( imageUrl == null ) \n\t\t\treturn false; // has never been used yet\n\n\t\tif ( pictureStatusCode != LOADING ) {\n\t\t\tTools.log( \"SourcePicture.stopLoadingExcept: called but pointless since image is not LOADING: \" + imageUrl.toString());\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\tif ( ! exemptionURL.toString().equals( imageUrl.toString() ) ) {\n\t\t\tTools.log (\"SourcePicture.stopLoadingExcept: called with Url \" + exemptionURL.toString() + \" --> stopping loading of \" + imageUrl.toString() );\n\t\t\tstopLoading();\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}", "language": "java", "Allcodes": "public boolean stopLoadingExcept( URL exemptionURL ) {\n\t\tif ( imageUrl == null ) \n\t\t\treturn false; // has never been used yet\n\n\t\tif ( pictureStatusCode != LOADING ) {\n\t\t\tTools.log( \"SourcePicture.stopLoadingExcept: called but pointless since image is not LOADING: \" + imageUrl.toString());\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\tif ( ! exemptionURL.toString().equals( imageUrl.toString() ) ) {\n\t\t\tTools.log (\"SourcePicture.stopLoadingExcept: called with Url \" + exemptionURL.toString() + \" --> stopping loading of \" + imageUrl.toString() );\n\t\t\tstopLoading();\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}", "code_tokens": ["public", "boolean", "stopLoadingExcept", "(", "URL", "exemptionURL", ")", "{", "if", "(", "imageUrl", "==", "null", ")", "return", "false", ";", "// has never been used yet", "if", "(", "pictureStatusCode", "!=", "LOADING", ")", "{", "Tools", ".", "log", "(", "\"SourcePicture.stopLoadingExcept: called but pointless since image is not LOADING: \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "return", "false", ";", "}", "if", "(", "!", "exemptionURL", ".", "toString", "(", ")", ".", "equals", "(", "imageUrl", ".", "toString", "(", ")", ")", ")", "{", "Tools", ".", "log", "(", "\"SourcePicture.stopLoadingExcept: called with Url \"", "+", "exemptionURL", ".", "toString", "(", ")", "+", "\" --> stopping loading of \"", "+", "imageUrl", ".", "toString", "(", ")", ")", ";", "stopLoading", "(", ")", ";", "return", "true", ";", "}", "else", "return", "false", ";", "}"], "docstring": "this method can be invoked to stop the current reader except if it\nis reading the desired file. It returns true is the desired file\nis being loaded. Otherwise it returns false.", "docstring_tokens": ["this", "method", "can", "be", "invoked", "to", "stop", "the", "current", "reader", "except", "if", "it", "is", "reading", "the", "desired", "file", ".", "It", "returns", "true", "is", "the", "desired", "file", "is", "being", "loaded", ".", "Otherwise", "it", "returns", "false", "."]}
{"code": "List<DapNode> path = getPath();", "comments": "excludes root/wrt", "lines": 4, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/dmr/DapNode.java", "func_name": "DapNode.computefqn", "original_string": "public String\n    computefqn()\n    {\n        List<DapNode> path = getPath(); // excludes root/wrt\n        StringBuilder fqn = new StringBuilder();\n        DapNode parent = path.get(0);\n        for(int i = 1; i < path.size(); i++) {   // start at 1 to skip root\n            DapNode current = path.get(i);\n            // Depending on what parent is, use different delimiters\n            switch (parent.getSort()) {\n            case DATASET:\n            case GROUP:\n            case ENUMERATION:\n                fqn.append('/');\n                fqn.append(Escape.backslashEscape(current.getShortName(),\"/.\"));\n                break;\n            // These use '.'\n            case STRUCTURE:\n            case SEQUENCE:\n            case ENUMCONST:\n            case VARIABLE:\n                fqn.append('.');\n                fqn.append(current.getEscapedShortName());\n                break;\n            default: // Others should never happen\n                throw new IllegalArgumentException(\"Illegal FQN parent\");\n            }\n            parent = current;\n        }\n        return fqn.toString();\n    }", "language": "java", "Allcodes": "public String\n    computefqn()\n    {\n        List<DapNode> path = getPath(); // excludes root/wrt\n        StringBuilder fqn = new StringBuilder();\n        DapNode parent = path.get(0);\n        for(int i = 1; i < path.size(); i++) {   // start at 1 to skip root\n            DapNode current = path.get(i);\n            // Depending on what parent is, use different delimiters\n            switch (parent.getSort()) {\n            case DATASET:\n            case GROUP:\n            case ENUMERATION:\n                fqn.append('/');\n                fqn.append(Escape.backslashEscape(current.getShortName(),\"/.\"));\n                break;\n            // These use '.'\n            case STRUCTURE:\n            case SEQUENCE:\n            case ENUMCONST:\n            case VARIABLE:\n                fqn.append('.');\n                fqn.append(current.getEscapedShortName());\n                break;\n            default: // Others should never happen\n                throw new IllegalArgumentException(\"Illegal FQN parent\");\n            }\n            parent = current;\n        }\n        return fqn.toString();\n    }", "code_tokens": ["public", "String", "computefqn", "(", ")", "{", "List", "<", "DapNode", ">", "path", "=", "getPath", "(", ")", ";", "// excludes root/wrt", "StringBuilder", "fqn", "=", "new", "StringBuilder", "(", ")", ";", "DapNode", "parent", "=", "path", ".", "get", "(", "0", ")", ";", "for", "(", "int", "i", "=", "1", ";", "i", "<", "path", ".", "size", "(", ")", ";", "i", "++", ")", "{", "// start at 1 to skip root", "DapNode", "current", "=", "path", ".", "get", "(", "i", ")", ";", "// Depending on what parent is, use different delimiters", "switch", "(", "parent", ".", "getSort", "(", ")", ")", "{", "case", "DATASET", ":", "case", "GROUP", ":", "case", "ENUMERATION", ":", "fqn", ".", "append", "(", "'", "'", ")", ";", "fqn", ".", "append", "(", "Escape", ".", "backslashEscape", "(", "current", ".", "getShortName", "(", ")", ",", "\"/.\"", ")", ")", ";", "break", ";", "// These use '.'", "case", "STRUCTURE", ":", "case", "SEQUENCE", ":", "case", "ENUMCONST", ":", "case", "VARIABLE", ":", "fqn", ".", "append", "(", "'", "'", ")", ";", "fqn", ".", "append", "(", "current", ".", "getEscapedShortName", "(", ")", ")", ";", "break", ";", "default", ":", "// Others should never happen", "throw", "new", "IllegalArgumentException", "(", "\"Illegal FQN parent\"", ")", ";", "}", "parent", "=", "current", ";", "}", "return", "fqn", ".", "toString", "(", ")", ";", "}"], "docstring": "Compute the FQN of this node", "docstring_tokens": ["Compute", "the", "FQN", "of", "this", "node"]}
{"code": "elem.detach();", "comments": "In case this element had previously been added to a Document.", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ncml/NcMLWriter.java", "func_name": "NcMLWriter.writeToWriter", "original_string": "public void writeToWriter(Element elem, Writer writer) throws IOException {\r\n    xmlOutputter.setFormat(xmlFormat);\r\n    elem.detach();  // In case this element had previously been added to a Document.\r\n    xmlOutputter.output(new Document(elem), writer);\r\n  }", "language": "java", "Allcodes": "public void writeToWriter(Element elem, Writer writer) throws IOException {\r\n    xmlOutputter.setFormat(xmlFormat);\r\n    elem.detach();  // In case this element had previously been added to a Document.\r\n    xmlOutputter.output(new Document(elem), writer);\r\n  }", "code_tokens": ["public", "void", "writeToWriter", "(", "Element", "elem", ",", "Writer", "writer", ")", "throws", "IOException", "{", "xmlOutputter", ".", "setFormat", "(", "xmlFormat", ")", ";", "elem", ".", "detach", "(", ")", ";", "// In case this element had previously been added to a Document.\r", "xmlOutputter", ".", "output", "(", "new", "Document", "(", "elem", ")", ",", "writer", ")", ";", "}"], "docstring": "Writes an NcML element to a Writer.\n\n@param elem  an NcML element.\n@param writer  the Writer to write the NcML document to. Will be closed at end of the method.\n@throws IOException  if there's any problem writing.", "docstring_tokens": ["Writes", "an", "NcML", "element", "to", "a", "Writer", "."]}
{"code": "break;", "comments": "node either has no attributes or name only", "lines": 63, "repo": "Unidata/thredds", "path": "dap4/d4lib/src/main/java/dap4/dap4lib/DMRPrinter.java", "func_name": "DMRPrinter.printXMLAttributes", "original_string": "void\n    printXMLAttributes(DapNode node, CEConstraint ce, int flags)\n            throws IOException\n    {\n        if((flags & PERLINE) != 0)\n            printer.indent(2);\n\n        // Print name first, if non-null and !NONAME\n        // Note that the short name needs to use\n        // entity escaping (which is done by printXMLattribute),\n        // but backslash escaping is not required.\n        String name = node.getShortName();\n        if(name != null && (flags & NONAME) == 0) {\n            name = node.getShortName();\n            printXMLAttribute(\"name\", name, flags);\n        }\n\n        switch (node.getSort()) {\n        case DATASET:\n            DapDataset dataset = (DapDataset) node;\n            printXMLAttribute(\"dapVersion\", dataset.getDapVersion(), flags);\n            printXMLAttribute(\"dmrVersion\", dataset.getDMRVersion(), flags);\n            // boilerplate\n            printXMLAttribute(\"xmlns\", \"http://xml.opendap.org/ns/DAP/4.0#\", flags);\n            printXMLAttribute(\"xmlns:dap\", \"http://xml.opendap.org/ns/DAP/4.0#\", flags);\n            break;\n\n        case DIMENSION:\n            DapDimension orig = (DapDimension) node;\n            if(orig.isShared()) {//not Anonymous\n                // name will have already been printed\n                // Now, we need to get the size as defined by the constraint\n                DapDimension actual = this.ce.getRedefDim(orig);\n                if(actual == null)\n                    actual = orig;\n                long size = actual.getSize();\n                printXMLAttribute(\"size\", Long.toString(size), flags);\n            }\n            break;\n\n        case ENUMERATION:\n            printXMLAttribute(\"basetype\", ((DapEnumeration) node).getBaseType().getTypeName(), flags);\n            break;\n\n        case VARIABLE:\n            DapVariable var = (DapVariable) node;\n            DapType basetype = var.getBaseType();\n            if(basetype.isEnumType()) {\n                printXMLAttribute(\"enum\", basetype.getTypeName(), flags);\n            }\n            break;\n\n        case ATTRIBUTE:\n            DapAttribute attr = (DapAttribute) node;\n            basetype = attr.getBaseType();\n            printXMLAttribute(\"type\", basetype.getTypeName(), flags);\n            if(attr.getBaseType().isEnumType()) {\n                printXMLAttribute(\"enum\", basetype.getTypeName(), flags);\n            }\n            break;\n\n        default:\n            break; // node either has no attributes or name only\n        } //switch\n        if(!this.testing)\n            printReserved(node);\n        if((flags & PERLINE) != 0) {\n            printer.outdent(2);\n        }\n    }", "language": "java", "Allcodes": "void\n    printXMLAttributes(DapNode node, CEConstraint ce, int flags)\n            throws IOException\n    {\n        if((flags & PERLINE) != 0)\n            printer.indent(2);\n\n        // Print name first, if non-null and !NONAME\n        // Note that the short name needs to use\n        // entity escaping (which is done by printXMLattribute),\n        // but backslash escaping is not required.\n        String name = node.getShortName();\n        if(name != null && (flags & NONAME) == 0) {\n            name = node.getShortName();\n            printXMLAttribute(\"name\", name, flags);\n        }\n\n        switch (node.getSort()) {\n        case DATASET:\n            DapDataset dataset = (DapDataset) node;\n            printXMLAttribute(\"dapVersion\", dataset.getDapVersion(), flags);\n            printXMLAttribute(\"dmrVersion\", dataset.getDMRVersion(), flags);\n            // boilerplate\n            printXMLAttribute(\"xmlns\", \"http://xml.opendap.org/ns/DAP/4.0#\", flags);\n            printXMLAttribute(\"xmlns:dap\", \"http://xml.opendap.org/ns/DAP/4.0#\", flags);\n            break;\n\n        case DIMENSION:\n            DapDimension orig = (DapDimension) node;\n            if(orig.isShared()) {//not Anonymous\n                // name will have already been printed\n                // Now, we need to get the size as defined by the constraint\n                DapDimension actual = this.ce.getRedefDim(orig);\n                if(actual == null)\n                    actual = orig;\n                long size = actual.getSize();\n                printXMLAttribute(\"size\", Long.toString(size), flags);\n            }\n            break;\n\n        case ENUMERATION:\n            printXMLAttribute(\"basetype\", ((DapEnumeration) node).getBaseType().getTypeName(), flags);\n            break;\n\n        case VARIABLE:\n            DapVariable var = (DapVariable) node;\n            DapType basetype = var.getBaseType();\n            if(basetype.isEnumType()) {\n                printXMLAttribute(\"enum\", basetype.getTypeName(), flags);\n            }\n            break;\n\n        case ATTRIBUTE:\n            DapAttribute attr = (DapAttribute) node;\n            basetype = attr.getBaseType();\n            printXMLAttribute(\"type\", basetype.getTypeName(), flags);\n            if(attr.getBaseType().isEnumType()) {\n                printXMLAttribute(\"enum\", basetype.getTypeName(), flags);\n            }\n            break;\n\n        default:\n            break; // node either has no attributes or name only\n        } //switch\n        if(!this.testing)\n            printReserved(node);\n        if((flags & PERLINE) != 0) {\n            printer.outdent(2);\n        }\n    }", "code_tokens": ["void", "printXMLAttributes", "(", "DapNode", "node", ",", "CEConstraint", "ce", ",", "int", "flags", ")", "throws", "IOException", "{", "if", "(", "(", "flags", "&", "PERLINE", ")", "!=", "0", ")", "printer", ".", "indent", "(", "2", ")", ";", "// Print name first, if non-null and !NONAME", "// Note that the short name needs to use", "// entity escaping (which is done by printXMLattribute),", "// but backslash escaping is not required.", "String", "name", "=", "node", ".", "getShortName", "(", ")", ";", "if", "(", "name", "!=", "null", "&&", "(", "flags", "&", "NONAME", ")", "==", "0", ")", "{", "name", "=", "node", ".", "getShortName", "(", ")", ";", "printXMLAttribute", "(", "\"name\"", ",", "name", ",", "flags", ")", ";", "}", "switch", "(", "node", ".", "getSort", "(", ")", ")", "{", "case", "DATASET", ":", "DapDataset", "dataset", "=", "(", "DapDataset", ")", "node", ";", "printXMLAttribute", "(", "\"dapVersion\"", ",", "dataset", ".", "getDapVersion", "(", ")", ",", "flags", ")", ";", "printXMLAttribute", "(", "\"dmrVersion\"", ",", "dataset", ".", "getDMRVersion", "(", ")", ",", "flags", ")", ";", "// boilerplate", "printXMLAttribute", "(", "\"xmlns\"", ",", "\"http://xml.opendap.org/ns/DAP/4.0#\"", ",", "flags", ")", ";", "printXMLAttribute", "(", "\"xmlns:dap\"", ",", "\"http://xml.opendap.org/ns/DAP/4.0#\"", ",", "flags", ")", ";", "break", ";", "case", "DIMENSION", ":", "DapDimension", "orig", "=", "(", "DapDimension", ")", "node", ";", "if", "(", "orig", ".", "isShared", "(", ")", ")", "{", "//not Anonymous", "// name will have already been printed", "// Now, we need to get the size as defined by the constraint", "DapDimension", "actual", "=", "this", ".", "ce", ".", "getRedefDim", "(", "orig", ")", ";", "if", "(", "actual", "==", "null", ")", "actual", "=", "orig", ";", "long", "size", "=", "actual", ".", "getSize", "(", ")", ";", "printXMLAttribute", "(", "\"size\"", ",", "Long", ".", "toString", "(", "size", ")", ",", "flags", ")", ";", "}", "break", ";", "case", "ENUMERATION", ":", "printXMLAttribute", "(", "\"basetype\"", ",", "(", "(", "DapEnumeration", ")", "node", ")", ".", "getBaseType", "(", ")", ".", "getTypeName", "(", ")", ",", "flags", ")", ";", "break", ";", "case", "VARIABLE", ":", "DapVariable", "var", "=", "(", "DapVariable", ")", "node", ";", "DapType", "basetype", "=", "var", ".", "getBaseType", "(", ")", ";", "if", "(", "basetype", ".", "isEnumType", "(", ")", ")", "{", "printXMLAttribute", "(", "\"enum\"", ",", "basetype", ".", "getTypeName", "(", ")", ",", "flags", ")", ";", "}", "break", ";", "case", "ATTRIBUTE", ":", "DapAttribute", "attr", "=", "(", "DapAttribute", ")", "node", ";", "basetype", "=", "attr", ".", "getBaseType", "(", ")", ";", "printXMLAttribute", "(", "\"type\"", ",", "basetype", ".", "getTypeName", "(", ")", ",", "flags", ")", ";", "if", "(", "attr", ".", "getBaseType", "(", ")", ".", "isEnumType", "(", ")", ")", "{", "printXMLAttribute", "(", "\"enum\"", ",", "basetype", ".", "getTypeName", "(", ")", ",", "flags", ")", ";", "}", "break", ";", "default", ":", "break", ";", "// node either has no attributes or name only", "}", "//switch", "if", "(", "!", "this", ".", "testing", ")", "printReserved", "(", "node", ")", ";", "if", "(", "(", "flags", "&", "PERLINE", ")", "!=", "0", ")", "{", "printer", ".", "outdent", "(", "2", ")", ";", "}", "}"], "docstring": "Print info from the node that needs to be in the form of xml attributes", "docstring_tokens": ["Print", "info", "from", "the", "node", "that", "needs", "to", "be", "in", "the", "form", "of", "xml", "attributes"]}
{"code": "long size = dim.getSize();", "comments": "the size for printing purposes", "lines": 19, "repo": "Unidata/thredds", "path": "dap4/d4lib/src/main/java/dap4/dap4lib/DMRPrinter.java", "func_name": "DMRPrinter.printDimrefs", "original_string": "void\n    printDimrefs(DapVariable var)\n            throws DapException\n    {\n        if(var.getRank() == 0) return;\n        List<DapDimension> dimset = this.ce.getConstrainedDimensions(var);\n        if(dimset == null)\n            throw new DapException(\"Unknown variable: \" + var);\n        assert var.getRank() == dimset.size();\n        for(int i = 0; i < var.getRank(); i++) {\n            DapDimension dim = dimset.get(i);\n            printer.marginPrint(\"<Dim\");\n            if(dim.isShared()) {\n                String fqn = dim.getFQN();\n                assert (fqn != null) : \"Illegal Dimension reference\";\n                fqn = fqnXMLEscape(fqn);\n                printXMLAttribute(\"name\", fqn, XMLESCAPED);\n            } else {\n                long size = dim.getSize();// the size for printing purposes\n                printXMLAttribute(\"size\", Long.toString(size), NILFLAGS);\n            }\n            printer.println(\"/>\");\n        }\n    }", "language": "java", "Allcodes": "void\n    printDimrefs(DapVariable var)\n            throws DapException\n    {\n        if(var.getRank() == 0) return;\n        List<DapDimension> dimset = this.ce.getConstrainedDimensions(var);\n        if(dimset == null)\n            throw new DapException(\"Unknown variable: \" + var);\n        assert var.getRank() == dimset.size();\n        for(int i = 0; i < var.getRank(); i++) {\n            DapDimension dim = dimset.get(i);\n            printer.marginPrint(\"<Dim\");\n            if(dim.isShared()) {\n                String fqn = dim.getFQN();\n                assert (fqn != null) : \"Illegal Dimension reference\";\n                fqn = fqnXMLEscape(fqn);\n                printXMLAttribute(\"name\", fqn, XMLESCAPED);\n            } else {\n                long size = dim.getSize();// the size for printing purposes\n                printXMLAttribute(\"size\", Long.toString(size), NILFLAGS);\n            }\n            printer.println(\"/>\");\n        }\n    }", "code_tokens": ["void", "printDimrefs", "(", "DapVariable", "var", ")", "throws", "DapException", "{", "if", "(", "var", ".", "getRank", "(", ")", "==", "0", ")", "return", ";", "List", "<", "DapDimension", ">", "dimset", "=", "this", ".", "ce", ".", "getConstrainedDimensions", "(", "var", ")", ";", "if", "(", "dimset", "==", "null", ")", "throw", "new", "DapException", "(", "\"Unknown variable: \"", "+", "var", ")", ";", "assert", "var", ".", "getRank", "(", ")", "==", "dimset", ".", "size", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "var", ".", "getRank", "(", ")", ";", "i", "++", ")", "{", "DapDimension", "dim", "=", "dimset", ".", "get", "(", "i", ")", ";", "printer", ".", "marginPrint", "(", "\"<Dim\"", ")", ";", "if", "(", "dim", ".", "isShared", "(", ")", ")", "{", "String", "fqn", "=", "dim", ".", "getFQN", "(", ")", ";", "assert", "(", "fqn", "!=", "null", ")", ":", "\"Illegal Dimension reference\"", ";", "fqn", "=", "fqnXMLEscape", "(", "fqn", ")", ";", "printXMLAttribute", "(", "\"name\"", ",", "fqn", ",", "XMLESCAPED", ")", ";", "}", "else", "{", "long", "size", "=", "dim", ".", "getSize", "(", ")", ";", "// the size for printing purposes", "printXMLAttribute", "(", "\"size\"", ",", "Long", ".", "toString", "(", "size", ")", ",", "NILFLAGS", ")", ";", "}", "printer", ".", "println", "(", "\"/>\"", ")", ";", "}", "}"], "docstring": "Print the dimrefs for a variable's dimensions.\nIf the variable has a non-whole projection, then use size\nelse use the dimension name.\n\n@param var whole dimensions are to be printed\n@throws DapException", "docstring_tokens": ["Print", "the", "dimrefs", "for", "a", "variable", "s", "dimensions", ".", "If", "the", "variable", "has", "a", "non", "-", "whole", "projection", "then", "use", "size", "else", "use", "the", "dimension", "name", "."]}
{"code": "af = new AreaFile(fileName);", "comments": "LOOK opening again not ok for isValidFile", "lines": 5, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/mcidas/AreaReader.java", "func_name": "AreaReader.isValidFile", "original_string": "public static boolean isValidFile(RandomAccessFile raf) {\r\n    String fileName = raf.getLocation();\r\n    AreaFile af = null;\r\n    try {\r\n      af = new AreaFile(fileName);  // LOOK opening again not ok for isValidFile\r\n      return true;\r\n    } catch (AreaFileException e) {\r\n      return false;                 // barfola\r\n    } finally {\r\n      if (af != null) af.close();  // LOOK need to look at this code\r\n    }\r\n  }", "language": "java", "Allcodes": "public static boolean isValidFile(RandomAccessFile raf) {\r\n    String fileName = raf.getLocation();\r\n    AreaFile af = null;\r\n    try {\r\n      af = new AreaFile(fileName);  // LOOK opening again not ok for isValidFile\r\n      return true;\r\n    } catch (AreaFileException e) {\r\n      return false;                 // barfola\r\n    } finally {\r\n      if (af != null) af.close();  // LOOK need to look at this code\r\n    }\r\n  }", "code_tokens": ["public", "static", "boolean", "isValidFile", "(", "RandomAccessFile", "raf", ")", "{", "String", "fileName", "=", "raf", ".", "getLocation", "(", ")", ";", "AreaFile", "af", "=", "null", ";", "try", "{", "af", "=", "new", "AreaFile", "(", "fileName", ")", ";", "// LOOK opening again not ok for isValidFile\r", "return", "true", ";", "}", "catch", "(", "AreaFileException", "e", ")", "{", "return", "false", ";", "// barfola\r", "}", "finally", "{", "if", "(", "af", "!=", "null", ")", "af", ".", "close", "(", ")", ";", "// LOOK need to look at this code\r", "}", "}"], "docstring": "Check to see if this is a valid AREA file.\n\n@param raf the file in question\n@return true if it is an AREA file.", "docstring_tokens": ["Check", "to", "see", "if", "this", "is", "a", "valid", "AREA", "file", "."]}
{"code": "if (af != null) af.close();", "comments": "LOOK need to look at this code", "lines": 10, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/mcidas/AreaReader.java", "func_name": "AreaReader.isValidFile", "original_string": "public static boolean isValidFile(RandomAccessFile raf) {\r\n    String fileName = raf.getLocation();\r\n    AreaFile af = null;\r\n    try {\r\n      af = new AreaFile(fileName);  // LOOK opening again not ok for isValidFile\r\n      return true;\r\n    } catch (AreaFileException e) {\r\n      return false;                 // barfola\r\n    } finally {\r\n      if (af != null) af.close();  // LOOK need to look at this code\r\n    }\r\n  }", "language": "java", "Allcodes": "public static boolean isValidFile(RandomAccessFile raf) {\r\n    String fileName = raf.getLocation();\r\n    AreaFile af = null;\r\n    try {\r\n      af = new AreaFile(fileName);  // LOOK opening again not ok for isValidFile\r\n      return true;\r\n    } catch (AreaFileException e) {\r\n      return false;                 // barfola\r\n    } finally {\r\n      if (af != null) af.close();  // LOOK need to look at this code\r\n    }\r\n  }", "code_tokens": ["public", "static", "boolean", "isValidFile", "(", "RandomAccessFile", "raf", ")", "{", "String", "fileName", "=", "raf", ".", "getLocation", "(", ")", ";", "AreaFile", "af", "=", "null", ";", "try", "{", "af", "=", "new", "AreaFile", "(", "fileName", ")", ";", "// LOOK opening again not ok for isValidFile\r", "return", "true", ";", "}", "catch", "(", "AreaFileException", "e", ")", "{", "return", "false", ";", "// barfola\r", "}", "finally", "{", "if", "(", "af", "!=", "null", ")", "af", ".", "close", "(", ")", ";", "// LOOK need to look at this code\r", "}", "}"], "docstring": "Check to see if this is a valid AREA file.\n\n@param raf the file in question\n@return true if it is an AREA file.", "docstring_tokens": ["Check", "to", "see", "if", "this", "is", "a", "valid", "AREA", "file", "."]}
{"code": "return ((DConstructor) aggRef).getVariable(field);", "comments": "recurse", "lines": 11, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/DSequence.java", "func_name": "DSequence.getVariable", "original_string": "public BaseType getVariable(int row, String name) throws NoSuchVariableException {\r\n\r\n        int dotIndex = name.indexOf('.');\r\n\r\n        if (dotIndex != -1) {  // name contains \".\"\r\n            String aggregate = name.substring(0, dotIndex);\r\n            String field = name.substring(dotIndex + 1);\r\n\r\n            BaseType aggRef = getVariable(aggregate);\r\n            if (aggRef instanceof DConstructor)\r\n                return ((DConstructor) aggRef).getVariable(field);  // recurse\r\n            else\r\n                ; // fall through to throw statement\r\n        } else {\r\n            Vector selectedRow = (Vector) allValues.elementAt(row);\r\n            for (Enumeration e = selectedRow.elements(); e.hasMoreElements();) {\r\n                BaseType v = (BaseType) e.nextElement();\r\n                if (v.getEncodedName().equals(name))\r\n                    return v;\r\n            }\r\n        }\r\n        throw new NoSuchVariableException(\"DSequence: getVariable()\");\r\n    }", "language": "java", "Allcodes": "public BaseType getVariable(int row, String name) throws NoSuchVariableException {\r\n\r\n        int dotIndex = name.indexOf('.');\r\n\r\n        if (dotIndex != -1) {  // name contains \".\"\r\n            String aggregate = name.substring(0, dotIndex);\r\n            String field = name.substring(dotIndex + 1);\r\n\r\n            BaseType aggRef = getVariable(aggregate);\r\n            if (aggRef instanceof DConstructor)\r\n                return ((DConstructor) aggRef).getVariable(field);  // recurse\r\n            else\r\n                ; // fall through to throw statement\r\n        } else {\r\n            Vector selectedRow = (Vector) allValues.elementAt(row);\r\n            for (Enumeration e = selectedRow.elements(); e.hasMoreElements();) {\r\n                BaseType v = (BaseType) e.nextElement();\r\n                if (v.getEncodedName().equals(name))\r\n                    return v;\r\n            }\r\n        }\r\n        throw new NoSuchVariableException(\"DSequence: getVariable()\");\r\n    }", "code_tokens": ["public", "BaseType", "getVariable", "(", "int", "row", ",", "String", "name", ")", "throws", "NoSuchVariableException", "{", "int", "dotIndex", "=", "name", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "dotIndex", "!=", "-", "1", ")", "{", "// name contains \".\"\r", "String", "aggregate", "=", "name", ".", "substring", "(", "0", ",", "dotIndex", ")", ";", "String", "field", "=", "name", ".", "substring", "(", "dotIndex", "+", "1", ")", ";", "BaseType", "aggRef", "=", "getVariable", "(", "aggregate", ")", ";", "if", "(", "aggRef", "instanceof", "DConstructor", ")", "return", "(", "(", "DConstructor", ")", "aggRef", ")", ".", "getVariable", "(", "field", ")", ";", "// recurse\r", "else", ";", "// fall through to throw statement\r", "}", "else", "{", "Vector", "selectedRow", "=", "(", "Vector", ")", "allValues", ".", "elementAt", "(", "row", ")", ";", "for", "(", "Enumeration", "e", "=", "selectedRow", ".", "elements", "(", ")", ";", "e", ".", "hasMoreElements", "(", ")", ";", ")", "{", "BaseType", "v", "=", "(", "BaseType", ")", "e", ".", "nextElement", "(", ")", ";", "if", "(", "v", ".", "getEncodedName", "(", ")", ".", "equals", "(", "name", ")", ")", "return", "v", ";", "}", "}", "throw", "new", "NoSuchVariableException", "(", "\"DSequence: getVariable()\"", ")", ";", "}"], "docstring": "Returns the named variable in the given row of the sequence.\n\n@param row  the row number to retrieve.\n@param name the name of the variable.\n@return the named variable.\n@throws NoSuchVariableException if the named variable does not\nexist in this container.", "docstring_tokens": ["Returns", "the", "named", "variable", "in", "the", "given", "row", "of", "the", "sequence", "."]}
{"code": ";", "comments": "fall through to throw statement", "lines": 13, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/DSequence.java", "func_name": "DSequence.getVariable", "original_string": "public BaseType getVariable(int row, String name) throws NoSuchVariableException {\r\n\r\n        int dotIndex = name.indexOf('.');\r\n\r\n        if (dotIndex != -1) {  // name contains \".\"\r\n            String aggregate = name.substring(0, dotIndex);\r\n            String field = name.substring(dotIndex + 1);\r\n\r\n            BaseType aggRef = getVariable(aggregate);\r\n            if (aggRef instanceof DConstructor)\r\n                return ((DConstructor) aggRef).getVariable(field);  // recurse\r\n            else\r\n                ; // fall through to throw statement\r\n        } else {\r\n            Vector selectedRow = (Vector) allValues.elementAt(row);\r\n            for (Enumeration e = selectedRow.elements(); e.hasMoreElements();) {\r\n                BaseType v = (BaseType) e.nextElement();\r\n                if (v.getEncodedName().equals(name))\r\n                    return v;\r\n            }\r\n        }\r\n        throw new NoSuchVariableException(\"DSequence: getVariable()\");\r\n    }", "language": "java", "Allcodes": "public BaseType getVariable(int row, String name) throws NoSuchVariableException {\r\n\r\n        int dotIndex = name.indexOf('.');\r\n\r\n        if (dotIndex != -1) {  // name contains \".\"\r\n            String aggregate = name.substring(0, dotIndex);\r\n            String field = name.substring(dotIndex + 1);\r\n\r\n            BaseType aggRef = getVariable(aggregate);\r\n            if (aggRef instanceof DConstructor)\r\n                return ((DConstructor) aggRef).getVariable(field);  // recurse\r\n            else\r\n                ; // fall through to throw statement\r\n        } else {\r\n            Vector selectedRow = (Vector) allValues.elementAt(row);\r\n            for (Enumeration e = selectedRow.elements(); e.hasMoreElements();) {\r\n                BaseType v = (BaseType) e.nextElement();\r\n                if (v.getEncodedName().equals(name))\r\n                    return v;\r\n            }\r\n        }\r\n        throw new NoSuchVariableException(\"DSequence: getVariable()\");\r\n    }", "code_tokens": ["public", "BaseType", "getVariable", "(", "int", "row", ",", "String", "name", ")", "throws", "NoSuchVariableException", "{", "int", "dotIndex", "=", "name", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "dotIndex", "!=", "-", "1", ")", "{", "// name contains \".\"\r", "String", "aggregate", "=", "name", ".", "substring", "(", "0", ",", "dotIndex", ")", ";", "String", "field", "=", "name", ".", "substring", "(", "dotIndex", "+", "1", ")", ";", "BaseType", "aggRef", "=", "getVariable", "(", "aggregate", ")", ";", "if", "(", "aggRef", "instanceof", "DConstructor", ")", "return", "(", "(", "DConstructor", ")", "aggRef", ")", ".", "getVariable", "(", "field", ")", ";", "// recurse\r", "else", ";", "// fall through to throw statement\r", "}", "else", "{", "Vector", "selectedRow", "=", "(", "Vector", ")", "allValues", ".", "elementAt", "(", "row", ")", ";", "for", "(", "Enumeration", "e", "=", "selectedRow", ".", "elements", "(", ")", ";", "e", ".", "hasMoreElements", "(", ")", ";", ")", "{", "BaseType", "v", "=", "(", "BaseType", ")", "e", ".", "nextElement", "(", ")", ";", "if", "(", "v", ".", "getEncodedName", "(", ")", ".", "equals", "(", "name", ")", ")", "return", "v", ";", "}", "}", "throw", "new", "NoSuchVariableException", "(", "\"DSequence: getVariable()\"", ")", ";", "}"], "docstring": "Returns the named variable in the given row of the sequence.\n\n@param row  the row number to retrieve.\n@param name the name of the variable.\n@return the named variable.\n@throws NoSuchVariableException if the named variable does not\nexist in this container.", "docstring_tokens": ["Returns", "the", "named", "variable", "in", "the", "given", "row", "of", "the", "sequence", "."]}
{"code": "long pos = Math.max(0, drsPos- (20*1000));", "comments": "go back 20K", "lines": 3, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib2/Grib2RecordScanner.java", "func_name": "Grib2RecordScanner.findRecordByDrspos", "original_string": "@Nullable\r\n  public static Grib2Record findRecordByDrspos(RandomAccessFile raf, long drsPos) throws IOException {\r\n    long pos = Math.max(0, drsPos- (20*1000)); // go back 20K\r\n    Grib2RecordScanner scan = new Grib2RecordScanner(raf, pos);\r\n    while (scan.hasNext()) {\r\n      ucar.nc2.grib.grib2.Grib2Record gr = scan.next();\r\n      Grib2SectionDataRepresentation drs = gr.getDataRepresentationSection();\r\n      if (drsPos == drs.getStartingPosition()) return gr;\r\n      if (raf.getFilePointer() > drsPos) break;   // missed it.\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "@Nullable\r\n  public static Grib2Record findRecordByDrspos(RandomAccessFile raf, long drsPos) throws IOException {\r\n    long pos = Math.max(0, drsPos- (20*1000)); // go back 20K\r\n    Grib2RecordScanner scan = new Grib2RecordScanner(raf, pos);\r\n    while (scan.hasNext()) {\r\n      ucar.nc2.grib.grib2.Grib2Record gr = scan.next();\r\n      Grib2SectionDataRepresentation drs = gr.getDataRepresentationSection();\r\n      if (drsPos == drs.getStartingPosition()) return gr;\r\n      if (raf.getFilePointer() > drsPos) break;   // missed it.\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["@", "Nullable", "public", "static", "Grib2Record", "findRecordByDrspos", "(", "RandomAccessFile", "raf", ",", "long", "drsPos", ")", "throws", "IOException", "{", "long", "pos", "=", "Math", ".", "max", "(", "0", ",", "drsPos", "-", "(", "20", "*", "1000", ")", ")", ";", "// go back 20K\r", "Grib2RecordScanner", "scan", "=", "new", "Grib2RecordScanner", "(", "raf", ",", "pos", ")", ";", "while", "(", "scan", ".", "hasNext", "(", ")", ")", "{", "ucar", ".", "nc2", ".", "grib", ".", "grib2", ".", "Grib2Record", "gr", "=", "scan", ".", "next", "(", ")", ";", "Grib2SectionDataRepresentation", "drs", "=", "gr", ".", "getDataRepresentationSection", "(", ")", ";", "if", "(", "drsPos", "==", "drs", ".", "getStartingPosition", "(", ")", ")", "return", "gr", ";", "if", "(", "raf", ".", "getFilePointer", "(", ")", ">", "drsPos", ")", "break", ";", "// missed it.\r", "}", "return", "null", ";", "}"], "docstring": "tricky bit of business. recapture the entire record based on drs position.\nfor validation.\n@param raf             from this RandomAccessFile\n@param drsPos          Grib2SectionDataRepresentation starts here", "docstring_tokens": ["tricky", "bit", "of", "business", ".", "recapture", "the", "entire", "record", "based", "on", "drs", "position", ".", "for", "validation", "."]}
{"code": "if (raf.getFilePointer() > drsPos) break;", "comments": "missed it.", "lines": 9, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib2/Grib2RecordScanner.java", "func_name": "Grib2RecordScanner.findRecordByDrspos", "original_string": "@Nullable\r\n  public static Grib2Record findRecordByDrspos(RandomAccessFile raf, long drsPos) throws IOException {\r\n    long pos = Math.max(0, drsPos- (20*1000)); // go back 20K\r\n    Grib2RecordScanner scan = new Grib2RecordScanner(raf, pos);\r\n    while (scan.hasNext()) {\r\n      ucar.nc2.grib.grib2.Grib2Record gr = scan.next();\r\n      Grib2SectionDataRepresentation drs = gr.getDataRepresentationSection();\r\n      if (drsPos == drs.getStartingPosition()) return gr;\r\n      if (raf.getFilePointer() > drsPos) break;   // missed it.\r\n    }\r\n    return null;\r\n  }", "language": "java", "Allcodes": "@Nullable\r\n  public static Grib2Record findRecordByDrspos(RandomAccessFile raf, long drsPos) throws IOException {\r\n    long pos = Math.max(0, drsPos- (20*1000)); // go back 20K\r\n    Grib2RecordScanner scan = new Grib2RecordScanner(raf, pos);\r\n    while (scan.hasNext()) {\r\n      ucar.nc2.grib.grib2.Grib2Record gr = scan.next();\r\n      Grib2SectionDataRepresentation drs = gr.getDataRepresentationSection();\r\n      if (drsPos == drs.getStartingPosition()) return gr;\r\n      if (raf.getFilePointer() > drsPos) break;   // missed it.\r\n    }\r\n    return null;\r\n  }", "code_tokens": ["@", "Nullable", "public", "static", "Grib2Record", "findRecordByDrspos", "(", "RandomAccessFile", "raf", ",", "long", "drsPos", ")", "throws", "IOException", "{", "long", "pos", "=", "Math", ".", "max", "(", "0", ",", "drsPos", "-", "(", "20", "*", "1000", ")", ")", ";", "// go back 20K\r", "Grib2RecordScanner", "scan", "=", "new", "Grib2RecordScanner", "(", "raf", ",", "pos", ")", ";", "while", "(", "scan", ".", "hasNext", "(", ")", ")", "{", "ucar", ".", "nc2", ".", "grib", ".", "grib2", ".", "Grib2Record", "gr", "=", "scan", ".", "next", "(", ")", ";", "Grib2SectionDataRepresentation", "drs", "=", "gr", ".", "getDataRepresentationSection", "(", ")", ";", "if", "(", "drsPos", "==", "drs", ".", "getStartingPosition", "(", ")", ")", "return", "gr", ";", "if", "(", "raf", ".", "getFilePointer", "(", ")", ">", "drsPos", ")", "break", ";", "// missed it.\r", "}", "return", "null", ";", "}"], "docstring": "tricky bit of business. recapture the entire record based on drs position.\nfor validation.\n@param raf             from this RandomAccessFile\n@param drsPos          Grib2SectionDataRepresentation starts here", "docstring_tokens": ["tricky", "bit", "of", "business", ".", "recapture", "the", "entire", "record", "based", "on", "drs", "position", ".", "for", "validation", "."]}
{"code": "vinfo.setLayoutInfo();", "comments": "make sure needed info is present", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/hdf4/H4iosp.java", "func_name": "H4iosp.readStructureData", "original_string": "private ucar.ma2.ArrayStructure readStructureData(ucar.nc2.Structure s, Section section) throws java.io.IOException, InvalidRangeException {\r\n    H4header.Vinfo vinfo = (H4header.Vinfo) s.getSPobject();\r\n    vinfo.setLayoutInfo();   // make sure needed info is present\r\n    int recsize = vinfo.elemSize;\r\n\r\n    // create the ArrayStructure\r\n    StructureMembers members = s.makeStructureMembers();\r\n    for (StructureMembers.Member m : members.getMembers()) {\r\n      Variable v2 = s.findVariable(m.getName());\r\n      H4header.Minfo minfo = (H4header.Minfo) v2.getSPobject();\r\n      m.setDataParam(minfo.offset);\r\n    }\r\n    members.setStructureSize(recsize);\r\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, section.getShape());  // LOOK subset\r\n\r\n    // loop over records\r\n    byte[] result = structureArray.getByteBuffer().array();\r\n\r\n    /*if (vinfo.isChunked) {\r\n      InputStream is = getChunkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);  */\r\n\r\n    if (!vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1, true);\r\n\r\n      /* option 1\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutSegmented(vinfo.segPos, vinfo.segSize, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1);  */\r\n\r\n      // option 2\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      InputStream is = new LinkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (!vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getLinkedCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else {\r\n      throw new IllegalStateException();\r\n    }\r\n\r\n    return structureArray;\r\n  }", "language": "java", "Allcodes": "private ucar.ma2.ArrayStructure readStructureData(ucar.nc2.Structure s, Section section) throws java.io.IOException, InvalidRangeException {\r\n    H4header.Vinfo vinfo = (H4header.Vinfo) s.getSPobject();\r\n    vinfo.setLayoutInfo();   // make sure needed info is present\r\n    int recsize = vinfo.elemSize;\r\n\r\n    // create the ArrayStructure\r\n    StructureMembers members = s.makeStructureMembers();\r\n    for (StructureMembers.Member m : members.getMembers()) {\r\n      Variable v2 = s.findVariable(m.getName());\r\n      H4header.Minfo minfo = (H4header.Minfo) v2.getSPobject();\r\n      m.setDataParam(minfo.offset);\r\n    }\r\n    members.setStructureSize(recsize);\r\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, section.getShape());  // LOOK subset\r\n\r\n    // loop over records\r\n    byte[] result = structureArray.getByteBuffer().array();\r\n\r\n    /*if (vinfo.isChunked) {\r\n      InputStream is = getChunkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);  */\r\n\r\n    if (!vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1, true);\r\n\r\n      /* option 1\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutSegmented(vinfo.segPos, vinfo.segSize, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1);  */\r\n\r\n      // option 2\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      InputStream is = new LinkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (!vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getLinkedCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else {\r\n      throw new IllegalStateException();\r\n    }\r\n\r\n    return structureArray;\r\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "ArrayStructure", "readStructureData", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", ",", "InvalidRangeException", "{", "H4header", ".", "Vinfo", "vinfo", "=", "(", "H4header", ".", "Vinfo", ")", "s", ".", "getSPobject", "(", ")", ";", "vinfo", ".", "setLayoutInfo", "(", ")", ";", "// make sure needed info is present\r", "int", "recsize", "=", "vinfo", ".", "elemSize", ";", "// create the ArrayStructure\r", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "H4header", ".", "Minfo", "minfo", "=", "(", "H4header", ".", "Minfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "minfo", ".", "offset", ")", ";", "}", "members", ".", "setStructureSize", "(", "recsize", ")", ";", "ArrayStructureBB", "structureArray", "=", "new", "ArrayStructureBB", "(", "members", ",", "section", ".", "getShape", "(", ")", ")", ";", "// LOOK subset\r", "// loop over records\r", "byte", "[", "]", "result", "=", "structureArray", ".", "getByteBuffer", "(", ")", ".", "array", "(", ")", ";", "/*if (vinfo.isChunked) {\r\n      InputStream is = getChunkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);  */", "if", "(", "!", "vinfo", ".", "isLinked", "&&", "!", "vinfo", ".", "isCompressed", ")", "{", "Layout", "layout", "=", "new", "LayoutRegular", "(", "vinfo", ".", "start", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "raf", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ",", "-", "1", ",", "true", ")", ";", "/* option 1\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutSegmented(vinfo.segPos, vinfo.segSize, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1);  */", "// option 2\r", "}", "else", "if", "(", "vinfo", ".", "isLinked", "&&", "!", "vinfo", ".", "isCompressed", ")", "{", "InputStream", "is", "=", "new", "LinkedInputStream", "(", "vinfo", ")", ";", "PositioningDataInputStream", "dataSource", "=", "new", "PositioningDataInputStream", "(", "is", ")", ";", "Layout", "layout", "=", "new", "LayoutRegular", "(", "0", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "dataSource", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ")", ";", "}", "else", "if", "(", "!", "vinfo", ".", "isLinked", "&&", "vinfo", ".", "isCompressed", ")", "{", "InputStream", "is", "=", "getCompressedInputStream", "(", "vinfo", ")", ";", "PositioningDataInputStream", "dataSource", "=", "new", "PositioningDataInputStream", "(", "is", ")", ";", "Layout", "layout", "=", "new", "LayoutRegular", "(", "0", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "dataSource", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ")", ";", "}", "else", "if", "(", "vinfo", ".", "isLinked", "&&", "vinfo", ".", "isCompressed", ")", "{", "InputStream", "is", "=", "getLinkedCompressedInputStream", "(", "vinfo", ")", ";", "PositioningDataInputStream", "dataSource", "=", "new", "PositioningDataInputStream", "(", "is", ")", ";", "Layout", "layout", "=", "new", "LayoutRegular", "(", "0", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "dataSource", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "return", "structureArray", ";", "}"], "docstring": "Structures must be fixed sized\n\n@param s       the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException                    on error\n@throws ucar.ma2.InvalidRangeException if invalid section", "docstring_tokens": ["Structures", "must", "be", "fixed", "sized"]}
{"code": "ArrayStructureBB structureArray = new ArrayStructureBB(members, section.getShape());", "comments": "LOOK subset", "lines": 14, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/hdf4/H4iosp.java", "func_name": "H4iosp.readStructureData", "original_string": "private ucar.ma2.ArrayStructure readStructureData(ucar.nc2.Structure s, Section section) throws java.io.IOException, InvalidRangeException {\r\n    H4header.Vinfo vinfo = (H4header.Vinfo) s.getSPobject();\r\n    vinfo.setLayoutInfo();   // make sure needed info is present\r\n    int recsize = vinfo.elemSize;\r\n\r\n    // create the ArrayStructure\r\n    StructureMembers members = s.makeStructureMembers();\r\n    for (StructureMembers.Member m : members.getMembers()) {\r\n      Variable v2 = s.findVariable(m.getName());\r\n      H4header.Minfo minfo = (H4header.Minfo) v2.getSPobject();\r\n      m.setDataParam(minfo.offset);\r\n    }\r\n    members.setStructureSize(recsize);\r\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, section.getShape());  // LOOK subset\r\n\r\n    // loop over records\r\n    byte[] result = structureArray.getByteBuffer().array();\r\n\r\n    /*if (vinfo.isChunked) {\r\n      InputStream is = getChunkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);  */\r\n\r\n    if (!vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1, true);\r\n\r\n      /* option 1\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutSegmented(vinfo.segPos, vinfo.segSize, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1);  */\r\n\r\n      // option 2\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      InputStream is = new LinkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (!vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getLinkedCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else {\r\n      throw new IllegalStateException();\r\n    }\r\n\r\n    return structureArray;\r\n  }", "language": "java", "Allcodes": "private ucar.ma2.ArrayStructure readStructureData(ucar.nc2.Structure s, Section section) throws java.io.IOException, InvalidRangeException {\r\n    H4header.Vinfo vinfo = (H4header.Vinfo) s.getSPobject();\r\n    vinfo.setLayoutInfo();   // make sure needed info is present\r\n    int recsize = vinfo.elemSize;\r\n\r\n    // create the ArrayStructure\r\n    StructureMembers members = s.makeStructureMembers();\r\n    for (StructureMembers.Member m : members.getMembers()) {\r\n      Variable v2 = s.findVariable(m.getName());\r\n      H4header.Minfo minfo = (H4header.Minfo) v2.getSPobject();\r\n      m.setDataParam(minfo.offset);\r\n    }\r\n    members.setStructureSize(recsize);\r\n    ArrayStructureBB structureArray = new ArrayStructureBB(members, section.getShape());  // LOOK subset\r\n\r\n    // loop over records\r\n    byte[] result = structureArray.getByteBuffer().array();\r\n\r\n    /*if (vinfo.isChunked) {\r\n      InputStream is = getChunkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);  */\r\n\r\n    if (!vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1, true);\r\n\r\n      /* option 1\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutSegmented(vinfo.segPos, vinfo.segSize, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1);  */\r\n\r\n      // option 2\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      InputStream is = new LinkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (!vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else if (vinfo.isLinked && vinfo.isCompressed) {\r\n      InputStream is = getLinkedCompressedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(0, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);\r\n\r\n    } else {\r\n      throw new IllegalStateException();\r\n    }\r\n\r\n    return structureArray;\r\n  }", "code_tokens": ["private", "ucar", ".", "ma2", ".", "ArrayStructure", "readStructureData", "(", "ucar", ".", "nc2", ".", "Structure", "s", ",", "Section", "section", ")", "throws", "java", ".", "io", ".", "IOException", ",", "InvalidRangeException", "{", "H4header", ".", "Vinfo", "vinfo", "=", "(", "H4header", ".", "Vinfo", ")", "s", ".", "getSPobject", "(", ")", ";", "vinfo", ".", "setLayoutInfo", "(", ")", ";", "// make sure needed info is present\r", "int", "recsize", "=", "vinfo", ".", "elemSize", ";", "// create the ArrayStructure\r", "StructureMembers", "members", "=", "s", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "members", ".", "getMembers", "(", ")", ")", "{", "Variable", "v2", "=", "s", ".", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "H4header", ".", "Minfo", "minfo", "=", "(", "H4header", ".", "Minfo", ")", "v2", ".", "getSPobject", "(", ")", ";", "m", ".", "setDataParam", "(", "minfo", ".", "offset", ")", ";", "}", "members", ".", "setStructureSize", "(", "recsize", ")", ";", "ArrayStructureBB", "structureArray", "=", "new", "ArrayStructureBB", "(", "members", ",", "section", ".", "getShape", "(", ")", ")", ";", "// LOOK subset\r", "// loop over records\r", "byte", "[", "]", "result", "=", "structureArray", ".", "getByteBuffer", "(", ")", ".", "array", "(", ")", ";", "/*if (vinfo.isChunked) {\r\n      InputStream is = getChunkedInputStream(vinfo);\r\n      PositioningDataInputStream dataSource = new PositioningDataInputStream(is);\r\n      Layout layout = new LayoutRegular(vinfo.start, recsize, s.getShape(), section);\r\n      IospHelper.readData(dataSource, layout, DataType.STRUCTURE, result);  */", "if", "(", "!", "vinfo", ".", "isLinked", "&&", "!", "vinfo", ".", "isCompressed", ")", "{", "Layout", "layout", "=", "new", "LayoutRegular", "(", "vinfo", ".", "start", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "raf", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ",", "-", "1", ",", "true", ")", ";", "/* option 1\r\n    } else if (vinfo.isLinked && !vinfo.isCompressed) {\r\n      Layout layout = new LayoutSegmented(vinfo.segPos, vinfo.segSize, recsize, s.getShape(), section);\r\n      IospHelper.readData(raf, layout, DataType.STRUCTURE, result, -1);  */", "// option 2\r", "}", "else", "if", "(", "vinfo", ".", "isLinked", "&&", "!", "vinfo", ".", "isCompressed", ")", "{", "InputStream", "is", "=", "new", "LinkedInputStream", "(", "vinfo", ")", ";", "PositioningDataInputStream", "dataSource", "=", "new", "PositioningDataInputStream", "(", "is", ")", ";", "Layout", "layout", "=", "new", "LayoutRegular", "(", "0", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "dataSource", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ")", ";", "}", "else", "if", "(", "!", "vinfo", ".", "isLinked", "&&", "vinfo", ".", "isCompressed", ")", "{", "InputStream", "is", "=", "getCompressedInputStream", "(", "vinfo", ")", ";", "PositioningDataInputStream", "dataSource", "=", "new", "PositioningDataInputStream", "(", "is", ")", ";", "Layout", "layout", "=", "new", "LayoutRegular", "(", "0", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "dataSource", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ")", ";", "}", "else", "if", "(", "vinfo", ".", "isLinked", "&&", "vinfo", ".", "isCompressed", ")", "{", "InputStream", "is", "=", "getLinkedCompressedInputStream", "(", "vinfo", ")", ";", "PositioningDataInputStream", "dataSource", "=", "new", "PositioningDataInputStream", "(", "is", ")", ";", "Layout", "layout", "=", "new", "LayoutRegular", "(", "0", ",", "recsize", ",", "s", ".", "getShape", "(", ")", ",", "section", ")", ";", "IospHelper", ".", "readData", "(", "dataSource", ",", "layout", ",", "DataType", ".", "STRUCTURE", ",", "result", ")", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "return", "structureArray", ";", "}"], "docstring": "Structures must be fixed sized\n\n@param s       the record structure\n@param section the record range to read\n@return an ArrayStructure, with all the data read in.\n@throws IOException                    on error\n@throws ucar.ma2.InvalidRangeException if invalid section", "docstring_tokens": ["Structures", "must", "be", "fixed", "sized"]}
{"code": "g2d.setColor(Color.black);", "comments": "getBackground());", "lines": 19, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/image/PicturePane.java", "func_name": "PicturePane.paintComponent", "original_string": "public void paintComponent(Graphics g) {\n\t\tint WindowWidth = getSize().width;\n\t\tint WindowHeight = getSize().height;\n\n    Tools.log (\"paintComponent called\");\n\n\t\tif (Dragging == false) {  //otherwise it's already a move Cursor\n\t\t\tsetCursor(new Cursor(Cursor.WAIT_CURSOR));\n\t\t}\n\n\t\tif ( sclPic.getScaledPicture() != null ) {\n\t\t\tGraphics2D g2d = (Graphics2D)g;\n\n\t\t\tint X_Offset = (int) ((double) (WindowWidth / 2) - (focusPoint.x * sclPic.getScaleFactor()));\n\t\t\tint Y_Offset = (int) ((double) (WindowHeight / 2) - (focusPoint.y * sclPic.getScaleFactor()));\n\n\t\t\t// clear damaged component area\n\t\t \tRectangle clipBounds = g2d.getClipBounds();\n\t\t\tg2d.setColor(Color.black); // getBackground());\n\t\t\tg2d.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);\n\t\t\t\t     \n\t\t\tg2d.drawRenderedImage(sclPic.getScaledPicture(), AffineTransform.getTranslateInstance( X_Offset, Y_Offset));\n\t\t\t//g2d.drawImage(sclPic.getScaledPicture(), null, 0, 0);\n\n\t\t\tif (showInfo) {\n\t\t\t\tg2d.setColor(Color.white);\n\t\t\t\tg2d.drawString(legend, infoPoint.x, infoPoint.y);\n\t\t\t\tg2d.drawString(\"Size: \" + Integer.toString(sclPic.getOriginalWidth()) + \" x \" + Integer.toString(sclPic.getOriginalHeight())\n\t\t\t\t\t\t+ \" Offset: \" + X_Offset + \" x \" + Y_Offset\n\t\t\t\t\t\t+ \" Mid: \" + Integer.toString(focusPoint.x) + \" x \" + Integer.toString(focusPoint.y)\n\t\t\t\t\t\t+ \" Scale: \" + twoDecimalFormatter.format(sclPic.getScaleFactor()), infoPoint.x, infoPoint.y + lineSpacing);\n\t\t\t\t/* g2d.drawString(\"File: \" + sclPic.getFilename()\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (2 * lineSpacing) );\n\t\t\t\tg2d.drawString(\"Loaded in: \" \n\t\t\t\t\t\t+ twoDecimalFormatter.format( sclPic.getSourcePicture().loadTime / 1000F )\n\t\t\t\t\t\t+ \" Seconds\"\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (3 * lineSpacing) );\n\t\t\t\tg2d.drawString(\"Free memory: \" \n\t\t\t\t\t\t+ Long.toString( Runtime.getRuntime().freeMemory( )/1024/1024, 0 ) \n\t\t\t\t\t\t+ \" MB\"\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (4 * lineSpacing) ); */\n\t\t\t}\n\t\t} else {\n\t\t\t// paint a black square\n\t\t\tg.setClip(0, 0, WindowWidth, WindowHeight);\n\t\t\tg.setColor(Color.black);\n\t\t\tg.fillRect(0,0,WindowWidth,WindowHeight);\n\t\t}\n\n\t\tif (Dragging == false) {  //otherwise a move Cursor and should remain\n\t\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR)); \n\t\t}\n\t}", "language": "java", "Allcodes": "public void paintComponent(Graphics g) {\n\t\tint WindowWidth = getSize().width;\n\t\tint WindowHeight = getSize().height;\n\n    Tools.log (\"paintComponent called\");\n\n\t\tif (Dragging == false) {  //otherwise it's already a move Cursor\n\t\t\tsetCursor(new Cursor(Cursor.WAIT_CURSOR));\n\t\t}\n\n\t\tif ( sclPic.getScaledPicture() != null ) {\n\t\t\tGraphics2D g2d = (Graphics2D)g;\n\n\t\t\tint X_Offset = (int) ((double) (WindowWidth / 2) - (focusPoint.x * sclPic.getScaleFactor()));\n\t\t\tint Y_Offset = (int) ((double) (WindowHeight / 2) - (focusPoint.y * sclPic.getScaleFactor()));\n\n\t\t\t// clear damaged component area\n\t\t \tRectangle clipBounds = g2d.getClipBounds();\n\t\t\tg2d.setColor(Color.black); // getBackground());\n\t\t\tg2d.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);\n\t\t\t\t     \n\t\t\tg2d.drawRenderedImage(sclPic.getScaledPicture(), AffineTransform.getTranslateInstance( X_Offset, Y_Offset));\n\t\t\t//g2d.drawImage(sclPic.getScaledPicture(), null, 0, 0);\n\n\t\t\tif (showInfo) {\n\t\t\t\tg2d.setColor(Color.white);\n\t\t\t\tg2d.drawString(legend, infoPoint.x, infoPoint.y);\n\t\t\t\tg2d.drawString(\"Size: \" + Integer.toString(sclPic.getOriginalWidth()) + \" x \" + Integer.toString(sclPic.getOriginalHeight())\n\t\t\t\t\t\t+ \" Offset: \" + X_Offset + \" x \" + Y_Offset\n\t\t\t\t\t\t+ \" Mid: \" + Integer.toString(focusPoint.x) + \" x \" + Integer.toString(focusPoint.y)\n\t\t\t\t\t\t+ \" Scale: \" + twoDecimalFormatter.format(sclPic.getScaleFactor()), infoPoint.x, infoPoint.y + lineSpacing);\n\t\t\t\t/* g2d.drawString(\"File: \" + sclPic.getFilename()\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (2 * lineSpacing) );\n\t\t\t\tg2d.drawString(\"Loaded in: \" \n\t\t\t\t\t\t+ twoDecimalFormatter.format( sclPic.getSourcePicture().loadTime / 1000F )\n\t\t\t\t\t\t+ \" Seconds\"\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (3 * lineSpacing) );\n\t\t\t\tg2d.drawString(\"Free memory: \" \n\t\t\t\t\t\t+ Long.toString( Runtime.getRuntime().freeMemory( )/1024/1024, 0 ) \n\t\t\t\t\t\t+ \" MB\"\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (4 * lineSpacing) ); */\n\t\t\t}\n\t\t} else {\n\t\t\t// paint a black square\n\t\t\tg.setClip(0, 0, WindowWidth, WindowHeight);\n\t\t\tg.setColor(Color.black);\n\t\t\tg.fillRect(0,0,WindowWidth,WindowHeight);\n\t\t}\n\n\t\tif (Dragging == false) {  //otherwise a move Cursor and should remain\n\t\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR)); \n\t\t}\n\t}", "code_tokens": ["public", "void", "paintComponent", "(", "Graphics", "g", ")", "{", "int", "WindowWidth", "=", "getSize", "(", ")", ".", "width", ";", "int", "WindowHeight", "=", "getSize", "(", ")", ".", "height", ";", "Tools", ".", "log", "(", "\"paintComponent called\"", ")", ";", "if", "(", "Dragging", "==", "false", ")", "{", "//otherwise it's already a move Cursor", "setCursor", "(", "new", "Cursor", "(", "Cursor", ".", "WAIT_CURSOR", ")", ")", ";", "}", "if", "(", "sclPic", ".", "getScaledPicture", "(", ")", "!=", "null", ")", "{", "Graphics2D", "g2d", "=", "(", "Graphics2D", ")", "g", ";", "int", "X_Offset", "=", "(", "int", ")", "(", "(", "double", ")", "(", "WindowWidth", "/", "2", ")", "-", "(", "focusPoint", ".", "x", "*", "sclPic", ".", "getScaleFactor", "(", ")", ")", ")", ";", "int", "Y_Offset", "=", "(", "int", ")", "(", "(", "double", ")", "(", "WindowHeight", "/", "2", ")", "-", "(", "focusPoint", ".", "y", "*", "sclPic", ".", "getScaleFactor", "(", ")", ")", ")", ";", "// clear damaged component area", "Rectangle", "clipBounds", "=", "g2d", ".", "getClipBounds", "(", ")", ";", "g2d", ".", "setColor", "(", "Color", ".", "black", ")", ";", "// getBackground());", "g2d", ".", "fillRect", "(", "clipBounds", ".", "x", ",", "clipBounds", ".", "y", ",", "clipBounds", ".", "width", ",", "clipBounds", ".", "height", ")", ";", "g2d", ".", "drawRenderedImage", "(", "sclPic", ".", "getScaledPicture", "(", ")", ",", "AffineTransform", ".", "getTranslateInstance", "(", "X_Offset", ",", "Y_Offset", ")", ")", ";", "//g2d.drawImage(sclPic.getScaledPicture(), null, 0, 0);", "if", "(", "showInfo", ")", "{", "g2d", ".", "setColor", "(", "Color", ".", "white", ")", ";", "g2d", ".", "drawString", "(", "legend", ",", "infoPoint", ".", "x", ",", "infoPoint", ".", "y", ")", ";", "g2d", ".", "drawString", "(", "\"Size: \"", "+", "Integer", ".", "toString", "(", "sclPic", ".", "getOriginalWidth", "(", ")", ")", "+", "\" x \"", "+", "Integer", ".", "toString", "(", "sclPic", ".", "getOriginalHeight", "(", ")", ")", "+", "\" Offset: \"", "+", "X_Offset", "+", "\" x \"", "+", "Y_Offset", "+", "\" Mid: \"", "+", "Integer", ".", "toString", "(", "focusPoint", ".", "x", ")", "+", "\" x \"", "+", "Integer", ".", "toString", "(", "focusPoint", ".", "y", ")", "+", "\" Scale: \"", "+", "twoDecimalFormatter", ".", "format", "(", "sclPic", ".", "getScaleFactor", "(", ")", ")", ",", "infoPoint", ".", "x", ",", "infoPoint", ".", "y", "+", "lineSpacing", ")", ";", "/* g2d.drawString(\"File: \" + sclPic.getFilename()\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (2 * lineSpacing) );\n\t\t\t\tg2d.drawString(\"Loaded in: \" \n\t\t\t\t\t\t+ twoDecimalFormatter.format( sclPic.getSourcePicture().loadTime / 1000F )\n\t\t\t\t\t\t+ \" Seconds\"\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (3 * lineSpacing) );\n\t\t\t\tg2d.drawString(\"Free memory: \" \n\t\t\t\t\t\t+ Long.toString( Runtime.getRuntime().freeMemory( )/1024/1024, 0 ) \n\t\t\t\t\t\t+ \" MB\"\n\t\t\t\t\t\t, infoPoint.x\n\t\t\t\t\t\t, infoPoint.y + (4 * lineSpacing) ); */", "}", "}", "else", "{", "// paint a black square", "g", ".", "setClip", "(", "0", ",", "0", ",", "WindowWidth", ",", "WindowHeight", ")", ";", "g", ".", "setColor", "(", "Color", ".", "black", ")", ";", "g", ".", "fillRect", "(", "0", ",", "0", ",", "WindowWidth", ",", "WindowHeight", ")", ";", "}", "if", "(", "Dragging", "==", "false", ")", "{", "//otherwise a move Cursor and should remain", "setCursor", "(", "new", "Cursor", "(", "Cursor", ".", "DEFAULT_CURSOR", ")", ")", ";", "}", "}"], "docstring": "we are overriding the default paintComponent method, grabbing the Graphics\nhandle and doing our own drawing here. Esentially this method draws a large\nblack rectangle. A drawRenderedImage is then painted doing an affine transformation\non the scaled image to position it so the the desired point is in the middle of the\nGraphics object. The picture is not scaled here because this is a slow operation\nand only needs to be done once, while moving the image is something the user is\nlikely to do more often.", "docstring_tokens": ["we", "are", "overriding", "the", "default", "paintComponent", "method", "grabbing", "the", "Graphics", "handle", "and", "doing", "our", "own", "drawing", "here", ".", "Esentially", "this", "method", "draws", "a", "large", "black", "rectangle", ".", "A", "drawRenderedImage", "is", "then", "painted", "doing", "an", "affine", "transformation", "on", "the", "scaled", "image", "to", "position", "it", "so", "the", "the", "desired", "point", "is", "in", "the", "middle", "of", "the", "Graphics", "object", ".", "The", "picture", "is", "not", "scaled", "here", "because", "this", "is", "a", "slow", "operation", "and", "only", "needs", "to", "be", "done", "once", "while", "moving", "the", "image", "is", "something", "the", "user", "is", "likely", "to", "do", "more", "often", "."]}
{"code": "bufferedOS.write(\"\\nData:\\n\".getBytes(CDM.utf8Charset));", "comments": "JCARON CHANGED", "lines": 32, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/DataDDS.java", "func_name": "DataDDS.externalize", "original_string": "public final void externalize(OutputStream os, boolean compress, boolean headers)\r\n            throws IOException {\r\n        // First, print headers\r\n        if (headers) {\r\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(os,Util.UTF8));\r\n            pw.println(\"HTTP/1.0 200 OK\");\r\n            pw.println(\"XDAP: \" + ServerVersion.DAP2_PROTOCOL_VERSION);\r\n            pw.println(\"XDODS-Server: DODS/\" + ServerVersion.DAP2_PROTOCOL_VERSION);\r\n            pw.println(\"Content-type: application/octet-stream\");\r\n            pw.println(\"Content-Description: dods-data\");\r\n            if (compress) {\r\n                pw.println(\"Content-Encoding: deflate\");\r\n            }\r\n            pw.println();\r\n            pw.flush();\r\n        }\r\n\r\n        // Buffer the output stream for better performance\r\n        OutputStream bufferedOS;\r\n        if (compress) {\r\n            // need a BufferedOutputStream - 3X performance - LOOK: why ??\r\n            bufferedOS = new BufferedOutputStream(new DeflaterOutputStream(os));\r\n        } else {\r\n            bufferedOS = new BufferedOutputStream(os);\r\n        }\r\n\r\n        // Redefine PrintWriter here, so the DDS is also compressed if necessary\r\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(bufferedOS,Util.UTF8));\r\n        print(pw);\r\n        // pw.println(\"Data:\");  // JCARON CHANGED\r\n        pw.flush();\r\n        bufferedOS.write(\"\\nData:\\n\".getBytes(CDM.utf8Charset)); // JCARON CHANGED\r\n        bufferedOS.flush();\r\n\r\n        // Use a DataOutputStream for serialize\r\n        DataOutputStream dataOS = new DataOutputStream(bufferedOS);\r\n        for (Enumeration e = getVariables(); e.hasMoreElements();) {\r\n            ClientIO bt = (ClientIO) e.nextElement();\r\n            bt.externalize(dataOS);\r\n        }\r\n        // Note: for DeflaterOutputStream, flush() is not sufficient to flush\r\n        // all buffered data\r\n        dataOS.close();\r\n    }", "language": "java", "Allcodes": "public final void externalize(OutputStream os, boolean compress, boolean headers)\r\n            throws IOException {\r\n        // First, print headers\r\n        if (headers) {\r\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(os,Util.UTF8));\r\n            pw.println(\"HTTP/1.0 200 OK\");\r\n            pw.println(\"XDAP: \" + ServerVersion.DAP2_PROTOCOL_VERSION);\r\n            pw.println(\"XDODS-Server: DODS/\" + ServerVersion.DAP2_PROTOCOL_VERSION);\r\n            pw.println(\"Content-type: application/octet-stream\");\r\n            pw.println(\"Content-Description: dods-data\");\r\n            if (compress) {\r\n                pw.println(\"Content-Encoding: deflate\");\r\n            }\r\n            pw.println();\r\n            pw.flush();\r\n        }\r\n\r\n        // Buffer the output stream for better performance\r\n        OutputStream bufferedOS;\r\n        if (compress) {\r\n            // need a BufferedOutputStream - 3X performance - LOOK: why ??\r\n            bufferedOS = new BufferedOutputStream(new DeflaterOutputStream(os));\r\n        } else {\r\n            bufferedOS = new BufferedOutputStream(os);\r\n        }\r\n\r\n        // Redefine PrintWriter here, so the DDS is also compressed if necessary\r\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(bufferedOS,Util.UTF8));\r\n        print(pw);\r\n        // pw.println(\"Data:\");  // JCARON CHANGED\r\n        pw.flush();\r\n        bufferedOS.write(\"\\nData:\\n\".getBytes(CDM.utf8Charset)); // JCARON CHANGED\r\n        bufferedOS.flush();\r\n\r\n        // Use a DataOutputStream for serialize\r\n        DataOutputStream dataOS = new DataOutputStream(bufferedOS);\r\n        for (Enumeration e = getVariables(); e.hasMoreElements();) {\r\n            ClientIO bt = (ClientIO) e.nextElement();\r\n            bt.externalize(dataOS);\r\n        }\r\n        // Note: for DeflaterOutputStream, flush() is not sufficient to flush\r\n        // all buffered data\r\n        dataOS.close();\r\n    }", "code_tokens": ["public", "final", "void", "externalize", "(", "OutputStream", "os", ",", "boolean", "compress", ",", "boolean", "headers", ")", "throws", "IOException", "{", "// First, print headers\r", "if", "(", "headers", ")", "{", "PrintWriter", "pw", "=", "new", "PrintWriter", "(", "new", "OutputStreamWriter", "(", "os", ",", "Util", ".", "UTF8", ")", ")", ";", "pw", ".", "println", "(", "\"HTTP/1.0 200 OK\"", ")", ";", "pw", ".", "println", "(", "\"XDAP: \"", "+", "ServerVersion", ".", "DAP2_PROTOCOL_VERSION", ")", ";", "pw", ".", "println", "(", "\"XDODS-Server: DODS/\"", "+", "ServerVersion", ".", "DAP2_PROTOCOL_VERSION", ")", ";", "pw", ".", "println", "(", "\"Content-type: application/octet-stream\"", ")", ";", "pw", ".", "println", "(", "\"Content-Description: dods-data\"", ")", ";", "if", "(", "compress", ")", "{", "pw", ".", "println", "(", "\"Content-Encoding: deflate\"", ")", ";", "}", "pw", ".", "println", "(", ")", ";", "pw", ".", "flush", "(", ")", ";", "}", "// Buffer the output stream for better performance\r", "OutputStream", "bufferedOS", ";", "if", "(", "compress", ")", "{", "// need a BufferedOutputStream - 3X performance - LOOK: why ??\r", "bufferedOS", "=", "new", "BufferedOutputStream", "(", "new", "DeflaterOutputStream", "(", "os", ")", ")", ";", "}", "else", "{", "bufferedOS", "=", "new", "BufferedOutputStream", "(", "os", ")", ";", "}", "// Redefine PrintWriter here, so the DDS is also compressed if necessary\r", "PrintWriter", "pw", "=", "new", "PrintWriter", "(", "new", "OutputStreamWriter", "(", "bufferedOS", ",", "Util", ".", "UTF8", ")", ")", ";", "print", "(", "pw", ")", ";", "// pw.println(\"Data:\");  // JCARON CHANGED\r", "pw", ".", "flush", "(", ")", ";", "bufferedOS", ".", "write", "(", "\"\\nData:\\n\"", ".", "getBytes", "(", "CDM", ".", "utf8Charset", ")", ")", ";", "// JCARON CHANGED\r", "bufferedOS", ".", "flush", "(", ")", ";", "// Use a DataOutputStream for serialize\r", "DataOutputStream", "dataOS", "=", "new", "DataOutputStream", "(", "bufferedOS", ")", ";", "for", "(", "Enumeration", "e", "=", "getVariables", "(", ")", ";", "e", ".", "hasMoreElements", "(", ")", ";", ")", "{", "ClientIO", "bt", "=", "(", "ClientIO", ")", "e", ".", "nextElement", "(", ")", ";", "bt", ".", "externalize", "(", "dataOS", ")", ";", "}", "// Note: for DeflaterOutputStream, flush() is not sufficient to flush\r", "// all buffered data\r", "dataOS", ".", "close", "(", ")", ";", "}"], "docstring": "Dump the dataset using externalize methods. This should create\na multipart Mime document with the binary representation of the\nDDS that is currently in memory.\n\n@param os       the <code>OutputStream</code> to use.\n@param compress <code>true</code> if we should compress the output.\n@param headers  <code>true</code> if we should print HTTP headers.\n@throws IOException thrown on any <code>OutputStream</code> exception.", "docstring_tokens": ["Dump", "the", "dataset", "using", "externalize", "methods", ".", "This", "should", "create", "a", "multipart", "Mime", "document", "with", "the", "binary", "representation", "of", "the", "DDS", "that", "is", "currently", "in", "memory", "."]}
{"code": "return null;", "comments": "nothing found", "lines": 21, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/gis/SpatialGrid.java", "func_name": "SpatialGrid.findClosest", "original_string": "public Object findClosest(Point2D pt) {\n    Object o = null;\n    int indexX = (int) ((pt.getX()-offsetX)/gridWidth);\n    int indexY = (int) ((pt.getY()-offsetY)/gridHeight);\n\n    if (debugClosest)\n      System.out.println(\"findClosest \"+ pt+ \" \"+indexX+\" \"+indexY);\n\n    if ((indexX < 0) || (indexX >= countX) || (indexY < 0) || (indexY >= countY)) // outside box\n      return null;\n\n    GridCell gwant = gridArray[indexY][indexX];\n    if (gwant.used)  // that was easy\n      return gwant.o;\n\n    // check the surrounding points along perimeter of increasing diameter\n    for (int p=1; p<Math.max(countX-1, countY-1); p++)\n      if (null != (o = findClosestAlongPerimeter(pt, indexX, indexY, p)))\n        return o;\n\n    return null; // nothing found\n  }", "language": "java", "Allcodes": "public Object findClosest(Point2D pt) {\n    Object o = null;\n    int indexX = (int) ((pt.getX()-offsetX)/gridWidth);\n    int indexY = (int) ((pt.getY()-offsetY)/gridHeight);\n\n    if (debugClosest)\n      System.out.println(\"findClosest \"+ pt+ \" \"+indexX+\" \"+indexY);\n\n    if ((indexX < 0) || (indexX >= countX) || (indexY < 0) || (indexY >= countY)) // outside box\n      return null;\n\n    GridCell gwant = gridArray[indexY][indexX];\n    if (gwant.used)  // that was easy\n      return gwant.o;\n\n    // check the surrounding points along perimeter of increasing diameter\n    for (int p=1; p<Math.max(countX-1, countY-1); p++)\n      if (null != (o = findClosestAlongPerimeter(pt, indexX, indexY, p)))\n        return o;\n\n    return null; // nothing found\n  }", "code_tokens": ["public", "Object", "findClosest", "(", "Point2D", "pt", ")", "{", "Object", "o", "=", "null", ";", "int", "indexX", "=", "(", "int", ")", "(", "(", "pt", ".", "getX", "(", ")", "-", "offsetX", ")", "/", "gridWidth", ")", ";", "int", "indexY", "=", "(", "int", ")", "(", "(", "pt", ".", "getY", "(", ")", "-", "offsetY", ")", "/", "gridHeight", ")", ";", "if", "(", "debugClosest", ")", "System", ".", "out", ".", "println", "(", "\"findClosest \"", "+", "pt", "+", "\" \"", "+", "indexX", "+", "\" \"", "+", "indexY", ")", ";", "if", "(", "(", "indexX", "<", "0", ")", "||", "(", "indexX", ">=", "countX", ")", "||", "(", "indexY", "<", "0", ")", "||", "(", "indexY", ">=", "countY", ")", ")", "// outside box", "return", "null", ";", "GridCell", "gwant", "=", "gridArray", "[", "indexY", "]", "[", "indexX", "]", ";", "if", "(", "gwant", ".", "used", ")", "// that was easy", "return", "gwant", ".", "o", ";", "// check the surrounding points along perimeter of increasing diameter", "for", "(", "int", "p", "=", "1", ";", "p", "<", "Math", ".", "max", "(", "countX", "-", "1", ",", "countY", "-", "1", ")", ";", "p", "++", ")", "if", "(", "null", "!=", "(", "o", "=", "findClosestAlongPerimeter", "(", "pt", ",", "indexX", ",", "indexY", ",", "p", ")", ")", ")", "return", "o", ";", "return", "null", ";", "// nothing found", "}"], "docstring": "Find the closest marked cell to the given point\n@param pt  find the closest marked cell to this point\n@return the object associated with the closest cell, or null if none", "docstring_tokens": ["Find", "the", "closest", "marked", "cell", "to", "the", "given", "point"]}
{"code": "url = url.toLowerCase();", "comments": "for matching purposes", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/DatasetUrl.java", "func_name": "DatasetUrl.searchPath", "original_string": "static private ServiceType searchPath(String url) {\n      if(false) { // Disable for now\n      if(url == null || url.length() == 0)\n        return null;\n      url = url.toLowerCase(); // for matching purposes\n      for(int i=0; i<FRAGPROTOCOLS.length;i++) {\n        String p = FRAGPROTOCOLS[i];\n        if(url.indexOf(\"/thredds/\"+p.toLowerCase()+\"/\")>= 0) {\n          return FRAGPROTOSVCTYPE[i];\n        }\n      }\n      }\n      return null;\n    }", "language": "java", "Allcodes": "static private ServiceType searchPath(String url) {\n      if(false) { // Disable for now\n      if(url == null || url.length() == 0)\n        return null;\n      url = url.toLowerCase(); // for matching purposes\n      for(int i=0; i<FRAGPROTOCOLS.length;i++) {\n        String p = FRAGPROTOCOLS[i];\n        if(url.indexOf(\"/thredds/\"+p.toLowerCase()+\"/\")>= 0) {\n          return FRAGPROTOSVCTYPE[i];\n        }\n      }\n      }\n      return null;\n    }", "code_tokens": ["static", "private", "ServiceType", "searchPath", "(", "String", "url", ")", "{", "if", "(", "false", ")", "{", "// Disable for now", "if", "(", "url", "==", "null", "||", "url", ".", "length", "(", ")", "==", "0", ")", "return", "null", ";", "url", "=", "url", ".", "toLowerCase", "(", ")", ";", "// for matching purposes", "for", "(", "int", "i", "=", "0", ";", "i", "<", "FRAGPROTOCOLS", ".", "length", ";", "i", "++", ")", "{", "String", "p", "=", "FRAGPROTOCOLS", "[", "i", "]", ";", "if", "(", "url", ".", "indexOf", "(", "\"/thredds/\"", "+", "p", ".", "toLowerCase", "(", ")", "+", "\"/\"", ")", ">=", "0", ")", "{", "return", "FRAGPROTOSVCTYPE", "[", "i", "]", ";", "}", "}", "}", "return", "null", ";", "}"], "docstring": "Given a url, search the path to look for protocol indicators\n\n@param url the url is to be examined\n@return The discovered ServiceType, or null", "docstring_tokens": ["Given", "a", "url", "search", "the", "path", "to", "look", "for", "protocol", "indicators"]}
{"code": "boolean isVlen = v.isVariableLength();", "comments": "&& v.getRank() > 1;", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamWriter.java", "func_name": "NcStreamWriter.sendData2", "original_string": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "language": "java", "Allcodes": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "code_tokens": ["public", "long", "sendData2", "(", "Variable", "v", ",", "Section", "section", ",", "OutputStream", "out", ",", "NcStreamCompression", "compress", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "if", "(", "show", ")", "System", ".", "out", ".", "printf", "(", "\" %s section=%s%n\"", ",", "v", ".", "getFullName", "(", ")", ",", "section", ")", ";", "boolean", "isVlen", "=", "v", ".", "isVariableLength", "(", ")", ";", "//  && v.getRank() > 1;\r", "if", "(", "isVlen", ")", "v", ".", "read", "(", "section", ")", ";", "NcStreamDataCol", "encoder", "=", "new", "NcStreamDataCol", "(", ")", ";", "NcStreamProto", ".", "DataCol", "dataProto", "=", "encoder", ".", "encodeData2", "(", "v", ".", "getFullName", "(", ")", ",", "isVlen", ",", "section", ",", "v", ".", "read", "(", "section", ")", ")", ";", "// LOOK trap error, write error message ??\r", "// dataProto.writeDelimitedTo(out);\r", "long", "size", "=", "0", ";", "size", "+=", "writeBytes", "(", "out", ",", "NcStream", ".", "MAGIC_DATA2", ")", ";", "// data version 3\r", "byte", "[", "]", "datab", "=", "dataProto", ".", "toByteArray", "(", ")", ";", "size", "+=", "NcStream", ".", "writeVInt", "(", "out", ",", "datab", ".", "length", ")", ";", "// dataProto len\r", "size", "+=", "writeBytes", "(", "out", ",", "datab", ")", ";", "// dataProto\r", "return", "size", ";", "}"], "docstring": "LOOK compression not used", "docstring_tokens": ["LOOK", "compression", "not", "used"]}
{"code": "size += writeBytes(out, NcStream.MAGIC_DATA2);", "comments": "data version 3", "lines": 14, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamWriter.java", "func_name": "NcStreamWriter.sendData2", "original_string": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "language": "java", "Allcodes": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "code_tokens": ["public", "long", "sendData2", "(", "Variable", "v", ",", "Section", "section", ",", "OutputStream", "out", ",", "NcStreamCompression", "compress", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "if", "(", "show", ")", "System", ".", "out", ".", "printf", "(", "\" %s section=%s%n\"", ",", "v", ".", "getFullName", "(", ")", ",", "section", ")", ";", "boolean", "isVlen", "=", "v", ".", "isVariableLength", "(", ")", ";", "//  && v.getRank() > 1;\r", "if", "(", "isVlen", ")", "v", ".", "read", "(", "section", ")", ";", "NcStreamDataCol", "encoder", "=", "new", "NcStreamDataCol", "(", ")", ";", "NcStreamProto", ".", "DataCol", "dataProto", "=", "encoder", ".", "encodeData2", "(", "v", ".", "getFullName", "(", ")", ",", "isVlen", ",", "section", ",", "v", ".", "read", "(", "section", ")", ")", ";", "// LOOK trap error, write error message ??\r", "// dataProto.writeDelimitedTo(out);\r", "long", "size", "=", "0", ";", "size", "+=", "writeBytes", "(", "out", ",", "NcStream", ".", "MAGIC_DATA2", ")", ";", "// data version 3\r", "byte", "[", "]", "datab", "=", "dataProto", ".", "toByteArray", "(", ")", ";", "size", "+=", "NcStream", ".", "writeVInt", "(", "out", ",", "datab", ".", "length", ")", ";", "// dataProto len\r", "size", "+=", "writeBytes", "(", "out", ",", "datab", ")", ";", "// dataProto\r", "return", "size", ";", "}"], "docstring": "LOOK compression not used", "docstring_tokens": ["LOOK", "compression", "not", "used"]}
{"code": "size += NcStream.writeVInt(out, datab.length);", "comments": "dataProto len", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamWriter.java", "func_name": "NcStreamWriter.sendData2", "original_string": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "language": "java", "Allcodes": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "code_tokens": ["public", "long", "sendData2", "(", "Variable", "v", ",", "Section", "section", ",", "OutputStream", "out", ",", "NcStreamCompression", "compress", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "if", "(", "show", ")", "System", ".", "out", ".", "printf", "(", "\" %s section=%s%n\"", ",", "v", ".", "getFullName", "(", ")", ",", "section", ")", ";", "boolean", "isVlen", "=", "v", ".", "isVariableLength", "(", ")", ";", "//  && v.getRank() > 1;\r", "if", "(", "isVlen", ")", "v", ".", "read", "(", "section", ")", ";", "NcStreamDataCol", "encoder", "=", "new", "NcStreamDataCol", "(", ")", ";", "NcStreamProto", ".", "DataCol", "dataProto", "=", "encoder", ".", "encodeData2", "(", "v", ".", "getFullName", "(", ")", ",", "isVlen", ",", "section", ",", "v", ".", "read", "(", "section", ")", ")", ";", "// LOOK trap error, write error message ??\r", "// dataProto.writeDelimitedTo(out);\r", "long", "size", "=", "0", ";", "size", "+=", "writeBytes", "(", "out", ",", "NcStream", ".", "MAGIC_DATA2", ")", ";", "// data version 3\r", "byte", "[", "]", "datab", "=", "dataProto", ".", "toByteArray", "(", ")", ";", "size", "+=", "NcStream", ".", "writeVInt", "(", "out", ",", "datab", ".", "length", ")", ";", "// dataProto len\r", "size", "+=", "writeBytes", "(", "out", ",", "datab", ")", ";", "// dataProto\r", "return", "size", ";", "}"], "docstring": "LOOK compression not used", "docstring_tokens": ["LOOK", "compression", "not", "used"]}
{"code": "size += writeBytes(out, datab);", "comments": "dataProto", "lines": 18, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/stream/NcStreamWriter.java", "func_name": "NcStreamWriter.sendData2", "original_string": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "language": "java", "Allcodes": "public long sendData2(Variable v, Section section, OutputStream out, NcStreamCompression compress) throws IOException, InvalidRangeException {\r\n    if (show) System.out.printf(\" %s section=%s%n\", v.getFullName(), section);\r\n\r\n    boolean isVlen = v.isVariableLength(); //  && v.getRank() > 1;\r\n    if (isVlen)\r\n      v.read(section);\r\n    NcStreamDataCol encoder = new NcStreamDataCol();\r\n    NcStreamProto.DataCol dataProto = encoder.encodeData2(v.getFullName(), isVlen, section, v.read(section));\r\n\r\n    // LOOK trap error, write error message ??\r\n\r\n    // dataProto.writeDelimitedTo(out);\r\n    long size = 0;\r\n    size += writeBytes(out, NcStream.MAGIC_DATA2); // data version 3\r\n\r\n    byte[] datab = dataProto.toByteArray();\r\n    size += NcStream.writeVInt(out, datab.length); // dataProto len\r\n    size += writeBytes(out, datab); // dataProto\r\n    return size;\r\n  }", "code_tokens": ["public", "long", "sendData2", "(", "Variable", "v", ",", "Section", "section", ",", "OutputStream", "out", ",", "NcStreamCompression", "compress", ")", "throws", "IOException", ",", "InvalidRangeException", "{", "if", "(", "show", ")", "System", ".", "out", ".", "printf", "(", "\" %s section=%s%n\"", ",", "v", ".", "getFullName", "(", ")", ",", "section", ")", ";", "boolean", "isVlen", "=", "v", ".", "isVariableLength", "(", ")", ";", "//  && v.getRank() > 1;\r", "if", "(", "isVlen", ")", "v", ".", "read", "(", "section", ")", ";", "NcStreamDataCol", "encoder", "=", "new", "NcStreamDataCol", "(", ")", ";", "NcStreamProto", ".", "DataCol", "dataProto", "=", "encoder", ".", "encodeData2", "(", "v", ".", "getFullName", "(", ")", ",", "isVlen", ",", "section", ",", "v", ".", "read", "(", "section", ")", ")", ";", "// LOOK trap error, write error message ??\r", "// dataProto.writeDelimitedTo(out);\r", "long", "size", "=", "0", ";", "size", "+=", "writeBytes", "(", "out", ",", "NcStream", ".", "MAGIC_DATA2", ")", ";", "// data version 3\r", "byte", "[", "]", "datab", "=", "dataProto", ".", "toByteArray", "(", ")", ";", "size", "+=", "NcStream", ".", "writeVInt", "(", "out", ",", "datab", ".", "length", ")", ";", "// dataProto len\r", "size", "+=", "writeBytes", "(", "out", ",", "datab", ")", ";", "// dataProto\r", "return", "size", ";", "}"], "docstring": "LOOK compression not used", "docstring_tokens": ["LOOK", "compression", "not", "used"]}
{"code": "q.addFirst(abspath);", "comments": "prime the search queue", "lines": 11, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapUtil.java", "func_name": "DapUtil.locateFile", "original_string": "static public String\n    locateFile(String filename, String abspath, boolean wantdir)\n    {\n        Deque<String> q = new ArrayDeque<String>();\n        // clean up the path and filename\n        filename = filename.trim().replace('\\\\', '/');\n        abspath = abspath.trim().replace('\\\\', '/');\n        if(filename.charAt(0) == '/') filename = filename.substring(1);\n        if(filename.endsWith(\"/\")) filename = filename.substring(0, filename.length() - 1);\n        if(abspath.endsWith(\"/\")) abspath = abspath.substring(0, abspath.length() - 1);\n        q.addFirst(abspath);  // prime the search queue\n\n        for(; ; ) {  // breadth first search\n            String currentpath = q.poll();\n            if(currentpath == null) break; // done searching\n            File current = new File(currentpath);\n            File[] contents = current.listFiles();\n            if(contents != null) {\n                for(File subfile : contents) {\n                    if(!subfile.getName().equals(filename)) continue;\n                    if((wantdir && subfile.isDirectory())\n                            || (!wantdir && subfile.isFile())) {\n                        // Assume this is it\n                        return DapUtil.canonicalpath(subfile.getAbsolutePath());\n                    }\n                }\n                for(File subfile : contents) {\n                    if(subfile.isDirectory())\n                        q.addFirst(currentpath + \"/\" + subfile.getName());\n                }\n            }\n        }\n        return null;\n    }", "language": "java", "Allcodes": "static public String\n    locateFile(String filename, String abspath, boolean wantdir)\n    {\n        Deque<String> q = new ArrayDeque<String>();\n        // clean up the path and filename\n        filename = filename.trim().replace('\\\\', '/');\n        abspath = abspath.trim().replace('\\\\', '/');\n        if(filename.charAt(0) == '/') filename = filename.substring(1);\n        if(filename.endsWith(\"/\")) filename = filename.substring(0, filename.length() - 1);\n        if(abspath.endsWith(\"/\")) abspath = abspath.substring(0, abspath.length() - 1);\n        q.addFirst(abspath);  // prime the search queue\n\n        for(; ; ) {  // breadth first search\n            String currentpath = q.poll();\n            if(currentpath == null) break; // done searching\n            File current = new File(currentpath);\n            File[] contents = current.listFiles();\n            if(contents != null) {\n                for(File subfile : contents) {\n                    if(!subfile.getName().equals(filename)) continue;\n                    if((wantdir && subfile.isDirectory())\n                            || (!wantdir && subfile.isFile())) {\n                        // Assume this is it\n                        return DapUtil.canonicalpath(subfile.getAbsolutePath());\n                    }\n                }\n                for(File subfile : contents) {\n                    if(subfile.isDirectory())\n                        q.addFirst(currentpath + \"/\" + subfile.getName());\n                }\n            }\n        }\n        return null;\n    }", "code_tokens": ["static", "public", "String", "locateFile", "(", "String", "filename", ",", "String", "abspath", ",", "boolean", "wantdir", ")", "{", "Deque", "<", "String", ">", "q", "=", "new", "ArrayDeque", "<", "String", ">", "(", ")", ";", "// clean up the path and filename", "filename", "=", "filename", ".", "trim", "(", ")", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "abspath", "=", "abspath", ".", "trim", "(", ")", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "if", "(", "filename", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "filename", "=", "filename", ".", "substring", "(", "1", ")", ";", "if", "(", "filename", ".", "endsWith", "(", "\"/\"", ")", ")", "filename", "=", "filename", ".", "substring", "(", "0", ",", "filename", ".", "length", "(", ")", "-", "1", ")", ";", "if", "(", "abspath", ".", "endsWith", "(", "\"/\"", ")", ")", "abspath", "=", "abspath", ".", "substring", "(", "0", ",", "abspath", ".", "length", "(", ")", "-", "1", ")", ";", "q", ".", "addFirst", "(", "abspath", ")", ";", "// prime the search queue", "for", "(", ";", ";", ")", "{", "// breadth first search", "String", "currentpath", "=", "q", ".", "poll", "(", ")", ";", "if", "(", "currentpath", "==", "null", ")", "break", ";", "// done searching", "File", "current", "=", "new", "File", "(", "currentpath", ")", ";", "File", "[", "]", "contents", "=", "current", ".", "listFiles", "(", ")", ";", "if", "(", "contents", "!=", "null", ")", "{", "for", "(", "File", "subfile", ":", "contents", ")", "{", "if", "(", "!", "subfile", ".", "getName", "(", ")", ".", "equals", "(", "filename", ")", ")", "continue", ";", "if", "(", "(", "wantdir", "&&", "subfile", ".", "isDirectory", "(", ")", ")", "||", "(", "!", "wantdir", "&&", "subfile", ".", "isFile", "(", ")", ")", ")", "{", "// Assume this is it", "return", "DapUtil", ".", "canonicalpath", "(", "subfile", ".", "getAbsolutePath", "(", ")", ")", ";", "}", "}", "for", "(", "File", "subfile", ":", "contents", ")", "{", "if", "(", "subfile", ".", "isDirectory", "(", ")", ")", "q", ".", "addFirst", "(", "currentpath", "+", "\"/\"", "+", "subfile", ".", "getName", "(", ")", ")", ";", "}", "}", "}", "return", "null", ";", "}"], "docstring": "Walk the specified subtree dir tree to try to locate file|dir named filename.\nUse breadth first search.\n\n@param filename Name of the file|dir to locate\n@param abspath  Absolute path from which to start search\n@param wantdir  True if we are looking for a directory,\nfalse if we are looking for a file\n@return absolute path of the file or null", "docstring_tokens": ["Walk", "the", "specified", "subtree", "dir", "tree", "to", "try", "to", "locate", "file|dir", "named", "filename", ".", "Use", "breadth", "first", "search", "."]}
{"code": "if(currentpath == null) break;", "comments": "done searching", "lines": 15, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapUtil.java", "func_name": "DapUtil.locateFile", "original_string": "static public String\n    locateFile(String filename, String abspath, boolean wantdir)\n    {\n        Deque<String> q = new ArrayDeque<String>();\n        // clean up the path and filename\n        filename = filename.trim().replace('\\\\', '/');\n        abspath = abspath.trim().replace('\\\\', '/');\n        if(filename.charAt(0) == '/') filename = filename.substring(1);\n        if(filename.endsWith(\"/\")) filename = filename.substring(0, filename.length() - 1);\n        if(abspath.endsWith(\"/\")) abspath = abspath.substring(0, abspath.length() - 1);\n        q.addFirst(abspath);  // prime the search queue\n\n        for(; ; ) {  // breadth first search\n            String currentpath = q.poll();\n            if(currentpath == null) break; // done searching\n            File current = new File(currentpath);\n            File[] contents = current.listFiles();\n            if(contents != null) {\n                for(File subfile : contents) {\n                    if(!subfile.getName().equals(filename)) continue;\n                    if((wantdir && subfile.isDirectory())\n                            || (!wantdir && subfile.isFile())) {\n                        // Assume this is it\n                        return DapUtil.canonicalpath(subfile.getAbsolutePath());\n                    }\n                }\n                for(File subfile : contents) {\n                    if(subfile.isDirectory())\n                        q.addFirst(currentpath + \"/\" + subfile.getName());\n                }\n            }\n        }\n        return null;\n    }", "language": "java", "Allcodes": "static public String\n    locateFile(String filename, String abspath, boolean wantdir)\n    {\n        Deque<String> q = new ArrayDeque<String>();\n        // clean up the path and filename\n        filename = filename.trim().replace('\\\\', '/');\n        abspath = abspath.trim().replace('\\\\', '/');\n        if(filename.charAt(0) == '/') filename = filename.substring(1);\n        if(filename.endsWith(\"/\")) filename = filename.substring(0, filename.length() - 1);\n        if(abspath.endsWith(\"/\")) abspath = abspath.substring(0, abspath.length() - 1);\n        q.addFirst(abspath);  // prime the search queue\n\n        for(; ; ) {  // breadth first search\n            String currentpath = q.poll();\n            if(currentpath == null) break; // done searching\n            File current = new File(currentpath);\n            File[] contents = current.listFiles();\n            if(contents != null) {\n                for(File subfile : contents) {\n                    if(!subfile.getName().equals(filename)) continue;\n                    if((wantdir && subfile.isDirectory())\n                            || (!wantdir && subfile.isFile())) {\n                        // Assume this is it\n                        return DapUtil.canonicalpath(subfile.getAbsolutePath());\n                    }\n                }\n                for(File subfile : contents) {\n                    if(subfile.isDirectory())\n                        q.addFirst(currentpath + \"/\" + subfile.getName());\n                }\n            }\n        }\n        return null;\n    }", "code_tokens": ["static", "public", "String", "locateFile", "(", "String", "filename", ",", "String", "abspath", ",", "boolean", "wantdir", ")", "{", "Deque", "<", "String", ">", "q", "=", "new", "ArrayDeque", "<", "String", ">", "(", ")", ";", "// clean up the path and filename", "filename", "=", "filename", ".", "trim", "(", ")", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "abspath", "=", "abspath", ".", "trim", "(", ")", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "if", "(", "filename", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "filename", "=", "filename", ".", "substring", "(", "1", ")", ";", "if", "(", "filename", ".", "endsWith", "(", "\"/\"", ")", ")", "filename", "=", "filename", ".", "substring", "(", "0", ",", "filename", ".", "length", "(", ")", "-", "1", ")", ";", "if", "(", "abspath", ".", "endsWith", "(", "\"/\"", ")", ")", "abspath", "=", "abspath", ".", "substring", "(", "0", ",", "abspath", ".", "length", "(", ")", "-", "1", ")", ";", "q", ".", "addFirst", "(", "abspath", ")", ";", "// prime the search queue", "for", "(", ";", ";", ")", "{", "// breadth first search", "String", "currentpath", "=", "q", ".", "poll", "(", ")", ";", "if", "(", "currentpath", "==", "null", ")", "break", ";", "// done searching", "File", "current", "=", "new", "File", "(", "currentpath", ")", ";", "File", "[", "]", "contents", "=", "current", ".", "listFiles", "(", ")", ";", "if", "(", "contents", "!=", "null", ")", "{", "for", "(", "File", "subfile", ":", "contents", ")", "{", "if", "(", "!", "subfile", ".", "getName", "(", ")", ".", "equals", "(", "filename", ")", ")", "continue", ";", "if", "(", "(", "wantdir", "&&", "subfile", ".", "isDirectory", "(", ")", ")", "||", "(", "!", "wantdir", "&&", "subfile", ".", "isFile", "(", ")", ")", ")", "{", "// Assume this is it", "return", "DapUtil", ".", "canonicalpath", "(", "subfile", ".", "getAbsolutePath", "(", ")", ")", ";", "}", "}", "for", "(", "File", "subfile", ":", "contents", ")", "{", "if", "(", "subfile", ".", "isDirectory", "(", ")", ")", "q", ".", "addFirst", "(", "currentpath", "+", "\"/\"", "+", "subfile", ".", "getName", "(", ")", ")", ";", "}", "}", "}", "return", "null", ";", "}"], "docstring": "Walk the specified subtree dir tree to try to locate file|dir named filename.\nUse breadth first search.\n\n@param filename Name of the file|dir to locate\n@param abspath  Absolute path from which to start search\n@param wantdir  True if we are looking for a directory,\nfalse if we are looking for a file\n@return absolute path of the file or null", "docstring_tokens": ["Walk", "the", "specified", "subtree", "dir", "tree", "to", "try", "to", "locate", "file|dir", "named", "filename", ".", "Use", "breadth", "first", "search", "."]}
{"code": "List<String> allprotocols = new ArrayList<>();", "comments": "all leading protocols upto path or host", "lines": 9, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapUtil.java", "func_name": "DapUtil.getProtocols", "original_string": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "language": "java", "Allcodes": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "code_tokens": ["static", "public", "List", "<", "String", ">", "getProtocols", "(", "String", "url", ",", "int", "[", "]", "breakpoint", ")", "{", "// break off any leading protocols;", "// there may be more than one.", "// Watch out for Windows paths starting with a drive letter.", "// Each protocol has trailing ':'  removed", "List", "<", "String", ">", "allprotocols", "=", "new", "ArrayList", "<>", "(", ")", ";", "// all leading protocols upto path or host", "// Note, we cannot use split because of the context sensitivity", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", "url", ")", ";", "int", "protosize", "=", "0", ";", "for", "(", ";", ";", ")", "{", "int", "index", "=", "buf", ".", "indexOf", "(", "\":\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "// no more protocols", "String", "protocol", "=", "buf", ".", "substring", "(", "0", ",", "index", ")", ";", "// Check for windows drive letter", "if", "(", "index", "==", "1", "//=>|protocol| == 1 => windows drive letter", "&&", "\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"", ".", "indexOf", "(", "buf", ".", "charAt", "(", "0", ")", ")", ">=", "0", ")", "break", ";", "allprotocols", ".", "add", "(", "protocol", ")", ";", "buf", ".", "delete", "(", "0", ",", "index", "+", "1", ")", ";", "// remove the leading protocol", "protosize", "+=", "(", "index", "+", "1", ")", ";", "if", "(", "buf", ".", "indexOf", "(", "\"/\"", ")", "==", "0", ")", "break", ";", "// anything after this is not a protocol", "}", "breakpoint", "[", "0", "]", "=", "protosize", ";", "return", "allprotocols", ";", "}"], "docstring": "Return the set of leading protocols for a url; may be more than one.\n\n@param url        the url whose protocols to return\n@param breakpoint return the index past last protocol\n@return list of leading protocols without the trailing :", "docstring_tokens": ["Return", "the", "set", "of", "leading", "protocols", "for", "a", "url", ";", "may", "be", "more", "than", "one", "."]}
{"code": "if(index < 0) break;", "comments": "no more protocols", "lines": 16, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapUtil.java", "func_name": "DapUtil.getProtocols", "original_string": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "language": "java", "Allcodes": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "code_tokens": ["static", "public", "List", "<", "String", ">", "getProtocols", "(", "String", "url", ",", "int", "[", "]", "breakpoint", ")", "{", "// break off any leading protocols;", "// there may be more than one.", "// Watch out for Windows paths starting with a drive letter.", "// Each protocol has trailing ':'  removed", "List", "<", "String", ">", "allprotocols", "=", "new", "ArrayList", "<>", "(", ")", ";", "// all leading protocols upto path or host", "// Note, we cannot use split because of the context sensitivity", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", "url", ")", ";", "int", "protosize", "=", "0", ";", "for", "(", ";", ";", ")", "{", "int", "index", "=", "buf", ".", "indexOf", "(", "\":\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "// no more protocols", "String", "protocol", "=", "buf", ".", "substring", "(", "0", ",", "index", ")", ";", "// Check for windows drive letter", "if", "(", "index", "==", "1", "//=>|protocol| == 1 => windows drive letter", "&&", "\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"", ".", "indexOf", "(", "buf", ".", "charAt", "(", "0", ")", ")", ">=", "0", ")", "break", ";", "allprotocols", ".", "add", "(", "protocol", ")", ";", "buf", ".", "delete", "(", "0", ",", "index", "+", "1", ")", ";", "// remove the leading protocol", "protosize", "+=", "(", "index", "+", "1", ")", ";", "if", "(", "buf", ".", "indexOf", "(", "\"/\"", ")", "==", "0", ")", "break", ";", "// anything after this is not a protocol", "}", "breakpoint", "[", "0", "]", "=", "protosize", ";", "return", "allprotocols", ";", "}"], "docstring": "Return the set of leading protocols for a url; may be more than one.\n\n@param url        the url whose protocols to return\n@param breakpoint return the index past last protocol\n@return list of leading protocols without the trailing :", "docstring_tokens": ["Return", "the", "set", "of", "leading", "protocols", "for", "a", "url", ";", "may", "be", "more", "than", "one", "."]}
{"code": "buf.delete(0, index + 1);", "comments": "remove the leading protocol", "lines": 23, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapUtil.java", "func_name": "DapUtil.getProtocols", "original_string": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "language": "java", "Allcodes": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "code_tokens": ["static", "public", "List", "<", "String", ">", "getProtocols", "(", "String", "url", ",", "int", "[", "]", "breakpoint", ")", "{", "// break off any leading protocols;", "// there may be more than one.", "// Watch out for Windows paths starting with a drive letter.", "// Each protocol has trailing ':'  removed", "List", "<", "String", ">", "allprotocols", "=", "new", "ArrayList", "<>", "(", ")", ";", "// all leading protocols upto path or host", "// Note, we cannot use split because of the context sensitivity", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", "url", ")", ";", "int", "protosize", "=", "0", ";", "for", "(", ";", ";", ")", "{", "int", "index", "=", "buf", ".", "indexOf", "(", "\":\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "// no more protocols", "String", "protocol", "=", "buf", ".", "substring", "(", "0", ",", "index", ")", ";", "// Check for windows drive letter", "if", "(", "index", "==", "1", "//=>|protocol| == 1 => windows drive letter", "&&", "\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"", ".", "indexOf", "(", "buf", ".", "charAt", "(", "0", ")", ")", ">=", "0", ")", "break", ";", "allprotocols", ".", "add", "(", "protocol", ")", ";", "buf", ".", "delete", "(", "0", ",", "index", "+", "1", ")", ";", "// remove the leading protocol", "protosize", "+=", "(", "index", "+", "1", ")", ";", "if", "(", "buf", ".", "indexOf", "(", "\"/\"", ")", "==", "0", ")", "break", ";", "// anything after this is not a protocol", "}", "breakpoint", "[", "0", "]", "=", "protosize", ";", "return", "allprotocols", ";", "}"], "docstring": "Return the set of leading protocols for a url; may be more than one.\n\n@param url        the url whose protocols to return\n@param breakpoint return the index past last protocol\n@return list of leading protocols without the trailing :", "docstring_tokens": ["Return", "the", "set", "of", "leading", "protocols", "for", "a", "url", ";", "may", "be", "more", "than", "one", "."]}
{"code": "break;", "comments": "anything after this is not a protocol", "lines": 26, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/DapUtil.java", "func_name": "DapUtil.getProtocols", "original_string": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "language": "java", "Allcodes": "static public List<String>\n    getProtocols(String url, int[] breakpoint)\n    {\n        // break off any leading protocols;\n        // there may be more than one.\n        // Watch out for Windows paths starting with a drive letter.\n        // Each protocol has trailing ':'  removed\n\n        List<String> allprotocols = new ArrayList<>(); // all leading protocols upto path or host\n\n        // Note, we cannot use split because of the context sensitivity\n        StringBuilder buf = new StringBuilder(url);\n        int protosize = 0;\n        for(; ; ) {\n            int index = buf.indexOf(\":\");\n            if(index < 0) break; // no more protocols\n            String protocol = buf.substring(0, index);\n            // Check for windows drive letter\n            if(index == 1 //=>|protocol| == 1 => windows drive letter\n                    && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                    .indexOf(buf.charAt(0)) >= 0) break;\n            allprotocols.add(protocol);\n            buf.delete(0, index + 1); // remove the leading protocol\n            protosize += (index + 1);\n            if(buf.indexOf(\"/\") == 0)\n                break; // anything after this is not a protocol\n        }\n        breakpoint[0] = protosize;\n        return allprotocols;\n    }", "code_tokens": ["static", "public", "List", "<", "String", ">", "getProtocols", "(", "String", "url", ",", "int", "[", "]", "breakpoint", ")", "{", "// break off any leading protocols;", "// there may be more than one.", "// Watch out for Windows paths starting with a drive letter.", "// Each protocol has trailing ':'  removed", "List", "<", "String", ">", "allprotocols", "=", "new", "ArrayList", "<>", "(", ")", ";", "// all leading protocols upto path or host", "// Note, we cannot use split because of the context sensitivity", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", "url", ")", ";", "int", "protosize", "=", "0", ";", "for", "(", ";", ";", ")", "{", "int", "index", "=", "buf", ".", "indexOf", "(", "\":\"", ")", ";", "if", "(", "index", "<", "0", ")", "break", ";", "// no more protocols", "String", "protocol", "=", "buf", ".", "substring", "(", "0", ",", "index", ")", ";", "// Check for windows drive letter", "if", "(", "index", "==", "1", "//=>|protocol| == 1 => windows drive letter", "&&", "\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"", ".", "indexOf", "(", "buf", ".", "charAt", "(", "0", ")", ")", ">=", "0", ")", "break", ";", "allprotocols", ".", "add", "(", "protocol", ")", ";", "buf", ".", "delete", "(", "0", ",", "index", "+", "1", ")", ";", "// remove the leading protocol", "protosize", "+=", "(", "index", "+", "1", ")", ";", "if", "(", "buf", ".", "indexOf", "(", "\"/\"", ")", "==", "0", ")", "break", ";", "// anything after this is not a protocol", "}", "breakpoint", "[", "0", "]", "=", "protosize", ";", "return", "allprotocols", ";", "}"], "docstring": "Return the set of leading protocols for a url; may be more than one.\n\n@param url        the url whose protocols to return\n@param breakpoint return the index past last protocol\n@return list of leading protocols without the trailing :", "docstring_tokens": ["Return", "the", "set", "of", "leading", "protocols", "for", "a", "url", ";", "may", "be", "more", "than", "one", "."]}
{"code": "newdecl.setParent(this);", "comments": "Cross link", "lines": 32, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/dmr/DapGroup.java", "func_name": "DapGroup.addDecl", "original_string": "public void\n    addDecl(DapNode newdecl)\n            throws DapException\n    {\n        DapSort newsort = newdecl.getSort();\n        String newname = newdecl.getShortName();\n        boolean suppress = false;\n        // Look for name conflicts (ignore anonymous dimensions)\n        if(newsort != DapSort.DIMENSION || newname != null) {\n            for(DapNode decl : decls) {\n                if(newsort == decl.getSort()\n                        && newname.equals(decl.getShortName()))\n                    throw new DapException(\"DapGroup: attempt to add duplicate decl: \" + newname);\n            }\n        } else { // Anonymous\n            DapDimension anon = (DapDimension) newdecl;\n            assert (newsort == DapSort.DIMENSION && newname == null);\n            // Search for matching anonymous dimension\n            boolean found = false;\n            for(DapDimension dim : dimensions) {\n                if(!dim.isShared() && dim.getSize() == anon.getSize()) {\n                    found = true;\n                    break;\n                }\n            }\n            // Define the anondecl in root group\n            if(!found && !isTopLevel()) getDataset().addDecl(anon);\n            suppress = found || !isTopLevel();\n        }\n        if(!suppress) {\n            decls.add(newdecl);\n            newdecl.setParent(this); // Cross link\n        }\n        switch (newdecl.getSort()) {\n        case ATTRIBUTE:\n        case ATTRIBUTESET:\n        case OTHERXML:\n            super.addAttribute((DapAttribute) newdecl);\n            break;\n        case DIMENSION:\n            if(!suppress)\n                dimensions.add((DapDimension) newdecl);\n            break;\n        case ENUMERATION:\n            enums.add((DapEnumeration) newdecl);\n            break;\n        case ATOMICTYPE:\n            break; // do nothing\n        case STRUCTURE:\n        case SEQUENCE:\n            compounds.add((DapStructure)newdecl);\n            break;\n        case VARIABLE:\n            variables.add((DapVariable) newdecl);\n            break;\n        case GROUP:\n        case DATASET:\n            if(this != (DapGroup) newdecl)\n                groups.add((DapGroup) newdecl);\n            break;\n        default:\n            throw new ClassCastException(newdecl.getShortName());\n        }\n    }", "language": "java", "Allcodes": "public void\n    addDecl(DapNode newdecl)\n            throws DapException\n    {\n        DapSort newsort = newdecl.getSort();\n        String newname = newdecl.getShortName();\n        boolean suppress = false;\n        // Look for name conflicts (ignore anonymous dimensions)\n        if(newsort != DapSort.DIMENSION || newname != null) {\n            for(DapNode decl : decls) {\n                if(newsort == decl.getSort()\n                        && newname.equals(decl.getShortName()))\n                    throw new DapException(\"DapGroup: attempt to add duplicate decl: \" + newname);\n            }\n        } else { // Anonymous\n            DapDimension anon = (DapDimension) newdecl;\n            assert (newsort == DapSort.DIMENSION && newname == null);\n            // Search for matching anonymous dimension\n            boolean found = false;\n            for(DapDimension dim : dimensions) {\n                if(!dim.isShared() && dim.getSize() == anon.getSize()) {\n                    found = true;\n                    break;\n                }\n            }\n            // Define the anondecl in root group\n            if(!found && !isTopLevel()) getDataset().addDecl(anon);\n            suppress = found || !isTopLevel();\n        }\n        if(!suppress) {\n            decls.add(newdecl);\n            newdecl.setParent(this); // Cross link\n        }\n        switch (newdecl.getSort()) {\n        case ATTRIBUTE:\n        case ATTRIBUTESET:\n        case OTHERXML:\n            super.addAttribute((DapAttribute) newdecl);\n            break;\n        case DIMENSION:\n            if(!suppress)\n                dimensions.add((DapDimension) newdecl);\n            break;\n        case ENUMERATION:\n            enums.add((DapEnumeration) newdecl);\n            break;\n        case ATOMICTYPE:\n            break; // do nothing\n        case STRUCTURE:\n        case SEQUENCE:\n            compounds.add((DapStructure)newdecl);\n            break;\n        case VARIABLE:\n            variables.add((DapVariable) newdecl);\n            break;\n        case GROUP:\n        case DATASET:\n            if(this != (DapGroup) newdecl)\n                groups.add((DapGroup) newdecl);\n            break;\n        default:\n            throw new ClassCastException(newdecl.getShortName());\n        }\n    }", "code_tokens": ["public", "void", "addDecl", "(", "DapNode", "newdecl", ")", "throws", "DapException", "{", "DapSort", "newsort", "=", "newdecl", ".", "getSort", "(", ")", ";", "String", "newname", "=", "newdecl", ".", "getShortName", "(", ")", ";", "boolean", "suppress", "=", "false", ";", "// Look for name conflicts (ignore anonymous dimensions)", "if", "(", "newsort", "!=", "DapSort", ".", "DIMENSION", "||", "newname", "!=", "null", ")", "{", "for", "(", "DapNode", "decl", ":", "decls", ")", "{", "if", "(", "newsort", "==", "decl", ".", "getSort", "(", ")", "&&", "newname", ".", "equals", "(", "decl", ".", "getShortName", "(", ")", ")", ")", "throw", "new", "DapException", "(", "\"DapGroup: attempt to add duplicate decl: \"", "+", "newname", ")", ";", "}", "}", "else", "{", "// Anonymous", "DapDimension", "anon", "=", "(", "DapDimension", ")", "newdecl", ";", "assert", "(", "newsort", "==", "DapSort", ".", "DIMENSION", "&&", "newname", "==", "null", ")", ";", "// Search for matching anonymous dimension", "boolean", "found", "=", "false", ";", "for", "(", "DapDimension", "dim", ":", "dimensions", ")", "{", "if", "(", "!", "dim", ".", "isShared", "(", ")", "&&", "dim", ".", "getSize", "(", ")", "==", "anon", ".", "getSize", "(", ")", ")", "{", "found", "=", "true", ";", "break", ";", "}", "}", "// Define the anondecl in root group", "if", "(", "!", "found", "&&", "!", "isTopLevel", "(", ")", ")", "getDataset", "(", ")", ".", "addDecl", "(", "anon", ")", ";", "suppress", "=", "found", "||", "!", "isTopLevel", "(", ")", ";", "}", "if", "(", "!", "suppress", ")", "{", "decls", ".", "add", "(", "newdecl", ")", ";", "newdecl", ".", "setParent", "(", "this", ")", ";", "// Cross link", "}", "switch", "(", "newdecl", ".", "getSort", "(", ")", ")", "{", "case", "ATTRIBUTE", ":", "case", "ATTRIBUTESET", ":", "case", "OTHERXML", ":", "super", ".", "addAttribute", "(", "(", "DapAttribute", ")", "newdecl", ")", ";", "break", ";", "case", "DIMENSION", ":", "if", "(", "!", "suppress", ")", "dimensions", ".", "add", "(", "(", "DapDimension", ")", "newdecl", ")", ";", "break", ";", "case", "ENUMERATION", ":", "enums", ".", "add", "(", "(", "DapEnumeration", ")", "newdecl", ")", ";", "break", ";", "case", "ATOMICTYPE", ":", "break", ";", "// do nothing", "case", "STRUCTURE", ":", "case", "SEQUENCE", ":", "compounds", ".", "add", "(", "(", "DapStructure", ")", "newdecl", ")", ";", "break", ";", "case", "VARIABLE", ":", "variables", ".", "add", "(", "(", "DapVariable", ")", "newdecl", ")", ";", "break", ";", "case", "GROUP", ":", "case", "DATASET", ":", "if", "(", "this", "!=", "(", "DapGroup", ")", "newdecl", ")", "groups", ".", "add", "(", "(", "DapGroup", ")", "newdecl", ")", ";", "break", ";", "default", ":", "throw", "new", "ClassCastException", "(", "newdecl", ".", "getShortName", "(", ")", ")", ";", "}", "}"], "docstring": "Add single declaration", "docstring_tokens": ["Add", "single", "declaration"]}
{"code": "break;", "comments": "do nothing", "lines": 48, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/dmr/DapGroup.java", "func_name": "DapGroup.addDecl", "original_string": "public void\n    addDecl(DapNode newdecl)\n            throws DapException\n    {\n        DapSort newsort = newdecl.getSort();\n        String newname = newdecl.getShortName();\n        boolean suppress = false;\n        // Look for name conflicts (ignore anonymous dimensions)\n        if(newsort != DapSort.DIMENSION || newname != null) {\n            for(DapNode decl : decls) {\n                if(newsort == decl.getSort()\n                        && newname.equals(decl.getShortName()))\n                    throw new DapException(\"DapGroup: attempt to add duplicate decl: \" + newname);\n            }\n        } else { // Anonymous\n            DapDimension anon = (DapDimension) newdecl;\n            assert (newsort == DapSort.DIMENSION && newname == null);\n            // Search for matching anonymous dimension\n            boolean found = false;\n            for(DapDimension dim : dimensions) {\n                if(!dim.isShared() && dim.getSize() == anon.getSize()) {\n                    found = true;\n                    break;\n                }\n            }\n            // Define the anondecl in root group\n            if(!found && !isTopLevel()) getDataset().addDecl(anon);\n            suppress = found || !isTopLevel();\n        }\n        if(!suppress) {\n            decls.add(newdecl);\n            newdecl.setParent(this); // Cross link\n        }\n        switch (newdecl.getSort()) {\n        case ATTRIBUTE:\n        case ATTRIBUTESET:\n        case OTHERXML:\n            super.addAttribute((DapAttribute) newdecl);\n            break;\n        case DIMENSION:\n            if(!suppress)\n                dimensions.add((DapDimension) newdecl);\n            break;\n        case ENUMERATION:\n            enums.add((DapEnumeration) newdecl);\n            break;\n        case ATOMICTYPE:\n            break; // do nothing\n        case STRUCTURE:\n        case SEQUENCE:\n            compounds.add((DapStructure)newdecl);\n            break;\n        case VARIABLE:\n            variables.add((DapVariable) newdecl);\n            break;\n        case GROUP:\n        case DATASET:\n            if(this != (DapGroup) newdecl)\n                groups.add((DapGroup) newdecl);\n            break;\n        default:\n            throw new ClassCastException(newdecl.getShortName());\n        }\n    }", "language": "java", "Allcodes": "public void\n    addDecl(DapNode newdecl)\n            throws DapException\n    {\n        DapSort newsort = newdecl.getSort();\n        String newname = newdecl.getShortName();\n        boolean suppress = false;\n        // Look for name conflicts (ignore anonymous dimensions)\n        if(newsort != DapSort.DIMENSION || newname != null) {\n            for(DapNode decl : decls) {\n                if(newsort == decl.getSort()\n                        && newname.equals(decl.getShortName()))\n                    throw new DapException(\"DapGroup: attempt to add duplicate decl: \" + newname);\n            }\n        } else { // Anonymous\n            DapDimension anon = (DapDimension) newdecl;\n            assert (newsort == DapSort.DIMENSION && newname == null);\n            // Search for matching anonymous dimension\n            boolean found = false;\n            for(DapDimension dim : dimensions) {\n                if(!dim.isShared() && dim.getSize() == anon.getSize()) {\n                    found = true;\n                    break;\n                }\n            }\n            // Define the anondecl in root group\n            if(!found && !isTopLevel()) getDataset().addDecl(anon);\n            suppress = found || !isTopLevel();\n        }\n        if(!suppress) {\n            decls.add(newdecl);\n            newdecl.setParent(this); // Cross link\n        }\n        switch (newdecl.getSort()) {\n        case ATTRIBUTE:\n        case ATTRIBUTESET:\n        case OTHERXML:\n            super.addAttribute((DapAttribute) newdecl);\n            break;\n        case DIMENSION:\n            if(!suppress)\n                dimensions.add((DapDimension) newdecl);\n            break;\n        case ENUMERATION:\n            enums.add((DapEnumeration) newdecl);\n            break;\n        case ATOMICTYPE:\n            break; // do nothing\n        case STRUCTURE:\n        case SEQUENCE:\n            compounds.add((DapStructure)newdecl);\n            break;\n        case VARIABLE:\n            variables.add((DapVariable) newdecl);\n            break;\n        case GROUP:\n        case DATASET:\n            if(this != (DapGroup) newdecl)\n                groups.add((DapGroup) newdecl);\n            break;\n        default:\n            throw new ClassCastException(newdecl.getShortName());\n        }\n    }", "code_tokens": ["public", "void", "addDecl", "(", "DapNode", "newdecl", ")", "throws", "DapException", "{", "DapSort", "newsort", "=", "newdecl", ".", "getSort", "(", ")", ";", "String", "newname", "=", "newdecl", ".", "getShortName", "(", ")", ";", "boolean", "suppress", "=", "false", ";", "// Look for name conflicts (ignore anonymous dimensions)", "if", "(", "newsort", "!=", "DapSort", ".", "DIMENSION", "||", "newname", "!=", "null", ")", "{", "for", "(", "DapNode", "decl", ":", "decls", ")", "{", "if", "(", "newsort", "==", "decl", ".", "getSort", "(", ")", "&&", "newname", ".", "equals", "(", "decl", ".", "getShortName", "(", ")", ")", ")", "throw", "new", "DapException", "(", "\"DapGroup: attempt to add duplicate decl: \"", "+", "newname", ")", ";", "}", "}", "else", "{", "// Anonymous", "DapDimension", "anon", "=", "(", "DapDimension", ")", "newdecl", ";", "assert", "(", "newsort", "==", "DapSort", ".", "DIMENSION", "&&", "newname", "==", "null", ")", ";", "// Search for matching anonymous dimension", "boolean", "found", "=", "false", ";", "for", "(", "DapDimension", "dim", ":", "dimensions", ")", "{", "if", "(", "!", "dim", ".", "isShared", "(", ")", "&&", "dim", ".", "getSize", "(", ")", "==", "anon", ".", "getSize", "(", ")", ")", "{", "found", "=", "true", ";", "break", ";", "}", "}", "// Define the anondecl in root group", "if", "(", "!", "found", "&&", "!", "isTopLevel", "(", ")", ")", "getDataset", "(", ")", ".", "addDecl", "(", "anon", ")", ";", "suppress", "=", "found", "||", "!", "isTopLevel", "(", ")", ";", "}", "if", "(", "!", "suppress", ")", "{", "decls", ".", "add", "(", "newdecl", ")", ";", "newdecl", ".", "setParent", "(", "this", ")", ";", "// Cross link", "}", "switch", "(", "newdecl", ".", "getSort", "(", ")", ")", "{", "case", "ATTRIBUTE", ":", "case", "ATTRIBUTESET", ":", "case", "OTHERXML", ":", "super", ".", "addAttribute", "(", "(", "DapAttribute", ")", "newdecl", ")", ";", "break", ";", "case", "DIMENSION", ":", "if", "(", "!", "suppress", ")", "dimensions", ".", "add", "(", "(", "DapDimension", ")", "newdecl", ")", ";", "break", ";", "case", "ENUMERATION", ":", "enums", ".", "add", "(", "(", "DapEnumeration", ")", "newdecl", ")", ";", "break", ";", "case", "ATOMICTYPE", ":", "break", ";", "// do nothing", "case", "STRUCTURE", ":", "case", "SEQUENCE", ":", "compounds", ".", "add", "(", "(", "DapStructure", ")", "newdecl", ")", ";", "break", ";", "case", "VARIABLE", ":", "variables", ".", "add", "(", "(", "DapVariable", ")", "newdecl", ")", ";", "break", ";", "case", "GROUP", ":", "case", "DATASET", ":", "if", "(", "this", "!=", "(", "DapGroup", ")", "newdecl", ")", "groups", ".", "add", "(", "(", "DapGroup", ")", "newdecl", ")", ";", "break", ";", "default", ":", "throw", "new", "ClassCastException", "(", "newdecl", ".", "getShortName", "(", ")", ")", ";", "}", "}"], "docstring": "Add single declaration", "docstring_tokens": ["Add", "single", "declaration"]}
{"code": "if (lonRange == null) lonRange = getXAxis().getRange();", "comments": "clumsy", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft2/coverage/HorizCoordSys.java", "func_name": "HorizCoordSys.getRanges", "original_string": "public List<RangeIterator> getRanges() {\n    List<RangeIterator> result = new ArrayList<>();\n    result.add(getYAxis().getRange());\n    RangeIterator lonRange = getXAxis().getRangeIterator();\n    if (lonRange == null) lonRange = getXAxis().getRange(); // clumsy\n    result.add(lonRange);\n\n    return result;\n  }", "language": "java", "Allcodes": "public List<RangeIterator> getRanges() {\n    List<RangeIterator> result = new ArrayList<>();\n    result.add(getYAxis().getRange());\n    RangeIterator lonRange = getXAxis().getRangeIterator();\n    if (lonRange == null) lonRange = getXAxis().getRange(); // clumsy\n    result.add(lonRange);\n\n    return result;\n  }", "code_tokens": ["public", "List", "<", "RangeIterator", ">", "getRanges", "(", ")", "{", "List", "<", "RangeIterator", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "result", ".", "add", "(", "getYAxis", "(", ")", ".", "getRange", "(", ")", ")", ";", "RangeIterator", "lonRange", "=", "getXAxis", "(", ")", ".", "getRangeIterator", "(", ")", ";", "if", "(", "lonRange", "==", "null", ")", "lonRange", "=", "getXAxis", "(", ")", ".", "getRange", "(", ")", ";", "// clumsy", "result", ".", "add", "(", "lonRange", ")", ";", "return", "result", ";", "}"], "docstring": "return y, x range", "docstring_tokens": ["return", "y", "x", "range"]}
{"code": "return;", "comments": "multiple calls ok", "lines": 4, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/HTTPSession.java", "func_name": "HTTPSession.close", "original_string": "synchronized public void close()\n    {\n        if(this.closed)\n            return; // multiple calls ok\n        closed = true;\n        for(HTTPMethod m : this.methods) {\n            m.close(); // forcibly close; will invoke removemethod().\n        }\n        methods.clear();\n    }", "language": "java", "Allcodes": "synchronized public void close()\n    {\n        if(this.closed)\n            return; // multiple calls ok\n        closed = true;\n        for(HTTPMethod m : this.methods) {\n            m.close(); // forcibly close; will invoke removemethod().\n        }\n        methods.clear();\n    }", "code_tokens": ["synchronized", "public", "void", "close", "(", ")", "{", "if", "(", "this", ".", "closed", ")", "return", ";", "// multiple calls ok", "closed", "=", "true", ";", "for", "(", "HTTPMethod", "m", ":", "this", ".", "methods", ")", "{", "m", ".", "close", "(", ")", ";", "// forcibly close; will invoke removemethod().", "}", "methods", ".", "clear", "(", ")", ";", "}"], "docstring": "Close the session. This implies closing\nany open methods.", "docstring_tokens": ["Close", "the", "session", ".", "This", "implies", "closing", "any", "open", "methods", "."]}
{"code": "m.close();", "comments": "forcibly close; will invoke removemethod().", "lines": 7, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/HTTPSession.java", "func_name": "HTTPSession.close", "original_string": "synchronized public void close()\n    {\n        if(this.closed)\n            return; // multiple calls ok\n        closed = true;\n        for(HTTPMethod m : this.methods) {\n            m.close(); // forcibly close; will invoke removemethod().\n        }\n        methods.clear();\n    }", "language": "java", "Allcodes": "synchronized public void close()\n    {\n        if(this.closed)\n            return; // multiple calls ok\n        closed = true;\n        for(HTTPMethod m : this.methods) {\n            m.close(); // forcibly close; will invoke removemethod().\n        }\n        methods.clear();\n    }", "code_tokens": ["synchronized", "public", "void", "close", "(", ")", "{", "if", "(", "this", ".", "closed", ")", "return", ";", "// multiple calls ok", "closed", "=", "true", ";", "for", "(", "HTTPMethod", "m", ":", "this", ".", "methods", ")", "{", "m", ".", "close", "(", ")", ";", "// forcibly close; will invoke removemethod().", "}", "methods", ".", "clear", "(", ")", ";", "}"], "docstring": "Close the session. This implies closing\nany open methods.", "docstring_tokens": ["Close", "the", "session", ".", "This", "implies", "closing", "any", "open", "methods", "."]}
{"code": "continue;", "comments": "ignore vlen", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.computeStrides", "original_string": "static private long computeStrides(int[] shape, int[] stride) {\r\n    long product = 1;\r\n    for (int ii = shape.length - 1; ii >= 0; ii--) {\r\n      final int thisDim = shape[ii];\r\n      if (thisDim < 0)\r\n        continue; // ignore vlen\r\n      stride[ii] = (int) product;\r\n      product *= thisDim;\r\n    }\r\n    return product;\r\n  }", "language": "java", "Allcodes": "static private long computeStrides(int[] shape, int[] stride) {\r\n    long product = 1;\r\n    for (int ii = shape.length - 1; ii >= 0; ii--) {\r\n      final int thisDim = shape[ii];\r\n      if (thisDim < 0)\r\n        continue; // ignore vlen\r\n      stride[ii] = (int) product;\r\n      product *= thisDim;\r\n    }\r\n    return product;\r\n  }", "code_tokens": ["static", "private", "long", "computeStrides", "(", "int", "[", "]", "shape", ",", "int", "[", "]", "stride", ")", "{", "long", "product", "=", "1", ";", "for", "(", "int", "ii", "=", "shape", ".", "length", "-", "1", ";", "ii", ">=", "0", ";", "ii", "--", ")", "{", "final", "int", "thisDim", "=", "shape", "[", "ii", "]", ";", "if", "(", "thisDim", "<", "0", ")", "continue", ";", "// ignore vlen\r", "stride", "[", "ii", "]", "=", "(", "int", ")", "product", ";", "product", "*=", "thisDim", ";", "}", "return", "product", ";", "}"], "docstring": "Compute standard strides based on array's shape.\nIgnore vlen\n\n@param shape  length of array in each dimension.\n@param stride put result here\n@return standard strides based on array's shape.", "docstring_tokens": ["Compute", "standard", "strides", "based", "on", "array", "s", "shape", ".", "Ignore", "vlen"]}
{"code": "newindex.offset += stride[ii] * r.first();", "comments": "constant due to rank reduction", "lines": 43, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.section", "original_string": "Index section(List<Range> ranges) throws InvalidRangeException {\r\n\r\n    // check ranges are valid\r\n    if (ranges.size() != rank)\r\n      throw new InvalidRangeException(\"Bad ranges [] length\");\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null)\r\n        continue;\r\n      if (r == Range.VLEN)\r\n        continue;\r\n      if ((r.first() < 0) || (r.first() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range starting value at index \" + ii + \" == \" + r.first());\r\n      if ((r.last() < 0) || (r.last() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range ending value at index \" + ii + \" == \" + r.last());\r\n    }\r\n\r\n    int reducedRank = rank;\r\n    for (Range r : ranges) {\r\n      if ((r != null) && (r.length() == 1))\r\n        reducedRank--;\r\n    }\r\n    Index newindex = Index.factory(reducedRank);\r\n    newindex.offset = offset;\r\n\r\n    // calc shape, size, and index transformations\r\n    // calc strides into original (backing) store\r\n    int newDim = 0;\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null) {          // null range means use the whole original dimension\r\n        newindex.shape[newDim] = shape[ii];\r\n        newindex.stride[newDim] = stride[ii];\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else if (r.length() != 1) {\r\n        newindex.shape[newDim] = r.length();\r\n        newindex.stride[newDim] = stride[ii] * r.stride();\r\n        newindex.offset += stride[ii] * r.first();\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else {\r\n        newindex.offset += stride[ii] * r.first();   // constant due to rank reduction\r\n      }\r\n    }\r\n    newindex.size = computeSize(newindex.shape);\r\n    newindex.fastIterator = fastIterator && (newindex.size == size); // if equal, then its not a real subset, so can still use fastIterator\r\n    newindex.precalc(); // any subclass-specific optimizations\r\n    return newindex;\r\n  }", "language": "java", "Allcodes": "Index section(List<Range> ranges) throws InvalidRangeException {\r\n\r\n    // check ranges are valid\r\n    if (ranges.size() != rank)\r\n      throw new InvalidRangeException(\"Bad ranges [] length\");\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null)\r\n        continue;\r\n      if (r == Range.VLEN)\r\n        continue;\r\n      if ((r.first() < 0) || (r.first() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range starting value at index \" + ii + \" == \" + r.first());\r\n      if ((r.last() < 0) || (r.last() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range ending value at index \" + ii + \" == \" + r.last());\r\n    }\r\n\r\n    int reducedRank = rank;\r\n    for (Range r : ranges) {\r\n      if ((r != null) && (r.length() == 1))\r\n        reducedRank--;\r\n    }\r\n    Index newindex = Index.factory(reducedRank);\r\n    newindex.offset = offset;\r\n\r\n    // calc shape, size, and index transformations\r\n    // calc strides into original (backing) store\r\n    int newDim = 0;\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null) {          // null range means use the whole original dimension\r\n        newindex.shape[newDim] = shape[ii];\r\n        newindex.stride[newDim] = stride[ii];\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else if (r.length() != 1) {\r\n        newindex.shape[newDim] = r.length();\r\n        newindex.stride[newDim] = stride[ii] * r.stride();\r\n        newindex.offset += stride[ii] * r.first();\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else {\r\n        newindex.offset += stride[ii] * r.first();   // constant due to rank reduction\r\n      }\r\n    }\r\n    newindex.size = computeSize(newindex.shape);\r\n    newindex.fastIterator = fastIterator && (newindex.size == size); // if equal, then its not a real subset, so can still use fastIterator\r\n    newindex.precalc(); // any subclass-specific optimizations\r\n    return newindex;\r\n  }", "code_tokens": ["Index", "section", "(", "List", "<", "Range", ">", "ranges", ")", "throws", "InvalidRangeException", "{", "// check ranges are valid\r", "if", "(", "ranges", ".", "size", "(", ")", "!=", "rank", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad ranges [] length\"", ")", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "Range", "r", "=", "ranges", ".", "get", "(", "ii", ")", ";", "if", "(", "r", "==", "null", ")", "continue", ";", "if", "(", "r", "==", "Range", ".", "VLEN", ")", "continue", ";", "if", "(", "(", "r", ".", "first", "(", ")", "<", "0", ")", "||", "(", "r", ".", "first", "(", ")", ">=", "shape", "[", "ii", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad range starting value at index \"", "+", "ii", "+", "\" == \"", "+", "r", ".", "first", "(", ")", ")", ";", "if", "(", "(", "r", ".", "last", "(", ")", "<", "0", ")", "||", "(", "r", ".", "last", "(", ")", ">=", "shape", "[", "ii", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad range ending value at index \"", "+", "ii", "+", "\" == \"", "+", "r", ".", "last", "(", ")", ")", ";", "}", "int", "reducedRank", "=", "rank", ";", "for", "(", "Range", "r", ":", "ranges", ")", "{", "if", "(", "(", "r", "!=", "null", ")", "&&", "(", "r", ".", "length", "(", ")", "==", "1", ")", ")", "reducedRank", "--", ";", "}", "Index", "newindex", "=", "Index", ".", "factory", "(", "reducedRank", ")", ";", "newindex", ".", "offset", "=", "offset", ";", "// calc shape, size, and index transformations\r", "// calc strides into original (backing) store\r", "int", "newDim", "=", "0", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "Range", "r", "=", "ranges", ".", "get", "(", "ii", ")", ";", "if", "(", "r", "==", "null", ")", "{", "// null range means use the whole original dimension\r", "newindex", ".", "shape", "[", "newDim", "]", "=", "shape", "[", "ii", "]", ";", "newindex", ".", "stride", "[", "newDim", "]", "=", "stride", "[", "ii", "]", ";", "//if (name != null) newindex.name[newDim] = name[ii];\r", "newDim", "++", ";", "}", "else", "if", "(", "r", ".", "length", "(", ")", "!=", "1", ")", "{", "newindex", ".", "shape", "[", "newDim", "]", "=", "r", ".", "length", "(", ")", ";", "newindex", ".", "stride", "[", "newDim", "]", "=", "stride", "[", "ii", "]", "*", "r", ".", "stride", "(", ")", ";", "newindex", ".", "offset", "+=", "stride", "[", "ii", "]", "*", "r", ".", "first", "(", ")", ";", "//if (name != null) newindex.name[newDim] = name[ii];\r", "newDim", "++", ";", "}", "else", "{", "newindex", ".", "offset", "+=", "stride", "[", "ii", "]", "*", "r", ".", "first", "(", ")", ";", "// constant due to rank reduction\r", "}", "}", "newindex", ".", "size", "=", "computeSize", "(", "newindex", ".", "shape", ")", ";", "newindex", ".", "fastIterator", "=", "fastIterator", "&&", "(", "newindex", ".", "size", "==", "size", ")", ";", "// if equal, then its not a real subset, so can still use fastIterator\r", "newindex", ".", "precalc", "(", ")", ";", "// any subclass-specific optimizations\r", "return", "newindex", ";", "}"], "docstring": "create a new Index based on a subsection of this one, with rank reduction if\ndimension length == 1.\n\n@param ranges array of Ranges that specify the array subset.\nMust be same rank as original Array.\nA particular Range: 1) may be a subset; 2) may be null, meaning use entire Range.\n@return new Index, with same or smaller rank as original.\n@throws InvalidRangeException if ranges dont match current shape", "docstring_tokens": ["create", "a", "new", "Index", "based", "on", "a", "subsection", "of", "this", "one", "with", "rank", "reduction", "if", "dimension", "length", "==", "1", "."]}
{"code": "newindex.fastIterator = fastIterator && (newindex.size == size);", "comments": "if equal, then its not a real subset, so can still use fastIterator", "lines": 47, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.section", "original_string": "Index section(List<Range> ranges) throws InvalidRangeException {\r\n\r\n    // check ranges are valid\r\n    if (ranges.size() != rank)\r\n      throw new InvalidRangeException(\"Bad ranges [] length\");\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null)\r\n        continue;\r\n      if (r == Range.VLEN)\r\n        continue;\r\n      if ((r.first() < 0) || (r.first() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range starting value at index \" + ii + \" == \" + r.first());\r\n      if ((r.last() < 0) || (r.last() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range ending value at index \" + ii + \" == \" + r.last());\r\n    }\r\n\r\n    int reducedRank = rank;\r\n    for (Range r : ranges) {\r\n      if ((r != null) && (r.length() == 1))\r\n        reducedRank--;\r\n    }\r\n    Index newindex = Index.factory(reducedRank);\r\n    newindex.offset = offset;\r\n\r\n    // calc shape, size, and index transformations\r\n    // calc strides into original (backing) store\r\n    int newDim = 0;\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null) {          // null range means use the whole original dimension\r\n        newindex.shape[newDim] = shape[ii];\r\n        newindex.stride[newDim] = stride[ii];\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else if (r.length() != 1) {\r\n        newindex.shape[newDim] = r.length();\r\n        newindex.stride[newDim] = stride[ii] * r.stride();\r\n        newindex.offset += stride[ii] * r.first();\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else {\r\n        newindex.offset += stride[ii] * r.first();   // constant due to rank reduction\r\n      }\r\n    }\r\n    newindex.size = computeSize(newindex.shape);\r\n    newindex.fastIterator = fastIterator && (newindex.size == size); // if equal, then its not a real subset, so can still use fastIterator\r\n    newindex.precalc(); // any subclass-specific optimizations\r\n    return newindex;\r\n  }", "language": "java", "Allcodes": "Index section(List<Range> ranges) throws InvalidRangeException {\r\n\r\n    // check ranges are valid\r\n    if (ranges.size() != rank)\r\n      throw new InvalidRangeException(\"Bad ranges [] length\");\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null)\r\n        continue;\r\n      if (r == Range.VLEN)\r\n        continue;\r\n      if ((r.first() < 0) || (r.first() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range starting value at index \" + ii + \" == \" + r.first());\r\n      if ((r.last() < 0) || (r.last() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range ending value at index \" + ii + \" == \" + r.last());\r\n    }\r\n\r\n    int reducedRank = rank;\r\n    for (Range r : ranges) {\r\n      if ((r != null) && (r.length() == 1))\r\n        reducedRank--;\r\n    }\r\n    Index newindex = Index.factory(reducedRank);\r\n    newindex.offset = offset;\r\n\r\n    // calc shape, size, and index transformations\r\n    // calc strides into original (backing) store\r\n    int newDim = 0;\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null) {          // null range means use the whole original dimension\r\n        newindex.shape[newDim] = shape[ii];\r\n        newindex.stride[newDim] = stride[ii];\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else if (r.length() != 1) {\r\n        newindex.shape[newDim] = r.length();\r\n        newindex.stride[newDim] = stride[ii] * r.stride();\r\n        newindex.offset += stride[ii] * r.first();\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else {\r\n        newindex.offset += stride[ii] * r.first();   // constant due to rank reduction\r\n      }\r\n    }\r\n    newindex.size = computeSize(newindex.shape);\r\n    newindex.fastIterator = fastIterator && (newindex.size == size); // if equal, then its not a real subset, so can still use fastIterator\r\n    newindex.precalc(); // any subclass-specific optimizations\r\n    return newindex;\r\n  }", "code_tokens": ["Index", "section", "(", "List", "<", "Range", ">", "ranges", ")", "throws", "InvalidRangeException", "{", "// check ranges are valid\r", "if", "(", "ranges", ".", "size", "(", ")", "!=", "rank", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad ranges [] length\"", ")", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "Range", "r", "=", "ranges", ".", "get", "(", "ii", ")", ";", "if", "(", "r", "==", "null", ")", "continue", ";", "if", "(", "r", "==", "Range", ".", "VLEN", ")", "continue", ";", "if", "(", "(", "r", ".", "first", "(", ")", "<", "0", ")", "||", "(", "r", ".", "first", "(", ")", ">=", "shape", "[", "ii", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad range starting value at index \"", "+", "ii", "+", "\" == \"", "+", "r", ".", "first", "(", ")", ")", ";", "if", "(", "(", "r", ".", "last", "(", ")", "<", "0", ")", "||", "(", "r", ".", "last", "(", ")", ">=", "shape", "[", "ii", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad range ending value at index \"", "+", "ii", "+", "\" == \"", "+", "r", ".", "last", "(", ")", ")", ";", "}", "int", "reducedRank", "=", "rank", ";", "for", "(", "Range", "r", ":", "ranges", ")", "{", "if", "(", "(", "r", "!=", "null", ")", "&&", "(", "r", ".", "length", "(", ")", "==", "1", ")", ")", "reducedRank", "--", ";", "}", "Index", "newindex", "=", "Index", ".", "factory", "(", "reducedRank", ")", ";", "newindex", ".", "offset", "=", "offset", ";", "// calc shape, size, and index transformations\r", "// calc strides into original (backing) store\r", "int", "newDim", "=", "0", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "Range", "r", "=", "ranges", ".", "get", "(", "ii", ")", ";", "if", "(", "r", "==", "null", ")", "{", "// null range means use the whole original dimension\r", "newindex", ".", "shape", "[", "newDim", "]", "=", "shape", "[", "ii", "]", ";", "newindex", ".", "stride", "[", "newDim", "]", "=", "stride", "[", "ii", "]", ";", "//if (name != null) newindex.name[newDim] = name[ii];\r", "newDim", "++", ";", "}", "else", "if", "(", "r", ".", "length", "(", ")", "!=", "1", ")", "{", "newindex", ".", "shape", "[", "newDim", "]", "=", "r", ".", "length", "(", ")", ";", "newindex", ".", "stride", "[", "newDim", "]", "=", "stride", "[", "ii", "]", "*", "r", ".", "stride", "(", ")", ";", "newindex", ".", "offset", "+=", "stride", "[", "ii", "]", "*", "r", ".", "first", "(", ")", ";", "//if (name != null) newindex.name[newDim] = name[ii];\r", "newDim", "++", ";", "}", "else", "{", "newindex", ".", "offset", "+=", "stride", "[", "ii", "]", "*", "r", ".", "first", "(", ")", ";", "// constant due to rank reduction\r", "}", "}", "newindex", ".", "size", "=", "computeSize", "(", "newindex", ".", "shape", ")", ";", "newindex", ".", "fastIterator", "=", "fastIterator", "&&", "(", "newindex", ".", "size", "==", "size", ")", ";", "// if equal, then its not a real subset, so can still use fastIterator\r", "newindex", ".", "precalc", "(", ")", ";", "// any subclass-specific optimizations\r", "return", "newindex", ";", "}"], "docstring": "create a new Index based on a subsection of this one, with rank reduction if\ndimension length == 1.\n\n@param ranges array of Ranges that specify the array subset.\nMust be same rank as original Array.\nA particular Range: 1) may be a subset; 2) may be null, meaning use entire Range.\n@return new Index, with same or smaller rank as original.\n@throws InvalidRangeException if ranges dont match current shape", "docstring_tokens": ["create", "a", "new", "Index", "based", "on", "a", "subsection", "of", "this", "one", "with", "rank", "reduction", "if", "dimension", "length", "==", "1", "."]}
{"code": "newindex.precalc();", "comments": "any subclass-specific optimizations", "lines": 48, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.section", "original_string": "Index section(List<Range> ranges) throws InvalidRangeException {\r\n\r\n    // check ranges are valid\r\n    if (ranges.size() != rank)\r\n      throw new InvalidRangeException(\"Bad ranges [] length\");\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null)\r\n        continue;\r\n      if (r == Range.VLEN)\r\n        continue;\r\n      if ((r.first() < 0) || (r.first() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range starting value at index \" + ii + \" == \" + r.first());\r\n      if ((r.last() < 0) || (r.last() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range ending value at index \" + ii + \" == \" + r.last());\r\n    }\r\n\r\n    int reducedRank = rank;\r\n    for (Range r : ranges) {\r\n      if ((r != null) && (r.length() == 1))\r\n        reducedRank--;\r\n    }\r\n    Index newindex = Index.factory(reducedRank);\r\n    newindex.offset = offset;\r\n\r\n    // calc shape, size, and index transformations\r\n    // calc strides into original (backing) store\r\n    int newDim = 0;\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null) {          // null range means use the whole original dimension\r\n        newindex.shape[newDim] = shape[ii];\r\n        newindex.stride[newDim] = stride[ii];\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else if (r.length() != 1) {\r\n        newindex.shape[newDim] = r.length();\r\n        newindex.stride[newDim] = stride[ii] * r.stride();\r\n        newindex.offset += stride[ii] * r.first();\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else {\r\n        newindex.offset += stride[ii] * r.first();   // constant due to rank reduction\r\n      }\r\n    }\r\n    newindex.size = computeSize(newindex.shape);\r\n    newindex.fastIterator = fastIterator && (newindex.size == size); // if equal, then its not a real subset, so can still use fastIterator\r\n    newindex.precalc(); // any subclass-specific optimizations\r\n    return newindex;\r\n  }", "language": "java", "Allcodes": "Index section(List<Range> ranges) throws InvalidRangeException {\r\n\r\n    // check ranges are valid\r\n    if (ranges.size() != rank)\r\n      throw new InvalidRangeException(\"Bad ranges [] length\");\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null)\r\n        continue;\r\n      if (r == Range.VLEN)\r\n        continue;\r\n      if ((r.first() < 0) || (r.first() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range starting value at index \" + ii + \" == \" + r.first());\r\n      if ((r.last() < 0) || (r.last() >= shape[ii]))\r\n        throw new InvalidRangeException(\"Bad range ending value at index \" + ii + \" == \" + r.last());\r\n    }\r\n\r\n    int reducedRank = rank;\r\n    for (Range r : ranges) {\r\n      if ((r != null) && (r.length() == 1))\r\n        reducedRank--;\r\n    }\r\n    Index newindex = Index.factory(reducedRank);\r\n    newindex.offset = offset;\r\n\r\n    // calc shape, size, and index transformations\r\n    // calc strides into original (backing) store\r\n    int newDim = 0;\r\n    for (int ii = 0; ii < rank; ii++) {\r\n      Range r = ranges.get(ii);\r\n      if (r == null) {          // null range means use the whole original dimension\r\n        newindex.shape[newDim] = shape[ii];\r\n        newindex.stride[newDim] = stride[ii];\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else if (r.length() != 1) {\r\n        newindex.shape[newDim] = r.length();\r\n        newindex.stride[newDim] = stride[ii] * r.stride();\r\n        newindex.offset += stride[ii] * r.first();\r\n        //if (name != null) newindex.name[newDim] = name[ii];\r\n        newDim++;\r\n      } else {\r\n        newindex.offset += stride[ii] * r.first();   // constant due to rank reduction\r\n      }\r\n    }\r\n    newindex.size = computeSize(newindex.shape);\r\n    newindex.fastIterator = fastIterator && (newindex.size == size); // if equal, then its not a real subset, so can still use fastIterator\r\n    newindex.precalc(); // any subclass-specific optimizations\r\n    return newindex;\r\n  }", "code_tokens": ["Index", "section", "(", "List", "<", "Range", ">", "ranges", ")", "throws", "InvalidRangeException", "{", "// check ranges are valid\r", "if", "(", "ranges", ".", "size", "(", ")", "!=", "rank", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad ranges [] length\"", ")", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "Range", "r", "=", "ranges", ".", "get", "(", "ii", ")", ";", "if", "(", "r", "==", "null", ")", "continue", ";", "if", "(", "r", "==", "Range", ".", "VLEN", ")", "continue", ";", "if", "(", "(", "r", ".", "first", "(", ")", "<", "0", ")", "||", "(", "r", ".", "first", "(", ")", ">=", "shape", "[", "ii", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad range starting value at index \"", "+", "ii", "+", "\" == \"", "+", "r", ".", "first", "(", ")", ")", ";", "if", "(", "(", "r", ".", "last", "(", ")", "<", "0", ")", "||", "(", "r", ".", "last", "(", ")", ">=", "shape", "[", "ii", "]", ")", ")", "throw", "new", "InvalidRangeException", "(", "\"Bad range ending value at index \"", "+", "ii", "+", "\" == \"", "+", "r", ".", "last", "(", ")", ")", ";", "}", "int", "reducedRank", "=", "rank", ";", "for", "(", "Range", "r", ":", "ranges", ")", "{", "if", "(", "(", "r", "!=", "null", ")", "&&", "(", "r", ".", "length", "(", ")", "==", "1", ")", ")", "reducedRank", "--", ";", "}", "Index", "newindex", "=", "Index", ".", "factory", "(", "reducedRank", ")", ";", "newindex", ".", "offset", "=", "offset", ";", "// calc shape, size, and index transformations\r", "// calc strides into original (backing) store\r", "int", "newDim", "=", "0", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "Range", "r", "=", "ranges", ".", "get", "(", "ii", ")", ";", "if", "(", "r", "==", "null", ")", "{", "// null range means use the whole original dimension\r", "newindex", ".", "shape", "[", "newDim", "]", "=", "shape", "[", "ii", "]", ";", "newindex", ".", "stride", "[", "newDim", "]", "=", "stride", "[", "ii", "]", ";", "//if (name != null) newindex.name[newDim] = name[ii];\r", "newDim", "++", ";", "}", "else", "if", "(", "r", ".", "length", "(", ")", "!=", "1", ")", "{", "newindex", ".", "shape", "[", "newDim", "]", "=", "r", ".", "length", "(", ")", ";", "newindex", ".", "stride", "[", "newDim", "]", "=", "stride", "[", "ii", "]", "*", "r", ".", "stride", "(", ")", ";", "newindex", ".", "offset", "+=", "stride", "[", "ii", "]", "*", "r", ".", "first", "(", ")", ";", "//if (name != null) newindex.name[newDim] = name[ii];\r", "newDim", "++", ";", "}", "else", "{", "newindex", ".", "offset", "+=", "stride", "[", "ii", "]", "*", "r", ".", "first", "(", ")", ";", "// constant due to rank reduction\r", "}", "}", "newindex", ".", "size", "=", "computeSize", "(", "newindex", ".", "shape", ")", ";", "newindex", ".", "fastIterator", "=", "fastIterator", "&&", "(", "newindex", ".", "size", "==", "size", ")", ";", "// if equal, then its not a real subset, so can still use fastIterator\r", "newindex", ".", "precalc", "(", ")", ";", "// any subclass-specific optimizations\r", "return", "newindex", ";", "}"], "docstring": "create a new Index based on a subsection of this one, with rank reduction if\ndimension length == 1.\n\n@param ranges array of Ranges that specify the array subset.\nMust be same rank as original Array.\nA particular Range: 1) may be a subset; 2) may be null, meaning use entire Range.\n@return new Index, with same or smaller rank as original.\n@throws InvalidRangeException if ranges dont match current shape", "docstring_tokens": ["create", "a", "new", "Index", "based", "on", "a", "subsection", "of", "this", "one", "with", "rank", "reduction", "if", "dimension", "length", "==", "1", "."]}
{"code": "return newc.reduce();", "comments": "any more to do?", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.reduce", "original_string": "Index reduce() {\r\n    Index c = this;\r\n    for (int ii = 0; ii < rank; ii++)\r\n      if (shape[ii] == 1) {  // do this on the first one you find\r\n        Index newc = c.reduce(ii);\r\n        return newc.reduce();  // any more to do?\r\n      }\r\n    return c;\r\n  }", "language": "java", "Allcodes": "Index reduce() {\r\n    Index c = this;\r\n    for (int ii = 0; ii < rank; ii++)\r\n      if (shape[ii] == 1) {  // do this on the first one you find\r\n        Index newc = c.reduce(ii);\r\n        return newc.reduce();  // any more to do?\r\n      }\r\n    return c;\r\n  }", "code_tokens": ["Index", "reduce", "(", ")", "{", "Index", "c", "=", "this", ";", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "if", "(", "shape", "[", "ii", "]", "==", "1", ")", "{", "// do this on the first one you find\r", "Index", "newc", "=", "c", ".", "reduce", "(", "ii", ")", ";", "return", "newc", ".", "reduce", "(", ")", ";", "// any more to do?\r", "}", "return", "c", ";", "}"], "docstring": "Create a new Index based on current one by\neliminating any dimensions with length one.\n\n@return the new Index", "docstring_tokens": ["Create", "a", "new", "Index", "based", "on", "current", "one", "by", "eliminating", "any", "dimensions", "with", "length", "one", "."]}
{"code": "newIndex.fastIterator = fastIterator && !isPermuted;", "comments": "useful optimization", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.permute", "original_string": "Index permute(int[] dims) {\r\n    if (dims.length != shape.length)\r\n      throw new IllegalArgumentException();\r\n    for (int dim : dims)\r\n      if ((dim < 0) || (dim >= rank))\r\n        throw new IllegalArgumentException();\r\n\r\n    boolean isPermuted = false;\r\n    Index newIndex = (Index) this.clone();\r\n    for (int i = 0; i < dims.length; i++) {\r\n      newIndex.stride[i] = stride[dims[i]];\r\n      newIndex.shape[i] = shape[dims[i]];\r\n      //if (name != null) newIndex.name[i] = name[dims[i]];\r\n      if (i != dims[i]) isPermuted = true;\r\n    }\r\n\r\n    newIndex.fastIterator = fastIterator && !isPermuted; // useful optimization\r\n    newIndex.precalc(); // any subclass-specific optimizations\r\n    return newIndex;\r\n  }", "language": "java", "Allcodes": "Index permute(int[] dims) {\r\n    if (dims.length != shape.length)\r\n      throw new IllegalArgumentException();\r\n    for (int dim : dims)\r\n      if ((dim < 0) || (dim >= rank))\r\n        throw new IllegalArgumentException();\r\n\r\n    boolean isPermuted = false;\r\n    Index newIndex = (Index) this.clone();\r\n    for (int i = 0; i < dims.length; i++) {\r\n      newIndex.stride[i] = stride[dims[i]];\r\n      newIndex.shape[i] = shape[dims[i]];\r\n      //if (name != null) newIndex.name[i] = name[dims[i]];\r\n      if (i != dims[i]) isPermuted = true;\r\n    }\r\n\r\n    newIndex.fastIterator = fastIterator && !isPermuted; // useful optimization\r\n    newIndex.precalc(); // any subclass-specific optimizations\r\n    return newIndex;\r\n  }", "code_tokens": ["Index", "permute", "(", "int", "[", "]", "dims", ")", "{", "if", "(", "dims", ".", "length", "!=", "shape", ".", "length", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "for", "(", "int", "dim", ":", "dims", ")", "if", "(", "(", "dim", "<", "0", ")", "||", "(", "dim", ">=", "rank", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "boolean", "isPermuted", "=", "false", ";", "Index", "newIndex", "=", "(", "Index", ")", "this", ".", "clone", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "dims", ".", "length", ";", "i", "++", ")", "{", "newIndex", ".", "stride", "[", "i", "]", "=", "stride", "[", "dims", "[", "i", "]", "]", ";", "newIndex", ".", "shape", "[", "i", "]", "=", "shape", "[", "dims", "[", "i", "]", "]", ";", "//if (name != null) newIndex.name[i] = name[dims[i]];\r", "if", "(", "i", "!=", "dims", "[", "i", "]", ")", "isPermuted", "=", "true", ";", "}", "newIndex", ".", "fastIterator", "=", "fastIterator", "&&", "!", "isPermuted", ";", "// useful optimization\r", "newIndex", ".", "precalc", "(", ")", ";", "// any subclass-specific optimizations\r", "return", "newIndex", ";", "}"], "docstring": "create a new Index based on a permutation of the current indices; vlen fails.\n\n@param dims: the old index dim[k] becomes the new kth index.\n@return new Index with permuted indices", "docstring_tokens": ["create", "a", "new", "Index", "based", "on", "a", "permutation", "of", "the", "current", "indices", ";", "vlen", "fails", "."]}
{"code": "int value = offset;", "comments": "NB: dont have to check each index again", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.currentElement", "original_string": "public int currentElement() {\r\n    int value = offset;                 // NB: dont have to check each index again\r\n    for (int ii = 0; ii < rank; ii++) { // general rank\r\n      if (shape[ii] < 0) break;//vlen\r\n      value += current[ii] * stride[ii];\r\n    }\r\n    return value;\r\n  }", "language": "java", "Allcodes": "public int currentElement() {\r\n    int value = offset;                 // NB: dont have to check each index again\r\n    for (int ii = 0; ii < rank; ii++) { // general rank\r\n      if (shape[ii] < 0) break;//vlen\r\n      value += current[ii] * stride[ii];\r\n    }\r\n    return value;\r\n  }", "code_tokens": ["public", "int", "currentElement", "(", ")", "{", "int", "value", "=", "offset", ";", "// NB: dont have to check each index again\r", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "// general rank\r", "if", "(", "shape", "[", "ii", "]", "<", "0", ")", "break", ";", "//vlen\r", "value", "+=", "current", "[", "ii", "]", "*", "stride", "[", "ii", "]", ";", "}", "return", "value", ";", "}"], "docstring": "Get the current element's index into the 1D backing array.\nVLEN stops processing.\n\n@return the current element's index into the 1D backing array.", "docstring_tokens": ["Get", "the", "current", "element", "s", "index", "into", "the", "1D", "backing", "array", ".", "VLEN", "stops", "processing", "."]}
{"code": "if (shape[ii] < 0) break;", "comments": "vlen", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/Index.java", "func_name": "Index.currentElement", "original_string": "public int currentElement() {\r\n    int value = offset;                 // NB: dont have to check each index again\r\n    for (int ii = 0; ii < rank; ii++) { // general rank\r\n      if (shape[ii] < 0) break;//vlen\r\n      value += current[ii] * stride[ii];\r\n    }\r\n    return value;\r\n  }", "language": "java", "Allcodes": "public int currentElement() {\r\n    int value = offset;                 // NB: dont have to check each index again\r\n    for (int ii = 0; ii < rank; ii++) { // general rank\r\n      if (shape[ii] < 0) break;//vlen\r\n      value += current[ii] * stride[ii];\r\n    }\r\n    return value;\r\n  }", "code_tokens": ["public", "int", "currentElement", "(", ")", "{", "int", "value", "=", "offset", ";", "// NB: dont have to check each index again\r", "for", "(", "int", "ii", "=", "0", ";", "ii", "<", "rank", ";", "ii", "++", ")", "{", "// general rank\r", "if", "(", "shape", "[", "ii", "]", "<", "0", ")", "break", ";", "//vlen\r", "value", "+=", "current", "[", "ii", "]", "*", "stride", "[", "ii", "]", ";", "}", "return", "value", ";", "}"], "docstring": "Get the current element's index into the 1D backing array.\nVLEN stops processing.\n\n@return the current element's index into the 1D backing array.", "docstring_tokens": ["Get", "the", "current", "element", "s", "index", "into", "the", "1D", "backing", "array", ".", "VLEN", "stops", "processing", "."]}
{"code": "long olderThan = System.currentTimeMillis() - olderThanInMsecs;", "comments": "new files must be older than this.", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/inventory/MFileCollectionManager.java", "func_name": "MFileCollectionManager.scanFirstTime", "original_string": "private boolean scanFirstTime() throws IOException {\r\n    Map<String, MFile> newMap = new HashMap<>();\r\n    if (!hasScans()) {\r\n        map = newMap;\r\n        return false;\r\n    }\r\n\r\n    reallyScan(newMap);\r\n    // deleteOld(newMap); // ?? hmmmmm LOOK this seems wrong; maintainence in background ?? generally collection doesnt exist\r\n\r\n    // implement olderThan\r\n    if (olderThanInMsecs > 0) {\r\n      long olderThan = System.currentTimeMillis() - olderThanInMsecs; // new files must be older than this.\r\n      Iterator<MFile> iter = newMap.values().iterator(); // need iterator so we can remove()\r\n      while (iter.hasNext()) {\r\n        MFile newFile = iter.next();\r\n        String path = newFile.getPath();\r\n        if (newFile.getLastModified() > olderThan) { // the file is too new\r\n          iter.remove();\r\n          logger.debug(\"{}: scan found new Dataset but its too recently modified = {}\", collectionName, path);\r\n        }\r\n      }\r\n    }\r\n\r\n    map = newMap;\r\n    this.lastScanned = System.currentTimeMillis();\r\n    this.lastChanged.set(this.lastScanned);\r\n    logger.debug(\"{} : initial scan found n datasets = {} \", collectionName, map.keySet().size());\r\n    return map.keySet().size() > 0;\r\n  }", "language": "java", "Allcodes": "private boolean scanFirstTime() throws IOException {\r\n    Map<String, MFile> newMap = new HashMap<>();\r\n    if (!hasScans()) {\r\n        map = newMap;\r\n        return false;\r\n    }\r\n\r\n    reallyScan(newMap);\r\n    // deleteOld(newMap); // ?? hmmmmm LOOK this seems wrong; maintainence in background ?? generally collection doesnt exist\r\n\r\n    // implement olderThan\r\n    if (olderThanInMsecs > 0) {\r\n      long olderThan = System.currentTimeMillis() - olderThanInMsecs; // new files must be older than this.\r\n      Iterator<MFile> iter = newMap.values().iterator(); // need iterator so we can remove()\r\n      while (iter.hasNext()) {\r\n        MFile newFile = iter.next();\r\n        String path = newFile.getPath();\r\n        if (newFile.getLastModified() > olderThan) { // the file is too new\r\n          iter.remove();\r\n          logger.debug(\"{}: scan found new Dataset but its too recently modified = {}\", collectionName, path);\r\n        }\r\n      }\r\n    }\r\n\r\n    map = newMap;\r\n    this.lastScanned = System.currentTimeMillis();\r\n    this.lastChanged.set(this.lastScanned);\r\n    logger.debug(\"{} : initial scan found n datasets = {} \", collectionName, map.keySet().size());\r\n    return map.keySet().size() > 0;\r\n  }", "code_tokens": ["private", "boolean", "scanFirstTime", "(", ")", "throws", "IOException", "{", "Map", "<", "String", ",", "MFile", ">", "newMap", "=", "new", "HashMap", "<>", "(", ")", ";", "if", "(", "!", "hasScans", "(", ")", ")", "{", "map", "=", "newMap", ";", "return", "false", ";", "}", "reallyScan", "(", "newMap", ")", ";", "// deleteOld(newMap); // ?? hmmmmm LOOK this seems wrong; maintainence in background ?? generally collection doesnt exist\r", "// implement olderThan\r", "if", "(", "olderThanInMsecs", ">", "0", ")", "{", "long", "olderThan", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "olderThanInMsecs", ";", "// new files must be older than this.\r", "Iterator", "<", "MFile", ">", "iter", "=", "newMap", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "// need iterator so we can remove()\r", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "MFile", "newFile", "=", "iter", ".", "next", "(", ")", ";", "String", "path", "=", "newFile", ".", "getPath", "(", ")", ";", "if", "(", "newFile", ".", "getLastModified", "(", ")", ">", "olderThan", ")", "{", "// the file is too new\r", "iter", ".", "remove", "(", ")", ";", "logger", ".", "debug", "(", "\"{}: scan found new Dataset but its too recently modified = {}\"", ",", "collectionName", ",", "path", ")", ";", "}", "}", "}", "map", "=", "newMap", ";", "this", ".", "lastScanned", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "this", ".", "lastChanged", ".", "set", "(", "this", ".", "lastScanned", ")", ";", "logger", ".", "debug", "(", "\"{} : initial scan found n datasets = {} \"", ",", "collectionName", ",", "map", ".", "keySet", "(", ")", ".", "size", "(", ")", ")", ";", "return", "map", ".", "keySet", "(", ")", ".", "size", "(", ")", ">", "0", ";", "}"], "docstring": "only called from synch methods", "docstring_tokens": ["only", "called", "from", "synch", "methods"]}
{"code": "Iterator<MFile> iter = newMap.values().iterator();", "comments": "need iterator so we can remove()", "lines": 14, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/inventory/MFileCollectionManager.java", "func_name": "MFileCollectionManager.scanFirstTime", "original_string": "private boolean scanFirstTime() throws IOException {\r\n    Map<String, MFile> newMap = new HashMap<>();\r\n    if (!hasScans()) {\r\n        map = newMap;\r\n        return false;\r\n    }\r\n\r\n    reallyScan(newMap);\r\n    // deleteOld(newMap); // ?? hmmmmm LOOK this seems wrong; maintainence in background ?? generally collection doesnt exist\r\n\r\n    // implement olderThan\r\n    if (olderThanInMsecs > 0) {\r\n      long olderThan = System.currentTimeMillis() - olderThanInMsecs; // new files must be older than this.\r\n      Iterator<MFile> iter = newMap.values().iterator(); // need iterator so we can remove()\r\n      while (iter.hasNext()) {\r\n        MFile newFile = iter.next();\r\n        String path = newFile.getPath();\r\n        if (newFile.getLastModified() > olderThan) { // the file is too new\r\n          iter.remove();\r\n          logger.debug(\"{}: scan found new Dataset but its too recently modified = {}\", collectionName, path);\r\n        }\r\n      }\r\n    }\r\n\r\n    map = newMap;\r\n    this.lastScanned = System.currentTimeMillis();\r\n    this.lastChanged.set(this.lastScanned);\r\n    logger.debug(\"{} : initial scan found n datasets = {} \", collectionName, map.keySet().size());\r\n    return map.keySet().size() > 0;\r\n  }", "language": "java", "Allcodes": "private boolean scanFirstTime() throws IOException {\r\n    Map<String, MFile> newMap = new HashMap<>();\r\n    if (!hasScans()) {\r\n        map = newMap;\r\n        return false;\r\n    }\r\n\r\n    reallyScan(newMap);\r\n    // deleteOld(newMap); // ?? hmmmmm LOOK this seems wrong; maintainence in background ?? generally collection doesnt exist\r\n\r\n    // implement olderThan\r\n    if (olderThanInMsecs > 0) {\r\n      long olderThan = System.currentTimeMillis() - olderThanInMsecs; // new files must be older than this.\r\n      Iterator<MFile> iter = newMap.values().iterator(); // need iterator so we can remove()\r\n      while (iter.hasNext()) {\r\n        MFile newFile = iter.next();\r\n        String path = newFile.getPath();\r\n        if (newFile.getLastModified() > olderThan) { // the file is too new\r\n          iter.remove();\r\n          logger.debug(\"{}: scan found new Dataset but its too recently modified = {}\", collectionName, path);\r\n        }\r\n      }\r\n    }\r\n\r\n    map = newMap;\r\n    this.lastScanned = System.currentTimeMillis();\r\n    this.lastChanged.set(this.lastScanned);\r\n    logger.debug(\"{} : initial scan found n datasets = {} \", collectionName, map.keySet().size());\r\n    return map.keySet().size() > 0;\r\n  }", "code_tokens": ["private", "boolean", "scanFirstTime", "(", ")", "throws", "IOException", "{", "Map", "<", "String", ",", "MFile", ">", "newMap", "=", "new", "HashMap", "<>", "(", ")", ";", "if", "(", "!", "hasScans", "(", ")", ")", "{", "map", "=", "newMap", ";", "return", "false", ";", "}", "reallyScan", "(", "newMap", ")", ";", "// deleteOld(newMap); // ?? hmmmmm LOOK this seems wrong; maintainence in background ?? generally collection doesnt exist\r", "// implement olderThan\r", "if", "(", "olderThanInMsecs", ">", "0", ")", "{", "long", "olderThan", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "olderThanInMsecs", ";", "// new files must be older than this.\r", "Iterator", "<", "MFile", ">", "iter", "=", "newMap", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "// need iterator so we can remove()\r", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "MFile", "newFile", "=", "iter", ".", "next", "(", ")", ";", "String", "path", "=", "newFile", ".", "getPath", "(", ")", ";", "if", "(", "newFile", ".", "getLastModified", "(", ")", ">", "olderThan", ")", "{", "// the file is too new\r", "iter", ".", "remove", "(", ")", ";", "logger", ".", "debug", "(", "\"{}: scan found new Dataset but its too recently modified = {}\"", ",", "collectionName", ",", "path", ")", ";", "}", "}", "}", "map", "=", "newMap", ";", "this", ".", "lastScanned", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "this", ".", "lastChanged", ".", "set", "(", "this", ".", "lastScanned", ")", ";", "logger", ".", "debug", "(", "\"{} : initial scan found n datasets = {} \"", ",", "collectionName", ",", "map", ".", "keySet", "(", ")", ".", "size", "(", ")", ")", ";", "return", "map", ".", "keySet", "(", ")", ".", "size", "(", ")", ">", "0", ";", "}"], "docstring": "only called from synch methods", "docstring_tokens": ["only", "called", "from", "synch", "methods"]}
{"code": "writer.abort();", "comments": "clean up", "lines": 23, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/FileWriter2.java", "func_name": "FileWriter2.write", "original_string": "public NetcdfFile write(CancelTask cancel) throws IOException {\r\n\r\n    try {\r\n      if (version.isExtendedModel())\r\n        addGroupExtended(null, fileIn.getRootGroup());\r\n      else\r\n        addGroupClassic();\r\n\r\n      if (cancel != null && cancel.isCancel()) return null;\r\n\r\n      // create the file\r\n      writer.create();\r\n\r\n      if (cancel != null && cancel.isCancel()) return null;\r\n      double total = copyVarData(varList, null, cancel);\r\n      if (cancel != null && cancel.isCancel()) return null;\r\n\r\n      writer.flush();\r\n      if (debug) System.out.println(\"FileWriter done total bytes = \" + total);\r\n\r\n    } catch (IOException ioe) {\r\n      ioe.printStackTrace();\r\n      writer.abort();  // clean up\r\n      throw ioe;\r\n    }\r\n\r\n    return writer.getNetcdfFile();\r\n  }", "language": "java", "Allcodes": "public NetcdfFile write(CancelTask cancel) throws IOException {\r\n\r\n    try {\r\n      if (version.isExtendedModel())\r\n        addGroupExtended(null, fileIn.getRootGroup());\r\n      else\r\n        addGroupClassic();\r\n\r\n      if (cancel != null && cancel.isCancel()) return null;\r\n\r\n      // create the file\r\n      writer.create();\r\n\r\n      if (cancel != null && cancel.isCancel()) return null;\r\n      double total = copyVarData(varList, null, cancel);\r\n      if (cancel != null && cancel.isCancel()) return null;\r\n\r\n      writer.flush();\r\n      if (debug) System.out.println(\"FileWriter done total bytes = \" + total);\r\n\r\n    } catch (IOException ioe) {\r\n      ioe.printStackTrace();\r\n      writer.abort();  // clean up\r\n      throw ioe;\r\n    }\r\n\r\n    return writer.getNetcdfFile();\r\n  }", "code_tokens": ["public", "NetcdfFile", "write", "(", "CancelTask", "cancel", ")", "throws", "IOException", "{", "try", "{", "if", "(", "version", ".", "isExtendedModel", "(", ")", ")", "addGroupExtended", "(", "null", ",", "fileIn", ".", "getRootGroup", "(", ")", ")", ";", "else", "addGroupClassic", "(", ")", ";", "if", "(", "cancel", "!=", "null", "&&", "cancel", ".", "isCancel", "(", ")", ")", "return", "null", ";", "// create the file\r", "writer", ".", "create", "(", ")", ";", "if", "(", "cancel", "!=", "null", "&&", "cancel", ".", "isCancel", "(", ")", ")", "return", "null", ";", "double", "total", "=", "copyVarData", "(", "varList", ",", "null", ",", "cancel", ")", ";", "if", "(", "cancel", "!=", "null", "&&", "cancel", ".", "isCancel", "(", ")", ")", "return", "null", ";", "writer", ".", "flush", "(", ")", ";", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\"FileWriter done total bytes = \"", "+", "total", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "ioe", ".", "printStackTrace", "(", ")", ";", "writer", ".", "abort", "(", ")", ";", "// clean up\r", "throw", "ioe", ";", "}", "return", "writer", ".", "getNetcdfFile", "(", ")", ";", "}"], "docstring": "Write the input file to the output file.\n@param cancel  allow user to cancel; may be null.\n@return the open output file.\n@throws IOException", "docstring_tokens": ["Write", "the", "input", "file", "to", "the", "output", "file", "."]}
{"code": "m.setDataArray(newSeq);", "comments": "put back into member array", "lines": 35, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/StructureDS.java", "func_name": "StructureDS.convert", "original_string": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "language": "java", "Allcodes": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "code_tokens": ["protected", "ArrayStructure", "convert", "(", "Array", "data", ",", "Section", "section", ")", "throws", "IOException", "{", "ArrayStructure", "orgAS", "=", "(", "ArrayStructure", ")", "data", ";", "if", "(", "!", "convertNeeded", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ")", "{", "// name, info change only\r", "convertMemberInfo", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ";", "return", "orgAS", ";", "}", "// LOOK! converting to ArrayStructureMA\r", "// do any enum/scale/offset/missing/unsigned conversions\r", "ArrayStructure", "newAS", "=", "ArrayStructureMA", ".", "factoryMA", "(", "orgAS", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "newAS", ".", "getMembers", "(", ")", ")", "{", "VariableEnhanced", "v2", "=", "(", "VariableEnhanced", ")", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "(", "v2", "==", "null", ")", "&&", "(", "orgVar", "!=", "null", ")", ")", "// these are from orgVar - may have been renamed\r", "v2", "=", "findVariableFromOrgName", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "v2", "==", "null", ")", "continue", ";", "if", "(", "v2", "instanceof", "VariableDS", ")", "{", "VariableDS", "vds", "=", "(", "VariableDS", ")", "v2", ";", "if", "(", "vds", ".", "needConvert", "(", ")", ")", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "// mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r", "// VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r", "mdata", "=", "vds", ".", "convert", "(", "mdata", ",", "vds", ".", "getEnhanceMode", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "else", "if", "(", "v2", "instanceof", "StructureDS", ")", "{", "StructureDS", "innerStruct", "=", "(", "StructureDS", ")", "v2", ";", "if", "(", "innerStruct", ".", "convertNeeded", "(", "null", ")", ")", "{", "if", "(", "innerStruct", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "{", "ArrayObject", ".", "D1", "seqArray", "=", "(", "ArrayObject", ".", "D1", ")", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "ArrayObject", ".", "D1", "newSeq", "=", "(", "ArrayObject", ".", "D1", ")", "Array", ".", "factory", "(", "DataType", ".", "SEQUENCE", ",", "new", "int", "[", "]", "{", "(", "int", ")", "seqArray", ".", "getSize", "(", ")", "}", ")", ";", "m", ".", "setDataArray", "(", "newSeq", ")", ";", "// put back into member array\r", "// wrap each Sequence\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "seqArray", ".", "getSize", "(", ")", ";", "i", "++", ")", "{", "ArraySequence", "innerSeq", "=", "(", "ArraySequence", ")", "seqArray", ".", "get", "(", "i", ")", ";", "// get old ArraySequence\r", "newSeq", ".", "set", "(", "i", ",", "new", "SequenceConverter", "(", "innerStruct", ",", "innerSeq", ")", ")", ";", "// wrap in converter\r", "}", "// non-Sequence Structures\r", "}", "else", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "mdata", "=", "innerStruct", ".", "convert", "(", "mdata", ",", "null", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "// always convert the inner StructureMembers\r", "innerStruct", ".", "convertMemberInfo", "(", "m", ".", "getStructureMembers", "(", ")", ")", ";", "}", "}", "StructureMembers", "sm", "=", "newAS", ".", "getStructureMembers", "(", ")", ";", "convertMemberInfo", "(", "sm", ")", ";", "// check for variables that have been added by NcML\r", "for", "(", "Variable", "v", ":", "getVariables", "(", ")", ")", "{", "if", "(", "!", "varHasData", "(", "v", ",", "sm", ")", ")", "{", "try", "{", "Variable", "completeVar", "=", "getParentGroup", "(", ")", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "// LOOK BAD\r", "Array", "mdata", "=", "completeVar", ".", "read", "(", "section", ")", ";", "StructureMembers", ".", "Member", "m", "=", "sm", ".", "addMember", "(", "v", ".", "getShortName", "(", ")", ",", "v", ".", "getDescription", "(", ")", ",", "v", ".", "getUnitsString", "(", ")", ",", "v", ".", "getDataType", "(", ")", ",", "v", ".", "getShape", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "throw", "new", "IOException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "return", "newAS", ";", "}"], "docstring": "3) variable with cached data added to StructureDS through NcML", "docstring_tokens": ["3", ")", "variable", "with", "cached", "data", "added", "to", "StructureDS", "through", "NcML"]}
{"code": "ArraySequence innerSeq = (ArraySequence) seqArray.get(i);", "comments": "get old ArraySequence", "lines": 39, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/StructureDS.java", "func_name": "StructureDS.convert", "original_string": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "language": "java", "Allcodes": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "code_tokens": ["protected", "ArrayStructure", "convert", "(", "Array", "data", ",", "Section", "section", ")", "throws", "IOException", "{", "ArrayStructure", "orgAS", "=", "(", "ArrayStructure", ")", "data", ";", "if", "(", "!", "convertNeeded", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ")", "{", "// name, info change only\r", "convertMemberInfo", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ";", "return", "orgAS", ";", "}", "// LOOK! converting to ArrayStructureMA\r", "// do any enum/scale/offset/missing/unsigned conversions\r", "ArrayStructure", "newAS", "=", "ArrayStructureMA", ".", "factoryMA", "(", "orgAS", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "newAS", ".", "getMembers", "(", ")", ")", "{", "VariableEnhanced", "v2", "=", "(", "VariableEnhanced", ")", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "(", "v2", "==", "null", ")", "&&", "(", "orgVar", "!=", "null", ")", ")", "// these are from orgVar - may have been renamed\r", "v2", "=", "findVariableFromOrgName", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "v2", "==", "null", ")", "continue", ";", "if", "(", "v2", "instanceof", "VariableDS", ")", "{", "VariableDS", "vds", "=", "(", "VariableDS", ")", "v2", ";", "if", "(", "vds", ".", "needConvert", "(", ")", ")", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "// mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r", "// VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r", "mdata", "=", "vds", ".", "convert", "(", "mdata", ",", "vds", ".", "getEnhanceMode", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "else", "if", "(", "v2", "instanceof", "StructureDS", ")", "{", "StructureDS", "innerStruct", "=", "(", "StructureDS", ")", "v2", ";", "if", "(", "innerStruct", ".", "convertNeeded", "(", "null", ")", ")", "{", "if", "(", "innerStruct", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "{", "ArrayObject", ".", "D1", "seqArray", "=", "(", "ArrayObject", ".", "D1", ")", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "ArrayObject", ".", "D1", "newSeq", "=", "(", "ArrayObject", ".", "D1", ")", "Array", ".", "factory", "(", "DataType", ".", "SEQUENCE", ",", "new", "int", "[", "]", "{", "(", "int", ")", "seqArray", ".", "getSize", "(", ")", "}", ")", ";", "m", ".", "setDataArray", "(", "newSeq", ")", ";", "// put back into member array\r", "// wrap each Sequence\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "seqArray", ".", "getSize", "(", ")", ";", "i", "++", ")", "{", "ArraySequence", "innerSeq", "=", "(", "ArraySequence", ")", "seqArray", ".", "get", "(", "i", ")", ";", "// get old ArraySequence\r", "newSeq", ".", "set", "(", "i", ",", "new", "SequenceConverter", "(", "innerStruct", ",", "innerSeq", ")", ")", ";", "// wrap in converter\r", "}", "// non-Sequence Structures\r", "}", "else", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "mdata", "=", "innerStruct", ".", "convert", "(", "mdata", ",", "null", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "// always convert the inner StructureMembers\r", "innerStruct", ".", "convertMemberInfo", "(", "m", ".", "getStructureMembers", "(", ")", ")", ";", "}", "}", "StructureMembers", "sm", "=", "newAS", ".", "getStructureMembers", "(", ")", ";", "convertMemberInfo", "(", "sm", ")", ";", "// check for variables that have been added by NcML\r", "for", "(", "Variable", "v", ":", "getVariables", "(", ")", ")", "{", "if", "(", "!", "varHasData", "(", "v", ",", "sm", ")", ")", "{", "try", "{", "Variable", "completeVar", "=", "getParentGroup", "(", ")", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "// LOOK BAD\r", "Array", "mdata", "=", "completeVar", ".", "read", "(", "section", ")", ";", "StructureMembers", ".", "Member", "m", "=", "sm", ".", "addMember", "(", "v", ".", "getShortName", "(", ")", ",", "v", ".", "getDescription", "(", ")", ",", "v", ".", "getUnitsString", "(", ")", ",", "v", ".", "getDataType", "(", ")", ",", "v", ".", "getShape", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "throw", "new", "IOException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "return", "newAS", ";", "}"], "docstring": "3) variable with cached data added to StructureDS through NcML", "docstring_tokens": ["3", ")", "variable", "with", "cached", "data", "added", "to", "StructureDS", "through", "NcML"]}
{"code": "newSeq.set(i, new SequenceConverter(innerStruct, innerSeq));", "comments": "wrap in converter", "lines": 40, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/StructureDS.java", "func_name": "StructureDS.convert", "original_string": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "language": "java", "Allcodes": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "code_tokens": ["protected", "ArrayStructure", "convert", "(", "Array", "data", ",", "Section", "section", ")", "throws", "IOException", "{", "ArrayStructure", "orgAS", "=", "(", "ArrayStructure", ")", "data", ";", "if", "(", "!", "convertNeeded", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ")", "{", "// name, info change only\r", "convertMemberInfo", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ";", "return", "orgAS", ";", "}", "// LOOK! converting to ArrayStructureMA\r", "// do any enum/scale/offset/missing/unsigned conversions\r", "ArrayStructure", "newAS", "=", "ArrayStructureMA", ".", "factoryMA", "(", "orgAS", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "newAS", ".", "getMembers", "(", ")", ")", "{", "VariableEnhanced", "v2", "=", "(", "VariableEnhanced", ")", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "(", "v2", "==", "null", ")", "&&", "(", "orgVar", "!=", "null", ")", ")", "// these are from orgVar - may have been renamed\r", "v2", "=", "findVariableFromOrgName", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "v2", "==", "null", ")", "continue", ";", "if", "(", "v2", "instanceof", "VariableDS", ")", "{", "VariableDS", "vds", "=", "(", "VariableDS", ")", "v2", ";", "if", "(", "vds", ".", "needConvert", "(", ")", ")", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "// mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r", "// VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r", "mdata", "=", "vds", ".", "convert", "(", "mdata", ",", "vds", ".", "getEnhanceMode", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "else", "if", "(", "v2", "instanceof", "StructureDS", ")", "{", "StructureDS", "innerStruct", "=", "(", "StructureDS", ")", "v2", ";", "if", "(", "innerStruct", ".", "convertNeeded", "(", "null", ")", ")", "{", "if", "(", "innerStruct", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "{", "ArrayObject", ".", "D1", "seqArray", "=", "(", "ArrayObject", ".", "D1", ")", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "ArrayObject", ".", "D1", "newSeq", "=", "(", "ArrayObject", ".", "D1", ")", "Array", ".", "factory", "(", "DataType", ".", "SEQUENCE", ",", "new", "int", "[", "]", "{", "(", "int", ")", "seqArray", ".", "getSize", "(", ")", "}", ")", ";", "m", ".", "setDataArray", "(", "newSeq", ")", ";", "// put back into member array\r", "// wrap each Sequence\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "seqArray", ".", "getSize", "(", ")", ";", "i", "++", ")", "{", "ArraySequence", "innerSeq", "=", "(", "ArraySequence", ")", "seqArray", ".", "get", "(", "i", ")", ";", "// get old ArraySequence\r", "newSeq", ".", "set", "(", "i", ",", "new", "SequenceConverter", "(", "innerStruct", ",", "innerSeq", ")", ")", ";", "// wrap in converter\r", "}", "// non-Sequence Structures\r", "}", "else", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "mdata", "=", "innerStruct", ".", "convert", "(", "mdata", ",", "null", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "// always convert the inner StructureMembers\r", "innerStruct", ".", "convertMemberInfo", "(", "m", ".", "getStructureMembers", "(", ")", ")", ";", "}", "}", "StructureMembers", "sm", "=", "newAS", ".", "getStructureMembers", "(", ")", ";", "convertMemberInfo", "(", "sm", ")", ";", "// check for variables that have been added by NcML\r", "for", "(", "Variable", "v", ":", "getVariables", "(", ")", ")", "{", "if", "(", "!", "varHasData", "(", "v", ",", "sm", ")", ")", "{", "try", "{", "Variable", "completeVar", "=", "getParentGroup", "(", ")", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "// LOOK BAD\r", "Array", "mdata", "=", "completeVar", ".", "read", "(", "section", ")", ";", "StructureMembers", ".", "Member", "m", "=", "sm", ".", "addMember", "(", "v", ".", "getShortName", "(", ")", ",", "v", ".", "getDescription", "(", ")", ",", "v", ".", "getUnitsString", "(", ")", ",", "v", ".", "getDataType", "(", ")", ",", "v", ".", "getShape", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "throw", "new", "IOException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "return", "newAS", ";", "}"], "docstring": "3) variable with cached data added to StructureDS through NcML", "docstring_tokens": ["3", ")", "variable", "with", "cached", "data", "added", "to", "StructureDS", "through", "NcML"]}
{"code": "Variable completeVar = getParentGroup().findVariable(v.getShortName());", "comments": "LOOK BAD", "lines": 64, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/StructureDS.java", "func_name": "StructureDS.convert", "original_string": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "language": "java", "Allcodes": "protected ArrayStructure convert(Array data, Section section) throws IOException {\r\n    ArrayStructure orgAS = (ArrayStructure) data;\r\n    if (!convertNeeded(orgAS.getStructureMembers())) {\r\n      // name, info change only\r\n      convertMemberInfo(orgAS.getStructureMembers());\r\n      return orgAS;\r\n    }\r\n\r\n    // LOOK! converting to ArrayStructureMA\r\n    // do any enum/scale/offset/missing/unsigned conversions\r\n    ArrayStructure newAS = ArrayStructureMA.factoryMA(orgAS);\r\n    for (StructureMembers.Member m : newAS.getMembers()) {\r\n      VariableEnhanced v2 = (VariableEnhanced) findVariable(m.getName());\r\n      if ((v2 == null) && (orgVar != null)) // these are from orgVar - may have been renamed\r\n        v2 = findVariableFromOrgName(m.getName());\r\n      if (v2 == null) continue;\r\n\r\n      if (v2 instanceof VariableDS) {\r\n        VariableDS vds = (VariableDS) v2;\r\n        if (vds.needConvert()) {\r\n          Array mdata = newAS.extractMemberArray(m);\r\n          // mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r\n          // VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r\n          mdata = vds.convert(mdata, vds.getEnhanceMode());\r\n          newAS.setMemberArray(m, mdata);\r\n        }\r\n\r\n      } else if (v2 instanceof StructureDS) {\r\n        StructureDS innerStruct = (StructureDS) v2;\r\n        if (innerStruct.convertNeeded(null)) {\r\n\r\n          if (innerStruct.getDataType() == DataType.SEQUENCE) {\r\n            ArrayObject.D1 seqArray = (ArrayObject.D1) newAS.extractMemberArray(m);\r\n            ArrayObject.D1 newSeq = (ArrayObject.D1) Array.factory(DataType.SEQUENCE, new int[] {(int) seqArray.getSize()});\r\n            m.setDataArray(newSeq); // put back into member array\r\n\r\n            // wrap each Sequence\r\n            for (int i = 0; i < seqArray.getSize(); i++) {\r\n              ArraySequence innerSeq = (ArraySequence) seqArray.get(i); // get old ArraySequence\r\n              newSeq.set(i, new SequenceConverter(innerStruct, innerSeq)); // wrap in converter\r\n            }\r\n\r\n            // non-Sequence Structures\r\n          } else {\r\n            Array mdata = newAS.extractMemberArray(m);\r\n            mdata = innerStruct.convert(mdata, null);\r\n            newAS.setMemberArray(m, mdata);\r\n          }\r\n\r\n        }\r\n\r\n        // always convert the inner StructureMembers\r\n        innerStruct.convertMemberInfo(m.getStructureMembers());\r\n      }\r\n    }\r\n\r\n    StructureMembers sm = newAS.getStructureMembers();\r\n    convertMemberInfo(sm);\r\n\r\n    // check for variables that have been added by NcML\r\n    for (Variable v : getVariables()) {\r\n      if (!varHasData(v, sm)) {\r\n        try {\r\n          Variable completeVar = getParentGroup().findVariable(v.getShortName()); // LOOK BAD\r\n          Array mdata = completeVar.read(section);\r\n          StructureMembers.Member m = sm.addMember(v.getShortName(), v.getDescription(), v.getUnitsString(), v.getDataType(), v.getShape());\r\n          newAS.setMemberArray(m, mdata);\r\n        } catch (InvalidRangeException e) {\r\n          throw new IOException(e.getMessage());\r\n        }\r\n      }\r\n    }\r\n\r\n    return newAS;\r\n  }", "code_tokens": ["protected", "ArrayStructure", "convert", "(", "Array", "data", ",", "Section", "section", ")", "throws", "IOException", "{", "ArrayStructure", "orgAS", "=", "(", "ArrayStructure", ")", "data", ";", "if", "(", "!", "convertNeeded", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ")", "{", "// name, info change only\r", "convertMemberInfo", "(", "orgAS", ".", "getStructureMembers", "(", ")", ")", ";", "return", "orgAS", ";", "}", "// LOOK! converting to ArrayStructureMA\r", "// do any enum/scale/offset/missing/unsigned conversions\r", "ArrayStructure", "newAS", "=", "ArrayStructureMA", ".", "factoryMA", "(", "orgAS", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "newAS", ".", "getMembers", "(", ")", ")", "{", "VariableEnhanced", "v2", "=", "(", "VariableEnhanced", ")", "findVariable", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "(", "v2", "==", "null", ")", "&&", "(", "orgVar", "!=", "null", ")", ")", "// these are from orgVar - may have been renamed\r", "v2", "=", "findVariableFromOrgName", "(", "m", ".", "getName", "(", ")", ")", ";", "if", "(", "v2", "==", "null", ")", "continue", ";", "if", "(", "v2", "instanceof", "VariableDS", ")", "{", "VariableDS", "vds", "=", "(", "VariableDS", ")", "v2", ";", "if", "(", "vds", ".", "needConvert", "(", ")", ")", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "// mdata has not yet been enhanced, but vds would *think* that it has been if we used the 1-arg version of\r", "// VariableDS.convert(). So, we use the 2-arg version to explicitly request enhancement.\r", "mdata", "=", "vds", ".", "convert", "(", "mdata", ",", "vds", ".", "getEnhanceMode", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "else", "if", "(", "v2", "instanceof", "StructureDS", ")", "{", "StructureDS", "innerStruct", "=", "(", "StructureDS", ")", "v2", ";", "if", "(", "innerStruct", ".", "convertNeeded", "(", "null", ")", ")", "{", "if", "(", "innerStruct", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "{", "ArrayObject", ".", "D1", "seqArray", "=", "(", "ArrayObject", ".", "D1", ")", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "ArrayObject", ".", "D1", "newSeq", "=", "(", "ArrayObject", ".", "D1", ")", "Array", ".", "factory", "(", "DataType", ".", "SEQUENCE", ",", "new", "int", "[", "]", "{", "(", "int", ")", "seqArray", ".", "getSize", "(", ")", "}", ")", ";", "m", ".", "setDataArray", "(", "newSeq", ")", ";", "// put back into member array\r", "// wrap each Sequence\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "seqArray", ".", "getSize", "(", ")", ";", "i", "++", ")", "{", "ArraySequence", "innerSeq", "=", "(", "ArraySequence", ")", "seqArray", ".", "get", "(", "i", ")", ";", "// get old ArraySequence\r", "newSeq", ".", "set", "(", "i", ",", "new", "SequenceConverter", "(", "innerStruct", ",", "innerSeq", ")", ")", ";", "// wrap in converter\r", "}", "// non-Sequence Structures\r", "}", "else", "{", "Array", "mdata", "=", "newAS", ".", "extractMemberArray", "(", "m", ")", ";", "mdata", "=", "innerStruct", ".", "convert", "(", "mdata", ",", "null", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "}", "// always convert the inner StructureMembers\r", "innerStruct", ".", "convertMemberInfo", "(", "m", ".", "getStructureMembers", "(", ")", ")", ";", "}", "}", "StructureMembers", "sm", "=", "newAS", ".", "getStructureMembers", "(", ")", ";", "convertMemberInfo", "(", "sm", ")", ";", "// check for variables that have been added by NcML\r", "for", "(", "Variable", "v", ":", "getVariables", "(", ")", ")", "{", "if", "(", "!", "varHasData", "(", "v", ",", "sm", ")", ")", "{", "try", "{", "Variable", "completeVar", "=", "getParentGroup", "(", ")", ".", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", ";", "// LOOK BAD\r", "Array", "mdata", "=", "completeVar", ".", "read", "(", "section", ")", ";", "StructureMembers", ".", "Member", "m", "=", "sm", ".", "addMember", "(", "v", ".", "getShortName", "(", ")", ",", "v", ".", "getDescription", "(", ")", ",", "v", ".", "getUnitsString", "(", ")", ",", "v", ".", "getDataType", "(", ")", ",", "v", ".", "getShape", "(", ")", ")", ";", "newAS", ".", "setMemberArray", "(", "m", ",", "mdata", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "throw", "new", "IOException", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "return", "newAS", ";", "}"], "docstring": "3) variable with cached data added to StructureDS through NcML", "docstring_tokens": ["3", ")", "variable", "with", "cached", "data", "added", "to", "StructureDS", "through", "NcML"]}
{"code": "rc = match.dataRoot.getRestrict();", "comments": "datasetScan, featCollection are restricted at the dataRoot", "lines": 9, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/DatasetManager.java", "func_name": "DatasetManager.resourceControlOk", "original_string": "public boolean resourceControlOk(HttpServletRequest req, HttpServletResponse res, String reqPath) {\n    if (null == reqPath)\n      reqPath = TdsPathUtils.extractPath(req, null);\n\n    // see if its under resource control\n    String rc = null;\n    DataRootManager.DataRootMatch match = dataRootManager.findDataRootMatch(reqPath);\n    if (match != null) {\n      rc = match.dataRoot.getRestrict(); // datasetScan, featCollection are restricted at the dataRoot\n    }\n\n    if (rc == null) {\n      rc = datasetTracker.findResourceControl(reqPath); // regular datasets tracked here\n    }\n\n    return resourceAuthorized(req, res, rc);\n  }", "language": "java", "Allcodes": "public boolean resourceControlOk(HttpServletRequest req, HttpServletResponse res, String reqPath) {\n    if (null == reqPath)\n      reqPath = TdsPathUtils.extractPath(req, null);\n\n    // see if its under resource control\n    String rc = null;\n    DataRootManager.DataRootMatch match = dataRootManager.findDataRootMatch(reqPath);\n    if (match != null) {\n      rc = match.dataRoot.getRestrict(); // datasetScan, featCollection are restricted at the dataRoot\n    }\n\n    if (rc == null) {\n      rc = datasetTracker.findResourceControl(reqPath); // regular datasets tracked here\n    }\n\n    return resourceAuthorized(req, res, rc);\n  }", "code_tokens": ["public", "boolean", "resourceControlOk", "(", "HttpServletRequest", "req", ",", "HttpServletResponse", "res", ",", "String", "reqPath", ")", "{", "if", "(", "null", "==", "reqPath", ")", "reqPath", "=", "TdsPathUtils", ".", "extractPath", "(", "req", ",", "null", ")", ";", "// see if its under resource control", "String", "rc", "=", "null", ";", "DataRootManager", ".", "DataRootMatch", "match", "=", "dataRootManager", ".", "findDataRootMatch", "(", "reqPath", ")", ";", "if", "(", "match", "!=", "null", ")", "{", "rc", "=", "match", ".", "dataRoot", ".", "getRestrict", "(", ")", ";", "// datasetScan, featCollection are restricted at the dataRoot", "}", "if", "(", "rc", "==", "null", ")", "{", "rc", "=", "datasetTracker", ".", "findResourceControl", "(", "reqPath", ")", ";", "// regular datasets tracked here", "}", "return", "resourceAuthorized", "(", "req", ",", "res", ",", "rc", ")", ";", "}"], "docstring": "Check if this is making a request for a restricted dataset, and if so, if its allowed.\n\n@param req     the request\n@param res     the response\n@param reqPath the request path; if null, use req.getPathInfo()\n@return true if ok to proceed. If false, the appropriate error or redirect message has been sent, the caller only needs to return.", "docstring_tokens": ["Check", "if", "this", "is", "making", "a", "request", "for", "a", "restricted", "dataset", "and", "if", "so", "if", "its", "allowed", "."]}
{"code": "rc = datasetTracker.findResourceControl(reqPath);", "comments": "regular datasets tracked here", "lines": 13, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/DatasetManager.java", "func_name": "DatasetManager.resourceControlOk", "original_string": "public boolean resourceControlOk(HttpServletRequest req, HttpServletResponse res, String reqPath) {\n    if (null == reqPath)\n      reqPath = TdsPathUtils.extractPath(req, null);\n\n    // see if its under resource control\n    String rc = null;\n    DataRootManager.DataRootMatch match = dataRootManager.findDataRootMatch(reqPath);\n    if (match != null) {\n      rc = match.dataRoot.getRestrict(); // datasetScan, featCollection are restricted at the dataRoot\n    }\n\n    if (rc == null) {\n      rc = datasetTracker.findResourceControl(reqPath); // regular datasets tracked here\n    }\n\n    return resourceAuthorized(req, res, rc);\n  }", "language": "java", "Allcodes": "public boolean resourceControlOk(HttpServletRequest req, HttpServletResponse res, String reqPath) {\n    if (null == reqPath)\n      reqPath = TdsPathUtils.extractPath(req, null);\n\n    // see if its under resource control\n    String rc = null;\n    DataRootManager.DataRootMatch match = dataRootManager.findDataRootMatch(reqPath);\n    if (match != null) {\n      rc = match.dataRoot.getRestrict(); // datasetScan, featCollection are restricted at the dataRoot\n    }\n\n    if (rc == null) {\n      rc = datasetTracker.findResourceControl(reqPath); // regular datasets tracked here\n    }\n\n    return resourceAuthorized(req, res, rc);\n  }", "code_tokens": ["public", "boolean", "resourceControlOk", "(", "HttpServletRequest", "req", ",", "HttpServletResponse", "res", ",", "String", "reqPath", ")", "{", "if", "(", "null", "==", "reqPath", ")", "reqPath", "=", "TdsPathUtils", ".", "extractPath", "(", "req", ",", "null", ")", ";", "// see if its under resource control", "String", "rc", "=", "null", ";", "DataRootManager", ".", "DataRootMatch", "match", "=", "dataRootManager", ".", "findDataRootMatch", "(", "reqPath", ")", ";", "if", "(", "match", "!=", "null", ")", "{", "rc", "=", "match", ".", "dataRoot", ".", "getRestrict", "(", ")", ";", "// datasetScan, featCollection are restricted at the dataRoot", "}", "if", "(", "rc", "==", "null", ")", "{", "rc", "=", "datasetTracker", ".", "findResourceControl", "(", "reqPath", ")", ";", "// regular datasets tracked here", "}", "return", "resourceAuthorized", "(", "req", ",", "res", ",", "rc", ")", ";", "}"], "docstring": "Check if this is making a request for a restricted dataset, and if so, if its allowed.\n\n@param req     the request\n@param res     the response\n@param reqPath the request path; if null, use req.getPathInfo()\n@return true if ok to proceed. If false, the appropriate error or redirect message has been sent, the caller only needs to return.", "docstring_tokens": ["Check", "if", "this", "is", "making", "a", "request", "for", "a", "restricted", "dataset", "and", "if", "so", "if", "its", "allowed", "."]}
{"code": "shape = new int[] { 0 };", "comments": "\"from\" really was empty.", "lines": 38, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/ArrayStructureMA.java", "func_name": "ArrayStructureMA.factoryMA", "original_string": "static public ArrayStructureMA factoryMA(ArrayStructure from) throws IOException {\r\n    if (from instanceof ArrayStructureMA)\r\n      return (ArrayStructureMA) from;\r\n\r\n    // To create an ArrayStructureMA that we can iterate over later, we need to know the shape of \"from\".\r\n    if (from.getSize() > 0) {\r\n      ArrayStructureMA to = new ArrayStructureMA(new StructureMembers(from.getStructureMembers()), from.getShape());\r\n      for (StructureMembers.Member m : from.getMembers()) {\r\n        to.setMemberArray(m.getName(), from.extractMemberArray(m));\r\n      }\r\n      return to;\r\n    }\r\n\r\n    // from.getSize() <= 0. This usually means that \"from\" is an ArraySequence, and that we won't know its size until\r\n    // we iterate over it. extractMemberArray() will do that iteration for us, and then we can use the size of the\r\n    // array it returns to determine the shape of \"from\".\r\n\r\n    int numRecords = -1;\r\n    Map<String, Array> memberArrayMap = new LinkedHashMap<>();\r\n\r\n    for (StructureMembers.Member m : from.getMembers()) {\r\n      Array array = from.extractMemberArray(m);\r\n      assert array.getSize() > 0 : \"array's size should have been computed in extractMemberArray().\";\r\n      int firstDimLen = array.getShape()[0];\r\n\r\n      if (numRecords == -1) {\r\n        numRecords = firstDimLen;\r\n      } else {\r\n        assert numRecords == firstDimLen : String.format(\"Expected all structure members to have the same first\" +\r\n                \"dimension length, but %d != %d.\", numRecords, firstDimLen);\r\n      }\r\n\r\n      memberArrayMap.put(m.getName(), array);\r\n    }\r\n\r\n    int[] shape;\r\n    if (numRecords == -1) {\r\n      shape = new int[] { 0 };  // \"from\" really was empty.\r\n    } else {\r\n      shape = new int[] { numRecords };\r\n    }\r\n\r\n    ArrayStructureMA to = new ArrayStructureMA(new StructureMembers(from.getStructureMembers()), shape);\r\n\r\n    for (Map.Entry<String, Array> entry : memberArrayMap.entrySet()) {\r\n      to.setMemberArray(entry.getKey(), entry.getValue());\r\n    }\r\n\r\n    return to;\r\n  }", "language": "java", "Allcodes": "static public ArrayStructureMA factoryMA(ArrayStructure from) throws IOException {\r\n    if (from instanceof ArrayStructureMA)\r\n      return (ArrayStructureMA) from;\r\n\r\n    // To create an ArrayStructureMA that we can iterate over later, we need to know the shape of \"from\".\r\n    if (from.getSize() > 0) {\r\n      ArrayStructureMA to = new ArrayStructureMA(new StructureMembers(from.getStructureMembers()), from.getShape());\r\n      for (StructureMembers.Member m : from.getMembers()) {\r\n        to.setMemberArray(m.getName(), from.extractMemberArray(m));\r\n      }\r\n      return to;\r\n    }\r\n\r\n    // from.getSize() <= 0. This usually means that \"from\" is an ArraySequence, and that we won't know its size until\r\n    // we iterate over it. extractMemberArray() will do that iteration for us, and then we can use the size of the\r\n    // array it returns to determine the shape of \"from\".\r\n\r\n    int numRecords = -1;\r\n    Map<String, Array> memberArrayMap = new LinkedHashMap<>();\r\n\r\n    for (StructureMembers.Member m : from.getMembers()) {\r\n      Array array = from.extractMemberArray(m);\r\n      assert array.getSize() > 0 : \"array's size should have been computed in extractMemberArray().\";\r\n      int firstDimLen = array.getShape()[0];\r\n\r\n      if (numRecords == -1) {\r\n        numRecords = firstDimLen;\r\n      } else {\r\n        assert numRecords == firstDimLen : String.format(\"Expected all structure members to have the same first\" +\r\n                \"dimension length, but %d != %d.\", numRecords, firstDimLen);\r\n      }\r\n\r\n      memberArrayMap.put(m.getName(), array);\r\n    }\r\n\r\n    int[] shape;\r\n    if (numRecords == -1) {\r\n      shape = new int[] { 0 };  // \"from\" really was empty.\r\n    } else {\r\n      shape = new int[] { numRecords };\r\n    }\r\n\r\n    ArrayStructureMA to = new ArrayStructureMA(new StructureMembers(from.getStructureMembers()), shape);\r\n\r\n    for (Map.Entry<String, Array> entry : memberArrayMap.entrySet()) {\r\n      to.setMemberArray(entry.getKey(), entry.getValue());\r\n    }\r\n\r\n    return to;\r\n  }", "code_tokens": ["static", "public", "ArrayStructureMA", "factoryMA", "(", "ArrayStructure", "from", ")", "throws", "IOException", "{", "if", "(", "from", "instanceof", "ArrayStructureMA", ")", "return", "(", "ArrayStructureMA", ")", "from", ";", "// To create an ArrayStructureMA that we can iterate over later, we need to know the shape of \"from\".\r", "if", "(", "from", ".", "getSize", "(", ")", ">", "0", ")", "{", "ArrayStructureMA", "to", "=", "new", "ArrayStructureMA", "(", "new", "StructureMembers", "(", "from", ".", "getStructureMembers", "(", ")", ")", ",", "from", ".", "getShape", "(", ")", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "from", ".", "getMembers", "(", ")", ")", "{", "to", ".", "setMemberArray", "(", "m", ".", "getName", "(", ")", ",", "from", ".", "extractMemberArray", "(", "m", ")", ")", ";", "}", "return", "to", ";", "}", "// from.getSize() <= 0. This usually means that \"from\" is an ArraySequence, and that we won't know its size until\r", "// we iterate over it. extractMemberArray() will do that iteration for us, and then we can use the size of the\r", "// array it returns to determine the shape of \"from\".\r", "int", "numRecords", "=", "-", "1", ";", "Map", "<", "String", ",", "Array", ">", "memberArrayMap", "=", "new", "LinkedHashMap", "<>", "(", ")", ";", "for", "(", "StructureMembers", ".", "Member", "m", ":", "from", ".", "getMembers", "(", ")", ")", "{", "Array", "array", "=", "from", ".", "extractMemberArray", "(", "m", ")", ";", "assert", "array", ".", "getSize", "(", ")", ">", "0", ":", "\"array's size should have been computed in extractMemberArray().\"", ";", "int", "firstDimLen", "=", "array", ".", "getShape", "(", ")", "[", "0", "]", ";", "if", "(", "numRecords", "==", "-", "1", ")", "{", "numRecords", "=", "firstDimLen", ";", "}", "else", "{", "assert", "numRecords", "==", "firstDimLen", ":", "String", ".", "format", "(", "\"Expected all structure members to have the same first\"", "+", "\"dimension length, but %d != %d.\"", ",", "numRecords", ",", "firstDimLen", ")", ";", "}", "memberArrayMap", ".", "put", "(", "m", ".", "getName", "(", ")", ",", "array", ")", ";", "}", "int", "[", "]", "shape", ";", "if", "(", "numRecords", "==", "-", "1", ")", "{", "shape", "=", "new", "int", "[", "]", "{", "0", "}", ";", "// \"from\" really was empty.\r", "}", "else", "{", "shape", "=", "new", "int", "[", "]", "{", "numRecords", "}", ";", "}", "ArrayStructureMA", "to", "=", "new", "ArrayStructureMA", "(", "new", "StructureMembers", "(", "from", ".", "getStructureMembers", "(", ")", ")", ",", "shape", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Array", ">", "entry", ":", "memberArrayMap", ".", "entrySet", "(", ")", ")", "{", "to", ".", "setMemberArray", "(", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "}", "return", "to", ";", "}"], "docstring": "Turn any ArrayStructure into a ArrayStructureMA\n@param from copy from here. If from is a ArrayStructureMA, return it.\n@return equivalent ArrayStructureMA\n@throws java.io.IOException on error reading a sequence", "docstring_tokens": ["Turn", "any", "ArrayStructure", "into", "a", "ArrayStructureMA"]}
{"code": "data = Array.factory(DataType.SEQUENCE, shape);", "comments": "an array sequence - one for each parent element", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/ArrayStructureMA.java", "func_name": "ArrayStructureMA.factoryMA", "original_string": "static public ArrayStructureMA factoryMA(Structure from, int[] shape) throws IOException {\r\n    StructureMembers sm = from.makeStructureMembers();\r\n    for (Variable v : from.getVariables()) {\r\n      Array data;\r\n      if (v instanceof Sequence) {\r\n        data = Array.factory(DataType.SEQUENCE, shape);  // an array sequence - one for each parent element\r\n        //Structure s = (Structure) v;\r\n        //StructureMembers smn = s.makeStructureMembers();\r\n        // data = new ArraySequenceNested(smn, (int) Index.computeSize(v.getShapeAll())); // ??\r\n\r\n      } else if (v instanceof Structure)\r\n        data = ArrayStructureMA.factoryMA((Structure) v, combine(shape, v.getShape()));\r\n\r\n      else\r\n        data = Array.factory(v.getDataType(), combine(shape, v.getShape()));\r\n\r\n      StructureMembers.Member m = sm.findMember(v.getShortName());\r\n      m.setDataArray(data);\r\n    }\r\n\r\n    return new ArrayStructureMA(sm, shape);\r\n  }", "language": "java", "Allcodes": "static public ArrayStructureMA factoryMA(Structure from, int[] shape) throws IOException {\r\n    StructureMembers sm = from.makeStructureMembers();\r\n    for (Variable v : from.getVariables()) {\r\n      Array data;\r\n      if (v instanceof Sequence) {\r\n        data = Array.factory(DataType.SEQUENCE, shape);  // an array sequence - one for each parent element\r\n        //Structure s = (Structure) v;\r\n        //StructureMembers smn = s.makeStructureMembers();\r\n        // data = new ArraySequenceNested(smn, (int) Index.computeSize(v.getShapeAll())); // ??\r\n\r\n      } else if (v instanceof Structure)\r\n        data = ArrayStructureMA.factoryMA((Structure) v, combine(shape, v.getShape()));\r\n\r\n      else\r\n        data = Array.factory(v.getDataType(), combine(shape, v.getShape()));\r\n\r\n      StructureMembers.Member m = sm.findMember(v.getShortName());\r\n      m.setDataArray(data);\r\n    }\r\n\r\n    return new ArrayStructureMA(sm, shape);\r\n  }", "code_tokens": ["static", "public", "ArrayStructureMA", "factoryMA", "(", "Structure", "from", ",", "int", "[", "]", "shape", ")", "throws", "IOException", "{", "StructureMembers", "sm", "=", "from", ".", "makeStructureMembers", "(", ")", ";", "for", "(", "Variable", "v", ":", "from", ".", "getVariables", "(", ")", ")", "{", "Array", "data", ";", "if", "(", "v", "instanceof", "Sequence", ")", "{", "data", "=", "Array", ".", "factory", "(", "DataType", ".", "SEQUENCE", ",", "shape", ")", ";", "// an array sequence - one for each parent element\r", "//Structure s = (Structure) v;\r", "//StructureMembers smn = s.makeStructureMembers();\r", "// data = new ArraySequenceNested(smn, (int) Index.computeSize(v.getShapeAll())); // ??\r", "}", "else", "if", "(", "v", "instanceof", "Structure", ")", "data", "=", "ArrayStructureMA", ".", "factoryMA", "(", "(", "Structure", ")", "v", ",", "combine", "(", "shape", ",", "v", ".", "getShape", "(", ")", ")", ")", ";", "else", "data", "=", "Array", ".", "factory", "(", "v", ".", "getDataType", "(", ")", ",", "combine", "(", "shape", ",", "v", ".", "getShape", "(", ")", ")", ")", ";", "StructureMembers", ".", "Member", "m", "=", "sm", ".", "findMember", "(", "v", ".", "getShortName", "(", ")", ")", ";", "m", ".", "setDataArray", "(", "data", ")", ";", "}", "return", "new", "ArrayStructureMA", "(", "sm", ",", "shape", ")", ";", "}"], "docstring": "Create an ArrayStructure for a Structure. Allow nested Structures.\nCreate the data arrays, and an iterator.\n\n@param from copy from here. If from is a ArrayStructureMA, return it.\n@param shape the shape of the ArrayStructure\n@return equivilent ArrayStructureMA\n@throws java.io.IOException on error reading a sequence", "docstring_tokens": ["Create", "an", "ArrayStructure", "for", "a", "Structure", ".", "Allow", "nested", "Structures", ".", "Create", "the", "data", "arrays", "and", "an", "iterator", "."]}
{"code": "break;", "comments": "leave as is", "lines": 46, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/ce/CECompiler.java", "func_name": "CECompiler.compilefilter", "original_string": "public void\n    compilefilter(DapVariable var, DapSequence seq, CEAST expr)\n            throws DapException\n    {\n        if(expr == null)\n            return;\n        if(expr.sort == CEAST.Sort.SEGMENT) {\n            // This must be a simple segment and it must appear in seq\n            if(expr.subnodes != null)\n                throw new DapException(\"compilefilter: Non-simple segment:\" + expr.name);\n            // Look for the name in the top-level field of seq\n            DapVariable field = seq.findByName(expr.name);\n            if(field == null)\n                throw new DapException(\"compilefilter: Unknown filter variable:\" + expr.name);\n            expr.field = field;\n        } else if(expr.sort == CEAST.Sort.EXPR) {\n            if(expr.lhs != null)\n                compilefilter(var, seq, expr.lhs);\n            if(expr.rhs != null)\n                compilefilter(var, seq, expr.rhs);\n            // If both lhs and rhs are non-null,\n            // canonicalize any comparison so that it is var op const\n            if(expr.lhs != null && expr.rhs != null) {\n                boolean leftvar = (expr.lhs.sort == CEAST.Sort.SEGMENT);\n                boolean rightvar = (expr.rhs.sort == CEAST.Sort.SEGMENT);\n\n                if(rightvar && !leftvar) { // swap operands\n                    CEAST tmp = expr.lhs;\n                    expr.lhs = expr.rhs;\n                    expr.rhs = tmp;\n                    // fix operator\n                    switch (expr.op) {\n                    case LT:  //x<y -> y>x\n                        expr.op = CEAST.Operator.GT;\n                        break;\n                    case LE: //x<=y -> y>=x\n                        expr.op = CEAST.Operator.GE;\n                        break;\n                    case GT:  //x>y -> y<x\n                        expr.op = CEAST.Operator.LT;\n                        break;\n                    case GE:   //x>=y -> y<=x\n                        expr.op = CEAST.Operator.LE;\n                        break;\n                    default:\n                        break; // leave as is\n                    }\n                }\n            }\n        } else if(expr.sort == CEAST.Sort.CONSTANT) {\n            return;\n        } else\n            throw new DapException(\"compilefilter: Unexpected node type:\" + expr.sort);\n    }", "language": "java", "Allcodes": "public void\n    compilefilter(DapVariable var, DapSequence seq, CEAST expr)\n            throws DapException\n    {\n        if(expr == null)\n            return;\n        if(expr.sort == CEAST.Sort.SEGMENT) {\n            // This must be a simple segment and it must appear in seq\n            if(expr.subnodes != null)\n                throw new DapException(\"compilefilter: Non-simple segment:\" + expr.name);\n            // Look for the name in the top-level field of seq\n            DapVariable field = seq.findByName(expr.name);\n            if(field == null)\n                throw new DapException(\"compilefilter: Unknown filter variable:\" + expr.name);\n            expr.field = field;\n        } else if(expr.sort == CEAST.Sort.EXPR) {\n            if(expr.lhs != null)\n                compilefilter(var, seq, expr.lhs);\n            if(expr.rhs != null)\n                compilefilter(var, seq, expr.rhs);\n            // If both lhs and rhs are non-null,\n            // canonicalize any comparison so that it is var op const\n            if(expr.lhs != null && expr.rhs != null) {\n                boolean leftvar = (expr.lhs.sort == CEAST.Sort.SEGMENT);\n                boolean rightvar = (expr.rhs.sort == CEAST.Sort.SEGMENT);\n\n                if(rightvar && !leftvar) { // swap operands\n                    CEAST tmp = expr.lhs;\n                    expr.lhs = expr.rhs;\n                    expr.rhs = tmp;\n                    // fix operator\n                    switch (expr.op) {\n                    case LT:  //x<y -> y>x\n                        expr.op = CEAST.Operator.GT;\n                        break;\n                    case LE: //x<=y -> y>=x\n                        expr.op = CEAST.Operator.GE;\n                        break;\n                    case GT:  //x>y -> y<x\n                        expr.op = CEAST.Operator.LT;\n                        break;\n                    case GE:   //x>=y -> y<=x\n                        expr.op = CEAST.Operator.LE;\n                        break;\n                    default:\n                        break; // leave as is\n                    }\n                }\n            }\n        } else if(expr.sort == CEAST.Sort.CONSTANT) {\n            return;\n        } else\n            throw new DapException(\"compilefilter: Unexpected node type:\" + expr.sort);\n    }", "code_tokens": ["public", "void", "compilefilter", "(", "DapVariable", "var", ",", "DapSequence", "seq", ",", "CEAST", "expr", ")", "throws", "DapException", "{", "if", "(", "expr", "==", "null", ")", "return", ";", "if", "(", "expr", ".", "sort", "==", "CEAST", ".", "Sort", ".", "SEGMENT", ")", "{", "// This must be a simple segment and it must appear in seq", "if", "(", "expr", ".", "subnodes", "!=", "null", ")", "throw", "new", "DapException", "(", "\"compilefilter: Non-simple segment:\"", "+", "expr", ".", "name", ")", ";", "// Look for the name in the top-level field of seq", "DapVariable", "field", "=", "seq", ".", "findByName", "(", "expr", ".", "name", ")", ";", "if", "(", "field", "==", "null", ")", "throw", "new", "DapException", "(", "\"compilefilter: Unknown filter variable:\"", "+", "expr", ".", "name", ")", ";", "expr", ".", "field", "=", "field", ";", "}", "else", "if", "(", "expr", ".", "sort", "==", "CEAST", ".", "Sort", ".", "EXPR", ")", "{", "if", "(", "expr", ".", "lhs", "!=", "null", ")", "compilefilter", "(", "var", ",", "seq", ",", "expr", ".", "lhs", ")", ";", "if", "(", "expr", ".", "rhs", "!=", "null", ")", "compilefilter", "(", "var", ",", "seq", ",", "expr", ".", "rhs", ")", ";", "// If both lhs and rhs are non-null,", "// canonicalize any comparison so that it is var op const", "if", "(", "expr", ".", "lhs", "!=", "null", "&&", "expr", ".", "rhs", "!=", "null", ")", "{", "boolean", "leftvar", "=", "(", "expr", ".", "lhs", ".", "sort", "==", "CEAST", ".", "Sort", ".", "SEGMENT", ")", ";", "boolean", "rightvar", "=", "(", "expr", ".", "rhs", ".", "sort", "==", "CEAST", ".", "Sort", ".", "SEGMENT", ")", ";", "if", "(", "rightvar", "&&", "!", "leftvar", ")", "{", "// swap operands", "CEAST", "tmp", "=", "expr", ".", "lhs", ";", "expr", ".", "lhs", "=", "expr", ".", "rhs", ";", "expr", ".", "rhs", "=", "tmp", ";", "// fix operator", "switch", "(", "expr", ".", "op", ")", "{", "case", "LT", ":", "//x<y -> y>x", "expr", ".", "op", "=", "CEAST", ".", "Operator", ".", "GT", ";", "break", ";", "case", "LE", ":", "//x<=y -> y>=x", "expr", ".", "op", "=", "CEAST", ".", "Operator", ".", "GE", ";", "break", ";", "case", "GT", ":", "//x>y -> y<x", "expr", ".", "op", "=", "CEAST", ".", "Operator", ".", "LT", ";", "break", ";", "case", "GE", ":", "//x>=y -> y<=x", "expr", ".", "op", "=", "CEAST", ".", "Operator", ".", "LE", ";", "break", ";", "default", ":", "break", ";", "// leave as is", "}", "}", "}", "}", "else", "if", "(", "expr", ".", "sort", "==", "CEAST", ".", "Sort", ".", "CONSTANT", ")", "{", "return", ";", "}", "else", "throw", "new", "DapException", "(", "\"compilefilter: Unexpected node type:\"", "+", "expr", ".", "sort", ")", ";", "}"], "docstring": "Convert field references in a filter", "docstring_tokens": ["Convert", "field", "references", "in", "a", "filter"]}
{"code": "c = x.charAt(++pos);", "comments": "skip backslash, get next cha", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/EscapeStrings.java", "func_name": "EscapeStrings.backslashUnescape", "original_string": "static public String backslashUnescape(String x) {\n    if (!x.contains(\"\\\\\")) return x;\n\n    // gotta do it\n    StringBuilder sb = new StringBuilder(x.length());\n    for (int pos = 0; pos < x.length(); pos++) {\n      char c = x.charAt(pos);\n      if (c == '\\\\') {\n        c = x.charAt(++pos); // skip backslash, get next cha\n      }\n      sb.append(c);\n    }\n\n    return sb.toString();\n  }", "language": "java", "Allcodes": "static public String backslashUnescape(String x) {\n    if (!x.contains(\"\\\\\")) return x;\n\n    // gotta do it\n    StringBuilder sb = new StringBuilder(x.length());\n    for (int pos = 0; pos < x.length(); pos++) {\n      char c = x.charAt(pos);\n      if (c == '\\\\') {\n        c = x.charAt(++pos); // skip backslash, get next cha\n      }\n      sb.append(c);\n    }\n\n    return sb.toString();\n  }", "code_tokens": ["static", "public", "String", "backslashUnescape", "(", "String", "x", ")", "{", "if", "(", "!", "x", ".", "contains", "(", "\"\\\\\"", ")", ")", "return", "x", ";", "// gotta do it", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "x", ".", "length", "(", ")", ")", ";", "for", "(", "int", "pos", "=", "0", ";", "pos", "<", "x", ".", "length", "(", ")", ";", "pos", "++", ")", "{", "char", "c", "=", "x", ".", "charAt", "(", "pos", ")", ";", "if", "(", "c", "==", "'", "'", ")", "{", "c", "=", "x", ".", "charAt", "(", "++", "pos", ")", ";", "// skip backslash, get next cha", "}", "sb", ".", "append", "(", "c", ")", ";", "}", "return", "sb", ".", "toString", "(", ")", ";", "}"], "docstring": "backslash unescape a string\n\n@param x unescape this\n@return string with \\c -> c", "docstring_tokens": ["backslash", "unescape", "a", "string"]}
{"code": "result.add(escapedName.substring(start, escapedName.length()));", "comments": "remaining", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/EscapeStrings.java", "func_name": "EscapeStrings.tokenizeEscapedName", "original_string": "public static List<String> tokenizeEscapedName(String escapedName) {\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    int start = 0;\n    while (true) {\n      pos = escapedName.indexOf(sep, pos + 1);\n      if (pos <= 0) break;\n      if ((pos > 0) && escapedName.charAt(pos - 1) != '\\\\') {\n        result.add(escapedName.substring(start, pos));\n        start = pos + 1;\n      }\n    }\n    result.add(escapedName.substring(start, escapedName.length())); // remaining\n    return result;\n  }", "language": "java", "Allcodes": "public static List<String> tokenizeEscapedName(String escapedName) {\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    int start = 0;\n    while (true) {\n      pos = escapedName.indexOf(sep, pos + 1);\n      if (pos <= 0) break;\n      if ((pos > 0) && escapedName.charAt(pos - 1) != '\\\\') {\n        result.add(escapedName.substring(start, pos));\n        start = pos + 1;\n      }\n    }\n    result.add(escapedName.substring(start, escapedName.length())); // remaining\n    return result;\n  }", "code_tokens": ["public", "static", "List", "<", "String", ">", "tokenizeEscapedName", "(", "String", "escapedName", ")", "{", "List", "<", "String", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "int", "pos", "=", "0", ";", "int", "start", "=", "0", ";", "while", "(", "true", ")", "{", "pos", "=", "escapedName", ".", "indexOf", "(", "sep", ",", "pos", "+", "1", ")", ";", "if", "(", "pos", "<=", "0", ")", "break", ";", "if", "(", "(", "pos", ">", "0", ")", "&&", "escapedName", ".", "charAt", "(", "pos", "-", "1", ")", "!=", "'", "'", ")", "{", "result", ".", "add", "(", "escapedName", ".", "substring", "(", "start", ",", "pos", ")", ")", ";", "start", "=", "pos", "+", "1", ";", "}", "}", "result", ".", "add", "(", "escapedName", ".", "substring", "(", "start", ",", "escapedName", ".", "length", "(", ")", ")", ")", ";", "// remaining", "return", "result", ";", "}"], "docstring": "Tokenize an escaped name using \".\" as delimiter, skipping \"\\.\"\n\n@param escapedName an escaped name\n@return list of tokens", "docstring_tokens": ["Tokenize", "an", "escaped", "name", "using", ".", "as", "delimiter", "skipping", "\\", "."]}
{"code": "pressures[0][i] *= 1000;", "comments": "km->m", "lines": 67, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/vis5d/Vis5DIosp.java", "func_name": "Vis5DIosp.makeVerticalVariable", "original_string": "private Variable makeVerticalVariable(int vert_sys, int n_levels,\n                                        float[] vert_args)\n          throws IOException {\n\n    String vert_unit = null;\n    String vert_type;\n    ArrayFloat.D1 data = new ArrayFloat.D1(n_levels);\n    AxisType axisType = null;\n\n    switch (vert_sys) {\n\n      case (0):\n        vert_unit = null;\n        vert_type = \"height\";\n        break;\n\n      case (1):\n      case (2):\n        vert_unit = \"km\";\n        vert_type = \"altitude\";\n        axisType = AxisType.Height;\n        break;\n\n      case (3):\n        vert_unit = \"mbar\";\n        vert_type = \"pressure\";\n        axisType = AxisType.Pressure;\n        break;\n\n      default:\n        throw new IOException(\"vert_sys unknown\");\n    }\n\n    Variable vertVar = new Variable(ncfile, null, null, vert_type);\n    vertVar.setDimensions(LEVEL);\n    vertVar.setDataType(DataType.FLOAT);\n    if (vert_unit != null) {\n      vertVar.addAttribute(new Attribute(CDM.UNITS, vert_unit));\n    }\n    if (axisType != null) {\n      vertVar.addAttribute(new Attribute(_Coordinate.AxisType,\n              axisType.toString()));\n    }\n\n    switch (vert_sys) {\n\n      case (0):\n      case (1):\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[0] + vert_args[1] * i);\n        }\n        break;\n\n      case (2):  // Altitude in km - non-linear\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[i]);\n        }\n        break;\n\n      case (3):  // heights of pressure surfaces in km - non-linear\n        try {\n          Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem vert_cs =\n                  new Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem();\n          float[][] pressures = new float[1][n_levels];\n          System.arraycopy(vert_args, 0, pressures[0], 0, n_levels);\n          for (int i = 0; i < n_levels; i++) {\n            pressures[0][i] *= 1000;  // km->m\n          }\n          pressures = vert_cs.fromReference(pressures);  // convert to pressures\n          for (int i = 0; i < n_levels; i++) {\n            data.set(i, pressures[0][i]);\n          }\n        } catch (VisADException ve) {\n          throw new IOException(\"unable to make vertical system\");\n        }\n        break;\n    }\n    vertVar.setCachedData(data, false);\n    return vertVar;\n  }", "language": "java", "Allcodes": "private Variable makeVerticalVariable(int vert_sys, int n_levels,\n                                        float[] vert_args)\n          throws IOException {\n\n    String vert_unit = null;\n    String vert_type;\n    ArrayFloat.D1 data = new ArrayFloat.D1(n_levels);\n    AxisType axisType = null;\n\n    switch (vert_sys) {\n\n      case (0):\n        vert_unit = null;\n        vert_type = \"height\";\n        break;\n\n      case (1):\n      case (2):\n        vert_unit = \"km\";\n        vert_type = \"altitude\";\n        axisType = AxisType.Height;\n        break;\n\n      case (3):\n        vert_unit = \"mbar\";\n        vert_type = \"pressure\";\n        axisType = AxisType.Pressure;\n        break;\n\n      default:\n        throw new IOException(\"vert_sys unknown\");\n    }\n\n    Variable vertVar = new Variable(ncfile, null, null, vert_type);\n    vertVar.setDimensions(LEVEL);\n    vertVar.setDataType(DataType.FLOAT);\n    if (vert_unit != null) {\n      vertVar.addAttribute(new Attribute(CDM.UNITS, vert_unit));\n    }\n    if (axisType != null) {\n      vertVar.addAttribute(new Attribute(_Coordinate.AxisType,\n              axisType.toString()));\n    }\n\n    switch (vert_sys) {\n\n      case (0):\n      case (1):\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[0] + vert_args[1] * i);\n        }\n        break;\n\n      case (2):  // Altitude in km - non-linear\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[i]);\n        }\n        break;\n\n      case (3):  // heights of pressure surfaces in km - non-linear\n        try {\n          Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem vert_cs =\n                  new Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem();\n          float[][] pressures = new float[1][n_levels];\n          System.arraycopy(vert_args, 0, pressures[0], 0, n_levels);\n          for (int i = 0; i < n_levels; i++) {\n            pressures[0][i] *= 1000;  // km->m\n          }\n          pressures = vert_cs.fromReference(pressures);  // convert to pressures\n          for (int i = 0; i < n_levels; i++) {\n            data.set(i, pressures[0][i]);\n          }\n        } catch (VisADException ve) {\n          throw new IOException(\"unable to make vertical system\");\n        }\n        break;\n    }\n    vertVar.setCachedData(data, false);\n    return vertVar;\n  }", "code_tokens": ["private", "Variable", "makeVerticalVariable", "(", "int", "vert_sys", ",", "int", "n_levels", ",", "float", "[", "]", "vert_args", ")", "throws", "IOException", "{", "String", "vert_unit", "=", "null", ";", "String", "vert_type", ";", "ArrayFloat", ".", "D1", "data", "=", "new", "ArrayFloat", ".", "D1", "(", "n_levels", ")", ";", "AxisType", "axisType", "=", "null", ";", "switch", "(", "vert_sys", ")", "{", "case", "(", "0", ")", ":", "vert_unit", "=", "null", ";", "vert_type", "=", "\"height\"", ";", "break", ";", "case", "(", "1", ")", ":", "case", "(", "2", ")", ":", "vert_unit", "=", "\"km\"", ";", "vert_type", "=", "\"altitude\"", ";", "axisType", "=", "AxisType", ".", "Height", ";", "break", ";", "case", "(", "3", ")", ":", "vert_unit", "=", "\"mbar\"", ";", "vert_type", "=", "\"pressure\"", ";", "axisType", "=", "AxisType", ".", "Pressure", ";", "break", ";", "default", ":", "throw", "new", "IOException", "(", "\"vert_sys unknown\"", ")", ";", "}", "Variable", "vertVar", "=", "new", "Variable", "(", "ncfile", ",", "null", ",", "null", ",", "vert_type", ")", ";", "vertVar", ".", "setDimensions", "(", "LEVEL", ")", ";", "vertVar", ".", "setDataType", "(", "DataType", ".", "FLOAT", ")", ";", "if", "(", "vert_unit", "!=", "null", ")", "{", "vertVar", ".", "addAttribute", "(", "new", "Attribute", "(", "CDM", ".", "UNITS", ",", "vert_unit", ")", ")", ";", "}", "if", "(", "axisType", "!=", "null", ")", "{", "vertVar", ".", "addAttribute", "(", "new", "Attribute", "(", "_Coordinate", ".", "AxisType", ",", "axisType", ".", "toString", "(", ")", ")", ")", ";", "}", "switch", "(", "vert_sys", ")", "{", "case", "(", "0", ")", ":", "case", "(", "1", ")", ":", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "data", ".", "set", "(", "i", ",", "vert_args", "[", "0", "]", "+", "vert_args", "[", "1", "]", "*", "i", ")", ";", "}", "break", ";", "case", "(", "2", ")", ":", "// Altitude in km - non-linear", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "data", ".", "set", "(", "i", ",", "vert_args", "[", "i", "]", ")", ";", "}", "break", ";", "case", "(", "3", ")", ":", "// heights of pressure surfaces in km - non-linear", "try", "{", "Vis5DVerticalSystem", ".", "Vis5DVerticalCoordinateSystem", "vert_cs", "=", "new", "Vis5DVerticalSystem", ".", "Vis5DVerticalCoordinateSystem", "(", ")", ";", "float", "[", "]", "[", "]", "pressures", "=", "new", "float", "[", "1", "]", "[", "n_levels", "]", ";", "System", ".", "arraycopy", "(", "vert_args", ",", "0", ",", "pressures", "[", "0", "]", ",", "0", ",", "n_levels", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "pressures", "[", "0", "]", "[", "i", "]", "*=", "1000", ";", "// km->m", "}", "pressures", "=", "vert_cs", ".", "fromReference", "(", "pressures", ")", ";", "// convert to pressures", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "data", ".", "set", "(", "i", ",", "pressures", "[", "0", "]", "[", "i", "]", ")", ";", "}", "}", "catch", "(", "VisADException", "ve", ")", "{", "throw", "new", "IOException", "(", "\"unable to make vertical system\"", ")", ";", "}", "break", ";", "}", "vertVar", ".", "setCachedData", "(", "data", ",", "false", ")", ";", "return", "vertVar", ";", "}"], "docstring": "Create a vertical dimension variable based on the info.  Based on\nvisad.data.vis5d.Vis5DVerticalSystem.\n\n@param vert_sys  the vertical system id\n@param n_levels  the number of levels\n@param vert_args the vertical system arguments\n@return the vertical dimesion variable\n@throws IOException problem reading the file or creating the data", "docstring_tokens": ["Create", "a", "vertical", "dimension", "variable", "based", "on", "the", "info", ".", "Based", "on", "visad", ".", "data", ".", "vis5d", ".", "Vis5DVerticalSystem", "."]}
{"code": "pressures = vert_cs.fromReference(pressures);", "comments": "convert to pressures", "lines": 69, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/vis5d/Vis5DIosp.java", "func_name": "Vis5DIosp.makeVerticalVariable", "original_string": "private Variable makeVerticalVariable(int vert_sys, int n_levels,\n                                        float[] vert_args)\n          throws IOException {\n\n    String vert_unit = null;\n    String vert_type;\n    ArrayFloat.D1 data = new ArrayFloat.D1(n_levels);\n    AxisType axisType = null;\n\n    switch (vert_sys) {\n\n      case (0):\n        vert_unit = null;\n        vert_type = \"height\";\n        break;\n\n      case (1):\n      case (2):\n        vert_unit = \"km\";\n        vert_type = \"altitude\";\n        axisType = AxisType.Height;\n        break;\n\n      case (3):\n        vert_unit = \"mbar\";\n        vert_type = \"pressure\";\n        axisType = AxisType.Pressure;\n        break;\n\n      default:\n        throw new IOException(\"vert_sys unknown\");\n    }\n\n    Variable vertVar = new Variable(ncfile, null, null, vert_type);\n    vertVar.setDimensions(LEVEL);\n    vertVar.setDataType(DataType.FLOAT);\n    if (vert_unit != null) {\n      vertVar.addAttribute(new Attribute(CDM.UNITS, vert_unit));\n    }\n    if (axisType != null) {\n      vertVar.addAttribute(new Attribute(_Coordinate.AxisType,\n              axisType.toString()));\n    }\n\n    switch (vert_sys) {\n\n      case (0):\n      case (1):\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[0] + vert_args[1] * i);\n        }\n        break;\n\n      case (2):  // Altitude in km - non-linear\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[i]);\n        }\n        break;\n\n      case (3):  // heights of pressure surfaces in km - non-linear\n        try {\n          Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem vert_cs =\n                  new Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem();\n          float[][] pressures = new float[1][n_levels];\n          System.arraycopy(vert_args, 0, pressures[0], 0, n_levels);\n          for (int i = 0; i < n_levels; i++) {\n            pressures[0][i] *= 1000;  // km->m\n          }\n          pressures = vert_cs.fromReference(pressures);  // convert to pressures\n          for (int i = 0; i < n_levels; i++) {\n            data.set(i, pressures[0][i]);\n          }\n        } catch (VisADException ve) {\n          throw new IOException(\"unable to make vertical system\");\n        }\n        break;\n    }\n    vertVar.setCachedData(data, false);\n    return vertVar;\n  }", "language": "java", "Allcodes": "private Variable makeVerticalVariable(int vert_sys, int n_levels,\n                                        float[] vert_args)\n          throws IOException {\n\n    String vert_unit = null;\n    String vert_type;\n    ArrayFloat.D1 data = new ArrayFloat.D1(n_levels);\n    AxisType axisType = null;\n\n    switch (vert_sys) {\n\n      case (0):\n        vert_unit = null;\n        vert_type = \"height\";\n        break;\n\n      case (1):\n      case (2):\n        vert_unit = \"km\";\n        vert_type = \"altitude\";\n        axisType = AxisType.Height;\n        break;\n\n      case (3):\n        vert_unit = \"mbar\";\n        vert_type = \"pressure\";\n        axisType = AxisType.Pressure;\n        break;\n\n      default:\n        throw new IOException(\"vert_sys unknown\");\n    }\n\n    Variable vertVar = new Variable(ncfile, null, null, vert_type);\n    vertVar.setDimensions(LEVEL);\n    vertVar.setDataType(DataType.FLOAT);\n    if (vert_unit != null) {\n      vertVar.addAttribute(new Attribute(CDM.UNITS, vert_unit));\n    }\n    if (axisType != null) {\n      vertVar.addAttribute(new Attribute(_Coordinate.AxisType,\n              axisType.toString()));\n    }\n\n    switch (vert_sys) {\n\n      case (0):\n      case (1):\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[0] + vert_args[1] * i);\n        }\n        break;\n\n      case (2):  // Altitude in km - non-linear\n        for (int i = 0; i < n_levels; i++) {\n          data.set(i, vert_args[i]);\n        }\n        break;\n\n      case (3):  // heights of pressure surfaces in km - non-linear\n        try {\n          Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem vert_cs =\n                  new Vis5DVerticalSystem.Vis5DVerticalCoordinateSystem();\n          float[][] pressures = new float[1][n_levels];\n          System.arraycopy(vert_args, 0, pressures[0], 0, n_levels);\n          for (int i = 0; i < n_levels; i++) {\n            pressures[0][i] *= 1000;  // km->m\n          }\n          pressures = vert_cs.fromReference(pressures);  // convert to pressures\n          for (int i = 0; i < n_levels; i++) {\n            data.set(i, pressures[0][i]);\n          }\n        } catch (VisADException ve) {\n          throw new IOException(\"unable to make vertical system\");\n        }\n        break;\n    }\n    vertVar.setCachedData(data, false);\n    return vertVar;\n  }", "code_tokens": ["private", "Variable", "makeVerticalVariable", "(", "int", "vert_sys", ",", "int", "n_levels", ",", "float", "[", "]", "vert_args", ")", "throws", "IOException", "{", "String", "vert_unit", "=", "null", ";", "String", "vert_type", ";", "ArrayFloat", ".", "D1", "data", "=", "new", "ArrayFloat", ".", "D1", "(", "n_levels", ")", ";", "AxisType", "axisType", "=", "null", ";", "switch", "(", "vert_sys", ")", "{", "case", "(", "0", ")", ":", "vert_unit", "=", "null", ";", "vert_type", "=", "\"height\"", ";", "break", ";", "case", "(", "1", ")", ":", "case", "(", "2", ")", ":", "vert_unit", "=", "\"km\"", ";", "vert_type", "=", "\"altitude\"", ";", "axisType", "=", "AxisType", ".", "Height", ";", "break", ";", "case", "(", "3", ")", ":", "vert_unit", "=", "\"mbar\"", ";", "vert_type", "=", "\"pressure\"", ";", "axisType", "=", "AxisType", ".", "Pressure", ";", "break", ";", "default", ":", "throw", "new", "IOException", "(", "\"vert_sys unknown\"", ")", ";", "}", "Variable", "vertVar", "=", "new", "Variable", "(", "ncfile", ",", "null", ",", "null", ",", "vert_type", ")", ";", "vertVar", ".", "setDimensions", "(", "LEVEL", ")", ";", "vertVar", ".", "setDataType", "(", "DataType", ".", "FLOAT", ")", ";", "if", "(", "vert_unit", "!=", "null", ")", "{", "vertVar", ".", "addAttribute", "(", "new", "Attribute", "(", "CDM", ".", "UNITS", ",", "vert_unit", ")", ")", ";", "}", "if", "(", "axisType", "!=", "null", ")", "{", "vertVar", ".", "addAttribute", "(", "new", "Attribute", "(", "_Coordinate", ".", "AxisType", ",", "axisType", ".", "toString", "(", ")", ")", ")", ";", "}", "switch", "(", "vert_sys", ")", "{", "case", "(", "0", ")", ":", "case", "(", "1", ")", ":", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "data", ".", "set", "(", "i", ",", "vert_args", "[", "0", "]", "+", "vert_args", "[", "1", "]", "*", "i", ")", ";", "}", "break", ";", "case", "(", "2", ")", ":", "// Altitude in km - non-linear", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "data", ".", "set", "(", "i", ",", "vert_args", "[", "i", "]", ")", ";", "}", "break", ";", "case", "(", "3", ")", ":", "// heights of pressure surfaces in km - non-linear", "try", "{", "Vis5DVerticalSystem", ".", "Vis5DVerticalCoordinateSystem", "vert_cs", "=", "new", "Vis5DVerticalSystem", ".", "Vis5DVerticalCoordinateSystem", "(", ")", ";", "float", "[", "]", "[", "]", "pressures", "=", "new", "float", "[", "1", "]", "[", "n_levels", "]", ";", "System", ".", "arraycopy", "(", "vert_args", ",", "0", ",", "pressures", "[", "0", "]", ",", "0", ",", "n_levels", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "pressures", "[", "0", "]", "[", "i", "]", "*=", "1000", ";", "// km->m", "}", "pressures", "=", "vert_cs", ".", "fromReference", "(", "pressures", ")", ";", "// convert to pressures", "for", "(", "int", "i", "=", "0", ";", "i", "<", "n_levels", ";", "i", "++", ")", "{", "data", ".", "set", "(", "i", ",", "pressures", "[", "0", "]", "[", "i", "]", ")", ";", "}", "}", "catch", "(", "VisADException", "ve", ")", "{", "throw", "new", "IOException", "(", "\"unable to make vertical system\"", ")", ";", "}", "break", ";", "}", "vertVar", ".", "setCachedData", "(", "data", ",", "false", ")", ";", "return", "vertVar", ";", "}"], "docstring": "Create a vertical dimension variable based on the info.  Based on\nvisad.data.vis5d.Vis5DVerticalSystem.\n\n@param vert_sys  the vertical system id\n@param n_levels  the number of levels\n@param vert_args the vertical system arguments\n@return the vertical dimesion variable\n@throws IOException problem reading the file or creating the data", "docstring_tokens": ["Create", "a", "vertical", "dimension", "variable", "based", "on", "the", "info", ".", "Based", "on", "visad", ".", "data", ".", "vis5d", ".", "Vis5DVerticalSystem", "."]}
{"code": "return null;", "comments": "EOF", "lines": 7, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/atd/dorade/DoradeDescriptor.java", "func_name": "DoradeDescriptor.peekName", "original_string": "protected static String peekName(RandomAccessFile file)\n          throws DescriptorException {\n    try {\n      long filepos = file.getFilePointer();\n      byte[] nameBytes = new byte[4];\n      if (file.read(nameBytes) == -1)\n        return null;  // EOF\n      file.seek(filepos);\n      return new String(nameBytes, CDM.utf8Charset);\n\n    } catch (IOException ex) {\n      throw new DescriptorException(ex);\n    }\n  }", "language": "java", "Allcodes": "protected static String peekName(RandomAccessFile file)\n          throws DescriptorException {\n    try {\n      long filepos = file.getFilePointer();\n      byte[] nameBytes = new byte[4];\n      if (file.read(nameBytes) == -1)\n        return null;  // EOF\n      file.seek(filepos);\n      return new String(nameBytes, CDM.utf8Charset);\n\n    } catch (IOException ex) {\n      throw new DescriptorException(ex);\n    }\n  }", "code_tokens": ["protected", "static", "String", "peekName", "(", "RandomAccessFile", "file", ")", "throws", "DescriptorException", "{", "try", "{", "long", "filepos", "=", "file", ".", "getFilePointer", "(", ")", ";", "byte", "[", "]", "nameBytes", "=", "new", "byte", "[", "4", "]", ";", "if", "(", "file", ".", "read", "(", "nameBytes", ")", "==", "-", "1", ")", "return", "null", ";", "// EOF", "file", ".", "seek", "(", "filepos", ")", ";", "return", "new", "String", "(", "nameBytes", ",", "CDM", ".", "utf8Charset", ")", ";", "}", "catch", "(", "IOException", "ex", ")", "{", "throw", "new", "DescriptorException", "(", "ex", ")", ";", "}", "}"], "docstring": "Return the name of the DORADE descriptor at the current location\nin the file.  The current location will not be changed.\n\n@param file the DORADE sweep file, positioned at the beginning of a\ndescriptor\n@return the name of the DORADE descriptor starting at the current\nfile position, or null if no descriptor name is available\n@throws DescriptorException", "docstring_tokens": ["Return", "the", "name", "of", "the", "DORADE", "descriptor", "at", "the", "current", "location", "in", "the", "file", ".", "The", "current", "location", "will", "not", "be", "changed", "."]}
{"code": "currentOffset = 0;", "comments": "reset current array offset to 0", "lines": 2, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/HeaderInputStream.java", "func_name": "HeaderInputStream.getMoreBytes", "original_string": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "language": "java", "Allcodes": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "code_tokens": ["private", "void", "getMoreBytes", "(", ")", "throws", "IOException", "{", "currentOffset", "=", "0", ";", "// reset current array offset to 0\r", "int", "bytesRead", "=", "0", ";", "// bytes read so far\r", "int", "lookingFor", "=", "0", ";", "// character in endSequence to look for\r", "for", "(", ";", "bytesRead", "<", "lineBuf", ".", "length", ";", "bytesRead", "++", ")", "{", "int", "c", "=", "in", ".", "read", "(", ")", ";", "if", "(", "c", "==", "-", "1", ")", "break", ";", "// break on EOL and return what we have so far\r", "lineBuf", "[", "bytesRead", "]", "=", "(", "byte", ")", "c", ";", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "lookingFor", "]", ")", "{", "lookingFor", "++", ";", "if", "(", "lookingFor", "==", "endSequence", ".", "length", ")", "{", "endFound", "=", "true", ";", "break", ";", "}", "}", "else", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "0", "]", ")", "{", "// CHANGED JC\r", "lookingFor", "=", "1", ";", "}", "else", "{", "lookingFor", "=", "0", ";", "}", "}", "bytesRemaining", "=", "bytesRead", ";", "// number of bytes we've read\r", "}"], "docstring": "Get more bytes into buffer.  Stop when endSequence is found.", "docstring_tokens": ["Get", "more", "bytes", "into", "buffer", ".", "Stop", "when", "endSequence", "is", "found", "."]}
{"code": "int bytesRead = 0;", "comments": "bytes read so far", "lines": 3, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/HeaderInputStream.java", "func_name": "HeaderInputStream.getMoreBytes", "original_string": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "language": "java", "Allcodes": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "code_tokens": ["private", "void", "getMoreBytes", "(", ")", "throws", "IOException", "{", "currentOffset", "=", "0", ";", "// reset current array offset to 0\r", "int", "bytesRead", "=", "0", ";", "// bytes read so far\r", "int", "lookingFor", "=", "0", ";", "// character in endSequence to look for\r", "for", "(", ";", "bytesRead", "<", "lineBuf", ".", "length", ";", "bytesRead", "++", ")", "{", "int", "c", "=", "in", ".", "read", "(", ")", ";", "if", "(", "c", "==", "-", "1", ")", "break", ";", "// break on EOL and return what we have so far\r", "lineBuf", "[", "bytesRead", "]", "=", "(", "byte", ")", "c", ";", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "lookingFor", "]", ")", "{", "lookingFor", "++", ";", "if", "(", "lookingFor", "==", "endSequence", ".", "length", ")", "{", "endFound", "=", "true", ";", "break", ";", "}", "}", "else", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "0", "]", ")", "{", "// CHANGED JC\r", "lookingFor", "=", "1", ";", "}", "else", "{", "lookingFor", "=", "0", ";", "}", "}", "bytesRemaining", "=", "bytesRead", ";", "// number of bytes we've read\r", "}"], "docstring": "Get more bytes into buffer.  Stop when endSequence is found.", "docstring_tokens": ["Get", "more", "bytes", "into", "buffer", ".", "Stop", "when", "endSequence", "is", "found", "."]}
{"code": "int lookingFor = 0;", "comments": "character in endSequence to look for", "lines": 4, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/HeaderInputStream.java", "func_name": "HeaderInputStream.getMoreBytes", "original_string": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "language": "java", "Allcodes": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "code_tokens": ["private", "void", "getMoreBytes", "(", ")", "throws", "IOException", "{", "currentOffset", "=", "0", ";", "// reset current array offset to 0\r", "int", "bytesRead", "=", "0", ";", "// bytes read so far\r", "int", "lookingFor", "=", "0", ";", "// character in endSequence to look for\r", "for", "(", ";", "bytesRead", "<", "lineBuf", ".", "length", ";", "bytesRead", "++", ")", "{", "int", "c", "=", "in", ".", "read", "(", ")", ";", "if", "(", "c", "==", "-", "1", ")", "break", ";", "// break on EOL and return what we have so far\r", "lineBuf", "[", "bytesRead", "]", "=", "(", "byte", ")", "c", ";", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "lookingFor", "]", ")", "{", "lookingFor", "++", ";", "if", "(", "lookingFor", "==", "endSequence", ".", "length", ")", "{", "endFound", "=", "true", ";", "break", ";", "}", "}", "else", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "0", "]", ")", "{", "// CHANGED JC\r", "lookingFor", "=", "1", ";", "}", "else", "{", "lookingFor", "=", "0", ";", "}", "}", "bytesRemaining", "=", "bytesRead", ";", "// number of bytes we've read\r", "}"], "docstring": "Get more bytes into buffer.  Stop when endSequence is found.", "docstring_tokens": ["Get", "more", "bytes", "into", "buffer", ".", "Stop", "when", "endSequence", "is", "found", "."]}
{"code": "break;", "comments": "break on EOL and return what we have so far", "lines": 8, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/HeaderInputStream.java", "func_name": "HeaderInputStream.getMoreBytes", "original_string": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "language": "java", "Allcodes": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "code_tokens": ["private", "void", "getMoreBytes", "(", ")", "throws", "IOException", "{", "currentOffset", "=", "0", ";", "// reset current array offset to 0\r", "int", "bytesRead", "=", "0", ";", "// bytes read so far\r", "int", "lookingFor", "=", "0", ";", "// character in endSequence to look for\r", "for", "(", ";", "bytesRead", "<", "lineBuf", ".", "length", ";", "bytesRead", "++", ")", "{", "int", "c", "=", "in", ".", "read", "(", ")", ";", "if", "(", "c", "==", "-", "1", ")", "break", ";", "// break on EOL and return what we have so far\r", "lineBuf", "[", "bytesRead", "]", "=", "(", "byte", ")", "c", ";", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "lookingFor", "]", ")", "{", "lookingFor", "++", ";", "if", "(", "lookingFor", "==", "endSequence", ".", "length", ")", "{", "endFound", "=", "true", ";", "break", ";", "}", "}", "else", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "0", "]", ")", "{", "// CHANGED JC\r", "lookingFor", "=", "1", ";", "}", "else", "{", "lookingFor", "=", "0", ";", "}", "}", "bytesRemaining", "=", "bytesRead", ";", "// number of bytes we've read\r", "}"], "docstring": "Get more bytes into buffer.  Stop when endSequence is found.", "docstring_tokens": ["Get", "more", "bytes", "into", "buffer", ".", "Stop", "when", "endSequence", "is", "found", "."]}
{"code": "bytesRemaining = bytesRead;", "comments": "number of bytes we've read", "lines": 23, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/HeaderInputStream.java", "func_name": "HeaderInputStream.getMoreBytes", "original_string": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "language": "java", "Allcodes": "private void getMoreBytes() throws IOException {\r\n        currentOffset = 0;   // reset current array offset to 0\r\n        int bytesRead = 0;   // bytes read so far\r\n        int lookingFor = 0;  // character in endSequence to look for\r\n        for (; bytesRead < lineBuf.length; bytesRead++) {\r\n            int c = in.read();\r\n            if (c == -1)\r\n                break;  // break on EOL and return what we have so far\r\n\r\n            lineBuf[bytesRead] = (byte) c;\r\n            if (lineBuf[bytesRead] == endSequence[lookingFor]) {\r\n                lookingFor++;\r\n                if (lookingFor == endSequence.length) {\r\n                    endFound = true;\r\n                    break;\r\n                }\r\n            } else if (lineBuf[bytesRead] == endSequence[0]) { // CHANGED JC\r\n                lookingFor = 1;\r\n            } else {\r\n                lookingFor = 0;\r\n            }\r\n        }\r\n        bytesRemaining = bytesRead;  // number of bytes we've read\r\n    }", "code_tokens": ["private", "void", "getMoreBytes", "(", ")", "throws", "IOException", "{", "currentOffset", "=", "0", ";", "// reset current array offset to 0\r", "int", "bytesRead", "=", "0", ";", "// bytes read so far\r", "int", "lookingFor", "=", "0", ";", "// character in endSequence to look for\r", "for", "(", ";", "bytesRead", "<", "lineBuf", ".", "length", ";", "bytesRead", "++", ")", "{", "int", "c", "=", "in", ".", "read", "(", ")", ";", "if", "(", "c", "==", "-", "1", ")", "break", ";", "// break on EOL and return what we have so far\r", "lineBuf", "[", "bytesRead", "]", "=", "(", "byte", ")", "c", ";", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "lookingFor", "]", ")", "{", "lookingFor", "++", ";", "if", "(", "lookingFor", "==", "endSequence", ".", "length", ")", "{", "endFound", "=", "true", ";", "break", ";", "}", "}", "else", "if", "(", "lineBuf", "[", "bytesRead", "]", "==", "endSequence", "[", "0", "]", ")", "{", "// CHANGED JC\r", "lookingFor", "=", "1", ";", "}", "else", "{", "lookingFor", "=", "0", ";", "}", "}", "bytesRemaining", "=", "bytesRead", ";", "// number of bytes we've read\r", "}"], "docstring": "Get more bytes into buffer.  Stop when endSequence is found.", "docstring_tokens": ["Get", "more", "bytes", "into", "buffer", ".", "Stop", "when", "endSequence", "is", "found", "."]}
{"code": "if (coordvars.containsKey(v.getShortName())) continue;", "comments": "skip coordinate variables", "lines": 12, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/server/opendap/NcDDS.java", "func_name": "NcDDS.createFromDataset", "original_string": "private void createFromDataset(NetcdfDataset ncd) {\n        // get coordinate variables, disjunct from variables\n    for (CoordinateAxis axis : ncd.getCoordinateAxes()) {\n      coordvars.put(axis.getShortName(), axis);\n    }\n\n    // dup the variable set\n    ddsvars = new ArrayList<>(50);\n\n    // collect grid array variables and set of coordinate variables used in grids\n    for (Variable v : ncd.getVariables()) {\n      if (coordvars.containsKey(v.getShortName())) continue;  // skip coordinate variables\n      ddsvars.add(v);\n\n      boolean isgridarray = (v.getRank() > 1) && (v.getDataType() != DataType.STRUCTURE) && (v.getParentStructure() == null);\n      if (!isgridarray) continue;\n      List<Dimension> dimset = v.getDimensions();\n      int rank = dimset.size();\n      for (int i = 0; isgridarray && i < rank; i++) {\n        Dimension dim = dimset.get(i);\n        if (dim.getShortName() == null)\n          isgridarray = false;\n        else {\n          Variable gv = coordvars.get(dim.getShortName());\n          if (gv == null)\n            isgridarray = false;\n        }\n      }\n      if (isgridarray) {\n        gridarrays.put(v.getFullName(), v);\n        for (Dimension dim : dimset) {\n          Variable gv = coordvars.get(dim.getShortName());\n          if (gv != null)\n            used.put(gv.getFullName(), gv);\n        }\n      }\n    }\n\n        // Create the set of coordinates\n    for (Variable cv : ncd.getCoordinateAxes()) {\n      BaseType bt = createVariable(ncd, cv);\n      addVariable(bt);\n    }\n\n    // Create the set of variables\n    for (Variable cv : ddsvars) {\n      BaseType bt = createVariable(ncd, cv);\n      addVariable(bt);\n    }\n  }", "language": "java", "Allcodes": "private void createFromDataset(NetcdfDataset ncd) {\n        // get coordinate variables, disjunct from variables\n    for (CoordinateAxis axis : ncd.getCoordinateAxes()) {\n      coordvars.put(axis.getShortName(), axis);\n    }\n\n    // dup the variable set\n    ddsvars = new ArrayList<>(50);\n\n    // collect grid array variables and set of coordinate variables used in grids\n    for (Variable v : ncd.getVariables()) {\n      if (coordvars.containsKey(v.getShortName())) continue;  // skip coordinate variables\n      ddsvars.add(v);\n\n      boolean isgridarray = (v.getRank() > 1) && (v.getDataType() != DataType.STRUCTURE) && (v.getParentStructure() == null);\n      if (!isgridarray) continue;\n      List<Dimension> dimset = v.getDimensions();\n      int rank = dimset.size();\n      for (int i = 0; isgridarray && i < rank; i++) {\n        Dimension dim = dimset.get(i);\n        if (dim.getShortName() == null)\n          isgridarray = false;\n        else {\n          Variable gv = coordvars.get(dim.getShortName());\n          if (gv == null)\n            isgridarray = false;\n        }\n      }\n      if (isgridarray) {\n        gridarrays.put(v.getFullName(), v);\n        for (Dimension dim : dimset) {\n          Variable gv = coordvars.get(dim.getShortName());\n          if (gv != null)\n            used.put(gv.getFullName(), gv);\n        }\n      }\n    }\n\n        // Create the set of coordinates\n    for (Variable cv : ncd.getCoordinateAxes()) {\n      BaseType bt = createVariable(ncd, cv);\n      addVariable(bt);\n    }\n\n    // Create the set of variables\n    for (Variable cv : ddsvars) {\n      BaseType bt = createVariable(ncd, cv);\n      addVariable(bt);\n    }\n  }", "code_tokens": ["private", "void", "createFromDataset", "(", "NetcdfDataset", "ncd", ")", "{", "// get coordinate variables, disjunct from variables", "for", "(", "CoordinateAxis", "axis", ":", "ncd", ".", "getCoordinateAxes", "(", ")", ")", "{", "coordvars", ".", "put", "(", "axis", ".", "getShortName", "(", ")", ",", "axis", ")", ";", "}", "// dup the variable set", "ddsvars", "=", "new", "ArrayList", "<>", "(", "50", ")", ";", "// collect grid array variables and set of coordinate variables used in grids", "for", "(", "Variable", "v", ":", "ncd", ".", "getVariables", "(", ")", ")", "{", "if", "(", "coordvars", ".", "containsKey", "(", "v", ".", "getShortName", "(", ")", ")", ")", "continue", ";", "// skip coordinate variables", "ddsvars", ".", "add", "(", "v", ")", ";", "boolean", "isgridarray", "=", "(", "v", ".", "getRank", "(", ")", ">", "1", ")", "&&", "(", "v", ".", "getDataType", "(", ")", "!=", "DataType", ".", "STRUCTURE", ")", "&&", "(", "v", ".", "getParentStructure", "(", ")", "==", "null", ")", ";", "if", "(", "!", "isgridarray", ")", "continue", ";", "List", "<", "Dimension", ">", "dimset", "=", "v", ".", "getDimensions", "(", ")", ";", "int", "rank", "=", "dimset", ".", "size", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "isgridarray", "&&", "i", "<", "rank", ";", "i", "++", ")", "{", "Dimension", "dim", "=", "dimset", ".", "get", "(", "i", ")", ";", "if", "(", "dim", ".", "getShortName", "(", ")", "==", "null", ")", "isgridarray", "=", "false", ";", "else", "{", "Variable", "gv", "=", "coordvars", ".", "get", "(", "dim", ".", "getShortName", "(", ")", ")", ";", "if", "(", "gv", "==", "null", ")", "isgridarray", "=", "false", ";", "}", "}", "if", "(", "isgridarray", ")", "{", "gridarrays", ".", "put", "(", "v", ".", "getFullName", "(", ")", ",", "v", ")", ";", "for", "(", "Dimension", "dim", ":", "dimset", ")", "{", "Variable", "gv", "=", "coordvars", ".", "get", "(", "dim", ".", "getShortName", "(", ")", ")", ";", "if", "(", "gv", "!=", "null", ")", "used", ".", "put", "(", "gv", ".", "getFullName", "(", ")", ",", "gv", ")", ";", "}", "}", "}", "// Create the set of coordinates", "for", "(", "Variable", "cv", ":", "ncd", ".", "getCoordinateAxes", "(", ")", ")", "{", "BaseType", "bt", "=", "createVariable", "(", "ncd", ",", "cv", ")", ";", "addVariable", "(", "bt", ")", ";", "}", "// Create the set of variables", "for", "(", "Variable", "cv", ":", "ddsvars", ")", "{", "BaseType", "bt", "=", "createVariable", "(", "ncd", ",", "cv", ")", ";", "addVariable", "(", "bt", ")", ";", "}", "}"], "docstring": "take advantage of the work already done by NetcdfDataset", "docstring_tokens": ["take", "advantage", "of", "the", "work", "already", "done", "by", "NetcdfDataset"]}
{"code": "llproj.setCenterLon( wx0);", "comments": "shift cylinder seam", "lines": 18, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/NavigatedPanel.java", "func_name": "NavigatedPanel.fireMapAreaEvent", "original_string": "void fireMapAreaEvent() {\n    if (debugZoom)\n      System.out.println(\"NP.fireMapAreaEvent \");\n\n     // decide if we need a new Projection: for LatLonProjection only\n    if (project.isLatLon()) {\n      LatLonProjection llproj = (LatLonProjection) project;\n      ProjectionRect box = getMapArea();\n      double center = llproj.getCenterLon();\n      double lonBeg = LatLonPointImpl.lonNormal(box.getMinX(), center);\n      double lonEnd = lonBeg + box.getMaxX() - box.getMinX();\n      boolean showShift = Debug.isSet(\"projection/LatLonShift\") || debugNewProjection;\n      if (showShift) System.out.println(\"projection/LatLonShift: min,max = \"+ box.getMinX()+\" \"+\n            box.getMaxX()+\" beg,end= \"+lonBeg+\" \"+lonEnd+ \" center = \"+center);\n\n      if ( (lonBeg < center-180) || (lonEnd > center+180)) {  // got to do it\n        double wx0 = box.getX() + box.getWidth()/2;\n        llproj.setCenterLon( wx0);              // shift cylinder seam\n        double newWx0 = llproj.getCenterLon();  // normalize wx0 to [-180,180]\n        setWorldCenterX(newWx0);             // tell navigation panel to shift\n        if (showShift)\n          System.out.println(\"projection/LatLonShift: shift center to \"+wx0+\"->\"+newWx0);\n\n        // send projection event instead of map area event\n        lmProject.sendEvent( new NewProjectionEvent(this, llproj));\n        return;\n      }\n    }\n\n    // send new map area event\n    lmMapArea.sendEvent( new NewMapAreaEvent( this, getMapArea()));\n  }", "language": "java", "Allcodes": "void fireMapAreaEvent() {\n    if (debugZoom)\n      System.out.println(\"NP.fireMapAreaEvent \");\n\n     // decide if we need a new Projection: for LatLonProjection only\n    if (project.isLatLon()) {\n      LatLonProjection llproj = (LatLonProjection) project;\n      ProjectionRect box = getMapArea();\n      double center = llproj.getCenterLon();\n      double lonBeg = LatLonPointImpl.lonNormal(box.getMinX(), center);\n      double lonEnd = lonBeg + box.getMaxX() - box.getMinX();\n      boolean showShift = Debug.isSet(\"projection/LatLonShift\") || debugNewProjection;\n      if (showShift) System.out.println(\"projection/LatLonShift: min,max = \"+ box.getMinX()+\" \"+\n            box.getMaxX()+\" beg,end= \"+lonBeg+\" \"+lonEnd+ \" center = \"+center);\n\n      if ( (lonBeg < center-180) || (lonEnd > center+180)) {  // got to do it\n        double wx0 = box.getX() + box.getWidth()/2;\n        llproj.setCenterLon( wx0);              // shift cylinder seam\n        double newWx0 = llproj.getCenterLon();  // normalize wx0 to [-180,180]\n        setWorldCenterX(newWx0);             // tell navigation panel to shift\n        if (showShift)\n          System.out.println(\"projection/LatLonShift: shift center to \"+wx0+\"->\"+newWx0);\n\n        // send projection event instead of map area event\n        lmProject.sendEvent( new NewProjectionEvent(this, llproj));\n        return;\n      }\n    }\n\n    // send new map area event\n    lmMapArea.sendEvent( new NewMapAreaEvent( this, getMapArea()));\n  }", "code_tokens": ["void", "fireMapAreaEvent", "(", ")", "{", "if", "(", "debugZoom", ")", "System", ".", "out", ".", "println", "(", "\"NP.fireMapAreaEvent \"", ")", ";", "// decide if we need a new Projection: for LatLonProjection only", "if", "(", "project", ".", "isLatLon", "(", ")", ")", "{", "LatLonProjection", "llproj", "=", "(", "LatLonProjection", ")", "project", ";", "ProjectionRect", "box", "=", "getMapArea", "(", ")", ";", "double", "center", "=", "llproj", ".", "getCenterLon", "(", ")", ";", "double", "lonBeg", "=", "LatLonPointImpl", ".", "lonNormal", "(", "box", ".", "getMinX", "(", ")", ",", "center", ")", ";", "double", "lonEnd", "=", "lonBeg", "+", "box", ".", "getMaxX", "(", ")", "-", "box", ".", "getMinX", "(", ")", ";", "boolean", "showShift", "=", "Debug", ".", "isSet", "(", "\"projection/LatLonShift\"", ")", "||", "debugNewProjection", ";", "if", "(", "showShift", ")", "System", ".", "out", ".", "println", "(", "\"projection/LatLonShift: min,max = \"", "+", "box", ".", "getMinX", "(", ")", "+", "\" \"", "+", "box", ".", "getMaxX", "(", ")", "+", "\" beg,end= \"", "+", "lonBeg", "+", "\" \"", "+", "lonEnd", "+", "\" center = \"", "+", "center", ")", ";", "if", "(", "(", "lonBeg", "<", "center", "-", "180", ")", "||", "(", "lonEnd", ">", "center", "+", "180", ")", ")", "{", "// got to do it", "double", "wx0", "=", "box", ".", "getX", "(", ")", "+", "box", ".", "getWidth", "(", ")", "/", "2", ";", "llproj", ".", "setCenterLon", "(", "wx0", ")", ";", "// shift cylinder seam", "double", "newWx0", "=", "llproj", ".", "getCenterLon", "(", ")", ";", "// normalize wx0 to [-180,180]", "setWorldCenterX", "(", "newWx0", ")", ";", "// tell navigation panel to shift", "if", "(", "showShift", ")", "System", ".", "out", ".", "println", "(", "\"projection/LatLonShift: shift center to \"", "+", "wx0", "+", "\"->\"", "+", "newWx0", ")", ";", "// send projection event instead of map area event", "lmProject", ".", "sendEvent", "(", "new", "NewProjectionEvent", "(", "this", ",", "llproj", ")", ")", ";", "return", ";", "}", "}", "// send new map area event", "lmMapArea", ".", "sendEvent", "(", "new", "NewMapAreaEvent", "(", "this", ",", "getMapArea", "(", ")", ")", ")", ";", "}"], "docstring": "called by Navigation", "docstring_tokens": ["called", "by", "Navigation"]}
{"code": "double newWx0 = llproj.getCenterLon();", "comments": "normalize wx0 to [-180,180]", "lines": 19, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/NavigatedPanel.java", "func_name": "NavigatedPanel.fireMapAreaEvent", "original_string": "void fireMapAreaEvent() {\n    if (debugZoom)\n      System.out.println(\"NP.fireMapAreaEvent \");\n\n     // decide if we need a new Projection: for LatLonProjection only\n    if (project.isLatLon()) {\n      LatLonProjection llproj = (LatLonProjection) project;\n      ProjectionRect box = getMapArea();\n      double center = llproj.getCenterLon();\n      double lonBeg = LatLonPointImpl.lonNormal(box.getMinX(), center);\n      double lonEnd = lonBeg + box.getMaxX() - box.getMinX();\n      boolean showShift = Debug.isSet(\"projection/LatLonShift\") || debugNewProjection;\n      if (showShift) System.out.println(\"projection/LatLonShift: min,max = \"+ box.getMinX()+\" \"+\n            box.getMaxX()+\" beg,end= \"+lonBeg+\" \"+lonEnd+ \" center = \"+center);\n\n      if ( (lonBeg < center-180) || (lonEnd > center+180)) {  // got to do it\n        double wx0 = box.getX() + box.getWidth()/2;\n        llproj.setCenterLon( wx0);              // shift cylinder seam\n        double newWx0 = llproj.getCenterLon();  // normalize wx0 to [-180,180]\n        setWorldCenterX(newWx0);             // tell navigation panel to shift\n        if (showShift)\n          System.out.println(\"projection/LatLonShift: shift center to \"+wx0+\"->\"+newWx0);\n\n        // send projection event instead of map area event\n        lmProject.sendEvent( new NewProjectionEvent(this, llproj));\n        return;\n      }\n    }\n\n    // send new map area event\n    lmMapArea.sendEvent( new NewMapAreaEvent( this, getMapArea()));\n  }", "language": "java", "Allcodes": "void fireMapAreaEvent() {\n    if (debugZoom)\n      System.out.println(\"NP.fireMapAreaEvent \");\n\n     // decide if we need a new Projection: for LatLonProjection only\n    if (project.isLatLon()) {\n      LatLonProjection llproj = (LatLonProjection) project;\n      ProjectionRect box = getMapArea();\n      double center = llproj.getCenterLon();\n      double lonBeg = LatLonPointImpl.lonNormal(box.getMinX(), center);\n      double lonEnd = lonBeg + box.getMaxX() - box.getMinX();\n      boolean showShift = Debug.isSet(\"projection/LatLonShift\") || debugNewProjection;\n      if (showShift) System.out.println(\"projection/LatLonShift: min,max = \"+ box.getMinX()+\" \"+\n            box.getMaxX()+\" beg,end= \"+lonBeg+\" \"+lonEnd+ \" center = \"+center);\n\n      if ( (lonBeg < center-180) || (lonEnd > center+180)) {  // got to do it\n        double wx0 = box.getX() + box.getWidth()/2;\n        llproj.setCenterLon( wx0);              // shift cylinder seam\n        double newWx0 = llproj.getCenterLon();  // normalize wx0 to [-180,180]\n        setWorldCenterX(newWx0);             // tell navigation panel to shift\n        if (showShift)\n          System.out.println(\"projection/LatLonShift: shift center to \"+wx0+\"->\"+newWx0);\n\n        // send projection event instead of map area event\n        lmProject.sendEvent( new NewProjectionEvent(this, llproj));\n        return;\n      }\n    }\n\n    // send new map area event\n    lmMapArea.sendEvent( new NewMapAreaEvent( this, getMapArea()));\n  }", "code_tokens": ["void", "fireMapAreaEvent", "(", ")", "{", "if", "(", "debugZoom", ")", "System", ".", "out", ".", "println", "(", "\"NP.fireMapAreaEvent \"", ")", ";", "// decide if we need a new Projection: for LatLonProjection only", "if", "(", "project", ".", "isLatLon", "(", ")", ")", "{", "LatLonProjection", "llproj", "=", "(", "LatLonProjection", ")", "project", ";", "ProjectionRect", "box", "=", "getMapArea", "(", ")", ";", "double", "center", "=", "llproj", ".", "getCenterLon", "(", ")", ";", "double", "lonBeg", "=", "LatLonPointImpl", ".", "lonNormal", "(", "box", ".", "getMinX", "(", ")", ",", "center", ")", ";", "double", "lonEnd", "=", "lonBeg", "+", "box", ".", "getMaxX", "(", ")", "-", "box", ".", "getMinX", "(", ")", ";", "boolean", "showShift", "=", "Debug", ".", "isSet", "(", "\"projection/LatLonShift\"", ")", "||", "debugNewProjection", ";", "if", "(", "showShift", ")", "System", ".", "out", ".", "println", "(", "\"projection/LatLonShift: min,max = \"", "+", "box", ".", "getMinX", "(", ")", "+", "\" \"", "+", "box", ".", "getMaxX", "(", ")", "+", "\" beg,end= \"", "+", "lonBeg", "+", "\" \"", "+", "lonEnd", "+", "\" center = \"", "+", "center", ")", ";", "if", "(", "(", "lonBeg", "<", "center", "-", "180", ")", "||", "(", "lonEnd", ">", "center", "+", "180", ")", ")", "{", "// got to do it", "double", "wx0", "=", "box", ".", "getX", "(", ")", "+", "box", ".", "getWidth", "(", ")", "/", "2", ";", "llproj", ".", "setCenterLon", "(", "wx0", ")", ";", "// shift cylinder seam", "double", "newWx0", "=", "llproj", ".", "getCenterLon", "(", ")", ";", "// normalize wx0 to [-180,180]", "setWorldCenterX", "(", "newWx0", ")", ";", "// tell navigation panel to shift", "if", "(", "showShift", ")", "System", ".", "out", ".", "println", "(", "\"projection/LatLonShift: shift center to \"", "+", "wx0", "+", "\"->\"", "+", "newWx0", ")", ";", "// send projection event instead of map area event", "lmProject", ".", "sendEvent", "(", "new", "NewProjectionEvent", "(", "this", ",", "llproj", ")", ")", ";", "return", ";", "}", "}", "// send new map area event", "lmMapArea", ".", "sendEvent", "(", "new", "NewMapAreaEvent", "(", "this", ",", "getMapArea", "(", ")", ")", ")", ";", "}"], "docstring": "called by Navigation", "docstring_tokens": ["called", "by", "Navigation"]}
{"code": "setWorldCenterX(newWx0);", "comments": "tell navigation panel to shift", "lines": 20, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/NavigatedPanel.java", "func_name": "NavigatedPanel.fireMapAreaEvent", "original_string": "void fireMapAreaEvent() {\n    if (debugZoom)\n      System.out.println(\"NP.fireMapAreaEvent \");\n\n     // decide if we need a new Projection: for LatLonProjection only\n    if (project.isLatLon()) {\n      LatLonProjection llproj = (LatLonProjection) project;\n      ProjectionRect box = getMapArea();\n      double center = llproj.getCenterLon();\n      double lonBeg = LatLonPointImpl.lonNormal(box.getMinX(), center);\n      double lonEnd = lonBeg + box.getMaxX() - box.getMinX();\n      boolean showShift = Debug.isSet(\"projection/LatLonShift\") || debugNewProjection;\n      if (showShift) System.out.println(\"projection/LatLonShift: min,max = \"+ box.getMinX()+\" \"+\n            box.getMaxX()+\" beg,end= \"+lonBeg+\" \"+lonEnd+ \" center = \"+center);\n\n      if ( (lonBeg < center-180) || (lonEnd > center+180)) {  // got to do it\n        double wx0 = box.getX() + box.getWidth()/2;\n        llproj.setCenterLon( wx0);              // shift cylinder seam\n        double newWx0 = llproj.getCenterLon();  // normalize wx0 to [-180,180]\n        setWorldCenterX(newWx0);             // tell navigation panel to shift\n        if (showShift)\n          System.out.println(\"projection/LatLonShift: shift center to \"+wx0+\"->\"+newWx0);\n\n        // send projection event instead of map area event\n        lmProject.sendEvent( new NewProjectionEvent(this, llproj));\n        return;\n      }\n    }\n\n    // send new map area event\n    lmMapArea.sendEvent( new NewMapAreaEvent( this, getMapArea()));\n  }", "language": "java", "Allcodes": "void fireMapAreaEvent() {\n    if (debugZoom)\n      System.out.println(\"NP.fireMapAreaEvent \");\n\n     // decide if we need a new Projection: for LatLonProjection only\n    if (project.isLatLon()) {\n      LatLonProjection llproj = (LatLonProjection) project;\n      ProjectionRect box = getMapArea();\n      double center = llproj.getCenterLon();\n      double lonBeg = LatLonPointImpl.lonNormal(box.getMinX(), center);\n      double lonEnd = lonBeg + box.getMaxX() - box.getMinX();\n      boolean showShift = Debug.isSet(\"projection/LatLonShift\") || debugNewProjection;\n      if (showShift) System.out.println(\"projection/LatLonShift: min,max = \"+ box.getMinX()+\" \"+\n            box.getMaxX()+\" beg,end= \"+lonBeg+\" \"+lonEnd+ \" center = \"+center);\n\n      if ( (lonBeg < center-180) || (lonEnd > center+180)) {  // got to do it\n        double wx0 = box.getX() + box.getWidth()/2;\n        llproj.setCenterLon( wx0);              // shift cylinder seam\n        double newWx0 = llproj.getCenterLon();  // normalize wx0 to [-180,180]\n        setWorldCenterX(newWx0);             // tell navigation panel to shift\n        if (showShift)\n          System.out.println(\"projection/LatLonShift: shift center to \"+wx0+\"->\"+newWx0);\n\n        // send projection event instead of map area event\n        lmProject.sendEvent( new NewProjectionEvent(this, llproj));\n        return;\n      }\n    }\n\n    // send new map area event\n    lmMapArea.sendEvent( new NewMapAreaEvent( this, getMapArea()));\n  }", "code_tokens": ["void", "fireMapAreaEvent", "(", ")", "{", "if", "(", "debugZoom", ")", "System", ".", "out", ".", "println", "(", "\"NP.fireMapAreaEvent \"", ")", ";", "// decide if we need a new Projection: for LatLonProjection only", "if", "(", "project", ".", "isLatLon", "(", ")", ")", "{", "LatLonProjection", "llproj", "=", "(", "LatLonProjection", ")", "project", ";", "ProjectionRect", "box", "=", "getMapArea", "(", ")", ";", "double", "center", "=", "llproj", ".", "getCenterLon", "(", ")", ";", "double", "lonBeg", "=", "LatLonPointImpl", ".", "lonNormal", "(", "box", ".", "getMinX", "(", ")", ",", "center", ")", ";", "double", "lonEnd", "=", "lonBeg", "+", "box", ".", "getMaxX", "(", ")", "-", "box", ".", "getMinX", "(", ")", ";", "boolean", "showShift", "=", "Debug", ".", "isSet", "(", "\"projection/LatLonShift\"", ")", "||", "debugNewProjection", ";", "if", "(", "showShift", ")", "System", ".", "out", ".", "println", "(", "\"projection/LatLonShift: min,max = \"", "+", "box", ".", "getMinX", "(", ")", "+", "\" \"", "+", "box", ".", "getMaxX", "(", ")", "+", "\" beg,end= \"", "+", "lonBeg", "+", "\" \"", "+", "lonEnd", "+", "\" center = \"", "+", "center", ")", ";", "if", "(", "(", "lonBeg", "<", "center", "-", "180", ")", "||", "(", "lonEnd", ">", "center", "+", "180", ")", ")", "{", "// got to do it", "double", "wx0", "=", "box", ".", "getX", "(", ")", "+", "box", ".", "getWidth", "(", ")", "/", "2", ";", "llproj", ".", "setCenterLon", "(", "wx0", ")", ";", "// shift cylinder seam", "double", "newWx0", "=", "llproj", ".", "getCenterLon", "(", ")", ";", "// normalize wx0 to [-180,180]", "setWorldCenterX", "(", "newWx0", ")", ";", "// tell navigation panel to shift", "if", "(", "showShift", ")", "System", ".", "out", ".", "println", "(", "\"projection/LatLonShift: shift center to \"", "+", "wx0", "+", "\"->\"", "+", "newWx0", ")", ";", "// send projection event instead of map area event", "lmProject", ".", "sendEvent", "(", "new", "NewProjectionEvent", "(", "this", ",", "llproj", ")", ")", ";", "return", ";", "}", "}", "// send new map area event", "lmMapArea", ".", "sendEvent", "(", "new", "NewMapAreaEvent", "(", "this", ",", "getMapArea", "(", ")", ")", ")", ";", "}"], "docstring": "called by Navigation", "docstring_tokens": ["called", "by", "Navigation"]}
{"code": "redrawTimer.stop();", "comments": "one-shot timer", "lines": 12, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/NavigatedPanel.java", "func_name": "NavigatedPanel.redrawLater", "original_string": "private void redrawLater(int delay) {\n    boolean already = (redrawTimer != null) && (redrawTimer.isRunning());\n    if (debugThread) System.out.println( \"redrawLater isRunning= \"+ already);\n    if (already)\n      return;\n\n      // initialize Timer the first time\n    if (redrawTimer == null) {\n      redrawTimer = new javax.swing.Timer(0, new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          drawG();\n          redrawTimer.stop(); // one-shot timer\n        }\n      });\n    }\n      // start the timer running\n    redrawTimer.setDelay(delay);\n    redrawTimer.start();\n  }", "language": "java", "Allcodes": "private void redrawLater(int delay) {\n    boolean already = (redrawTimer != null) && (redrawTimer.isRunning());\n    if (debugThread) System.out.println( \"redrawLater isRunning= \"+ already);\n    if (already)\n      return;\n\n      // initialize Timer the first time\n    if (redrawTimer == null) {\n      redrawTimer = new javax.swing.Timer(0, new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          drawG();\n          redrawTimer.stop(); // one-shot timer\n        }\n      });\n    }\n      // start the timer running\n    redrawTimer.setDelay(delay);\n    redrawTimer.start();\n  }", "code_tokens": ["private", "void", "redrawLater", "(", "int", "delay", ")", "{", "boolean", "already", "=", "(", "redrawTimer", "!=", "null", ")", "&&", "(", "redrawTimer", ".", "isRunning", "(", ")", ")", ";", "if", "(", "debugThread", ")", "System", ".", "out", ".", "println", "(", "\"redrawLater isRunning= \"", "+", "already", ")", ";", "if", "(", "already", ")", "return", ";", "// initialize Timer the first time", "if", "(", "redrawTimer", "==", "null", ")", "{", "redrawTimer", "=", "new", "javax", ".", "swing", ".", "Timer", "(", "0", ",", "new", "ActionListener", "(", ")", "{", "public", "void", "actionPerformed", "(", "ActionEvent", "e", ")", "{", "drawG", "(", ")", ";", "redrawTimer", ".", "stop", "(", ")", ";", "// one-shot timer", "}", "}", ")", ";", "}", "// start the timer running", "redrawTimer", ".", "setDelay", "(", "delay", ")", ";", "redrawTimer", ".", "start", "(", ")", ";", "}"], "docstring": "from panning, so wait delay msecs before doing the redraw.", "docstring_tokens": ["from", "panning", "so", "wait", "delay", "msecs", "before", "doing", "the", "redraw", "."]}
{"code": "bImage = new BufferedImage(b.width, b.height, BufferedImage.TYPE_INT_RGB);", "comments": "why RGB ?", "lines": 18, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/geoloc/NavigatedPanel.java", "func_name": "NavigatedPanel.newScreenSize", "original_string": "private void newScreenSize(Rectangle b) {\n    boolean sameSize = (b.width == myBounds.width) && (b.height == myBounds.height);\n    if (debugBounds) System.out.println( \"NavigatedPanel newScreenSize old= \"+myBounds);\n    if (sameSize && (b.x == myBounds.x) && (b.y == myBounds.y))\n      return;\n\n    myBounds.setBounds(b);\n    if (sameSize)\n      return;\n\n    if (debugBounds) System.out.println( \"  newBounds = \" +b);\n\n    // create new buffer the size of the window\n    //if (bImage != null)\n    //  bImage.dispose();\n\n    if ((b.width > 0) && (b.height > 0)) {\n      bImage = new BufferedImage(b.width, b.height, BufferedImage.TYPE_INT_RGB); // why RGB ?\n    } else {                                                                     // why not device dependent?\n      bImage = null;\n    }\n\n   navigate.setScreenSize(b.width, b.height);\n  }", "language": "java", "Allcodes": "private void newScreenSize(Rectangle b) {\n    boolean sameSize = (b.width == myBounds.width) && (b.height == myBounds.height);\n    if (debugBounds) System.out.println( \"NavigatedPanel newScreenSize old= \"+myBounds);\n    if (sameSize && (b.x == myBounds.x) && (b.y == myBounds.y))\n      return;\n\n    myBounds.setBounds(b);\n    if (sameSize)\n      return;\n\n    if (debugBounds) System.out.println( \"  newBounds = \" +b);\n\n    // create new buffer the size of the window\n    //if (bImage != null)\n    //  bImage.dispose();\n\n    if ((b.width > 0) && (b.height > 0)) {\n      bImage = new BufferedImage(b.width, b.height, BufferedImage.TYPE_INT_RGB); // why RGB ?\n    } else {                                                                     // why not device dependent?\n      bImage = null;\n    }\n\n   navigate.setScreenSize(b.width, b.height);\n  }", "code_tokens": ["private", "void", "newScreenSize", "(", "Rectangle", "b", ")", "{", "boolean", "sameSize", "=", "(", "b", ".", "width", "==", "myBounds", ".", "width", ")", "&&", "(", "b", ".", "height", "==", "myBounds", ".", "height", ")", ";", "if", "(", "debugBounds", ")", "System", ".", "out", ".", "println", "(", "\"NavigatedPanel newScreenSize old= \"", "+", "myBounds", ")", ";", "if", "(", "sameSize", "&&", "(", "b", ".", "x", "==", "myBounds", ".", "x", ")", "&&", "(", "b", ".", "y", "==", "myBounds", ".", "y", ")", ")", "return", ";", "myBounds", ".", "setBounds", "(", "b", ")", ";", "if", "(", "sameSize", ")", "return", ";", "if", "(", "debugBounds", ")", "System", ".", "out", ".", "println", "(", "\"  newBounds = \"", "+", "b", ")", ";", "// create new buffer the size of the window", "//if (bImage != null)", "//  bImage.dispose();", "if", "(", "(", "b", ".", "width", ">", "0", ")", "&&", "(", "b", ".", "height", ">", "0", ")", ")", "{", "bImage", "=", "new", "BufferedImage", "(", "b", ".", "width", ",", "b", ".", "height", ",", "BufferedImage", ".", "TYPE_INT_RGB", ")", ";", "// why RGB ?", "}", "else", "{", "// why not device dependent?", "bImage", "=", "null", ";", "}", "navigate", ".", "setScreenSize", "(", "b", ".", "width", ",", "b", ".", "height", ")", ";", "}"], "docstring": "when component resizes we need a new buffer", "docstring_tokens": ["when", "component", "resizes", "we", "need", "a", "new", "buffer"]}
{"code": "vchain.add( 0, vp);", "comments": "reverse", "lines": 11, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/op/DatasetTreeView.java", "func_name": "DatasetTreeView.setSelected", "original_string": "public void setSelected( VariableIF v ) {\r\n        if (v == null) { return; }\r\n\r\n        // construct chain of variables\r\n        final List<VariableIF> vchain = new ArrayList<>();\r\n        vchain.add( v);\r\n\r\n        VariableIF vp = v;\r\n        while (vp.isMemberOfStructure()) {\r\n            vp = vp.getParentStructure();\r\n            vchain.add( 0, vp); // reverse\r\n        }\r\n\r\n        // construct chain of groups\r\n        final List<Group> gchain = new ArrayList<>();\r\n        Group gp = vp.getParentGroup();\r\n\r\n        gchain.add( gp);\r\n        while (gp.getParentGroup() != null) {\r\n            gp = gp.getParentGroup();\r\n            gchain.add( 0, gp); // reverse\r\n        }\r\n\r\n        final List<Object> pathList = new ArrayList<>();\r\n\r\n        // start at root, work down through the nested groups, if any\r\n        GroupNode gnode = (GroupNode) model.getRoot();\r\n        pathList.add( gnode);\r\n        Group parentGroup = gchain.get(0); // always the root group\r\n\r\n        for (int i=1; i < gchain.size(); i++) {\r\n            parentGroup = gchain.get(i);\r\n            gnode = gnode.findNestedGroup( parentGroup);\r\n            assert gnode != null;\r\n            pathList.add( gnode);\r\n        }\r\n\r\n        vp = vchain.get(0);\r\n        VariableNode vnode = gnode.findNestedVariable( vp);\r\n        if (vnode == null) { return; } // not found\r\n        pathList.add( vnode);\r\n\r\n        // now work down through the structure members, if any\r\n        for (int i=1; i < vchain.size(); i++) {\r\n            vp = vchain.get(i);\r\n            vnode = vnode.findNestedVariable( vp);\r\n            if (vnode == null) { return; } // not found\r\n            pathList.add(vnode);\r\n        }\r\n\r\n        // convert to TreePath, and select it\r\n        final Object[] paths = pathList.toArray();\r\n        final TreePath treePath = new TreePath(paths);\r\n        tree.setSelectionPath( treePath);\r\n        tree.scrollPathToVisible( treePath);\r\n    }", "language": "java", "Allcodes": "public void setSelected( VariableIF v ) {\r\n        if (v == null) { return; }\r\n\r\n        // construct chain of variables\r\n        final List<VariableIF> vchain = new ArrayList<>();\r\n        vchain.add( v);\r\n\r\n        VariableIF vp = v;\r\n        while (vp.isMemberOfStructure()) {\r\n            vp = vp.getParentStructure();\r\n            vchain.add( 0, vp); // reverse\r\n        }\r\n\r\n        // construct chain of groups\r\n        final List<Group> gchain = new ArrayList<>();\r\n        Group gp = vp.getParentGroup();\r\n\r\n        gchain.add( gp);\r\n        while (gp.getParentGroup() != null) {\r\n            gp = gp.getParentGroup();\r\n            gchain.add( 0, gp); // reverse\r\n        }\r\n\r\n        final List<Object> pathList = new ArrayList<>();\r\n\r\n        // start at root, work down through the nested groups, if any\r\n        GroupNode gnode = (GroupNode) model.getRoot();\r\n        pathList.add( gnode);\r\n        Group parentGroup = gchain.get(0); // always the root group\r\n\r\n        for (int i=1; i < gchain.size(); i++) {\r\n            parentGroup = gchain.get(i);\r\n            gnode = gnode.findNestedGroup( parentGroup);\r\n            assert gnode != null;\r\n            pathList.add( gnode);\r\n        }\r\n\r\n        vp = vchain.get(0);\r\n        VariableNode vnode = gnode.findNestedVariable( vp);\r\n        if (vnode == null) { return; } // not found\r\n        pathList.add( vnode);\r\n\r\n        // now work down through the structure members, if any\r\n        for (int i=1; i < vchain.size(); i++) {\r\n            vp = vchain.get(i);\r\n            vnode = vnode.findNestedVariable( vp);\r\n            if (vnode == null) { return; } // not found\r\n            pathList.add(vnode);\r\n        }\r\n\r\n        // convert to TreePath, and select it\r\n        final Object[] paths = pathList.toArray();\r\n        final TreePath treePath = new TreePath(paths);\r\n        tree.setSelectionPath( treePath);\r\n        tree.scrollPathToVisible( treePath);\r\n    }", "code_tokens": ["public", "void", "setSelected", "(", "VariableIF", "v", ")", "{", "if", "(", "v", "==", "null", ")", "{", "return", ";", "}", "// construct chain of variables\r", "final", "List", "<", "VariableIF", ">", "vchain", "=", "new", "ArrayList", "<>", "(", ")", ";", "vchain", ".", "add", "(", "v", ")", ";", "VariableIF", "vp", "=", "v", ";", "while", "(", "vp", ".", "isMemberOfStructure", "(", ")", ")", "{", "vp", "=", "vp", ".", "getParentStructure", "(", ")", ";", "vchain", ".", "add", "(", "0", ",", "vp", ")", ";", "// reverse\r", "}", "// construct chain of groups\r", "final", "List", "<", "Group", ">", "gchain", "=", "new", "ArrayList", "<>", "(", ")", ";", "Group", "gp", "=", "vp", ".", "getParentGroup", "(", ")", ";", "gchain", ".", "add", "(", "gp", ")", ";", "while", "(", "gp", ".", "getParentGroup", "(", ")", "!=", "null", ")", "{", "gp", "=", "gp", ".", "getParentGroup", "(", ")", ";", "gchain", ".", "add", "(", "0", ",", "gp", ")", ";", "// reverse\r", "}", "final", "List", "<", "Object", ">", "pathList", "=", "new", "ArrayList", "<>", "(", ")", ";", "// start at root, work down through the nested groups, if any\r", "GroupNode", "gnode", "=", "(", "GroupNode", ")", "model", ".", "getRoot", "(", ")", ";", "pathList", ".", "add", "(", "gnode", ")", ";", "Group", "parentGroup", "=", "gchain", ".", "get", "(", "0", ")", ";", "// always the root group\r", "for", "(", "int", "i", "=", "1", ";", "i", "<", "gchain", ".", "size", "(", ")", ";", "i", "++", ")", "{", "parentGroup", "=", "gchain", ".", "get", "(", "i", ")", ";", "gnode", "=", "gnode", ".", "findNestedGroup", "(", "parentGroup", ")", ";", "assert", "gnode", "!=", "null", ";", "pathList", ".", "add", "(", "gnode", ")", ";", "}", "vp", "=", "vchain", ".", "get", "(", "0", ")", ";", "VariableNode", "vnode", "=", "gnode", ".", "findNestedVariable", "(", "vp", ")", ";", "if", "(", "vnode", "==", "null", ")", "{", "return", ";", "}", "// not found\r", "pathList", ".", "add", "(", "vnode", ")", ";", "// now work down through the structure members, if any\r", "for", "(", "int", "i", "=", "1", ";", "i", "<", "vchain", ".", "size", "(", ")", ";", "i", "++", ")", "{", "vp", "=", "vchain", ".", "get", "(", "i", ")", ";", "vnode", "=", "vnode", ".", "findNestedVariable", "(", "vp", ")", ";", "if", "(", "vnode", "==", "null", ")", "{", "return", ";", "}", "// not found\r", "pathList", ".", "add", "(", "vnode", ")", ";", "}", "// convert to TreePath, and select it\r", "final", "Object", "[", "]", "paths", "=", "pathList", ".", "toArray", "(", ")", ";", "final", "TreePath", "treePath", "=", "new", "TreePath", "(", "paths", ")", ";", "tree", ".", "setSelectionPath", "(", "treePath", ")", ";", "tree", ".", "scrollPathToVisible", "(", "treePath", ")", ";", "}"], "docstring": "Set the currently selected Variable.\n\n@param v select this Variable, must be already in the tree.", "docstring_tokens": ["Set", "the", "currently", "selected", "Variable", "."]}
{"code": "Group parentGroup = gchain.get(0);", "comments": "always the root group", "lines": 29, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/op/DatasetTreeView.java", "func_name": "DatasetTreeView.setSelected", "original_string": "public void setSelected( VariableIF v ) {\r\n        if (v == null) { return; }\r\n\r\n        // construct chain of variables\r\n        final List<VariableIF> vchain = new ArrayList<>();\r\n        vchain.add( v);\r\n\r\n        VariableIF vp = v;\r\n        while (vp.isMemberOfStructure()) {\r\n            vp = vp.getParentStructure();\r\n            vchain.add( 0, vp); // reverse\r\n        }\r\n\r\n        // construct chain of groups\r\n        final List<Group> gchain = new ArrayList<>();\r\n        Group gp = vp.getParentGroup();\r\n\r\n        gchain.add( gp);\r\n        while (gp.getParentGroup() != null) {\r\n            gp = gp.getParentGroup();\r\n            gchain.add( 0, gp); // reverse\r\n        }\r\n\r\n        final List<Object> pathList = new ArrayList<>();\r\n\r\n        // start at root, work down through the nested groups, if any\r\n        GroupNode gnode = (GroupNode) model.getRoot();\r\n        pathList.add( gnode);\r\n        Group parentGroup = gchain.get(0); // always the root group\r\n\r\n        for (int i=1; i < gchain.size(); i++) {\r\n            parentGroup = gchain.get(i);\r\n            gnode = gnode.findNestedGroup( parentGroup);\r\n            assert gnode != null;\r\n            pathList.add( gnode);\r\n        }\r\n\r\n        vp = vchain.get(0);\r\n        VariableNode vnode = gnode.findNestedVariable( vp);\r\n        if (vnode == null) { return; } // not found\r\n        pathList.add( vnode);\r\n\r\n        // now work down through the structure members, if any\r\n        for (int i=1; i < vchain.size(); i++) {\r\n            vp = vchain.get(i);\r\n            vnode = vnode.findNestedVariable( vp);\r\n            if (vnode == null) { return; } // not found\r\n            pathList.add(vnode);\r\n        }\r\n\r\n        // convert to TreePath, and select it\r\n        final Object[] paths = pathList.toArray();\r\n        final TreePath treePath = new TreePath(paths);\r\n        tree.setSelectionPath( treePath);\r\n        tree.scrollPathToVisible( treePath);\r\n    }", "language": "java", "Allcodes": "public void setSelected( VariableIF v ) {\r\n        if (v == null) { return; }\r\n\r\n        // construct chain of variables\r\n        final List<VariableIF> vchain = new ArrayList<>();\r\n        vchain.add( v);\r\n\r\n        VariableIF vp = v;\r\n        while (vp.isMemberOfStructure()) {\r\n            vp = vp.getParentStructure();\r\n            vchain.add( 0, vp); // reverse\r\n        }\r\n\r\n        // construct chain of groups\r\n        final List<Group> gchain = new ArrayList<>();\r\n        Group gp = vp.getParentGroup();\r\n\r\n        gchain.add( gp);\r\n        while (gp.getParentGroup() != null) {\r\n            gp = gp.getParentGroup();\r\n            gchain.add( 0, gp); // reverse\r\n        }\r\n\r\n        final List<Object> pathList = new ArrayList<>();\r\n\r\n        // start at root, work down through the nested groups, if any\r\n        GroupNode gnode = (GroupNode) model.getRoot();\r\n        pathList.add( gnode);\r\n        Group parentGroup = gchain.get(0); // always the root group\r\n\r\n        for (int i=1; i < gchain.size(); i++) {\r\n            parentGroup = gchain.get(i);\r\n            gnode = gnode.findNestedGroup( parentGroup);\r\n            assert gnode != null;\r\n            pathList.add( gnode);\r\n        }\r\n\r\n        vp = vchain.get(0);\r\n        VariableNode vnode = gnode.findNestedVariable( vp);\r\n        if (vnode == null) { return; } // not found\r\n        pathList.add( vnode);\r\n\r\n        // now work down through the structure members, if any\r\n        for (int i=1; i < vchain.size(); i++) {\r\n            vp = vchain.get(i);\r\n            vnode = vnode.findNestedVariable( vp);\r\n            if (vnode == null) { return; } // not found\r\n            pathList.add(vnode);\r\n        }\r\n\r\n        // convert to TreePath, and select it\r\n        final Object[] paths = pathList.toArray();\r\n        final TreePath treePath = new TreePath(paths);\r\n        tree.setSelectionPath( treePath);\r\n        tree.scrollPathToVisible( treePath);\r\n    }", "code_tokens": ["public", "void", "setSelected", "(", "VariableIF", "v", ")", "{", "if", "(", "v", "==", "null", ")", "{", "return", ";", "}", "// construct chain of variables\r", "final", "List", "<", "VariableIF", ">", "vchain", "=", "new", "ArrayList", "<>", "(", ")", ";", "vchain", ".", "add", "(", "v", ")", ";", "VariableIF", "vp", "=", "v", ";", "while", "(", "vp", ".", "isMemberOfStructure", "(", ")", ")", "{", "vp", "=", "vp", ".", "getParentStructure", "(", ")", ";", "vchain", ".", "add", "(", "0", ",", "vp", ")", ";", "// reverse\r", "}", "// construct chain of groups\r", "final", "List", "<", "Group", ">", "gchain", "=", "new", "ArrayList", "<>", "(", ")", ";", "Group", "gp", "=", "vp", ".", "getParentGroup", "(", ")", ";", "gchain", ".", "add", "(", "gp", ")", ";", "while", "(", "gp", ".", "getParentGroup", "(", ")", "!=", "null", ")", "{", "gp", "=", "gp", ".", "getParentGroup", "(", ")", ";", "gchain", ".", "add", "(", "0", ",", "gp", ")", ";", "// reverse\r", "}", "final", "List", "<", "Object", ">", "pathList", "=", "new", "ArrayList", "<>", "(", ")", ";", "// start at root, work down through the nested groups, if any\r", "GroupNode", "gnode", "=", "(", "GroupNode", ")", "model", ".", "getRoot", "(", ")", ";", "pathList", ".", "add", "(", "gnode", ")", ";", "Group", "parentGroup", "=", "gchain", ".", "get", "(", "0", ")", ";", "// always the root group\r", "for", "(", "int", "i", "=", "1", ";", "i", "<", "gchain", ".", "size", "(", ")", ";", "i", "++", ")", "{", "parentGroup", "=", "gchain", ".", "get", "(", "i", ")", ";", "gnode", "=", "gnode", ".", "findNestedGroup", "(", "parentGroup", ")", ";", "assert", "gnode", "!=", "null", ";", "pathList", ".", "add", "(", "gnode", ")", ";", "}", "vp", "=", "vchain", ".", "get", "(", "0", ")", ";", "VariableNode", "vnode", "=", "gnode", ".", "findNestedVariable", "(", "vp", ")", ";", "if", "(", "vnode", "==", "null", ")", "{", "return", ";", "}", "// not found\r", "pathList", ".", "add", "(", "vnode", ")", ";", "// now work down through the structure members, if any\r", "for", "(", "int", "i", "=", "1", ";", "i", "<", "vchain", ".", "size", "(", ")", ";", "i", "++", ")", "{", "vp", "=", "vchain", ".", "get", "(", "i", ")", ";", "vnode", "=", "vnode", ".", "findNestedVariable", "(", "vp", ")", ";", "if", "(", "vnode", "==", "null", ")", "{", "return", ";", "}", "// not found\r", "pathList", ".", "add", "(", "vnode", ")", ";", "}", "// convert to TreePath, and select it\r", "final", "Object", "[", "]", "paths", "=", "pathList", ".", "toArray", "(", ")", ";", "final", "TreePath", "treePath", "=", "new", "TreePath", "(", "paths", ")", ";", "tree", ".", "setSelectionPath", "(", "treePath", ")", ";", "tree", ".", "scrollPathToVisible", "(", "treePath", ")", ";", "}"], "docstring": "Set the currently selected Variable.\n\n@param v select this Variable, must be already in the tree.", "docstring_tokens": ["Set", "the", "currently", "selected", "Variable", "."]}
{"code": "int startOffset = timeUnit.getOffset(refDate, start);", "comments": "LOOK wrong - not dealing with value ??", "lines": 5, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/coord/TimeCoordIntvDateValue.java", "func_name": "TimeCoordIntvDateValue.convertReferenceDate", "original_string": "public TimeCoordIntvValue convertReferenceDate(CalendarDate refDate, CalendarPeriod timeUnit) {\n    if (timeUnit == null) {\n      throw new IllegalArgumentException(\"null time unit\");\n    }\n    int startOffset = timeUnit.getOffset(refDate, start);   // LOOK wrong - not dealing with value ??\n    int endOffset = timeUnit.getOffset(refDate, end);\n    return new TimeCoordIntvValue(startOffset, endOffset);\n  }", "language": "java", "Allcodes": "public TimeCoordIntvValue convertReferenceDate(CalendarDate refDate, CalendarPeriod timeUnit) {\n    if (timeUnit == null) {\n      throw new IllegalArgumentException(\"null time unit\");\n    }\n    int startOffset = timeUnit.getOffset(refDate, start);   // LOOK wrong - not dealing with value ??\n    int endOffset = timeUnit.getOffset(refDate, end);\n    return new TimeCoordIntvValue(startOffset, endOffset);\n  }", "code_tokens": ["public", "TimeCoordIntvValue", "convertReferenceDate", "(", "CalendarDate", "refDate", ",", "CalendarPeriod", "timeUnit", ")", "{", "if", "(", "timeUnit", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"null time unit\"", ")", ";", "}", "int", "startOffset", "=", "timeUnit", ".", "getOffset", "(", "refDate", ",", "start", ")", ";", "// LOOK wrong - not dealing with value ??", "int", "endOffset", "=", "timeUnit", ".", "getOffset", "(", "refDate", ",", "end", ")", ";", "return", "new", "TimeCoordIntvValue", "(", "startOffset", ",", "endOffset", ")", ";", "}"], "docstring": "Calculate the offset in units of timeUnit from the given reference date?", "docstring_tokens": ["Calculate", "the", "offset", "in", "units", "of", "timeUnit", "from", "the", "given", "reference", "date?"]}
{"code": "int [] levels = new int[ inc];", "comments": "th[2] ];", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/nids/Nidsheader.java", "func_name": "Nidsheader.getDualpolLevels", "original_string": "public int[] getDualpolLevels(  short[] th) {\r\n\r\n        int inc = th.length;\r\n        int [] levels = new int[ inc]; //th[2] ];\r\n        for ( int i = 0; i < inc; i++ ) {    /* calibrated data values        */\r\n            levels[i] = th[i];\r\n        }\r\n\r\n        return levels;\r\n    }", "language": "java", "Allcodes": "public int[] getDualpolLevels(  short[] th) {\r\n\r\n        int inc = th.length;\r\n        int [] levels = new int[ inc]; //th[2] ];\r\n        for ( int i = 0; i < inc; i++ ) {    /* calibrated data values        */\r\n            levels[i] = th[i];\r\n        }\r\n\r\n        return levels;\r\n    }", "code_tokens": ["public", "int", "[", "]", "getDualpolLevels", "(", "short", "[", "]", "th", ")", "{", "int", "inc", "=", "th", ".", "length", ";", "int", "[", "]", "levels", "=", "new", "int", "[", "inc", "]", ";", "//th[2] ];\r", "for", "(", "int", "i", "=", "0", ";", "i", "<", "inc", ";", "i", "++", ")", "{", "/* calibrated data values        */", "levels", "[", "i", "]", "=", "th", "[", "i", "]", ";", "}", "return", "levels", ";", "}"], "docstring": "get the calibrate data values for dualpol data\n@param th\n@return", "docstring_tokens": ["get", "the", "calibrate", "data", "values", "for", "dualpol", "data"]}
{"code": "addCommonHeaders(drq);", "comments": "Add relevant headers", "lines": 38, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/DapController.java", "func_name": "DapController.doDMR", "original_string": "protected void\n    doDMR(DapRequest drq, DapContext cxt)\n            throws IOException\n    {\n        // Convert the url to an absolute path\n        String realpath = getResourcePath(drq, drq.getDatasetPath());\n\n        DSP dsp = DapCache.open(realpath, cxt);\n        DapDataset dmr = dsp.getDMR();\n\n        /* Annotate with our endianness */\n        ByteOrder order = (ByteOrder) cxt.get(Dap4Util.DAP4ENDIANTAG);\n        setEndianness(dmr, order);\n\n        // Process any constraint view\n        CEConstraint ce = null;\n        String sce = drq.queryLookup(DapProtocol.CONSTRAINTTAG);\n        ce = CEConstraint.compile(sce, dmr);\n        setConstraint(dmr, ce);\n\n        // Provide a PrintWriter for capturing the DMR.\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // Get the DMR as a string\n        DMRPrinter dapprinter = new DMRPrinter(dmr, ce, pw, drq.getFormat());\n        if(cxt.get(Dap4Util.DAP4TESTTAG) != null)\n            dapprinter.testprint();\n        else\n            dapprinter.print();\n        pw.close();\n        sw.close();\n\n        String sdmr = sw.toString();\n        if(DEBUG)\n            System.err.println(\"Sending: DMR:\\n\" + sdmr);\n\n        addCommonHeaders(drq);// Add relevant headers\n\n        // Wrap the outputstream with a Chunk writer\n        OutputStream out = drq.getOutputStream();\n        ChunkWriter cw = new ChunkWriter(out, RequestMode.DMR, order);\n        cw.cacheDMR(sdmr);\n        cw.close();\n    }", "language": "java", "Allcodes": "protected void\n    doDMR(DapRequest drq, DapContext cxt)\n            throws IOException\n    {\n        // Convert the url to an absolute path\n        String realpath = getResourcePath(drq, drq.getDatasetPath());\n\n        DSP dsp = DapCache.open(realpath, cxt);\n        DapDataset dmr = dsp.getDMR();\n\n        /* Annotate with our endianness */\n        ByteOrder order = (ByteOrder) cxt.get(Dap4Util.DAP4ENDIANTAG);\n        setEndianness(dmr, order);\n\n        // Process any constraint view\n        CEConstraint ce = null;\n        String sce = drq.queryLookup(DapProtocol.CONSTRAINTTAG);\n        ce = CEConstraint.compile(sce, dmr);\n        setConstraint(dmr, ce);\n\n        // Provide a PrintWriter for capturing the DMR.\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // Get the DMR as a string\n        DMRPrinter dapprinter = new DMRPrinter(dmr, ce, pw, drq.getFormat());\n        if(cxt.get(Dap4Util.DAP4TESTTAG) != null)\n            dapprinter.testprint();\n        else\n            dapprinter.print();\n        pw.close();\n        sw.close();\n\n        String sdmr = sw.toString();\n        if(DEBUG)\n            System.err.println(\"Sending: DMR:\\n\" + sdmr);\n\n        addCommonHeaders(drq);// Add relevant headers\n\n        // Wrap the outputstream with a Chunk writer\n        OutputStream out = drq.getOutputStream();\n        ChunkWriter cw = new ChunkWriter(out, RequestMode.DMR, order);\n        cw.cacheDMR(sdmr);\n        cw.close();\n    }", "code_tokens": ["protected", "void", "doDMR", "(", "DapRequest", "drq", ",", "DapContext", "cxt", ")", "throws", "IOException", "{", "// Convert the url to an absolute path", "String", "realpath", "=", "getResourcePath", "(", "drq", ",", "drq", ".", "getDatasetPath", "(", ")", ")", ";", "DSP", "dsp", "=", "DapCache", ".", "open", "(", "realpath", ",", "cxt", ")", ";", "DapDataset", "dmr", "=", "dsp", ".", "getDMR", "(", ")", ";", "/* Annotate with our endianness */", "ByteOrder", "order", "=", "(", "ByteOrder", ")", "cxt", ".", "get", "(", "Dap4Util", ".", "DAP4ENDIANTAG", ")", ";", "setEndianness", "(", "dmr", ",", "order", ")", ";", "// Process any constraint view", "CEConstraint", "ce", "=", "null", ";", "String", "sce", "=", "drq", ".", "queryLookup", "(", "DapProtocol", ".", "CONSTRAINTTAG", ")", ";", "ce", "=", "CEConstraint", ".", "compile", "(", "sce", ",", "dmr", ")", ";", "setConstraint", "(", "dmr", ",", "ce", ")", ";", "// Provide a PrintWriter for capturing the DMR.", "StringWriter", "sw", "=", "new", "StringWriter", "(", ")", ";", "PrintWriter", "pw", "=", "new", "PrintWriter", "(", "sw", ")", ";", "// Get the DMR as a string", "DMRPrinter", "dapprinter", "=", "new", "DMRPrinter", "(", "dmr", ",", "ce", ",", "pw", ",", "drq", ".", "getFormat", "(", ")", ")", ";", "if", "(", "cxt", ".", "get", "(", "Dap4Util", ".", "DAP4TESTTAG", ")", "!=", "null", ")", "dapprinter", ".", "testprint", "(", ")", ";", "else", "dapprinter", ".", "print", "(", ")", ";", "pw", ".", "close", "(", ")", ";", "sw", ".", "close", "(", ")", ";", "String", "sdmr", "=", "sw", ".", "toString", "(", ")", ";", "if", "(", "DEBUG", ")", "System", ".", "err", ".", "println", "(", "\"Sending: DMR:\\n\"", "+", "sdmr", ")", ";", "addCommonHeaders", "(", "drq", ")", ";", "// Add relevant headers", "// Wrap the outputstream with a Chunk writer", "OutputStream", "out", "=", "drq", ".", "getOutputStream", "(", ")", ";", "ChunkWriter", "cw", "=", "new", "ChunkWriter", "(", "out", ",", "RequestMode", ".", "DMR", ",", "order", ")", ";", "cw", ".", "cacheDMR", "(", "sdmr", ")", ";", "cw", ".", "close", "(", ")", ";", "}"], "docstring": "Process a DMR request.\n\n@param cxt The dap context", "docstring_tokens": ["Process", "a", "DMR", "request", "."]}
{"code": "sbuff.append(\"PARAMETER[\\\"latitude_of_origin\\\",\").append(getOriginLat()).append(\"],\");", "comments": "LOOK assumes getOriginLat = getParellel", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/projection/LambertConformal.java", "func_name": "LambertConformal.toWKS", "original_string": "public String toWKS() {\r\n    StringBuilder sbuff = new StringBuilder();\r\n    sbuff.append(\"PROJCS[\\\"\").append(getName()).append(\"\\\",\");\r\n    if (true) {\r\n      sbuff.append(\"GEOGCS[\\\"Normal Sphere (r=6371007)\\\",\");\r\n      sbuff.append(\"DATUM[\\\"unknown\\\",\");\r\n      sbuff.append(\"SPHEROID[\\\"sphere\\\",6371007,0]],\");\r\n    } else {\r\n      sbuff.append(\"GEOGCS[\\\"WGS 84\\\",\");\r\n      sbuff.append(\"DATUM[\\\"WGS_1984\\\",\");\r\n      sbuff.append(\"SPHEROID[\\\"WGS 84\\\",6378137,298.257223563],\");\r\n      sbuff.append(\"TOWGS84[0,0,0,0,0,0,0]],\");\r\n    }\r\n    sbuff.append(\"PRIMEM[\\\"Greenwich\\\",0],\");\r\n    sbuff.append(\"UNIT[\\\"degree\\\",0.0174532925199433]],\");\r\n    sbuff.append(\"PROJECTION[\\\"Lambert_Conformal_Conic_1SP\\\"],\");\r\n    sbuff.append(\"PARAMETER[\\\"latitude_of_origin\\\",\").append(getOriginLat()).append(\"],\");  // LOOK assumes getOriginLat = getParellel\r\n    sbuff.append(\"PARAMETER[\\\"central_meridian\\\",\").append(getOriginLon()).append(\"],\");\r\n    sbuff.append(\"PARAMETER[\\\"scale_factor\\\",1],\");\r\n    sbuff.append(\"PARAMETER[\\\"false_easting\\\",\").append(falseEasting).append(\"],\");\r\n    sbuff.append(\"PARAMETER[\\\"false_northing\\\",\").append(falseNorthing).append(\"],\");\r\n\r\n    return sbuff.toString();\r\n  }", "language": "java", "Allcodes": "public String toWKS() {\r\n    StringBuilder sbuff = new StringBuilder();\r\n    sbuff.append(\"PROJCS[\\\"\").append(getName()).append(\"\\\",\");\r\n    if (true) {\r\n      sbuff.append(\"GEOGCS[\\\"Normal Sphere (r=6371007)\\\",\");\r\n      sbuff.append(\"DATUM[\\\"unknown\\\",\");\r\n      sbuff.append(\"SPHEROID[\\\"sphere\\\",6371007,0]],\");\r\n    } else {\r\n      sbuff.append(\"GEOGCS[\\\"WGS 84\\\",\");\r\n      sbuff.append(\"DATUM[\\\"WGS_1984\\\",\");\r\n      sbuff.append(\"SPHEROID[\\\"WGS 84\\\",6378137,298.257223563],\");\r\n      sbuff.append(\"TOWGS84[0,0,0,0,0,0,0]],\");\r\n    }\r\n    sbuff.append(\"PRIMEM[\\\"Greenwich\\\",0],\");\r\n    sbuff.append(\"UNIT[\\\"degree\\\",0.0174532925199433]],\");\r\n    sbuff.append(\"PROJECTION[\\\"Lambert_Conformal_Conic_1SP\\\"],\");\r\n    sbuff.append(\"PARAMETER[\\\"latitude_of_origin\\\",\").append(getOriginLat()).append(\"],\");  // LOOK assumes getOriginLat = getParellel\r\n    sbuff.append(\"PARAMETER[\\\"central_meridian\\\",\").append(getOriginLon()).append(\"],\");\r\n    sbuff.append(\"PARAMETER[\\\"scale_factor\\\",1],\");\r\n    sbuff.append(\"PARAMETER[\\\"false_easting\\\",\").append(falseEasting).append(\"],\");\r\n    sbuff.append(\"PARAMETER[\\\"false_northing\\\",\").append(falseNorthing).append(\"],\");\r\n\r\n    return sbuff.toString();\r\n  }", "code_tokens": ["public", "String", "toWKS", "(", ")", "{", "StringBuilder", "sbuff", "=", "new", "StringBuilder", "(", ")", ";", "sbuff", ".", "append", "(", "\"PROJCS[\\\"\"", ")", ".", "append", "(", "getName", "(", ")", ")", ".", "append", "(", "\"\\\",\"", ")", ";", "if", "(", "true", ")", "{", "sbuff", ".", "append", "(", "\"GEOGCS[\\\"Normal Sphere (r=6371007)\\\",\"", ")", ";", "sbuff", ".", "append", "(", "\"DATUM[\\\"unknown\\\",\"", ")", ";", "sbuff", ".", "append", "(", "\"SPHEROID[\\\"sphere\\\",6371007,0]],\"", ")", ";", "}", "else", "{", "sbuff", ".", "append", "(", "\"GEOGCS[\\\"WGS 84\\\",\"", ")", ";", "sbuff", ".", "append", "(", "\"DATUM[\\\"WGS_1984\\\",\"", ")", ";", "sbuff", ".", "append", "(", "\"SPHEROID[\\\"WGS 84\\\",6378137,298.257223563],\"", ")", ";", "sbuff", ".", "append", "(", "\"TOWGS84[0,0,0,0,0,0,0]],\"", ")", ";", "}", "sbuff", ".", "append", "(", "\"PRIMEM[\\\"Greenwich\\\",0],\"", ")", ";", "sbuff", ".", "append", "(", "\"UNIT[\\\"degree\\\",0.0174532925199433]],\"", ")", ";", "sbuff", ".", "append", "(", "\"PROJECTION[\\\"Lambert_Conformal_Conic_1SP\\\"],\"", ")", ";", "sbuff", ".", "append", "(", "\"PARAMETER[\\\"latitude_of_origin\\\",\"", ")", ".", "append", "(", "getOriginLat", "(", ")", ")", ".", "append", "(", "\"],\"", ")", ";", "// LOOK assumes getOriginLat = getParellel\r", "sbuff", ".", "append", "(", "\"PARAMETER[\\\"central_meridian\\\",\"", ")", ".", "append", "(", "getOriginLon", "(", ")", ")", ".", "append", "(", "\"],\"", ")", ";", "sbuff", ".", "append", "(", "\"PARAMETER[\\\"scale_factor\\\",1],\"", ")", ";", "sbuff", ".", "append", "(", "\"PARAMETER[\\\"false_easting\\\",\"", ")", ".", "append", "(", "falseEasting", ")", ".", "append", "(", "\"],\"", ")", ";", "sbuff", ".", "append", "(", "\"PARAMETER[\\\"false_northing\\\",\"", ")", ".", "append", "(", "falseNorthing", ")", ".", "append", "(", "\"],\"", ")", ";", "return", "sbuff", ".", "toString", "(", ")", ";", "}"], "docstring": "Create a WKS string\n\n@return WKS string", "docstring_tokens": ["Create", "a", "WKS", "string"]}
{"code": "escaped.append(c);", "comments": "These are the only legal control chars", "lines": 31, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Escape.java", "func_name": "Escape.entityEscape", "original_string": "static public String\n    entityEscape(String s, String wrt)\n    {\n        if(wrt == null)\n            wrt = ENTITYESCAPES;\n        StringBuilder escaped = new StringBuilder();\n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            int index = wrt.indexOf(c);\n            if(index < 0)\n                escaped.append(c);\n            else switch (c) {\n            case '&':\n                escaped.append('&' + ENTITY_AMP + ';');\n                break;\n            case '<':\n                escaped.append('&' + ENTITY_LT + ';');\n                break;\n            case '>':\n                escaped.append('&' + ENTITY_GT + ';');\n                break;\n            case '\"':\n                escaped.append('&' + ENTITY_QUOT + ';');\n                break;\n            case '\\'':\n                escaped.append('&' + ENTITY_APOS + ';');\n                break;\n            case '\\r':\n            case '\\t':\n            case '\\n':\n                escaped.append(c);  // These are the only legal control chars\n                break;\n            case '\\0':\n                // What to do about nul? currrently we suppress it\n                break;\n            default:\n                if(c >= ' ')\n                    escaped.append(c);\n                break;\n            }\n        }\n        return escaped.toString();\n    }", "language": "java", "Allcodes": "static public String\n    entityEscape(String s, String wrt)\n    {\n        if(wrt == null)\n            wrt = ENTITYESCAPES;\n        StringBuilder escaped = new StringBuilder();\n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            int index = wrt.indexOf(c);\n            if(index < 0)\n                escaped.append(c);\n            else switch (c) {\n            case '&':\n                escaped.append('&' + ENTITY_AMP + ';');\n                break;\n            case '<':\n                escaped.append('&' + ENTITY_LT + ';');\n                break;\n            case '>':\n                escaped.append('&' + ENTITY_GT + ';');\n                break;\n            case '\"':\n                escaped.append('&' + ENTITY_QUOT + ';');\n                break;\n            case '\\'':\n                escaped.append('&' + ENTITY_APOS + ';');\n                break;\n            case '\\r':\n            case '\\t':\n            case '\\n':\n                escaped.append(c);  // These are the only legal control chars\n                break;\n            case '\\0':\n                // What to do about nul? currrently we suppress it\n                break;\n            default:\n                if(c >= ' ')\n                    escaped.append(c);\n                break;\n            }\n        }\n        return escaped.toString();\n    }", "code_tokens": ["static", "public", "String", "entityEscape", "(", "String", "s", ",", "String", "wrt", ")", "{", "if", "(", "wrt", "==", "null", ")", "wrt", "=", "ENTITYESCAPES", ";", "StringBuilder", "escaped", "=", "new", "StringBuilder", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "s", ".", "length", "(", ")", ";", "i", "++", ")", "{", "char", "c", "=", "s", ".", "charAt", "(", "i", ")", ";", "int", "index", "=", "wrt", ".", "indexOf", "(", "c", ")", ";", "if", "(", "index", "<", "0", ")", "escaped", ".", "append", "(", "c", ")", ";", "else", "switch", "(", "c", ")", "{", "case", "'", "'", ":", "escaped", ".", "append", "(", "'", "'", "+", "ENTITY_AMP", "+", "'", "'", ")", ";", "break", ";", "case", "'", "'", ":", "escaped", ".", "append", "(", "'", "'", "+", "ENTITY_LT", "+", "'", "'", ")", ";", "break", ";", "case", "'", "'", ":", "escaped", ".", "append", "(", "'", "'", "+", "ENTITY_GT", "+", "'", "'", ")", ";", "break", ";", "case", "'", "'", ":", "escaped", ".", "append", "(", "'", "'", "+", "ENTITY_QUOT", "+", "'", "'", ")", ";", "break", ";", "case", "'", "'", ":", "escaped", ".", "append", "(", "'", "'", "+", "ENTITY_APOS", "+", "'", "'", ")", ";", "break", ";", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "escaped", ".", "append", "(", "c", ")", ";", "// These are the only legal control chars", "break", ";", "case", "'", "'", ":", "// What to do about nul? currrently we suppress it", "break", ";", "default", ":", "if", "(", "c", ">=", "'", "'", ")", "escaped", ".", "append", "(", "c", ")", ";", "break", ";", "}", "}", "return", "escaped", ".", "toString", "(", ")", ";", "}"], "docstring": "Escape selected characters in a string using XML entities\n\n@param s   string to escape\n@param wrt which chars to escape\n@return escaped string", "docstring_tokens": ["Escape", "selected", "characters", "in", "a", "string", "using", "XML", "entities"]}
{"code": "piece.append(c);", "comments": "keep escapes in place", "lines": 11, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Escape.java", "func_name": "Escape.backslashsplit", "original_string": "static public List<String>\n    backslashsplit(String s, char sep)\n    {\n        List<String> path = new ArrayList<String>();\n        int len = s.length();\n        StringBuilder piece = new StringBuilder();\n        int i = 0;\n        for(; i <= len - 1; i++) {\n            char c = s.charAt(i);\n            if(c == '\\\\' && i < (len - 1)) {\n                piece.append(c); // keep escapes in place\n                piece.append(s.charAt(++i));\n            } else if(c == sep) {\n                path.add(piece.toString());\n                piece.setLength(0);\n            } else\n                piece.append(c);\n        }\n        path.add(piece.toString());\n        return path;\n    }", "language": "java", "Allcodes": "static public List<String>\n    backslashsplit(String s, char sep)\n    {\n        List<String> path = new ArrayList<String>();\n        int len = s.length();\n        StringBuilder piece = new StringBuilder();\n        int i = 0;\n        for(; i <= len - 1; i++) {\n            char c = s.charAt(i);\n            if(c == '\\\\' && i < (len - 1)) {\n                piece.append(c); // keep escapes in place\n                piece.append(s.charAt(++i));\n            } else if(c == sep) {\n                path.add(piece.toString());\n                piece.setLength(0);\n            } else\n                piece.append(c);\n        }\n        path.add(piece.toString());\n        return path;\n    }", "code_tokens": ["static", "public", "List", "<", "String", ">", "backslashsplit", "(", "String", "s", ",", "char", "sep", ")", "{", "List", "<", "String", ">", "path", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "int", "len", "=", "s", ".", "length", "(", ")", ";", "StringBuilder", "piece", "=", "new", "StringBuilder", "(", ")", ";", "int", "i", "=", "0", ";", "for", "(", ";", "i", "<=", "len", "-", "1", ";", "i", "++", ")", "{", "char", "c", "=", "s", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "==", "'", "'", "&&", "i", "<", "(", "len", "-", "1", ")", ")", "{", "piece", ".", "append", "(", "c", ")", ";", "// keep escapes in place", "piece", ".", "append", "(", "s", ".", "charAt", "(", "++", "i", ")", ")", ";", "}", "else", "if", "(", "c", "==", "sep", ")", "{", "path", ".", "add", "(", "piece", ".", "toString", "(", ")", ")", ";", "piece", ".", "setLength", "(", "0", ")", ";", "}", "else", "piece", ".", "append", "(", "c", ")", ";", "}", "path", ".", "add", "(", "piece", ".", "toString", "(", ")", ")", ";", "return", "path", ";", "}"], "docstring": "Split a string with respect to a separator\ncharacter and taking backslashes into consideration.\n\n@param s   The string to split\n@param sep The character on which to split\n@return a List of strings (all with escaping still intact)\nrepresenting s split at unescaped instances of sep.", "docstring_tokens": ["Split", "a", "string", "with", "respect", "to", "a", "separator", "character", "and", "taking", "backslashes", "into", "consideration", "."]}
{"code": "Map<CalendarDate, FmrInv> fmrMap = new HashMap<>();", "comments": "all files are grouped by run date in an FmrInv", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/Fmrc.java", "func_name": "Fmrc.makeFmrcInv", "original_string": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "language": "java", "Allcodes": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "code_tokens": ["private", "FmrcInv", "makeFmrcInv", "(", "Formatter", "debug", ")", "throws", "IOException", "{", "try", "{", "Map", "<", "CalendarDate", ",", "FmrInv", ">", "fmrMap", "=", "new", "HashMap", "<>", "(", ")", ";", "// all files are grouped by run date in an FmrInv\r", "List", "<", "FmrInv", ">", "fmrList", "=", "new", "ArrayList", "<>", "(", ")", ";", "// an fmrc is a collection of fmr\r", "// get the inventory, sorted by path\r", "for", "(", "MFile", "f", ":", "manager", ".", "getFilesSorted", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "filesRunDateMap", "=", "(", "(", "MFileCollectionManager", ")", "manager", ")", ".", "getFilesRunDateMap", "(", ")", ";", "CalendarDate", "runDate", ";", "if", "(", "!", "filesRunDateMap", ".", "isEmpty", "(", ")", ")", "{", "// run time has been defined in NcML FMRC agg by the coord attribute,\r", "// so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r", "// global attribute, otherwise the run time offsets might be incorrectly\r", "// computed if the incorrect run date is found in GridDatasetInv.java (line\r", "// 177 with comment // Look: not really right )\r", "runDate", "=", "CalendarDate", ".", "parseISOformat", "(", "null", ",", "filesRunDateMap", ".", "get", "(", "f", ".", "getPath", "(", ")", ")", ")", ";", "Element", "element", "=", "new", "Element", "(", "\"netcdf\"", ",", "ncNSHttps", ")", ";", "Element", "runDateAttr", "=", "ncmlWriter", ".", "makeAttributeElement", "(", "new", "Attribute", "(", "_Coordinate", ".", "ModelRunDate", ",", "runDate", ".", "toString", "(", ")", ")", ")", ";", "config", ".", "innerNcml", "=", "element", ".", "addContent", "(", "runDateAttr", ")", ";", "}", "GridDatasetInv", "inv", ";", "try", "{", "inv", "=", "GridDatasetInv", ".", "open", "(", "manager", ",", "f", ",", "config", ".", "innerNcml", ")", ";", "// inventory is discovered for each GDS\r", "}", "catch", "(", "IOException", "ioe", ")", "{", "logger", ".", "warn", "(", "\"Error opening \"", "+", "f", ".", "getPath", "(", ")", "+", "\"(skipped)\"", ",", "ioe", ")", ";", "continue", ";", "// skip\r", "}", "runDate", "=", "inv", ".", "getRunDate", "(", ")", ";", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"  opened %s rundate = %s%n\"", ",", "f", ".", "getPath", "(", ")", ",", "inv", ".", "getRunDateString", "(", ")", ")", ";", "// add to fmr for that rundate\r", "FmrInv", "fmr", "=", "fmrMap", ".", "get", "(", "runDate", ")", ";", "if", "(", "fmr", "==", "null", ")", "{", "fmr", "=", "new", "FmrInv", "(", "runDate", ")", ";", "fmrMap", ".", "put", "(", "runDate", ",", "fmr", ")", ";", "fmrList", ".", "add", "(", "fmr", ")", ";", "}", "fmr", ".", "addDataset", "(", "inv", ",", "debug", ")", ";", "}", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"%n\"", ")", ";", "// finish the FmrInv\r", "Collections", ".", "sort", "(", "fmrList", ")", ";", "for", "(", "FmrInv", "fmr", ":", "fmrList", ")", "{", "fmr", ".", "finish", "(", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"Fmrc:\"", "+", "config", ".", "name", "+", "\": made fmr with rundate=\"", "+", "fmr", ".", "getRunDate", "(", ")", "+", "\" nfiles= \"", "+", "fmr", ".", "getFiles", "(", ")", ".", "size", "(", ")", ")", ";", "}", "return", "new", "FmrcInv", "(", "\"fmrc:\"", "+", "manager", ".", "getCollectionName", "(", ")", ",", "fmrList", ",", "config", ".", "fmrcConfig", ".", "regularize", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "logger", ".", "error", "(", "\"makeFmrcInv\"", ",", "t", ")", ";", "throw", "new", "RuntimeException", "(", "t", ")", ";", "}", "}"], "docstring": "scan has been done, create FmrcInv", "docstring_tokens": ["scan", "has", "been", "done", "create", "FmrcInv"]}
{"code": "List<FmrInv> fmrList = new ArrayList<>();", "comments": "an fmrc is a collection of fmr", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/Fmrc.java", "func_name": "Fmrc.makeFmrcInv", "original_string": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "language": "java", "Allcodes": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "code_tokens": ["private", "FmrcInv", "makeFmrcInv", "(", "Formatter", "debug", ")", "throws", "IOException", "{", "try", "{", "Map", "<", "CalendarDate", ",", "FmrInv", ">", "fmrMap", "=", "new", "HashMap", "<>", "(", ")", ";", "// all files are grouped by run date in an FmrInv\r", "List", "<", "FmrInv", ">", "fmrList", "=", "new", "ArrayList", "<>", "(", ")", ";", "// an fmrc is a collection of fmr\r", "// get the inventory, sorted by path\r", "for", "(", "MFile", "f", ":", "manager", ".", "getFilesSorted", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "filesRunDateMap", "=", "(", "(", "MFileCollectionManager", ")", "manager", ")", ".", "getFilesRunDateMap", "(", ")", ";", "CalendarDate", "runDate", ";", "if", "(", "!", "filesRunDateMap", ".", "isEmpty", "(", ")", ")", "{", "// run time has been defined in NcML FMRC agg by the coord attribute,\r", "// so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r", "// global attribute, otherwise the run time offsets might be incorrectly\r", "// computed if the incorrect run date is found in GridDatasetInv.java (line\r", "// 177 with comment // Look: not really right )\r", "runDate", "=", "CalendarDate", ".", "parseISOformat", "(", "null", ",", "filesRunDateMap", ".", "get", "(", "f", ".", "getPath", "(", ")", ")", ")", ";", "Element", "element", "=", "new", "Element", "(", "\"netcdf\"", ",", "ncNSHttps", ")", ";", "Element", "runDateAttr", "=", "ncmlWriter", ".", "makeAttributeElement", "(", "new", "Attribute", "(", "_Coordinate", ".", "ModelRunDate", ",", "runDate", ".", "toString", "(", ")", ")", ")", ";", "config", ".", "innerNcml", "=", "element", ".", "addContent", "(", "runDateAttr", ")", ";", "}", "GridDatasetInv", "inv", ";", "try", "{", "inv", "=", "GridDatasetInv", ".", "open", "(", "manager", ",", "f", ",", "config", ".", "innerNcml", ")", ";", "// inventory is discovered for each GDS\r", "}", "catch", "(", "IOException", "ioe", ")", "{", "logger", ".", "warn", "(", "\"Error opening \"", "+", "f", ".", "getPath", "(", ")", "+", "\"(skipped)\"", ",", "ioe", ")", ";", "continue", ";", "// skip\r", "}", "runDate", "=", "inv", ".", "getRunDate", "(", ")", ";", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"  opened %s rundate = %s%n\"", ",", "f", ".", "getPath", "(", ")", ",", "inv", ".", "getRunDateString", "(", ")", ")", ";", "// add to fmr for that rundate\r", "FmrInv", "fmr", "=", "fmrMap", ".", "get", "(", "runDate", ")", ";", "if", "(", "fmr", "==", "null", ")", "{", "fmr", "=", "new", "FmrInv", "(", "runDate", ")", ";", "fmrMap", ".", "put", "(", "runDate", ",", "fmr", ")", ";", "fmrList", ".", "add", "(", "fmr", ")", ";", "}", "fmr", ".", "addDataset", "(", "inv", ",", "debug", ")", ";", "}", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"%n\"", ")", ";", "// finish the FmrInv\r", "Collections", ".", "sort", "(", "fmrList", ")", ";", "for", "(", "FmrInv", "fmr", ":", "fmrList", ")", "{", "fmr", ".", "finish", "(", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"Fmrc:\"", "+", "config", ".", "name", "+", "\": made fmr with rundate=\"", "+", "fmr", ".", "getRunDate", "(", ")", "+", "\" nfiles= \"", "+", "fmr", ".", "getFiles", "(", ")", ".", "size", "(", ")", ")", ";", "}", "return", "new", "FmrcInv", "(", "\"fmrc:\"", "+", "manager", ".", "getCollectionName", "(", ")", ",", "fmrList", ",", "config", ".", "fmrcConfig", ".", "regularize", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "logger", ".", "error", "(", "\"makeFmrcInv\"", ",", "t", ")", ";", "throw", "new", "RuntimeException", "(", "t", ")", ";", "}", "}"], "docstring": "scan has been done, create FmrcInv", "docstring_tokens": ["scan", "has", "been", "done", "create", "FmrcInv"]}
{"code": "inv = GridDatasetInv.open(manager, f, config.innerNcml);", "comments": "inventory is discovered for each GDS", "lines": 25, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/Fmrc.java", "func_name": "Fmrc.makeFmrcInv", "original_string": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "language": "java", "Allcodes": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "code_tokens": ["private", "FmrcInv", "makeFmrcInv", "(", "Formatter", "debug", ")", "throws", "IOException", "{", "try", "{", "Map", "<", "CalendarDate", ",", "FmrInv", ">", "fmrMap", "=", "new", "HashMap", "<>", "(", ")", ";", "// all files are grouped by run date in an FmrInv\r", "List", "<", "FmrInv", ">", "fmrList", "=", "new", "ArrayList", "<>", "(", ")", ";", "// an fmrc is a collection of fmr\r", "// get the inventory, sorted by path\r", "for", "(", "MFile", "f", ":", "manager", ".", "getFilesSorted", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "filesRunDateMap", "=", "(", "(", "MFileCollectionManager", ")", "manager", ")", ".", "getFilesRunDateMap", "(", ")", ";", "CalendarDate", "runDate", ";", "if", "(", "!", "filesRunDateMap", ".", "isEmpty", "(", ")", ")", "{", "// run time has been defined in NcML FMRC agg by the coord attribute,\r", "// so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r", "// global attribute, otherwise the run time offsets might be incorrectly\r", "// computed if the incorrect run date is found in GridDatasetInv.java (line\r", "// 177 with comment // Look: not really right )\r", "runDate", "=", "CalendarDate", ".", "parseISOformat", "(", "null", ",", "filesRunDateMap", ".", "get", "(", "f", ".", "getPath", "(", ")", ")", ")", ";", "Element", "element", "=", "new", "Element", "(", "\"netcdf\"", ",", "ncNSHttps", ")", ";", "Element", "runDateAttr", "=", "ncmlWriter", ".", "makeAttributeElement", "(", "new", "Attribute", "(", "_Coordinate", ".", "ModelRunDate", ",", "runDate", ".", "toString", "(", ")", ")", ")", ";", "config", ".", "innerNcml", "=", "element", ".", "addContent", "(", "runDateAttr", ")", ";", "}", "GridDatasetInv", "inv", ";", "try", "{", "inv", "=", "GridDatasetInv", ".", "open", "(", "manager", ",", "f", ",", "config", ".", "innerNcml", ")", ";", "// inventory is discovered for each GDS\r", "}", "catch", "(", "IOException", "ioe", ")", "{", "logger", ".", "warn", "(", "\"Error opening \"", "+", "f", ".", "getPath", "(", ")", "+", "\"(skipped)\"", ",", "ioe", ")", ";", "continue", ";", "// skip\r", "}", "runDate", "=", "inv", ".", "getRunDate", "(", ")", ";", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"  opened %s rundate = %s%n\"", ",", "f", ".", "getPath", "(", ")", ",", "inv", ".", "getRunDateString", "(", ")", ")", ";", "// add to fmr for that rundate\r", "FmrInv", "fmr", "=", "fmrMap", ".", "get", "(", "runDate", ")", ";", "if", "(", "fmr", "==", "null", ")", "{", "fmr", "=", "new", "FmrInv", "(", "runDate", ")", ";", "fmrMap", ".", "put", "(", "runDate", ",", "fmr", ")", ";", "fmrList", ".", "add", "(", "fmr", ")", ";", "}", "fmr", ".", "addDataset", "(", "inv", ",", "debug", ")", ";", "}", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"%n\"", ")", ";", "// finish the FmrInv\r", "Collections", ".", "sort", "(", "fmrList", ")", ";", "for", "(", "FmrInv", "fmr", ":", "fmrList", ")", "{", "fmr", ".", "finish", "(", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"Fmrc:\"", "+", "config", ".", "name", "+", "\": made fmr with rundate=\"", "+", "fmr", ".", "getRunDate", "(", ")", "+", "\" nfiles= \"", "+", "fmr", ".", "getFiles", "(", ")", ".", "size", "(", ")", ")", ";", "}", "return", "new", "FmrcInv", "(", "\"fmrc:\"", "+", "manager", ".", "getCollectionName", "(", ")", ",", "fmrList", ",", "config", ".", "fmrcConfig", ".", "regularize", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "logger", ".", "error", "(", "\"makeFmrcInv\"", ",", "t", ")", ";", "throw", "new", "RuntimeException", "(", "t", ")", ";", "}", "}"], "docstring": "scan has been done, create FmrcInv", "docstring_tokens": ["scan", "has", "been", "done", "create", "FmrcInv"]}
{"code": "continue;", "comments": "skip", "lines": 28, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/fmrc/Fmrc.java", "func_name": "Fmrc.makeFmrcInv", "original_string": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "language": "java", "Allcodes": "private FmrcInv makeFmrcInv(Formatter debug) throws IOException {\r\n    try {\r\n      Map<CalendarDate, FmrInv> fmrMap = new HashMap<>(); // all files are grouped by run date in an FmrInv\r\n      List<FmrInv> fmrList = new ArrayList<>(); // an fmrc is a collection of fmr\r\n\r\n      // get the inventory, sorted by path\r\n      for (MFile f : manager.getFilesSorted()) {\r\n        Map<String, String> filesRunDateMap = ((MFileCollectionManager) manager).getFilesRunDateMap();\r\n        CalendarDate runDate;\r\n\r\n        if (!filesRunDateMap.isEmpty()) {\r\n          // run time has been defined in NcML FMRC agg by the coord attribute,\r\n          // so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r\n          // global attribute, otherwise the run time offsets might be incorrectly\r\n          // computed if the incorrect run date is found in GridDatasetInv.java (line\r\n          // 177 with comment // Look: not really right )\r\n          runDate = CalendarDate.parseISOformat(null, filesRunDateMap.get(f.getPath()));\r\n          Element element = new Element(\"netcdf\", ncNSHttps);\r\n          Element runDateAttr = ncmlWriter.makeAttributeElement(new Attribute(_Coordinate.ModelRunDate, runDate.toString()));\r\n          config.innerNcml = element.addContent(runDateAttr);\r\n        }\r\n\r\n        GridDatasetInv inv;\r\n        try {\r\n          inv = GridDatasetInv.open(manager, f, config.innerNcml); // inventory is discovered for each GDS\r\n        } catch (IOException ioe) {\r\n          logger.warn(\"Error opening \" + f.getPath() + \"(skipped)\", ioe);\r\n          continue; // skip\r\n        }\r\n\r\n        runDate = inv.getRunDate();\r\n        if (debug != null) debug.format(\"  opened %s rundate = %s%n\", f.getPath(), inv.getRunDateString());\r\n\r\n        // add to fmr for that rundate\r\n        FmrInv fmr = fmrMap.get(runDate);\r\n        if (fmr == null) {\r\n          fmr = new FmrInv(runDate);\r\n          fmrMap.put(runDate, fmr);\r\n          fmrList.add(fmr);\r\n        }\r\n        fmr.addDataset(inv, debug);\r\n      }\r\n      if (debug != null) debug.format(\"%n\");\r\n\r\n      // finish the FmrInv\r\n      Collections.sort(fmrList);\r\n      for (FmrInv fmr : fmrList) {\r\n        fmr.finish();\r\n        if (logger.isDebugEnabled())\r\n          logger.debug(\"Fmrc:\"+config.name+\": made fmr with rundate=\"+fmr.getRunDate()+\" nfiles= \"+fmr.getFiles().size());\r\n      }\r\n\r\n      return new FmrcInv(\"fmrc:\"+manager.getCollectionName(), fmrList, config.fmrcConfig.regularize);\r\n\r\n    } catch (Throwable t) {\r\n      logger.error(\"makeFmrcInv\", t);\r\n      throw new RuntimeException(t);\r\n    }\r\n  }", "code_tokens": ["private", "FmrcInv", "makeFmrcInv", "(", "Formatter", "debug", ")", "throws", "IOException", "{", "try", "{", "Map", "<", "CalendarDate", ",", "FmrInv", ">", "fmrMap", "=", "new", "HashMap", "<>", "(", ")", ";", "// all files are grouped by run date in an FmrInv\r", "List", "<", "FmrInv", ">", "fmrList", "=", "new", "ArrayList", "<>", "(", ")", ";", "// an fmrc is a collection of fmr\r", "// get the inventory, sorted by path\r", "for", "(", "MFile", "f", ":", "manager", ".", "getFilesSorted", "(", ")", ")", "{", "Map", "<", "String", ",", "String", ">", "filesRunDateMap", "=", "(", "(", "MFileCollectionManager", ")", "manager", ")", ".", "getFilesRunDateMap", "(", ")", ";", "CalendarDate", "runDate", ";", "if", "(", "!", "filesRunDateMap", ".", "isEmpty", "(", ")", ")", "{", "// run time has been defined in NcML FMRC agg by the coord attribute,\r", "// so explicitly set it in the dataset using the _Coordinate.ModelBaseDate\r", "// global attribute, otherwise the run time offsets might be incorrectly\r", "// computed if the incorrect run date is found in GridDatasetInv.java (line\r", "// 177 with comment // Look: not really right )\r", "runDate", "=", "CalendarDate", ".", "parseISOformat", "(", "null", ",", "filesRunDateMap", ".", "get", "(", "f", ".", "getPath", "(", ")", ")", ")", ";", "Element", "element", "=", "new", "Element", "(", "\"netcdf\"", ",", "ncNSHttps", ")", ";", "Element", "runDateAttr", "=", "ncmlWriter", ".", "makeAttributeElement", "(", "new", "Attribute", "(", "_Coordinate", ".", "ModelRunDate", ",", "runDate", ".", "toString", "(", ")", ")", ")", ";", "config", ".", "innerNcml", "=", "element", ".", "addContent", "(", "runDateAttr", ")", ";", "}", "GridDatasetInv", "inv", ";", "try", "{", "inv", "=", "GridDatasetInv", ".", "open", "(", "manager", ",", "f", ",", "config", ".", "innerNcml", ")", ";", "// inventory is discovered for each GDS\r", "}", "catch", "(", "IOException", "ioe", ")", "{", "logger", ".", "warn", "(", "\"Error opening \"", "+", "f", ".", "getPath", "(", ")", "+", "\"(skipped)\"", ",", "ioe", ")", ";", "continue", ";", "// skip\r", "}", "runDate", "=", "inv", ".", "getRunDate", "(", ")", ";", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"  opened %s rundate = %s%n\"", ",", "f", ".", "getPath", "(", ")", ",", "inv", ".", "getRunDateString", "(", ")", ")", ";", "// add to fmr for that rundate\r", "FmrInv", "fmr", "=", "fmrMap", ".", "get", "(", "runDate", ")", ";", "if", "(", "fmr", "==", "null", ")", "{", "fmr", "=", "new", "FmrInv", "(", "runDate", ")", ";", "fmrMap", ".", "put", "(", "runDate", ",", "fmr", ")", ";", "fmrList", ".", "add", "(", "fmr", ")", ";", "}", "fmr", ".", "addDataset", "(", "inv", ",", "debug", ")", ";", "}", "if", "(", "debug", "!=", "null", ")", "debug", ".", "format", "(", "\"%n\"", ")", ";", "// finish the FmrInv\r", "Collections", ".", "sort", "(", "fmrList", ")", ";", "for", "(", "FmrInv", "fmr", ":", "fmrList", ")", "{", "fmr", ".", "finish", "(", ")", ";", "if", "(", "logger", ".", "isDebugEnabled", "(", ")", ")", "logger", ".", "debug", "(", "\"Fmrc:\"", "+", "config", ".", "name", "+", "\": made fmr with rundate=\"", "+", "fmr", ".", "getRunDate", "(", ")", "+", "\" nfiles= \"", "+", "fmr", ".", "getFiles", "(", ")", ".", "size", "(", ")", ")", ";", "}", "return", "new", "FmrcInv", "(", "\"fmrc:\"", "+", "manager", ".", "getCollectionName", "(", ")", ",", "fmrList", ",", "config", ".", "fmrcConfig", ".", "regularize", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "logger", ".", "error", "(", "\"makeFmrcInv\"", ",", "t", ")", ";", "throw", "new", "RuntimeException", "(", "t", ")", ";", "}", "}"], "docstring": "scan has been done, create FmrcInv", "docstring_tokens": ["scan", "has", "been", "done", "create", "FmrcInv"]}
{"code": "path = href.substring(contextPathPlus.length());", "comments": "absolute starting from content root", "lines": 36, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/ConfigCatalogInitialization.java", "func_name": "ConfigCatalogInitialization.processDatasets", "original_string": "private void processDatasets(long catId, ReadMode readMode, String dirPath, List<Dataset> datasets, Set<String> idMap) throws IOException {\n    if (exceedLimit) return;\n\n    for (Dataset ds : datasets) {\n      if (datasetTracker.trackDataset(catId, ds, callback)) countDatasets++;\n      if (maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess) exceedLimit = true;\n\n      // look for duplicate ids\n      String id = ds.getID();\n      if (id != null) {\n        if (idMap.contains(id)) {\n          logCatalogInit.error(ERROR + \"Duplicate id on  '\" + ds.getName() + \"' id= '\" + id + \"'\");\n        } else {\n          idMap.add(id);\n        }\n      }\n\n      if ((ds instanceof DatasetScan) || (ds instanceof FeatureCollectionRef)) continue;\n      if (ds instanceof CatalogScan) continue;\n\n      if (ds instanceof CatalogRef) { // follow catalog refs\n        CatalogRef catref = (CatalogRef) ds;\n        String href = catref.getXlinkHref();\n        // if (logCatalogInit.isDebugEnabled()) logCatalogInit.debug(\"  catref.getXlinkHref=\" + href);\n\n        // Check that catRef is relative\n        if (!href.startsWith(\"http:\")) {\n          // Clean up relative URLs that start with \"./\"\n          if (href.startsWith(\"./\")) {\n            href = href.substring(2);\n          }\n\n          String path;\n          String contextPathPlus = this.contextPath + \"/\";\n          if (href.startsWith(contextPathPlus)) {\n            path = href.substring(contextPathPlus.length()); // absolute starting from content root\n          } else if (href.startsWith(\"/\")) {\n            // Drop the catRef because it points to a non-TDS served catalog.\n            logCatalogInit.error(ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" +\n                    \"Parent catalog info: Name=\\\"\" + catref.getParentCatalog().getName() + \"\\\"; Base URI=\\\"\" + catref.getParentCatalog().getUriString() + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\");\n            continue;\n          } else {\n            path = dirPath + href;  // reletive starting from current directory\n          }\n\n          CatalogExt ext = catalogTracker.get(path);\n          long lastRead = (ext == null) ? 0 : ext.getLastRead();\n          checkCatalogToRead(readMode, path, false, lastRead);\n        }\n\n      } else {\n        // recurse through nested datasets\n        processDatasets(catId, readMode, dirPath, ds.getDatasetsLocal(), idMap);\n      }\n    }\n  }", "language": "java", "Allcodes": "private void processDatasets(long catId, ReadMode readMode, String dirPath, List<Dataset> datasets, Set<String> idMap) throws IOException {\n    if (exceedLimit) return;\n\n    for (Dataset ds : datasets) {\n      if (datasetTracker.trackDataset(catId, ds, callback)) countDatasets++;\n      if (maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess) exceedLimit = true;\n\n      // look for duplicate ids\n      String id = ds.getID();\n      if (id != null) {\n        if (idMap.contains(id)) {\n          logCatalogInit.error(ERROR + \"Duplicate id on  '\" + ds.getName() + \"' id= '\" + id + \"'\");\n        } else {\n          idMap.add(id);\n        }\n      }\n\n      if ((ds instanceof DatasetScan) || (ds instanceof FeatureCollectionRef)) continue;\n      if (ds instanceof CatalogScan) continue;\n\n      if (ds instanceof CatalogRef) { // follow catalog refs\n        CatalogRef catref = (CatalogRef) ds;\n        String href = catref.getXlinkHref();\n        // if (logCatalogInit.isDebugEnabled()) logCatalogInit.debug(\"  catref.getXlinkHref=\" + href);\n\n        // Check that catRef is relative\n        if (!href.startsWith(\"http:\")) {\n          // Clean up relative URLs that start with \"./\"\n          if (href.startsWith(\"./\")) {\n            href = href.substring(2);\n          }\n\n          String path;\n          String contextPathPlus = this.contextPath + \"/\";\n          if (href.startsWith(contextPathPlus)) {\n            path = href.substring(contextPathPlus.length()); // absolute starting from content root\n          } else if (href.startsWith(\"/\")) {\n            // Drop the catRef because it points to a non-TDS served catalog.\n            logCatalogInit.error(ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" +\n                    \"Parent catalog info: Name=\\\"\" + catref.getParentCatalog().getName() + \"\\\"; Base URI=\\\"\" + catref.getParentCatalog().getUriString() + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\");\n            continue;\n          } else {\n            path = dirPath + href;  // reletive starting from current directory\n          }\n\n          CatalogExt ext = catalogTracker.get(path);\n          long lastRead = (ext == null) ? 0 : ext.getLastRead();\n          checkCatalogToRead(readMode, path, false, lastRead);\n        }\n\n      } else {\n        // recurse through nested datasets\n        processDatasets(catId, readMode, dirPath, ds.getDatasetsLocal(), idMap);\n      }\n    }\n  }", "code_tokens": ["private", "void", "processDatasets", "(", "long", "catId", ",", "ReadMode", "readMode", ",", "String", "dirPath", ",", "List", "<", "Dataset", ">", "datasets", ",", "Set", "<", "String", ">", "idMap", ")", "throws", "IOException", "{", "if", "(", "exceedLimit", ")", "return", ";", "for", "(", "Dataset", "ds", ":", "datasets", ")", "{", "if", "(", "datasetTracker", ".", "trackDataset", "(", "catId", ",", "ds", ",", "callback", ")", ")", "countDatasets", "++", ";", "if", "(", "maxDatasetsProcess", ">", "0", "&&", "countDatasets", ">", "maxDatasetsProcess", ")", "exceedLimit", "=", "true", ";", "// look for duplicate ids", "String", "id", "=", "ds", ".", "getID", "(", ")", ";", "if", "(", "id", "!=", "null", ")", "{", "if", "(", "idMap", ".", "contains", "(", "id", ")", ")", "{", "logCatalogInit", ".", "error", "(", "ERROR", "+", "\"Duplicate id on  '\"", "+", "ds", ".", "getName", "(", ")", "+", "\"' id= '\"", "+", "id", "+", "\"'\"", ")", ";", "}", "else", "{", "idMap", ".", "add", "(", "id", ")", ";", "}", "}", "if", "(", "(", "ds", "instanceof", "DatasetScan", ")", "||", "(", "ds", "instanceof", "FeatureCollectionRef", ")", ")", "continue", ";", "if", "(", "ds", "instanceof", "CatalogScan", ")", "continue", ";", "if", "(", "ds", "instanceof", "CatalogRef", ")", "{", "// follow catalog refs", "CatalogRef", "catref", "=", "(", "CatalogRef", ")", "ds", ";", "String", "href", "=", "catref", ".", "getXlinkHref", "(", ")", ";", "// if (logCatalogInit.isDebugEnabled()) logCatalogInit.debug(\"  catref.getXlinkHref=\" + href);", "// Check that catRef is relative", "if", "(", "!", "href", ".", "startsWith", "(", "\"http:\"", ")", ")", "{", "// Clean up relative URLs that start with \"./\"", "if", "(", "href", ".", "startsWith", "(", "\"./\"", ")", ")", "{", "href", "=", "href", ".", "substring", "(", "2", ")", ";", "}", "String", "path", ";", "String", "contextPathPlus", "=", "this", ".", "contextPath", "+", "\"/\"", ";", "if", "(", "href", ".", "startsWith", "(", "contextPathPlus", ")", ")", "{", "path", "=", "href", ".", "substring", "(", "contextPathPlus", ".", "length", "(", ")", ")", ";", "// absolute starting from content root", "}", "else", "if", "(", "href", ".", "startsWith", "(", "\"/\"", ")", ")", "{", "// Drop the catRef because it points to a non-TDS served catalog.", "logCatalogInit", ".", "error", "(", "ERROR", "+", "\"Skipping catalogRef <xlink:href=\"", "+", "href", "+", "\">. Reference is relative to the server outside the context path [\"", "+", "contextPathPlus", "+", "\"]. \"", "+", "\"Parent catalog info: Name=\\\"\"", "+", "catref", ".", "getParentCatalog", "(", ")", ".", "getName", "(", ")", "+", "\"\\\"; Base URI=\\\"\"", "+", "catref", ".", "getParentCatalog", "(", ")", ".", "getUriString", "(", ")", "+", "\"\\\"; dirPath=\\\"\"", "+", "dirPath", "+", "\"\\\".\"", ")", ";", "continue", ";", "}", "else", "{", "path", "=", "dirPath", "+", "href", ";", "// reletive starting from current directory", "}", "CatalogExt", "ext", "=", "catalogTracker", ".", "get", "(", "path", ")", ";", "long", "lastRead", "=", "(", "ext", "==", "null", ")", "?", "0", ":", "ext", ".", "getLastRead", "(", ")", ";", "checkCatalogToRead", "(", "readMode", ",", "path", ",", "false", ",", "lastRead", ")", ";", "}", "}", "else", "{", "// recurse through nested datasets", "processDatasets", "(", "catId", ",", "readMode", ",", "dirPath", ",", "ds", ".", "getDatasetsLocal", "(", ")", ",", "idMap", ")", ";", "}", "}", "}"], "docstring": "dirPath = the directory path, reletive to the rootDir", "docstring_tokens": ["dirPath", "=", "the", "directory", "path", "reletive", "to", "the", "rootDir"]}
{"code": "path = dirPath + href;", "comments": "reletive starting from current directory", "lines": 43, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/core/ConfigCatalogInitialization.java", "func_name": "ConfigCatalogInitialization.processDatasets", "original_string": "private void processDatasets(long catId, ReadMode readMode, String dirPath, List<Dataset> datasets, Set<String> idMap) throws IOException {\n    if (exceedLimit) return;\n\n    for (Dataset ds : datasets) {\n      if (datasetTracker.trackDataset(catId, ds, callback)) countDatasets++;\n      if (maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess) exceedLimit = true;\n\n      // look for duplicate ids\n      String id = ds.getID();\n      if (id != null) {\n        if (idMap.contains(id)) {\n          logCatalogInit.error(ERROR + \"Duplicate id on  '\" + ds.getName() + \"' id= '\" + id + \"'\");\n        } else {\n          idMap.add(id);\n        }\n      }\n\n      if ((ds instanceof DatasetScan) || (ds instanceof FeatureCollectionRef)) continue;\n      if (ds instanceof CatalogScan) continue;\n\n      if (ds instanceof CatalogRef) { // follow catalog refs\n        CatalogRef catref = (CatalogRef) ds;\n        String href = catref.getXlinkHref();\n        // if (logCatalogInit.isDebugEnabled()) logCatalogInit.debug(\"  catref.getXlinkHref=\" + href);\n\n        // Check that catRef is relative\n        if (!href.startsWith(\"http:\")) {\n          // Clean up relative URLs that start with \"./\"\n          if (href.startsWith(\"./\")) {\n            href = href.substring(2);\n          }\n\n          String path;\n          String contextPathPlus = this.contextPath + \"/\";\n          if (href.startsWith(contextPathPlus)) {\n            path = href.substring(contextPathPlus.length()); // absolute starting from content root\n          } else if (href.startsWith(\"/\")) {\n            // Drop the catRef because it points to a non-TDS served catalog.\n            logCatalogInit.error(ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" +\n                    \"Parent catalog info: Name=\\\"\" + catref.getParentCatalog().getName() + \"\\\"; Base URI=\\\"\" + catref.getParentCatalog().getUriString() + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\");\n            continue;\n          } else {\n            path = dirPath + href;  // reletive starting from current directory\n          }\n\n          CatalogExt ext = catalogTracker.get(path);\n          long lastRead = (ext == null) ? 0 : ext.getLastRead();\n          checkCatalogToRead(readMode, path, false, lastRead);\n        }\n\n      } else {\n        // recurse through nested datasets\n        processDatasets(catId, readMode, dirPath, ds.getDatasetsLocal(), idMap);\n      }\n    }\n  }", "language": "java", "Allcodes": "private void processDatasets(long catId, ReadMode readMode, String dirPath, List<Dataset> datasets, Set<String> idMap) throws IOException {\n    if (exceedLimit) return;\n\n    for (Dataset ds : datasets) {\n      if (datasetTracker.trackDataset(catId, ds, callback)) countDatasets++;\n      if (maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess) exceedLimit = true;\n\n      // look for duplicate ids\n      String id = ds.getID();\n      if (id != null) {\n        if (idMap.contains(id)) {\n          logCatalogInit.error(ERROR + \"Duplicate id on  '\" + ds.getName() + \"' id= '\" + id + \"'\");\n        } else {\n          idMap.add(id);\n        }\n      }\n\n      if ((ds instanceof DatasetScan) || (ds instanceof FeatureCollectionRef)) continue;\n      if (ds instanceof CatalogScan) continue;\n\n      if (ds instanceof CatalogRef) { // follow catalog refs\n        CatalogRef catref = (CatalogRef) ds;\n        String href = catref.getXlinkHref();\n        // if (logCatalogInit.isDebugEnabled()) logCatalogInit.debug(\"  catref.getXlinkHref=\" + href);\n\n        // Check that catRef is relative\n        if (!href.startsWith(\"http:\")) {\n          // Clean up relative URLs that start with \"./\"\n          if (href.startsWith(\"./\")) {\n            href = href.substring(2);\n          }\n\n          String path;\n          String contextPathPlus = this.contextPath + \"/\";\n          if (href.startsWith(contextPathPlus)) {\n            path = href.substring(contextPathPlus.length()); // absolute starting from content root\n          } else if (href.startsWith(\"/\")) {\n            // Drop the catRef because it points to a non-TDS served catalog.\n            logCatalogInit.error(ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" +\n                    \"Parent catalog info: Name=\\\"\" + catref.getParentCatalog().getName() + \"\\\"; Base URI=\\\"\" + catref.getParentCatalog().getUriString() + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\");\n            continue;\n          } else {\n            path = dirPath + href;  // reletive starting from current directory\n          }\n\n          CatalogExt ext = catalogTracker.get(path);\n          long lastRead = (ext == null) ? 0 : ext.getLastRead();\n          checkCatalogToRead(readMode, path, false, lastRead);\n        }\n\n      } else {\n        // recurse through nested datasets\n        processDatasets(catId, readMode, dirPath, ds.getDatasetsLocal(), idMap);\n      }\n    }\n  }", "code_tokens": ["private", "void", "processDatasets", "(", "long", "catId", ",", "ReadMode", "readMode", ",", "String", "dirPath", ",", "List", "<", "Dataset", ">", "datasets", ",", "Set", "<", "String", ">", "idMap", ")", "throws", "IOException", "{", "if", "(", "exceedLimit", ")", "return", ";", "for", "(", "Dataset", "ds", ":", "datasets", ")", "{", "if", "(", "datasetTracker", ".", "trackDataset", "(", "catId", ",", "ds", ",", "callback", ")", ")", "countDatasets", "++", ";", "if", "(", "maxDatasetsProcess", ">", "0", "&&", "countDatasets", ">", "maxDatasetsProcess", ")", "exceedLimit", "=", "true", ";", "// look for duplicate ids", "String", "id", "=", "ds", ".", "getID", "(", ")", ";", "if", "(", "id", "!=", "null", ")", "{", "if", "(", "idMap", ".", "contains", "(", "id", ")", ")", "{", "logCatalogInit", ".", "error", "(", "ERROR", "+", "\"Duplicate id on  '\"", "+", "ds", ".", "getName", "(", ")", "+", "\"' id= '\"", "+", "id", "+", "\"'\"", ")", ";", "}", "else", "{", "idMap", ".", "add", "(", "id", ")", ";", "}", "}", "if", "(", "(", "ds", "instanceof", "DatasetScan", ")", "||", "(", "ds", "instanceof", "FeatureCollectionRef", ")", ")", "continue", ";", "if", "(", "ds", "instanceof", "CatalogScan", ")", "continue", ";", "if", "(", "ds", "instanceof", "CatalogRef", ")", "{", "// follow catalog refs", "CatalogRef", "catref", "=", "(", "CatalogRef", ")", "ds", ";", "String", "href", "=", "catref", ".", "getXlinkHref", "(", ")", ";", "// if (logCatalogInit.isDebugEnabled()) logCatalogInit.debug(\"  catref.getXlinkHref=\" + href);", "// Check that catRef is relative", "if", "(", "!", "href", ".", "startsWith", "(", "\"http:\"", ")", ")", "{", "// Clean up relative URLs that start with \"./\"", "if", "(", "href", ".", "startsWith", "(", "\"./\"", ")", ")", "{", "href", "=", "href", ".", "substring", "(", "2", ")", ";", "}", "String", "path", ";", "String", "contextPathPlus", "=", "this", ".", "contextPath", "+", "\"/\"", ";", "if", "(", "href", ".", "startsWith", "(", "contextPathPlus", ")", ")", "{", "path", "=", "href", ".", "substring", "(", "contextPathPlus", ".", "length", "(", ")", ")", ";", "// absolute starting from content root", "}", "else", "if", "(", "href", ".", "startsWith", "(", "\"/\"", ")", ")", "{", "// Drop the catRef because it points to a non-TDS served catalog.", "logCatalogInit", ".", "error", "(", "ERROR", "+", "\"Skipping catalogRef <xlink:href=\"", "+", "href", "+", "\">. Reference is relative to the server outside the context path [\"", "+", "contextPathPlus", "+", "\"]. \"", "+", "\"Parent catalog info: Name=\\\"\"", "+", "catref", ".", "getParentCatalog", "(", ")", ".", "getName", "(", ")", "+", "\"\\\"; Base URI=\\\"\"", "+", "catref", ".", "getParentCatalog", "(", ")", ".", "getUriString", "(", ")", "+", "\"\\\"; dirPath=\\\"\"", "+", "dirPath", "+", "\"\\\".\"", ")", ";", "continue", ";", "}", "else", "{", "path", "=", "dirPath", "+", "href", ";", "// reletive starting from current directory", "}", "CatalogExt", "ext", "=", "catalogTracker", ".", "get", "(", "path", ")", ";", "long", "lastRead", "=", "(", "ext", "==", "null", ")", "?", "0", ":", "ext", ".", "getLastRead", "(", ")", ";", "checkCatalogToRead", "(", "readMode", ",", "path", ",", "false", ",", "lastRead", ")", ";", "}", "}", "else", "{", "// recurse through nested datasets", "processDatasets", "(", "catId", ",", "readMode", ",", "dirPath", ",", "ds", ".", "getDatasetsLocal", "(", ")", ",", "idMap", ")", ";", "}", "}", "}"], "docstring": "dirPath = the directory path, reletive to the rootDir", "docstring_tokens": ["dirPath", "=", "the", "directory", "path", "reletive", "to", "the", "rootDir"]}
{"code": "raf.read();", "comments": "unused", "lines": 13, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib1/Grib1SectionBitMap.java", "func_name": "Grib1SectionBitMap.getBitmap", "original_string": "@Nullable\r\n  public byte[] getBitmap(RandomAccessFile raf) throws IOException {\r\n    if (startingPosition <= 0) {\r\n      throw new IllegalStateException(\"Grib1 Bit map has bad starting position\");\r\n    }\r\n\r\n    raf.seek(startingPosition);\r\n\r\n    // octet 1-3 (length of section)\r\n    int length = GribNumbers.uint3(raf);\r\n\r\n    // octet 4 unused bits\r\n    raf.read();   // unused\r\n\r\n    // octets 5-6\r\n    int bm = raf.readShort();\r\n    if (bm != 0) {\r\n      logger.warn(\"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\", bm);\r\n      return null;\r\n    }\r\n\r\n    // not sure if length is set correctly when pre-define bitmap is used, so  wait until that to test\r\n    // seeing a -1, bail out\r\n    if (length <= 6 || length > 10e6) {   // look max  ??\r\n      return null;\r\n    }\r\n\r\n    // read the bits as integers\r\n    int n = length - 6;\r\n    byte[] data = new byte[n];\r\n    raf.readFully(data);\r\n    return data;\r\n  }", "language": "java", "Allcodes": "@Nullable\r\n  public byte[] getBitmap(RandomAccessFile raf) throws IOException {\r\n    if (startingPosition <= 0) {\r\n      throw new IllegalStateException(\"Grib1 Bit map has bad starting position\");\r\n    }\r\n\r\n    raf.seek(startingPosition);\r\n\r\n    // octet 1-3 (length of section)\r\n    int length = GribNumbers.uint3(raf);\r\n\r\n    // octet 4 unused bits\r\n    raf.read();   // unused\r\n\r\n    // octets 5-6\r\n    int bm = raf.readShort();\r\n    if (bm != 0) {\r\n      logger.warn(\"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\", bm);\r\n      return null;\r\n    }\r\n\r\n    // not sure if length is set correctly when pre-define bitmap is used, so  wait until that to test\r\n    // seeing a -1, bail out\r\n    if (length <= 6 || length > 10e6) {   // look max  ??\r\n      return null;\r\n    }\r\n\r\n    // read the bits as integers\r\n    int n = length - 6;\r\n    byte[] data = new byte[n];\r\n    raf.readFully(data);\r\n    return data;\r\n  }", "code_tokens": ["@", "Nullable", "public", "byte", "[", "]", "getBitmap", "(", "RandomAccessFile", "raf", ")", "throws", "IOException", "{", "if", "(", "startingPosition", "<=", "0", ")", "{", "throw", "new", "IllegalStateException", "(", "\"Grib1 Bit map has bad starting position\"", ")", ";", "}", "raf", ".", "seek", "(", "startingPosition", ")", ";", "// octet 1-3 (length of section)\r", "int", "length", "=", "GribNumbers", ".", "uint3", "(", "raf", ")", ";", "// octet 4 unused bits\r", "raf", ".", "read", "(", ")", ";", "// unused\r", "// octets 5-6\r", "int", "bm", "=", "raf", ".", "readShort", "(", ")", ";", "if", "(", "bm", "!=", "0", ")", "{", "logger", ".", "warn", "(", "\"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\"", ",", "bm", ")", ";", "return", "null", ";", "}", "// not sure if length is set correctly when pre-define bitmap is used, so  wait until that to test\r", "// seeing a -1, bail out\r", "if", "(", "length", "<=", "6", "||", "length", ">", "10e6", ")", "{", "// look max  ??\r", "return", "null", ";", "}", "// read the bits as integers\r", "int", "n", "=", "length", "-", "6", ";", "byte", "[", "]", "data", "=", "new", "byte", "[", "n", "]", ";", "raf", ".", "readFully", "(", "data", ")", ";", "return", "data", ";", "}"], "docstring": "Read the bitmap array when needed, return null if none.", "docstring_tokens": ["Read", "the", "bitmap", "array", "when", "needed", "return", "null", "if", "none", "."]}
{"code": "ThreddsMetadata inherit = getInheritableMetadata();", "comments": "make sure exists", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/client/catalog/builder/DatasetBuilder.java", "func_name": "DatasetBuilder.transferMetadata", "original_string": "public void transferMetadata( DatasetNode from, boolean parentsAlso) {\n    if (parentsAlso) {\n      ThreddsMetadata inherit = getInheritableMetadata(); // make sure exists\n      inheritMetadata(from, inherit.getFlds());\n    }\n\n    // local metadata\n    for (Map.Entry<String, Object> entry : from.getFldIterator()) {\n      if (parentsAlso && entry.getKey().equals(Dataset.ThreddsMetadataInheritable)) continue; // already did this\n      if (Dataset.listFlds.contains(entry.getKey()))\n        addToNewList(flds, entry.getKey(), entry.getValue());\n      else\n        flds.put(entry.getKey(), entry.getValue());\n    }\n\n    // tmi must be mutable, transfer if not\n    ThreddsMetadata tmiOld = (ThreddsMetadata) get(Dataset.ThreddsMetadataInheritable);\n    if (tmiOld != null && tmiOld.isImmutable()) {\n      ThreddsMetadata tmiNew = new ThreddsMetadata(tmiOld);\n      flds.put(Dataset.ThreddsMetadataInheritable, tmiNew);\n    }\n  }", "language": "java", "Allcodes": "public void transferMetadata( DatasetNode from, boolean parentsAlso) {\n    if (parentsAlso) {\n      ThreddsMetadata inherit = getInheritableMetadata(); // make sure exists\n      inheritMetadata(from, inherit.getFlds());\n    }\n\n    // local metadata\n    for (Map.Entry<String, Object> entry : from.getFldIterator()) {\n      if (parentsAlso && entry.getKey().equals(Dataset.ThreddsMetadataInheritable)) continue; // already did this\n      if (Dataset.listFlds.contains(entry.getKey()))\n        addToNewList(flds, entry.getKey(), entry.getValue());\n      else\n        flds.put(entry.getKey(), entry.getValue());\n    }\n\n    // tmi must be mutable, transfer if not\n    ThreddsMetadata tmiOld = (ThreddsMetadata) get(Dataset.ThreddsMetadataInheritable);\n    if (tmiOld != null && tmiOld.isImmutable()) {\n      ThreddsMetadata tmiNew = new ThreddsMetadata(tmiOld);\n      flds.put(Dataset.ThreddsMetadataInheritable, tmiNew);\n    }\n  }", "code_tokens": ["public", "void", "transferMetadata", "(", "DatasetNode", "from", ",", "boolean", "parentsAlso", ")", "{", "if", "(", "parentsAlso", ")", "{", "ThreddsMetadata", "inherit", "=", "getInheritableMetadata", "(", ")", ";", "// make sure exists", "inheritMetadata", "(", "from", ",", "inherit", ".", "getFlds", "(", ")", ")", ";", "}", "// local metadata", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "from", ".", "getFldIterator", "(", ")", ")", "{", "if", "(", "parentsAlso", "&&", "entry", ".", "getKey", "(", ")", ".", "equals", "(", "Dataset", ".", "ThreddsMetadataInheritable", ")", ")", "continue", ";", "// already did this", "if", "(", "Dataset", ".", "listFlds", ".", "contains", "(", "entry", ".", "getKey", "(", ")", ")", ")", "addToNewList", "(", "flds", ",", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "else", "flds", ".", "put", "(", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "}", "// tmi must be mutable, transfer if not", "ThreddsMetadata", "tmiOld", "=", "(", "ThreddsMetadata", ")", "get", "(", "Dataset", ".", "ThreddsMetadataInheritable", ")", ";", "if", "(", "tmiOld", "!=", "null", "&&", "tmiOld", ".", "isImmutable", "(", ")", ")", "{", "ThreddsMetadata", "tmiNew", "=", "new", "ThreddsMetadata", "(", "tmiOld", ")", ";", "flds", ".", "put", "(", "Dataset", ".", "ThreddsMetadataInheritable", ",", "tmiNew", ")", ";", "}", "}"], "docstring": "transfer all metadata, optionally also inheritable metadata from parents", "docstring_tokens": ["transfer", "all", "metadata", "optionally", "also", "inheritable", "metadata", "from", "parents"]}
{"code": "if (parentsAlso && entry.getKey().equals(Dataset.ThreddsMetadataInheritable)) continue;", "comments": "already did this", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/client/catalog/builder/DatasetBuilder.java", "func_name": "DatasetBuilder.transferMetadata", "original_string": "public void transferMetadata( DatasetNode from, boolean parentsAlso) {\n    if (parentsAlso) {\n      ThreddsMetadata inherit = getInheritableMetadata(); // make sure exists\n      inheritMetadata(from, inherit.getFlds());\n    }\n\n    // local metadata\n    for (Map.Entry<String, Object> entry : from.getFldIterator()) {\n      if (parentsAlso && entry.getKey().equals(Dataset.ThreddsMetadataInheritable)) continue; // already did this\n      if (Dataset.listFlds.contains(entry.getKey()))\n        addToNewList(flds, entry.getKey(), entry.getValue());\n      else\n        flds.put(entry.getKey(), entry.getValue());\n    }\n\n    // tmi must be mutable, transfer if not\n    ThreddsMetadata tmiOld = (ThreddsMetadata) get(Dataset.ThreddsMetadataInheritable);\n    if (tmiOld != null && tmiOld.isImmutable()) {\n      ThreddsMetadata tmiNew = new ThreddsMetadata(tmiOld);\n      flds.put(Dataset.ThreddsMetadataInheritable, tmiNew);\n    }\n  }", "language": "java", "Allcodes": "public void transferMetadata( DatasetNode from, boolean parentsAlso) {\n    if (parentsAlso) {\n      ThreddsMetadata inherit = getInheritableMetadata(); // make sure exists\n      inheritMetadata(from, inherit.getFlds());\n    }\n\n    // local metadata\n    for (Map.Entry<String, Object> entry : from.getFldIterator()) {\n      if (parentsAlso && entry.getKey().equals(Dataset.ThreddsMetadataInheritable)) continue; // already did this\n      if (Dataset.listFlds.contains(entry.getKey()))\n        addToNewList(flds, entry.getKey(), entry.getValue());\n      else\n        flds.put(entry.getKey(), entry.getValue());\n    }\n\n    // tmi must be mutable, transfer if not\n    ThreddsMetadata tmiOld = (ThreddsMetadata) get(Dataset.ThreddsMetadataInheritable);\n    if (tmiOld != null && tmiOld.isImmutable()) {\n      ThreddsMetadata tmiNew = new ThreddsMetadata(tmiOld);\n      flds.put(Dataset.ThreddsMetadataInheritable, tmiNew);\n    }\n  }", "code_tokens": ["public", "void", "transferMetadata", "(", "DatasetNode", "from", ",", "boolean", "parentsAlso", ")", "{", "if", "(", "parentsAlso", ")", "{", "ThreddsMetadata", "inherit", "=", "getInheritableMetadata", "(", ")", ";", "// make sure exists", "inheritMetadata", "(", "from", ",", "inherit", ".", "getFlds", "(", ")", ")", ";", "}", "// local metadata", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "from", ".", "getFldIterator", "(", ")", ")", "{", "if", "(", "parentsAlso", "&&", "entry", ".", "getKey", "(", ")", ".", "equals", "(", "Dataset", ".", "ThreddsMetadataInheritable", ")", ")", "continue", ";", "// already did this", "if", "(", "Dataset", ".", "listFlds", ".", "contains", "(", "entry", ".", "getKey", "(", ")", ")", ")", "addToNewList", "(", "flds", ",", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "else", "flds", ".", "put", "(", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "}", "// tmi must be mutable, transfer if not", "ThreddsMetadata", "tmiOld", "=", "(", "ThreddsMetadata", ")", "get", "(", "Dataset", ".", "ThreddsMetadataInheritable", ")", ";", "if", "(", "tmiOld", "!=", "null", "&&", "tmiOld", ".", "isImmutable", "(", ")", ")", "{", "ThreddsMetadata", "tmiNew", "=", "new", "ThreddsMetadata", "(", "tmiOld", ")", ";", "flds", ".", "put", "(", "Dataset", ".", "ThreddsMetadataInheritable", ",", "tmiNew", ")", ";", "}", "}"], "docstring": "transfer all metadata, optionally also inheritable metadata from parents", "docstring_tokens": ["transfer", "all", "metadata", "optionally", "also", "inheritable", "metadata", "from", "parents"]}
{"code": "CoverageCoordAxisBuilder builder = new CoverageCoordAxisBuilder(this);", "comments": "copy", "lines": 27, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft2/coverage/CoverageCoordAxis1D.java", "func_name": "CoverageCoordAxis1D.subsetByIntervals", "original_string": "public Optional<CoverageCoordAxis> subsetByIntervals(List<MAMath.MinMax> lonIntvs, int stride) {\n    if (axisType != AxisType.Lon)\n      return Optional.empty(\"subsetByIntervals only for longitude\");\n    if (!isRegular())\n      return Optional.empty(\"subsetByIntervals only for regular longitude\");\n\n    CoordAxisHelper helper = new CoordAxisHelper(this);\n\n    double start = Double.NaN;\n    boolean first = true;\n    List<RangeIterator> ranges = new ArrayList<>();\n    for (MAMath.MinMax lonIntv : lonIntvs) {\n      if (first) start = lonIntv.min;\n      first = false;\n\n      Optional<RangeIterator> opt = helper.makeRange(lonIntv.min, lonIntv.max, stride);\n      if (!opt.isPresent())\n        return Optional.empty(opt.getErrorMessage());\n      ranges.add(opt.get());\n    }\n\n    try {\n      RangeComposite compositeRange = new RangeComposite(AxisType.Lon.toString(), ranges);\n      int npts = compositeRange.length();\n      double end = start + npts * resolution;\n\n      CoverageCoordAxisBuilder builder = new CoverageCoordAxisBuilder(this); // copy\n      builder.subset(npts, start, end, resolution, null);\n      builder.setRange(null);\n      builder.setCompositeRange(compositeRange);\n\n      return Optional.of(new CoverageCoordAxis1D(builder));\n    } catch (InvalidRangeException e) {\n      return Optional.empty(e.getMessage());\n    }\n  }", "language": "java", "Allcodes": "public Optional<CoverageCoordAxis> subsetByIntervals(List<MAMath.MinMax> lonIntvs, int stride) {\n    if (axisType != AxisType.Lon)\n      return Optional.empty(\"subsetByIntervals only for longitude\");\n    if (!isRegular())\n      return Optional.empty(\"subsetByIntervals only for regular longitude\");\n\n    CoordAxisHelper helper = new CoordAxisHelper(this);\n\n    double start = Double.NaN;\n    boolean first = true;\n    List<RangeIterator> ranges = new ArrayList<>();\n    for (MAMath.MinMax lonIntv : lonIntvs) {\n      if (first) start = lonIntv.min;\n      first = false;\n\n      Optional<RangeIterator> opt = helper.makeRange(lonIntv.min, lonIntv.max, stride);\n      if (!opt.isPresent())\n        return Optional.empty(opt.getErrorMessage());\n      ranges.add(opt.get());\n    }\n\n    try {\n      RangeComposite compositeRange = new RangeComposite(AxisType.Lon.toString(), ranges);\n      int npts = compositeRange.length();\n      double end = start + npts * resolution;\n\n      CoverageCoordAxisBuilder builder = new CoverageCoordAxisBuilder(this); // copy\n      builder.subset(npts, start, end, resolution, null);\n      builder.setRange(null);\n      builder.setCompositeRange(compositeRange);\n\n      return Optional.of(new CoverageCoordAxis1D(builder));\n    } catch (InvalidRangeException e) {\n      return Optional.empty(e.getMessage());\n    }\n  }", "code_tokens": ["public", "Optional", "<", "CoverageCoordAxis", ">", "subsetByIntervals", "(", "List", "<", "MAMath", ".", "MinMax", ">", "lonIntvs", ",", "int", "stride", ")", "{", "if", "(", "axisType", "!=", "AxisType", ".", "Lon", ")", "return", "Optional", ".", "empty", "(", "\"subsetByIntervals only for longitude\"", ")", ";", "if", "(", "!", "isRegular", "(", ")", ")", "return", "Optional", ".", "empty", "(", "\"subsetByIntervals only for regular longitude\"", ")", ";", "CoordAxisHelper", "helper", "=", "new", "CoordAxisHelper", "(", "this", ")", ";", "double", "start", "=", "Double", ".", "NaN", ";", "boolean", "first", "=", "true", ";", "List", "<", "RangeIterator", ">", "ranges", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "MAMath", ".", "MinMax", "lonIntv", ":", "lonIntvs", ")", "{", "if", "(", "first", ")", "start", "=", "lonIntv", ".", "min", ";", "first", "=", "false", ";", "Optional", "<", "RangeIterator", ">", "opt", "=", "helper", ".", "makeRange", "(", "lonIntv", ".", "min", ",", "lonIntv", ".", "max", ",", "stride", ")", ";", "if", "(", "!", "opt", ".", "isPresent", "(", ")", ")", "return", "Optional", ".", "empty", "(", "opt", ".", "getErrorMessage", "(", ")", ")", ";", "ranges", ".", "add", "(", "opt", ".", "get", "(", ")", ")", ";", "}", "try", "{", "RangeComposite", "compositeRange", "=", "new", "RangeComposite", "(", "AxisType", ".", "Lon", ".", "toString", "(", ")", ",", "ranges", ")", ";", "int", "npts", "=", "compositeRange", ".", "length", "(", ")", ";", "double", "end", "=", "start", "+", "npts", "*", "resolution", ";", "CoverageCoordAxisBuilder", "builder", "=", "new", "CoverageCoordAxisBuilder", "(", "this", ")", ";", "// copy", "builder", ".", "subset", "(", "npts", ",", "start", ",", "end", ",", "resolution", ",", "null", ")", ";", "builder", ".", "setRange", "(", "null", ")", ";", "builder", ".", "setCompositeRange", "(", "compositeRange", ")", ";", "return", "Optional", ".", "of", "(", "new", "CoverageCoordAxis1D", "(", "builder", ")", ")", ";", "}", "catch", "(", "InvalidRangeException", "e", ")", "{", "return", "Optional", ".", "empty", "(", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "docstring": "only for longitude, only for regular (do we need a subclass for longitude 1D coords ??", "docstring_tokens": ["only", "for", "longitude", "only", "for", "regular", "(", "do", "we", "need", "a", "subclass", "for", "longitude", "1D", "coords", "??"]}
{"code": "log.warn(\"GRIB gaussian lats: NP != NY, use NY\");", "comments": "see email from Toussaint@dkrz.de datafil:", "lines": 27, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/GdsHorizCoordSys.java", "func_name": "GdsHorizCoordSys.setGaussianLats", "original_string": "public void setGaussianLats(int nparallels, float la1, float la2) {\r\n    log.debug (\"la1 {}, la2 {}\", la1, la2);\r\n    if (this.gaussLats != null) throw new RuntimeException(\"Cant modify GdsHorizCoordSys\");\r\n\r\n    int nlats = (2 * nparallels);\r\n    GaussianLatitudes gaussLats = GaussianLatitudes.factory(nlats);\r\n\r\n    int bestStartIndex = 0, bestEndIndex = 0;\r\n    double bestStartDiff = Double.MAX_VALUE;\r\n    double bestEndDiff   = Double.MAX_VALUE;\r\n    for (int i = 0; i < nlats; i++) {\r\n      double diff = Math.abs(gaussLats.latd[i] - la1);\r\n      if (diff < bestStartDiff) {\r\n        bestStartDiff = diff;\r\n        bestStartIndex = i;\r\n      }\r\n      diff = Math.abs(gaussLats.latd[i] - la2);\r\n      if (diff < bestEndDiff) {\r\n        bestEndDiff = diff;\r\n        bestEndIndex = i;\r\n      }\r\n    }\r\n\r\n    log.debug (\"first pass: bestStartIndex {}, bestEndIndex {}\", bestStartIndex, bestEndIndex);\r\n\r\n    if (Math.abs(bestEndIndex - bestStartIndex) + 1 != nyRaw) {\r\n      log.warn(\"GRIB gaussian lats: NP != NY, use NY\");  // see email from Toussaint@dkrz.de datafil:\r\n      nlats = nyRaw;\r\n      gaussLats = GaussianLatitudes.factory(nlats);\r\n      bestStartIndex = 0;\r\n      bestEndIndex = nyRaw - 1;\r\n    }\r\n    boolean goesUp = bestEndIndex > bestStartIndex;\r\n\r\n    log.debug (\"bestStartIndex {}, bestEndIndex {}, goesUp {}\", bestStartIndex, bestEndIndex, goesUp);\r\n\r\n    // create the data\r\n    int useIndex = bestStartIndex;\r\n    float[] data = new float[nyRaw];\r\n    float[] gaussw = new float[nyRaw];\r\n    for (int i = 0; i < nyRaw; i++) {\r\n      data[i] = (float) gaussLats.latd[useIndex];\r\n      gaussw[i] = (float) gaussLats.gaussw[useIndex];\r\n\r\n        log.trace (\"i {}, useIndex {}, data {}, gaussw {}\", i, useIndex, data[i], gaussw[i]);\r\n      if (goesUp) {\r\n        useIndex++;\r\n      } else {\r\n        useIndex--;\r\n      }\r\n    }\r\n\r\n    this.gaussLats = Array.factory(DataType.FLOAT, new int[]{nyRaw}, data);\r\n    this.gaussw    = Array.factory(DataType.FLOAT, new int[]{nyRaw}, gaussw);\r\n  }", "language": "java", "Allcodes": "public void setGaussianLats(int nparallels, float la1, float la2) {\r\n    log.debug (\"la1 {}, la2 {}\", la1, la2);\r\n    if (this.gaussLats != null) throw new RuntimeException(\"Cant modify GdsHorizCoordSys\");\r\n\r\n    int nlats = (2 * nparallels);\r\n    GaussianLatitudes gaussLats = GaussianLatitudes.factory(nlats);\r\n\r\n    int bestStartIndex = 0, bestEndIndex = 0;\r\n    double bestStartDiff = Double.MAX_VALUE;\r\n    double bestEndDiff   = Double.MAX_VALUE;\r\n    for (int i = 0; i < nlats; i++) {\r\n      double diff = Math.abs(gaussLats.latd[i] - la1);\r\n      if (diff < bestStartDiff) {\r\n        bestStartDiff = diff;\r\n        bestStartIndex = i;\r\n      }\r\n      diff = Math.abs(gaussLats.latd[i] - la2);\r\n      if (diff < bestEndDiff) {\r\n        bestEndDiff = diff;\r\n        bestEndIndex = i;\r\n      }\r\n    }\r\n\r\n    log.debug (\"first pass: bestStartIndex {}, bestEndIndex {}\", bestStartIndex, bestEndIndex);\r\n\r\n    if (Math.abs(bestEndIndex - bestStartIndex) + 1 != nyRaw) {\r\n      log.warn(\"GRIB gaussian lats: NP != NY, use NY\");  // see email from Toussaint@dkrz.de datafil:\r\n      nlats = nyRaw;\r\n      gaussLats = GaussianLatitudes.factory(nlats);\r\n      bestStartIndex = 0;\r\n      bestEndIndex = nyRaw - 1;\r\n    }\r\n    boolean goesUp = bestEndIndex > bestStartIndex;\r\n\r\n    log.debug (\"bestStartIndex {}, bestEndIndex {}, goesUp {}\", bestStartIndex, bestEndIndex, goesUp);\r\n\r\n    // create the data\r\n    int useIndex = bestStartIndex;\r\n    float[] data = new float[nyRaw];\r\n    float[] gaussw = new float[nyRaw];\r\n    for (int i = 0; i < nyRaw; i++) {\r\n      data[i] = (float) gaussLats.latd[useIndex];\r\n      gaussw[i] = (float) gaussLats.gaussw[useIndex];\r\n\r\n        log.trace (\"i {}, useIndex {}, data {}, gaussw {}\", i, useIndex, data[i], gaussw[i]);\r\n      if (goesUp) {\r\n        useIndex++;\r\n      } else {\r\n        useIndex--;\r\n      }\r\n    }\r\n\r\n    this.gaussLats = Array.factory(DataType.FLOAT, new int[]{nyRaw}, data);\r\n    this.gaussw    = Array.factory(DataType.FLOAT, new int[]{nyRaw}, gaussw);\r\n  }", "code_tokens": ["public", "void", "setGaussianLats", "(", "int", "nparallels", ",", "float", "la1", ",", "float", "la2", ")", "{", "log", ".", "debug", "(", "\"la1 {}, la2 {}\"", ",", "la1", ",", "la2", ")", ";", "if", "(", "this", ".", "gaussLats", "!=", "null", ")", "throw", "new", "RuntimeException", "(", "\"Cant modify GdsHorizCoordSys\"", ")", ";", "int", "nlats", "=", "(", "2", "*", "nparallels", ")", ";", "GaussianLatitudes", "gaussLats", "=", "GaussianLatitudes", ".", "factory", "(", "nlats", ")", ";", "int", "bestStartIndex", "=", "0", ",", "bestEndIndex", "=", "0", ";", "double", "bestStartDiff", "=", "Double", ".", "MAX_VALUE", ";", "double", "bestEndDiff", "=", "Double", ".", "MAX_VALUE", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nlats", ";", "i", "++", ")", "{", "double", "diff", "=", "Math", ".", "abs", "(", "gaussLats", ".", "latd", "[", "i", "]", "-", "la1", ")", ";", "if", "(", "diff", "<", "bestStartDiff", ")", "{", "bestStartDiff", "=", "diff", ";", "bestStartIndex", "=", "i", ";", "}", "diff", "=", "Math", ".", "abs", "(", "gaussLats", ".", "latd", "[", "i", "]", "-", "la2", ")", ";", "if", "(", "diff", "<", "bestEndDiff", ")", "{", "bestEndDiff", "=", "diff", ";", "bestEndIndex", "=", "i", ";", "}", "}", "log", ".", "debug", "(", "\"first pass: bestStartIndex {}, bestEndIndex {}\"", ",", "bestStartIndex", ",", "bestEndIndex", ")", ";", "if", "(", "Math", ".", "abs", "(", "bestEndIndex", "-", "bestStartIndex", ")", "+", "1", "!=", "nyRaw", ")", "{", "log", ".", "warn", "(", "\"GRIB gaussian lats: NP != NY, use NY\"", ")", ";", "// see email from Toussaint@dkrz.de datafil:\r", "nlats", "=", "nyRaw", ";", "gaussLats", "=", "GaussianLatitudes", ".", "factory", "(", "nlats", ")", ";", "bestStartIndex", "=", "0", ";", "bestEndIndex", "=", "nyRaw", "-", "1", ";", "}", "boolean", "goesUp", "=", "bestEndIndex", ">", "bestStartIndex", ";", "log", ".", "debug", "(", "\"bestStartIndex {}, bestEndIndex {}, goesUp {}\"", ",", "bestStartIndex", ",", "bestEndIndex", ",", "goesUp", ")", ";", "// create the data\r", "int", "useIndex", "=", "bestStartIndex", ";", "float", "[", "]", "data", "=", "new", "float", "[", "nyRaw", "]", ";", "float", "[", "]", "gaussw", "=", "new", "float", "[", "nyRaw", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nyRaw", ";", "i", "++", ")", "{", "data", "[", "i", "]", "=", "(", "float", ")", "gaussLats", ".", "latd", "[", "useIndex", "]", ";", "gaussw", "[", "i", "]", "=", "(", "float", ")", "gaussLats", ".", "gaussw", "[", "useIndex", "]", ";", "log", ".", "trace", "(", "\"i {}, useIndex {}, data {}, gaussw {}\"", ",", "i", ",", "useIndex", ",", "data", "[", "i", "]", ",", "gaussw", "[", "i", "]", ")", ";", "if", "(", "goesUp", ")", "{", "useIndex", "++", ";", "}", "else", "{", "useIndex", "--", ";", "}", "}", "this", ".", "gaussLats", "=", "Array", ".", "factory", "(", "DataType", ".", "FLOAT", ",", "new", "int", "[", "]", "{", "nyRaw", "}", ",", "data", ")", ";", "this", ".", "gaussw", "=", "Array", ".", "factory", "(", "DataType", ".", "FLOAT", ",", "new", "int", "[", "]", "{", "nyRaw", "}", ",", "gaussw", ")", ";", "}"], "docstring": "some weird adjustment for la1 and la2.", "docstring_tokens": ["some", "weird", "adjustment", "for", "la1", "and", "la2", "."]}
{"code": "v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) );", "comments": "s.findVariable wants unescaped version", "lines": 22, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ParsedSectionSpec.java", "func_name": "ParsedSectionSpec.parseVariableSelector", "original_string": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "language": "java", "Allcodes": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "code_tokens": ["private", "static", "ParsedSectionSpec", "parseVariableSelector", "(", "Object", "parent", ",", "String", "selector", ")", "throws", "InvalidRangeException", "{", "String", "varNameEsc", ",", "indexSelect", "=", "null", ";", "int", "pos1", "=", "EscapeStrings", ".", "indexOf", "(", "selector", ",", "'", "'", ")", ";", "if", "(", "pos1", "<", "0", ")", "{", "// no index", "varNameEsc", "=", "selector", ";", "}", "else", "{", "varNameEsc", "=", "selector", ".", "substring", "(", "0", ",", "pos1", ")", ";", "int", "pos2", "=", "selector", ".", "indexOf", "(", "'", "'", ",", "pos1", "+", "1", ")", ";", "indexSelect", "=", "selector", ".", "substring", "(", "pos1", ",", "pos2", ")", ";", "}", "if", "(", "debugSelector", ")", "System", ".", "out", ".", "println", "(", "\" parseVariableSection <\"", "+", "selector", "+", "\"> = <\"", "+", "varNameEsc", "+", "\">, <\"", "+", "indexSelect", "+", "\">\"", ")", ";", "Variable", "v", "=", "null", ";", "if", "(", "parent", "instanceof", "NetcdfFile", ")", "{", "// then varNameEsc = varFullNameEsc (i.e. includes groups)", "NetcdfFile", "ncfile", "=", "(", "NetcdfFile", ")", "parent", ";", "v", "=", "ncfile", ".", "findVariable", "(", "varNameEsc", ")", ";", "}", "else", "if", "(", "parent", "instanceof", "Structure", ")", "{", "// then varNameEsc = memberNameEsc (i.e. includes groups)", "Structure", "s", "=", "(", "Structure", ")", "parent", ";", "v", "=", "s", ".", "findVariable", "(", "NetcdfFile", ".", "makeNameUnescaped", "(", "varNameEsc", ")", ")", ";", "// s.findVariable wants unescaped version", "}", "if", "(", "v", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\" cant find variable: \"", "+", "varNameEsc", "+", "\" in selector=\"", "+", "selector", ")", ";", "if", "(", "v", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "indexSelect", "=", "null", ";", "// ignore whatever was sent", "// get the selected Ranges, or all, and add to the list", "Section", "section", ";", "if", "(", "indexSelect", "!=", "null", ")", "{", "section", "=", "new", "Section", "(", "indexSelect", ")", ";", "section", "=", "Section", ".", "fill", "(", "section", ",", "v", ".", "getShape", "(", ")", ")", ";", "// Check section has no nulls, set from shape array.", "}", "else", "{", "section", "=", "v", ".", "getShapeAsSection", "(", ")", ";", "// all", "}", "return", "new", "ParsedSectionSpec", "(", "v", ",", "section", ")", ";", "}"], "docstring": "parse variable name and index selector out of the selector String. variable name must be escaped", "docstring_tokens": ["parse", "variable", "name", "and", "index", "selector", "out", "of", "the", "selector", "String", ".", "variable", "name", "must", "be", "escaped"]}
{"code": "indexSelect = null;", "comments": "ignore whatever was sent", "lines": 28, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ParsedSectionSpec.java", "func_name": "ParsedSectionSpec.parseVariableSelector", "original_string": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "language": "java", "Allcodes": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "code_tokens": ["private", "static", "ParsedSectionSpec", "parseVariableSelector", "(", "Object", "parent", ",", "String", "selector", ")", "throws", "InvalidRangeException", "{", "String", "varNameEsc", ",", "indexSelect", "=", "null", ";", "int", "pos1", "=", "EscapeStrings", ".", "indexOf", "(", "selector", ",", "'", "'", ")", ";", "if", "(", "pos1", "<", "0", ")", "{", "// no index", "varNameEsc", "=", "selector", ";", "}", "else", "{", "varNameEsc", "=", "selector", ".", "substring", "(", "0", ",", "pos1", ")", ";", "int", "pos2", "=", "selector", ".", "indexOf", "(", "'", "'", ",", "pos1", "+", "1", ")", ";", "indexSelect", "=", "selector", ".", "substring", "(", "pos1", ",", "pos2", ")", ";", "}", "if", "(", "debugSelector", ")", "System", ".", "out", ".", "println", "(", "\" parseVariableSection <\"", "+", "selector", "+", "\"> = <\"", "+", "varNameEsc", "+", "\">, <\"", "+", "indexSelect", "+", "\">\"", ")", ";", "Variable", "v", "=", "null", ";", "if", "(", "parent", "instanceof", "NetcdfFile", ")", "{", "// then varNameEsc = varFullNameEsc (i.e. includes groups)", "NetcdfFile", "ncfile", "=", "(", "NetcdfFile", ")", "parent", ";", "v", "=", "ncfile", ".", "findVariable", "(", "varNameEsc", ")", ";", "}", "else", "if", "(", "parent", "instanceof", "Structure", ")", "{", "// then varNameEsc = memberNameEsc (i.e. includes groups)", "Structure", "s", "=", "(", "Structure", ")", "parent", ";", "v", "=", "s", ".", "findVariable", "(", "NetcdfFile", ".", "makeNameUnescaped", "(", "varNameEsc", ")", ")", ";", "// s.findVariable wants unescaped version", "}", "if", "(", "v", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\" cant find variable: \"", "+", "varNameEsc", "+", "\" in selector=\"", "+", "selector", ")", ";", "if", "(", "v", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "indexSelect", "=", "null", ";", "// ignore whatever was sent", "// get the selected Ranges, or all, and add to the list", "Section", "section", ";", "if", "(", "indexSelect", "!=", "null", ")", "{", "section", "=", "new", "Section", "(", "indexSelect", ")", ";", "section", "=", "Section", ".", "fill", "(", "section", ",", "v", ".", "getShape", "(", ")", ")", ";", "// Check section has no nulls, set from shape array.", "}", "else", "{", "section", "=", "v", ".", "getShapeAsSection", "(", ")", ";", "// all", "}", "return", "new", "ParsedSectionSpec", "(", "v", ",", "section", ")", ";", "}"], "docstring": "parse variable name and index selector out of the selector String. variable name must be escaped", "docstring_tokens": ["parse", "variable", "name", "and", "index", "selector", "out", "of", "the", "selector", "String", ".", "variable", "name", "must", "be", "escaped"]}
{"code": "section = Section.fill(section, v.getShape());", "comments": "Check section has no nulls, set from shape array.", "lines": 34, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ParsedSectionSpec.java", "func_name": "ParsedSectionSpec.parseVariableSelector", "original_string": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "language": "java", "Allcodes": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "code_tokens": ["private", "static", "ParsedSectionSpec", "parseVariableSelector", "(", "Object", "parent", ",", "String", "selector", ")", "throws", "InvalidRangeException", "{", "String", "varNameEsc", ",", "indexSelect", "=", "null", ";", "int", "pos1", "=", "EscapeStrings", ".", "indexOf", "(", "selector", ",", "'", "'", ")", ";", "if", "(", "pos1", "<", "0", ")", "{", "// no index", "varNameEsc", "=", "selector", ";", "}", "else", "{", "varNameEsc", "=", "selector", ".", "substring", "(", "0", ",", "pos1", ")", ";", "int", "pos2", "=", "selector", ".", "indexOf", "(", "'", "'", ",", "pos1", "+", "1", ")", ";", "indexSelect", "=", "selector", ".", "substring", "(", "pos1", ",", "pos2", ")", ";", "}", "if", "(", "debugSelector", ")", "System", ".", "out", ".", "println", "(", "\" parseVariableSection <\"", "+", "selector", "+", "\"> = <\"", "+", "varNameEsc", "+", "\">, <\"", "+", "indexSelect", "+", "\">\"", ")", ";", "Variable", "v", "=", "null", ";", "if", "(", "parent", "instanceof", "NetcdfFile", ")", "{", "// then varNameEsc = varFullNameEsc (i.e. includes groups)", "NetcdfFile", "ncfile", "=", "(", "NetcdfFile", ")", "parent", ";", "v", "=", "ncfile", ".", "findVariable", "(", "varNameEsc", ")", ";", "}", "else", "if", "(", "parent", "instanceof", "Structure", ")", "{", "// then varNameEsc = memberNameEsc (i.e. includes groups)", "Structure", "s", "=", "(", "Structure", ")", "parent", ";", "v", "=", "s", ".", "findVariable", "(", "NetcdfFile", ".", "makeNameUnescaped", "(", "varNameEsc", ")", ")", ";", "// s.findVariable wants unescaped version", "}", "if", "(", "v", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\" cant find variable: \"", "+", "varNameEsc", "+", "\" in selector=\"", "+", "selector", ")", ";", "if", "(", "v", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "indexSelect", "=", "null", ";", "// ignore whatever was sent", "// get the selected Ranges, or all, and add to the list", "Section", "section", ";", "if", "(", "indexSelect", "!=", "null", ")", "{", "section", "=", "new", "Section", "(", "indexSelect", ")", ";", "section", "=", "Section", ".", "fill", "(", "section", ",", "v", ".", "getShape", "(", ")", ")", ";", "// Check section has no nulls, set from shape array.", "}", "else", "{", "section", "=", "v", ".", "getShapeAsSection", "(", ")", ";", "// all", "}", "return", "new", "ParsedSectionSpec", "(", "v", ",", "section", ")", ";", "}"], "docstring": "parse variable name and index selector out of the selector String. variable name must be escaped", "docstring_tokens": ["parse", "variable", "name", "and", "index", "selector", "out", "of", "the", "selector", "String", ".", "variable", "name", "must", "be", "escaped"]}
{"code": "section = v.getShapeAsSection();", "comments": "all", "lines": 36, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ParsedSectionSpec.java", "func_name": "ParsedSectionSpec.parseVariableSelector", "original_string": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "language": "java", "Allcodes": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "code_tokens": ["private", "static", "ParsedSectionSpec", "parseVariableSelector", "(", "Object", "parent", ",", "String", "selector", ")", "throws", "InvalidRangeException", "{", "String", "varNameEsc", ",", "indexSelect", "=", "null", ";", "int", "pos1", "=", "EscapeStrings", ".", "indexOf", "(", "selector", ",", "'", "'", ")", ";", "if", "(", "pos1", "<", "0", ")", "{", "// no index", "varNameEsc", "=", "selector", ";", "}", "else", "{", "varNameEsc", "=", "selector", ".", "substring", "(", "0", ",", "pos1", ")", ";", "int", "pos2", "=", "selector", ".", "indexOf", "(", "'", "'", ",", "pos1", "+", "1", ")", ";", "indexSelect", "=", "selector", ".", "substring", "(", "pos1", ",", "pos2", ")", ";", "}", "if", "(", "debugSelector", ")", "System", ".", "out", ".", "println", "(", "\" parseVariableSection <\"", "+", "selector", "+", "\"> = <\"", "+", "varNameEsc", "+", "\">, <\"", "+", "indexSelect", "+", "\">\"", ")", ";", "Variable", "v", "=", "null", ";", "if", "(", "parent", "instanceof", "NetcdfFile", ")", "{", "// then varNameEsc = varFullNameEsc (i.e. includes groups)", "NetcdfFile", "ncfile", "=", "(", "NetcdfFile", ")", "parent", ";", "v", "=", "ncfile", ".", "findVariable", "(", "varNameEsc", ")", ";", "}", "else", "if", "(", "parent", "instanceof", "Structure", ")", "{", "// then varNameEsc = memberNameEsc (i.e. includes groups)", "Structure", "s", "=", "(", "Structure", ")", "parent", ";", "v", "=", "s", ".", "findVariable", "(", "NetcdfFile", ".", "makeNameUnescaped", "(", "varNameEsc", ")", ")", ";", "// s.findVariable wants unescaped version", "}", "if", "(", "v", "==", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\" cant find variable: \"", "+", "varNameEsc", "+", "\" in selector=\"", "+", "selector", ")", ";", "if", "(", "v", ".", "getDataType", "(", ")", "==", "DataType", ".", "SEQUENCE", ")", "indexSelect", "=", "null", ";", "// ignore whatever was sent", "// get the selected Ranges, or all, and add to the list", "Section", "section", ";", "if", "(", "indexSelect", "!=", "null", ")", "{", "section", "=", "new", "Section", "(", "indexSelect", ")", ";", "section", "=", "Section", ".", "fill", "(", "section", ",", "v", ".", "getShape", "(", ")", ")", ";", "// Check section has no nulls, set from shape array.", "}", "else", "{", "section", "=", "v", ".", "getShapeAsSection", "(", ")", ";", "// all", "}", "return", "new", "ParsedSectionSpec", "(", "v", ",", "section", ")", ";", "}"], "docstring": "parse variable name and index selector out of the selector String. variable name must be escaped", "docstring_tokens": ["parse", "variable", "name", "and", "index", "selector", "out", "of", "the", "selector", "String", ".", "variable", "name", "must", "be", "escaped"]}
{"code": "return;", "comments": "recursive calls ok", "lines": 5, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/HTTPMethod.java", "func_name": "HTTPMethod.close", "original_string": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "language": "java", "Allcodes": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "{", "if", "(", "closed", ")", "return", ";", "// recursive calls ok", "closed", "=", "true", ";", "// mark as closed to prevent recursive calls", "if", "(", "methodstream", "!=", "null", ")", "{", "try", "{", "this", ".", "methodstream", ".", "close", "(", ")", ";", "// May recursr", "}", "catch", "(", "IOException", "ioe", ")", "{", "/*failure is ok*/", "}", "this", ".", "methodstream", "=", "null", ";", "}", "// Force release underlying connection back to the connection manager", "if", "(", "this", ".", "lastresponse", "!=", "null", ")", "{", "if", "(", "false", ")", "{", "try", "{", "try", "{", "// Attempt to keep connection alive by consuming its remaining content", "EntityUtils", ".", "consume", "(", "this", ".", "lastresponse", ".", "getEntity", "(", ")", ")", ";", "}", "finally", "{", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "// Paranoia", "}", "}", "catch", "(", "IOException", "ignore", ")", "{", "/*ignore*/", "}", "}", "else", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "this", ".", "lastresponse", "=", "null", ";", "}", "if", "(", "session", "!=", "null", ")", "{", "session", ".", "removeMethod", "(", "this", ")", ";", "if", "(", "localsession", ")", "{", "session", ".", "close", "(", ")", ";", "session", "=", "null", ";", "}", "}", "this", ".", "lastrequest", "=", "null", ";", "}"], "docstring": "Calling close will force the method to close, and will\nforce any open stream to terminate. If the session is local,\nThen that too will be closed.", "docstring_tokens": ["Calling", "close", "will", "force", "the", "method", "to", "close", "and", "will", "force", "any", "open", "stream", "to", "terminate", ".", "If", "the", "session", "is", "local", "Then", "that", "too", "will", "be", "closed", "."]}
{"code": "closed = true;", "comments": "mark as closed to prevent recursive calls", "lines": 6, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/HTTPMethod.java", "func_name": "HTTPMethod.close", "original_string": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "language": "java", "Allcodes": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "{", "if", "(", "closed", ")", "return", ";", "// recursive calls ok", "closed", "=", "true", ";", "// mark as closed to prevent recursive calls", "if", "(", "methodstream", "!=", "null", ")", "{", "try", "{", "this", ".", "methodstream", ".", "close", "(", ")", ";", "// May recursr", "}", "catch", "(", "IOException", "ioe", ")", "{", "/*failure is ok*/", "}", "this", ".", "methodstream", "=", "null", ";", "}", "// Force release underlying connection back to the connection manager", "if", "(", "this", ".", "lastresponse", "!=", "null", ")", "{", "if", "(", "false", ")", "{", "try", "{", "try", "{", "// Attempt to keep connection alive by consuming its remaining content", "EntityUtils", ".", "consume", "(", "this", ".", "lastresponse", ".", "getEntity", "(", ")", ")", ";", "}", "finally", "{", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "// Paranoia", "}", "}", "catch", "(", "IOException", "ignore", ")", "{", "/*ignore*/", "}", "}", "else", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "this", ".", "lastresponse", "=", "null", ";", "}", "if", "(", "session", "!=", "null", ")", "{", "session", ".", "removeMethod", "(", "this", ")", ";", "if", "(", "localsession", ")", "{", "session", ".", "close", "(", ")", ";", "session", "=", "null", ";", "}", "}", "this", ".", "lastrequest", "=", "null", ";", "}"], "docstring": "Calling close will force the method to close, and will\nforce any open stream to terminate. If the session is local,\nThen that too will be closed.", "docstring_tokens": ["Calling", "close", "will", "force", "the", "method", "to", "close", "and", "will", "force", "any", "open", "stream", "to", "terminate", ".", "If", "the", "session", "is", "local", "Then", "that", "too", "will", "be", "closed", "."]}
{"code": "this.methodstream.close();", "comments": "May recursr", "lines": 9, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/HTTPMethod.java", "func_name": "HTTPMethod.close", "original_string": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "language": "java", "Allcodes": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "{", "if", "(", "closed", ")", "return", ";", "// recursive calls ok", "closed", "=", "true", ";", "// mark as closed to prevent recursive calls", "if", "(", "methodstream", "!=", "null", ")", "{", "try", "{", "this", ".", "methodstream", ".", "close", "(", ")", ";", "// May recursr", "}", "catch", "(", "IOException", "ioe", ")", "{", "/*failure is ok*/", "}", "this", ".", "methodstream", "=", "null", ";", "}", "// Force release underlying connection back to the connection manager", "if", "(", "this", ".", "lastresponse", "!=", "null", ")", "{", "if", "(", "false", ")", "{", "try", "{", "try", "{", "// Attempt to keep connection alive by consuming its remaining content", "EntityUtils", ".", "consume", "(", "this", ".", "lastresponse", ".", "getEntity", "(", ")", ")", ";", "}", "finally", "{", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "// Paranoia", "}", "}", "catch", "(", "IOException", "ignore", ")", "{", "/*ignore*/", "}", "}", "else", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "this", ".", "lastresponse", "=", "null", ";", "}", "if", "(", "session", "!=", "null", ")", "{", "session", ".", "removeMethod", "(", "this", ")", ";", "if", "(", "localsession", ")", "{", "session", ".", "close", "(", ")", ";", "session", "=", "null", ";", "}", "}", "this", ".", "lastrequest", "=", "null", ";", "}"], "docstring": "Calling close will force the method to close, and will\nforce any open stream to terminate. If the session is local,\nThen that too will be closed.", "docstring_tokens": ["Calling", "close", "will", "force", "the", "method", "to", "close", "and", "will", "force", "any", "open", "stream", "to", "terminate", ".", "If", "the", "session", "is", "local", "Then", "that", "too", "will", "be", "closed", "."]}
{"code": "HttpClientUtils.closeQuietly(this.lastresponse);", "comments": "Paranoia", "lines": 21, "repo": "Unidata/thredds", "path": "httpservices/src/main/java/ucar/httpservices/HTTPMethod.java", "func_name": "HTTPMethod.close", "original_string": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "language": "java", "Allcodes": "public synchronized void\n    close()\n    {\n        if(closed)\n            return; // recursive calls ok\n        closed = true; // mark as closed to prevent recursive calls\n        if(methodstream != null) {\n            try {\n                this.methodstream.close(); // May recursr\n            } catch (IOException ioe) {/*failure is ok*/}\n            this.methodstream = null;\n        }\n        // Force release underlying connection back to the connection manager\n        if(this.lastresponse != null) {\n            if(false) {\n                try {\n                    try {\n                        // Attempt to keep connection alive by consuming its remaining content\n                        EntityUtils.consume(this.lastresponse.getEntity());\n                    } finally {\n                        HttpClientUtils.closeQuietly(this.lastresponse); // Paranoia\n                    }\n                } catch (IOException ignore) {/*ignore*/}\n            } else\n                HttpClientUtils.closeQuietly(this.lastresponse);\n            this.lastresponse = null;\n        }\n        if(session != null) {\n            session.removeMethod(this);\n            if(localsession) {\n                session.close();\n                session = null;\n            }\n        }\n        this.lastrequest = null;\n    }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "{", "if", "(", "closed", ")", "return", ";", "// recursive calls ok", "closed", "=", "true", ";", "// mark as closed to prevent recursive calls", "if", "(", "methodstream", "!=", "null", ")", "{", "try", "{", "this", ".", "methodstream", ".", "close", "(", ")", ";", "// May recursr", "}", "catch", "(", "IOException", "ioe", ")", "{", "/*failure is ok*/", "}", "this", ".", "methodstream", "=", "null", ";", "}", "// Force release underlying connection back to the connection manager", "if", "(", "this", ".", "lastresponse", "!=", "null", ")", "{", "if", "(", "false", ")", "{", "try", "{", "try", "{", "// Attempt to keep connection alive by consuming its remaining content", "EntityUtils", ".", "consume", "(", "this", ".", "lastresponse", ".", "getEntity", "(", ")", ")", ";", "}", "finally", "{", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "// Paranoia", "}", "}", "catch", "(", "IOException", "ignore", ")", "{", "/*ignore*/", "}", "}", "else", "HttpClientUtils", ".", "closeQuietly", "(", "this", ".", "lastresponse", ")", ";", "this", ".", "lastresponse", "=", "null", ";", "}", "if", "(", "session", "!=", "null", ")", "{", "session", ".", "removeMethod", "(", "this", ")", ";", "if", "(", "localsession", ")", "{", "session", ".", "close", "(", ")", ";", "session", "=", "null", ";", "}", "}", "this", ".", "lastrequest", "=", "null", ";", "}"], "docstring": "Calling close will force the method to close, and will\nforce any open stream to terminate. If the session is local,\nThen that too will be closed.", "docstring_tokens": ["Calling", "close", "will", "force", "the", "method", "to", "close", "and", "will", "force", "any", "open", "stream", "to", "terminate", ".", "If", "the", "session", "is", "local", "Then", "that", "too", "will", "be", "closed", "."]}
{"code": "obsDim = info.time.getDimension(info.time.getRank() - 1);", "comments": "may be time(time) or time(stn, obs)", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/plug/CFpointObs.java", "func_name": "CFpointObs.identifyEncodingStation", "original_string": "protected boolean identifyEncodingStation(NetcdfDataset ds, EncodingInfo info, CF.FeatureType ftype, Formatter errlog) {\r\n    // find the obs dimension\r\n    Dimension obsDim = null;\r\n    if (info.time.getRank() > 0)\r\n      obsDim = info.time.getDimension(info.time.getRank() - 1); // may be time(time) or time(stn, obs)\r\n    else if (info.time.getParentStructure() != null) {\r\n      Structure parent = info.time.getParentStructure(); // if time axis is a structure member, try pulling dimension out of parent structure\r\n      obsDim = parent.getDimension(parent.getRank() - 1);\r\n    }\r\n    if (obsDim == null) {\r\n      errlog.format(\"CFpointObs: must have a non-scalar Time coordinate%n\");\r\n      return false;\r\n    }\r\n\r\n    // find the station dimension\r\n    if (info.lat.getRank() == 0) {// scalar means single\r\n      info.set(Encoding.single, null, obsDim);\r\n      return true;\r\n    }\r\n\r\n    Dimension stnDim = info.lat.getDimension(0);\r\n    if (obsDim == stnDim) {\r\n      info.set(Encoding.flat, null, obsDim); // not used ?\r\n      return true;\r\n    }\r\n\r\n    // the raggeds\r\n    if (identifyRaggeds(ds, info, stnDim, obsDim, errlog))\r\n      return true;\r\n\r\n    // heres whats left\r\n    if (info.lat.getRank() == 1) {\r\n      //Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r\n      info.set(Encoding.multidim, stnDim, obsDim);\r\n      return true;\r\n    }\r\n\r\n    errlog.format(\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\", ftype);\r\n    return false;\r\n  }", "language": "java", "Allcodes": "protected boolean identifyEncodingStation(NetcdfDataset ds, EncodingInfo info, CF.FeatureType ftype, Formatter errlog) {\r\n    // find the obs dimension\r\n    Dimension obsDim = null;\r\n    if (info.time.getRank() > 0)\r\n      obsDim = info.time.getDimension(info.time.getRank() - 1); // may be time(time) or time(stn, obs)\r\n    else if (info.time.getParentStructure() != null) {\r\n      Structure parent = info.time.getParentStructure(); // if time axis is a structure member, try pulling dimension out of parent structure\r\n      obsDim = parent.getDimension(parent.getRank() - 1);\r\n    }\r\n    if (obsDim == null) {\r\n      errlog.format(\"CFpointObs: must have a non-scalar Time coordinate%n\");\r\n      return false;\r\n    }\r\n\r\n    // find the station dimension\r\n    if (info.lat.getRank() == 0) {// scalar means single\r\n      info.set(Encoding.single, null, obsDim);\r\n      return true;\r\n    }\r\n\r\n    Dimension stnDim = info.lat.getDimension(0);\r\n    if (obsDim == stnDim) {\r\n      info.set(Encoding.flat, null, obsDim); // not used ?\r\n      return true;\r\n    }\r\n\r\n    // the raggeds\r\n    if (identifyRaggeds(ds, info, stnDim, obsDim, errlog))\r\n      return true;\r\n\r\n    // heres whats left\r\n    if (info.lat.getRank() == 1) {\r\n      //Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r\n      info.set(Encoding.multidim, stnDim, obsDim);\r\n      return true;\r\n    }\r\n\r\n    errlog.format(\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\", ftype);\r\n    return false;\r\n  }", "code_tokens": ["protected", "boolean", "identifyEncodingStation", "(", "NetcdfDataset", "ds", ",", "EncodingInfo", "info", ",", "CF", ".", "FeatureType", "ftype", ",", "Formatter", "errlog", ")", "{", "// find the obs dimension\r", "Dimension", "obsDim", "=", "null", ";", "if", "(", "info", ".", "time", ".", "getRank", "(", ")", ">", "0", ")", "obsDim", "=", "info", ".", "time", ".", "getDimension", "(", "info", ".", "time", ".", "getRank", "(", ")", "-", "1", ")", ";", "// may be time(time) or time(stn, obs)\r", "else", "if", "(", "info", ".", "time", ".", "getParentStructure", "(", ")", "!=", "null", ")", "{", "Structure", "parent", "=", "info", ".", "time", ".", "getParentStructure", "(", ")", ";", "// if time axis is a structure member, try pulling dimension out of parent structure\r", "obsDim", "=", "parent", ".", "getDimension", "(", "parent", ".", "getRank", "(", ")", "-", "1", ")", ";", "}", "if", "(", "obsDim", "==", "null", ")", "{", "errlog", ".", "format", "(", "\"CFpointObs: must have a non-scalar Time coordinate%n\"", ")", ";", "return", "false", ";", "}", "// find the station dimension\r", "if", "(", "info", ".", "lat", ".", "getRank", "(", ")", "==", "0", ")", "{", "// scalar means single\r", "info", ".", "set", "(", "Encoding", ".", "single", ",", "null", ",", "obsDim", ")", ";", "return", "true", ";", "}", "Dimension", "stnDim", "=", "info", ".", "lat", ".", "getDimension", "(", "0", ")", ";", "if", "(", "obsDim", "==", "stnDim", ")", "{", "info", ".", "set", "(", "Encoding", ".", "flat", ",", "null", ",", "obsDim", ")", ";", "// not used ?\r", "return", "true", ";", "}", "// the raggeds\r", "if", "(", "identifyRaggeds", "(", "ds", ",", "info", ",", "stnDim", ",", "obsDim", ",", "errlog", ")", ")", "return", "true", ";", "// heres whats left\r", "if", "(", "info", ".", "lat", ".", "getRank", "(", ")", "==", "1", ")", "{", "//Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r", "info", ".", "set", "(", "Encoding", ".", "multidim", ",", "stnDim", ",", "obsDim", ")", ";", "return", "true", ";", "}", "errlog", ".", "format", "(", "\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\"", ",", "ftype", ")", ";", "return", "false", ";", "}"], "docstring": "for stations, figure out the encoding", "docstring_tokens": ["for", "stations", "figure", "out", "the", "encoding"]}
{"code": "Structure parent = info.time.getParentStructure();", "comments": "if time axis is a structure member, try pulling dimension out of parent structure", "lines": 7, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/plug/CFpointObs.java", "func_name": "CFpointObs.identifyEncodingStation", "original_string": "protected boolean identifyEncodingStation(NetcdfDataset ds, EncodingInfo info, CF.FeatureType ftype, Formatter errlog) {\r\n    // find the obs dimension\r\n    Dimension obsDim = null;\r\n    if (info.time.getRank() > 0)\r\n      obsDim = info.time.getDimension(info.time.getRank() - 1); // may be time(time) or time(stn, obs)\r\n    else if (info.time.getParentStructure() != null) {\r\n      Structure parent = info.time.getParentStructure(); // if time axis is a structure member, try pulling dimension out of parent structure\r\n      obsDim = parent.getDimension(parent.getRank() - 1);\r\n    }\r\n    if (obsDim == null) {\r\n      errlog.format(\"CFpointObs: must have a non-scalar Time coordinate%n\");\r\n      return false;\r\n    }\r\n\r\n    // find the station dimension\r\n    if (info.lat.getRank() == 0) {// scalar means single\r\n      info.set(Encoding.single, null, obsDim);\r\n      return true;\r\n    }\r\n\r\n    Dimension stnDim = info.lat.getDimension(0);\r\n    if (obsDim == stnDim) {\r\n      info.set(Encoding.flat, null, obsDim); // not used ?\r\n      return true;\r\n    }\r\n\r\n    // the raggeds\r\n    if (identifyRaggeds(ds, info, stnDim, obsDim, errlog))\r\n      return true;\r\n\r\n    // heres whats left\r\n    if (info.lat.getRank() == 1) {\r\n      //Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r\n      info.set(Encoding.multidim, stnDim, obsDim);\r\n      return true;\r\n    }\r\n\r\n    errlog.format(\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\", ftype);\r\n    return false;\r\n  }", "language": "java", "Allcodes": "protected boolean identifyEncodingStation(NetcdfDataset ds, EncodingInfo info, CF.FeatureType ftype, Formatter errlog) {\r\n    // find the obs dimension\r\n    Dimension obsDim = null;\r\n    if (info.time.getRank() > 0)\r\n      obsDim = info.time.getDimension(info.time.getRank() - 1); // may be time(time) or time(stn, obs)\r\n    else if (info.time.getParentStructure() != null) {\r\n      Structure parent = info.time.getParentStructure(); // if time axis is a structure member, try pulling dimension out of parent structure\r\n      obsDim = parent.getDimension(parent.getRank() - 1);\r\n    }\r\n    if (obsDim == null) {\r\n      errlog.format(\"CFpointObs: must have a non-scalar Time coordinate%n\");\r\n      return false;\r\n    }\r\n\r\n    // find the station dimension\r\n    if (info.lat.getRank() == 0) {// scalar means single\r\n      info.set(Encoding.single, null, obsDim);\r\n      return true;\r\n    }\r\n\r\n    Dimension stnDim = info.lat.getDimension(0);\r\n    if (obsDim == stnDim) {\r\n      info.set(Encoding.flat, null, obsDim); // not used ?\r\n      return true;\r\n    }\r\n\r\n    // the raggeds\r\n    if (identifyRaggeds(ds, info, stnDim, obsDim, errlog))\r\n      return true;\r\n\r\n    // heres whats left\r\n    if (info.lat.getRank() == 1) {\r\n      //Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r\n      info.set(Encoding.multidim, stnDim, obsDim);\r\n      return true;\r\n    }\r\n\r\n    errlog.format(\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\", ftype);\r\n    return false;\r\n  }", "code_tokens": ["protected", "boolean", "identifyEncodingStation", "(", "NetcdfDataset", "ds", ",", "EncodingInfo", "info", ",", "CF", ".", "FeatureType", "ftype", ",", "Formatter", "errlog", ")", "{", "// find the obs dimension\r", "Dimension", "obsDim", "=", "null", ";", "if", "(", "info", ".", "time", ".", "getRank", "(", ")", ">", "0", ")", "obsDim", "=", "info", ".", "time", ".", "getDimension", "(", "info", ".", "time", ".", "getRank", "(", ")", "-", "1", ")", ";", "// may be time(time) or time(stn, obs)\r", "else", "if", "(", "info", ".", "time", ".", "getParentStructure", "(", ")", "!=", "null", ")", "{", "Structure", "parent", "=", "info", ".", "time", ".", "getParentStructure", "(", ")", ";", "// if time axis is a structure member, try pulling dimension out of parent structure\r", "obsDim", "=", "parent", ".", "getDimension", "(", "parent", ".", "getRank", "(", ")", "-", "1", ")", ";", "}", "if", "(", "obsDim", "==", "null", ")", "{", "errlog", ".", "format", "(", "\"CFpointObs: must have a non-scalar Time coordinate%n\"", ")", ";", "return", "false", ";", "}", "// find the station dimension\r", "if", "(", "info", ".", "lat", ".", "getRank", "(", ")", "==", "0", ")", "{", "// scalar means single\r", "info", ".", "set", "(", "Encoding", ".", "single", ",", "null", ",", "obsDim", ")", ";", "return", "true", ";", "}", "Dimension", "stnDim", "=", "info", ".", "lat", ".", "getDimension", "(", "0", ")", ";", "if", "(", "obsDim", "==", "stnDim", ")", "{", "info", ".", "set", "(", "Encoding", ".", "flat", ",", "null", ",", "obsDim", ")", ";", "// not used ?\r", "return", "true", ";", "}", "// the raggeds\r", "if", "(", "identifyRaggeds", "(", "ds", ",", "info", ",", "stnDim", ",", "obsDim", ",", "errlog", ")", ")", "return", "true", ";", "// heres whats left\r", "if", "(", "info", ".", "lat", ".", "getRank", "(", ")", "==", "1", ")", "{", "//Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r", "info", ".", "set", "(", "Encoding", ".", "multidim", ",", "stnDim", ",", "obsDim", ")", ";", "return", "true", ";", "}", "errlog", ".", "format", "(", "\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\"", ",", "ftype", ")", ";", "return", "false", ";", "}"], "docstring": "for stations, figure out the encoding", "docstring_tokens": ["for", "stations", "figure", "out", "the", "encoding"]}
{"code": "info.set(Encoding.flat, null, obsDim);", "comments": "not used ?", "lines": 23, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/plug/CFpointObs.java", "func_name": "CFpointObs.identifyEncodingStation", "original_string": "protected boolean identifyEncodingStation(NetcdfDataset ds, EncodingInfo info, CF.FeatureType ftype, Formatter errlog) {\r\n    // find the obs dimension\r\n    Dimension obsDim = null;\r\n    if (info.time.getRank() > 0)\r\n      obsDim = info.time.getDimension(info.time.getRank() - 1); // may be time(time) or time(stn, obs)\r\n    else if (info.time.getParentStructure() != null) {\r\n      Structure parent = info.time.getParentStructure(); // if time axis is a structure member, try pulling dimension out of parent structure\r\n      obsDim = parent.getDimension(parent.getRank() - 1);\r\n    }\r\n    if (obsDim == null) {\r\n      errlog.format(\"CFpointObs: must have a non-scalar Time coordinate%n\");\r\n      return false;\r\n    }\r\n\r\n    // find the station dimension\r\n    if (info.lat.getRank() == 0) {// scalar means single\r\n      info.set(Encoding.single, null, obsDim);\r\n      return true;\r\n    }\r\n\r\n    Dimension stnDim = info.lat.getDimension(0);\r\n    if (obsDim == stnDim) {\r\n      info.set(Encoding.flat, null, obsDim); // not used ?\r\n      return true;\r\n    }\r\n\r\n    // the raggeds\r\n    if (identifyRaggeds(ds, info, stnDim, obsDim, errlog))\r\n      return true;\r\n\r\n    // heres whats left\r\n    if (info.lat.getRank() == 1) {\r\n      //Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r\n      info.set(Encoding.multidim, stnDim, obsDim);\r\n      return true;\r\n    }\r\n\r\n    errlog.format(\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\", ftype);\r\n    return false;\r\n  }", "language": "java", "Allcodes": "protected boolean identifyEncodingStation(NetcdfDataset ds, EncodingInfo info, CF.FeatureType ftype, Formatter errlog) {\r\n    // find the obs dimension\r\n    Dimension obsDim = null;\r\n    if (info.time.getRank() > 0)\r\n      obsDim = info.time.getDimension(info.time.getRank() - 1); // may be time(time) or time(stn, obs)\r\n    else if (info.time.getParentStructure() != null) {\r\n      Structure parent = info.time.getParentStructure(); // if time axis is a structure member, try pulling dimension out of parent structure\r\n      obsDim = parent.getDimension(parent.getRank() - 1);\r\n    }\r\n    if (obsDim == null) {\r\n      errlog.format(\"CFpointObs: must have a non-scalar Time coordinate%n\");\r\n      return false;\r\n    }\r\n\r\n    // find the station dimension\r\n    if (info.lat.getRank() == 0) {// scalar means single\r\n      info.set(Encoding.single, null, obsDim);\r\n      return true;\r\n    }\r\n\r\n    Dimension stnDim = info.lat.getDimension(0);\r\n    if (obsDim == stnDim) {\r\n      info.set(Encoding.flat, null, obsDim); // not used ?\r\n      return true;\r\n    }\r\n\r\n    // the raggeds\r\n    if (identifyRaggeds(ds, info, stnDim, obsDim, errlog))\r\n      return true;\r\n\r\n    // heres whats left\r\n    if (info.lat.getRank() == 1) {\r\n      //Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r\n      info.set(Encoding.multidim, stnDim, obsDim);\r\n      return true;\r\n    }\r\n\r\n    errlog.format(\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\", ftype);\r\n    return false;\r\n  }", "code_tokens": ["protected", "boolean", "identifyEncodingStation", "(", "NetcdfDataset", "ds", ",", "EncodingInfo", "info", ",", "CF", ".", "FeatureType", "ftype", ",", "Formatter", "errlog", ")", "{", "// find the obs dimension\r", "Dimension", "obsDim", "=", "null", ";", "if", "(", "info", ".", "time", ".", "getRank", "(", ")", ">", "0", ")", "obsDim", "=", "info", ".", "time", ".", "getDimension", "(", "info", ".", "time", ".", "getRank", "(", ")", "-", "1", ")", ";", "// may be time(time) or time(stn, obs)\r", "else", "if", "(", "info", ".", "time", ".", "getParentStructure", "(", ")", "!=", "null", ")", "{", "Structure", "parent", "=", "info", ".", "time", ".", "getParentStructure", "(", ")", ";", "// if time axis is a structure member, try pulling dimension out of parent structure\r", "obsDim", "=", "parent", ".", "getDimension", "(", "parent", ".", "getRank", "(", ")", "-", "1", ")", ";", "}", "if", "(", "obsDim", "==", "null", ")", "{", "errlog", ".", "format", "(", "\"CFpointObs: must have a non-scalar Time coordinate%n\"", ")", ";", "return", "false", ";", "}", "// find the station dimension\r", "if", "(", "info", ".", "lat", ".", "getRank", "(", ")", "==", "0", ")", "{", "// scalar means single\r", "info", ".", "set", "(", "Encoding", ".", "single", ",", "null", ",", "obsDim", ")", ";", "return", "true", ";", "}", "Dimension", "stnDim", "=", "info", ".", "lat", ".", "getDimension", "(", "0", ")", ";", "if", "(", "obsDim", "==", "stnDim", ")", "{", "info", ".", "set", "(", "Encoding", ".", "flat", ",", "null", ",", "obsDim", ")", ";", "// not used ?\r", "return", "true", ";", "}", "// the raggeds\r", "if", "(", "identifyRaggeds", "(", "ds", ",", "info", ",", "stnDim", ",", "obsDim", ",", "errlog", ")", ")", "return", "true", ";", "// heres whats left\r", "if", "(", "info", ".", "lat", ".", "getRank", "(", ")", "==", "1", ")", "{", "//Encoding e = (info.time.getParentStructure() != null) ? Encoding.multiStructure : Encoding.multidim;\r", "info", ".", "set", "(", "Encoding", ".", "multidim", ",", "stnDim", ",", "obsDim", ")", ";", "return", "true", ";", "}", "errlog", ".", "format", "(", "\"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\"", ",", "ftype", ")", ";", "return", "false", ";", "}"], "docstring": "for stations, figure out the encoding", "docstring_tokens": ["for", "stations", "figure", "out", "the", "encoding"]}
{"code": "timer = new javax.swing.Timer(1000, watcher);", "comments": "every second", "lines": 48, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/ProgressMonitor.java", "func_name": "ProgressMonitor.start", "original_string": "public void start(java.awt.Component top, String taskName, int progressMaxCount) {\n    // create ProgressMonitor\n    pm = new javax.swing.ProgressMonitor(top, taskName, \"\", 0, progressMaxCount);\n    pm.setMillisToDecideToPopup(millisToDecideToPopup);\n    pm.setMillisToPopup(millisToPopup);\n\n    // do task in a seperate, non-event, thread\n    taskThread = new Thread(task);\n    taskThread.start();\n\n    // create timer, whose events happen on the awt event Thread\n    ActionListener watcher = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n        secs++;\n        if (pm.isCanceled()) {\n          task.cancel();\n        } else {\n          // indicate progress\n          String note = task.getNote();\n          pm.setNote(note == null ? secs + \" secs\" : note);\n          int progress = task.getProgress();\n          pm.setProgress(progress <= 0 ? secs : progress);\n        }\n\n        // need to make sure task acknowledges the cancel; so dont shut down\n        // until the task is done\n        if (task.isDone()) {\n          timer.stop();\n          pm.close();\n          // Toolkit.getDefaultToolkit().beep();\n\n          if (task.isError()) {\n            javax.swing.JOptionPane.showMessageDialog(null, task.getErrorMessage());\n          }\n\n          if (task.isSuccess())\n            fireEvent(new ActionEvent(this, 0, \"success\"));\n          else if (task.isError())\n            fireEvent(new ActionEvent(this, 0, \"error\"));\n          else if (task.isCancel())\n            fireEvent(new ActionEvent(this, 0, \"cancel\"));\n          else\n            fireEvent(new ActionEvent(this, 0, \"done\"));\n        }\n      }\n    };\n\n    timer = new javax.swing.Timer(1000, watcher); // every second\n    timer.start();\n  }", "language": "java", "Allcodes": "public void start(java.awt.Component top, String taskName, int progressMaxCount) {\n    // create ProgressMonitor\n    pm = new javax.swing.ProgressMonitor(top, taskName, \"\", 0, progressMaxCount);\n    pm.setMillisToDecideToPopup(millisToDecideToPopup);\n    pm.setMillisToPopup(millisToPopup);\n\n    // do task in a seperate, non-event, thread\n    taskThread = new Thread(task);\n    taskThread.start();\n\n    // create timer, whose events happen on the awt event Thread\n    ActionListener watcher = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n        secs++;\n        if (pm.isCanceled()) {\n          task.cancel();\n        } else {\n          // indicate progress\n          String note = task.getNote();\n          pm.setNote(note == null ? secs + \" secs\" : note);\n          int progress = task.getProgress();\n          pm.setProgress(progress <= 0 ? secs : progress);\n        }\n\n        // need to make sure task acknowledges the cancel; so dont shut down\n        // until the task is done\n        if (task.isDone()) {\n          timer.stop();\n          pm.close();\n          // Toolkit.getDefaultToolkit().beep();\n\n          if (task.isError()) {\n            javax.swing.JOptionPane.showMessageDialog(null, task.getErrorMessage());\n          }\n\n          if (task.isSuccess())\n            fireEvent(new ActionEvent(this, 0, \"success\"));\n          else if (task.isError())\n            fireEvent(new ActionEvent(this, 0, \"error\"));\n          else if (task.isCancel())\n            fireEvent(new ActionEvent(this, 0, \"cancel\"));\n          else\n            fireEvent(new ActionEvent(this, 0, \"done\"));\n        }\n      }\n    };\n\n    timer = new javax.swing.Timer(1000, watcher); // every second\n    timer.start();\n  }", "code_tokens": ["public", "void", "start", "(", "java", ".", "awt", ".", "Component", "top", ",", "String", "taskName", ",", "int", "progressMaxCount", ")", "{", "// create ProgressMonitor", "pm", "=", "new", "javax", ".", "swing", ".", "ProgressMonitor", "(", "top", ",", "taskName", ",", "\"\"", ",", "0", ",", "progressMaxCount", ")", ";", "pm", ".", "setMillisToDecideToPopup", "(", "millisToDecideToPopup", ")", ";", "pm", ".", "setMillisToPopup", "(", "millisToPopup", ")", ";", "// do task in a seperate, non-event, thread", "taskThread", "=", "new", "Thread", "(", "task", ")", ";", "taskThread", ".", "start", "(", ")", ";", "// create timer, whose events happen on the awt event Thread", "ActionListener", "watcher", "=", "new", "ActionListener", "(", ")", "{", "public", "void", "actionPerformed", "(", "ActionEvent", "evt", ")", "{", "secs", "++", ";", "if", "(", "pm", ".", "isCanceled", "(", ")", ")", "{", "task", ".", "cancel", "(", ")", ";", "}", "else", "{", "// indicate progress", "String", "note", "=", "task", ".", "getNote", "(", ")", ";", "pm", ".", "setNote", "(", "note", "==", "null", "?", "secs", "+", "\" secs\"", ":", "note", ")", ";", "int", "progress", "=", "task", ".", "getProgress", "(", ")", ";", "pm", ".", "setProgress", "(", "progress", "<=", "0", "?", "secs", ":", "progress", ")", ";", "}", "// need to make sure task acknowledges the cancel; so dont shut down", "// until the task is done", "if", "(", "task", ".", "isDone", "(", ")", ")", "{", "timer", ".", "stop", "(", ")", ";", "pm", ".", "close", "(", ")", ";", "// Toolkit.getDefaultToolkit().beep();", "if", "(", "task", ".", "isError", "(", ")", ")", "{", "javax", ".", "swing", ".", "JOptionPane", ".", "showMessageDialog", "(", "null", ",", "task", ".", "getErrorMessage", "(", ")", ")", ";", "}", "if", "(", "task", ".", "isSuccess", "(", ")", ")", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"success\"", ")", ")", ";", "else", "if", "(", "task", ".", "isError", "(", ")", ")", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"error\"", ")", ")", ";", "else", "if", "(", "task", ".", "isCancel", "(", ")", ")", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"cancel\"", ")", ")", ";", "else", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"done\"", ")", ")", ";", "}", "}", "}", ";", "timer", "=", "new", "javax", ".", "swing", ".", "Timer", "(", "1000", ",", "watcher", ")", ";", "// every second", "timer", ".", "start", "(", ")", ";", "}"], "docstring": "Call this from awt event thread.\nThe task is run in a background thread.\n\n@param top              put ProgressMonitor on top of this component (may be null)\n@param taskName         display name of task\n@param progressMaxCount maximum number of Progress indicator", "docstring_tokens": ["Call", "this", "from", "awt", "event", "thread", ".", "The", "task", "is", "run", "in", "a", "background", "thread", "."]}
{"code": "return;", "comments": "only DMR should be sent", "lines": 14, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/ChunkWriter.java", "func_name": "ChunkWriter.close", "original_string": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "language": "java", "Allcodes": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "code_tokens": ["public", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "closed", ")", "return", ";", "closed", "=", "true", ";", "if", "(", "dmr8", "!=", "null", ")", "{", "sendDXR", "(", "dmr8", ")", ";", "dmr8", "=", "null", ";", "}", "if", "(", "mode", "==", "RequestMode", ".", "DMR", ")", "return", ";", "// only DMR should be sent", "// If there is no partial chunk to write then", "// we are done; else verify we can write and write the last", "// chunk; => multiple closes are ok.", "if", "(", "chunk", "==", "null", "||", "chunk", ".", "position", "(", ")", "==", "0", ")", "return", ";", "// There is data left to write.", "verifystate", "(", ")", ";", "// are we in a state supporting data write?", "// Force out the current chunk (might be empty)", "// but do not close the underlying output stream", "state", "=", "State", ".", "DATA", ";", "// pretend", "int", "flags", "=", "DapUtil", ".", "CHUNK_END", ";", "writeChunk", "(", "flags", ")", ";", "state", "=", "State", ".", "END", ";", "this", ".", "output", ".", "flush", "(", ")", ";", "// Do not close", "if", "(", "this", ".", "saveoutput", "!=", "null", ")", "{", "// write to true output target", "this", ".", "saveoutput", ".", "write", "(", "(", "(", "ByteArrayOutputStream", ")", "this", ".", "output", ")", ".", "toByteArray", "(", ")", ")", ";", "}", "}"], "docstring": "Closes this output stream and releases any system resources\nassociated with this stream. Except, the underlying stream is not\nactually closed; that is left to the servlet level\n\n@throws IOException on IO related errors", "docstring_tokens": ["Closes", "this", "output", "stream", "and", "releases", "any", "system", "resources", "associated", "with", "this", "stream", ".", "Except", "the", "underlying", "stream", "is", "not", "actually", "closed", ";", "that", "is", "left", "to", "the", "servlet", "level"]}
{"code": "verifystate();", "comments": "are we in a state supporting data write?", "lines": 23, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/ChunkWriter.java", "func_name": "ChunkWriter.close", "original_string": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "language": "java", "Allcodes": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "code_tokens": ["public", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "closed", ")", "return", ";", "closed", "=", "true", ";", "if", "(", "dmr8", "!=", "null", ")", "{", "sendDXR", "(", "dmr8", ")", ";", "dmr8", "=", "null", ";", "}", "if", "(", "mode", "==", "RequestMode", ".", "DMR", ")", "return", ";", "// only DMR should be sent", "// If there is no partial chunk to write then", "// we are done; else verify we can write and write the last", "// chunk; => multiple closes are ok.", "if", "(", "chunk", "==", "null", "||", "chunk", ".", "position", "(", ")", "==", "0", ")", "return", ";", "// There is data left to write.", "verifystate", "(", ")", ";", "// are we in a state supporting data write?", "// Force out the current chunk (might be empty)", "// but do not close the underlying output stream", "state", "=", "State", ".", "DATA", ";", "// pretend", "int", "flags", "=", "DapUtil", ".", "CHUNK_END", ";", "writeChunk", "(", "flags", ")", ";", "state", "=", "State", ".", "END", ";", "this", ".", "output", ".", "flush", "(", ")", ";", "// Do not close", "if", "(", "this", ".", "saveoutput", "!=", "null", ")", "{", "// write to true output target", "this", ".", "saveoutput", ".", "write", "(", "(", "(", "ByteArrayOutputStream", ")", "this", ".", "output", ")", ".", "toByteArray", "(", ")", ")", ";", "}", "}"], "docstring": "Closes this output stream and releases any system resources\nassociated with this stream. Except, the underlying stream is not\nactually closed; that is left to the servlet level\n\n@throws IOException on IO related errors", "docstring_tokens": ["Closes", "this", "output", "stream", "and", "releases", "any", "system", "resources", "associated", "with", "this", "stream", ".", "Except", "the", "underlying", "stream", "is", "not", "actually", "closed", ";", "that", "is", "left", "to", "the", "servlet", "level"]}
{"code": "state = State.DATA;", "comments": "pretend", "lines": 27, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/ChunkWriter.java", "func_name": "ChunkWriter.close", "original_string": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "language": "java", "Allcodes": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "code_tokens": ["public", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "closed", ")", "return", ";", "closed", "=", "true", ";", "if", "(", "dmr8", "!=", "null", ")", "{", "sendDXR", "(", "dmr8", ")", ";", "dmr8", "=", "null", ";", "}", "if", "(", "mode", "==", "RequestMode", ".", "DMR", ")", "return", ";", "// only DMR should be sent", "// If there is no partial chunk to write then", "// we are done; else verify we can write and write the last", "// chunk; => multiple closes are ok.", "if", "(", "chunk", "==", "null", "||", "chunk", ".", "position", "(", ")", "==", "0", ")", "return", ";", "// There is data left to write.", "verifystate", "(", ")", ";", "// are we in a state supporting data write?", "// Force out the current chunk (might be empty)", "// but do not close the underlying output stream", "state", "=", "State", ".", "DATA", ";", "// pretend", "int", "flags", "=", "DapUtil", ".", "CHUNK_END", ";", "writeChunk", "(", "flags", ")", ";", "state", "=", "State", ".", "END", ";", "this", ".", "output", ".", "flush", "(", ")", ";", "// Do not close", "if", "(", "this", ".", "saveoutput", "!=", "null", ")", "{", "// write to true output target", "this", ".", "saveoutput", ".", "write", "(", "(", "(", "ByteArrayOutputStream", ")", "this", ".", "output", ")", ".", "toByteArray", "(", ")", ")", ";", "}", "}"], "docstring": "Closes this output stream and releases any system resources\nassociated with this stream. Except, the underlying stream is not\nactually closed; that is left to the servlet level\n\n@throws IOException on IO related errors", "docstring_tokens": ["Closes", "this", "output", "stream", "and", "releases", "any", "system", "resources", "associated", "with", "this", "stream", ".", "Except", "the", "underlying", "stream", "is", "not", "actually", "closed", ";", "that", "is", "left", "to", "the", "servlet", "level"]}
{"code": "this.output.flush();", "comments": "Do not close", "lines": 32, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/ChunkWriter.java", "func_name": "ChunkWriter.close", "original_string": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "language": "java", "Allcodes": "public void close()\n            throws IOException\n    {\n        if(closed)\n            return;\n        closed = true;\n\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n\n        if(mode == RequestMode.DMR)\n            return; // only DMR should be sent\n\n        // If there is no partial chunk to write then\n        // we are done; else verify we can write and write the last\n        // chunk; => multiple closes are ok.\n        if(chunk == null || chunk.position() == 0)\n            return;\n\n        // There is data left to write.\n        verifystate(); // are we in a state supporting data write?\n\n        // Force out the current chunk (might be empty)\n        // but do not close the underlying output stream\n        state = State.DATA; // pretend\n\n        int flags = DapUtil.CHUNK_END;\n        writeChunk(flags);\n        state = State.END;\n        this.output.flush(); // Do not close\n        if(this.saveoutput != null) {\n            // write to true output target\n            this.saveoutput.write(((ByteArrayOutputStream) this.output).toByteArray());\n        }\n    }", "code_tokens": ["public", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "closed", ")", "return", ";", "closed", "=", "true", ";", "if", "(", "dmr8", "!=", "null", ")", "{", "sendDXR", "(", "dmr8", ")", ";", "dmr8", "=", "null", ";", "}", "if", "(", "mode", "==", "RequestMode", ".", "DMR", ")", "return", ";", "// only DMR should be sent", "// If there is no partial chunk to write then", "// we are done; else verify we can write and write the last", "// chunk; => multiple closes are ok.", "if", "(", "chunk", "==", "null", "||", "chunk", ".", "position", "(", ")", "==", "0", ")", "return", ";", "// There is data left to write.", "verifystate", "(", ")", ";", "// are we in a state supporting data write?", "// Force out the current chunk (might be empty)", "// but do not close the underlying output stream", "state", "=", "State", ".", "DATA", ";", "// pretend", "int", "flags", "=", "DapUtil", ".", "CHUNK_END", ";", "writeChunk", "(", "flags", ")", ";", "state", "=", "State", ".", "END", ";", "this", ".", "output", ".", "flush", "(", ")", ";", "// Do not close", "if", "(", "this", ".", "saveoutput", "!=", "null", ")", "{", "// write to true output target", "this", ".", "saveoutput", ".", "write", "(", "(", "(", "ByteArrayOutputStream", ")", "this", ".", "output", ")", ".", "toByteArray", "(", ")", ")", ";", "}", "}"], "docstring": "Closes this output stream and releases any system resources\nassociated with this stream. Except, the underlying stream is not\nactually closed; that is left to the servlet level\n\n@throws IOException on IO related errors", "docstring_tokens": ["Closes", "this", "output", "stream", "and", "releases", "any", "system", "resources", "associated", "with", "this", "stream", ".", "Except", "the", "underlying", "stream", "is", "not", "actually", "closed", ";", "that", "is", "left", "to", "the", "servlet", "level"]}
{"code": "return;", "comments": "leave to close() to do this", "lines": 7, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/ChunkWriter.java", "func_name": "ChunkWriter.flush", "original_string": "@Override\n    public void\n    flush()\n            throws IOException\n    {\n        if(mode == RequestMode.DMR)\n            return; // leave to close() to do this\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n    }", "language": "java", "Allcodes": "@Override\n    public void\n    flush()\n            throws IOException\n    {\n        if(mode == RequestMode.DMR)\n            return; // leave to close() to do this\n        if(dmr8 != null) {\n            sendDXR(dmr8);\n            dmr8 = null;\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "flush", "(", ")", "throws", "IOException", "{", "if", "(", "mode", "==", "RequestMode", ".", "DMR", ")", "return", ";", "// leave to close() to do this", "if", "(", "dmr8", "!=", "null", ")", "{", "sendDXR", "(", "dmr8", ")", ";", "dmr8", "=", "null", ";", "}", "}"], "docstring": "Overload flush to also write out the DMR\n\n@throws IOException", "docstring_tokens": ["Overload", "flush", "to", "also", "write", "out", "the", "DMR"]}
{"code": "Collections.sort(result, (o1, o2) -> o1.getCatRelLocation().compareTo(o2.getCatRelLocation()));", "comments": "java 8 lambda, baby", "lines": 7, "repo": "Unidata/thredds", "path": "tdcommon/src/main/java/thredds/server/catalog/tracker/CatalogTracker.java", "func_name": "CatalogTracker.getCatalogs", "original_string": "public Iterable<? extends CatalogExt> getCatalogs() {\n    if (catalogs == null) readCatalogs();\n\n    List<CatalogExt> result = new ArrayList<>();\n    for (CatalogExt ext : catalogs.values())\n      result.add(ext);\n    Collections.sort(result, (o1, o2) -> o1.getCatRelLocation().compareTo(o2.getCatRelLocation()));    // java 8 lambda, baby\n    return result;\n  }", "language": "java", "Allcodes": "public Iterable<? extends CatalogExt> getCatalogs() {\n    if (catalogs == null) readCatalogs();\n\n    List<CatalogExt> result = new ArrayList<>();\n    for (CatalogExt ext : catalogs.values())\n      result.add(ext);\n    Collections.sort(result, (o1, o2) -> o1.getCatRelLocation().compareTo(o2.getCatRelLocation()));    // java 8 lambda, baby\n    return result;\n  }", "code_tokens": ["public", "Iterable", "<", "?", "extends", "CatalogExt", ">", "getCatalogs", "(", ")", "{", "if", "(", "catalogs", "==", "null", ")", "readCatalogs", "(", ")", ";", "List", "<", "CatalogExt", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "CatalogExt", "ext", ":", "catalogs", ".", "values", "(", ")", ")", "result", ".", "(", "ext", ")", ";", "Collections", ".", "sort", "(", "result", ",", "(", "o1", ",", "o2", ")", "->", "o1", ".", "getCatRelLocation", "(", ")", ".", "compareTo", "(", "o2", ".", "getCatRelLocation", "(", ")", ")", ")", ";", "// java 8 lambda, baby", "return", "result", ";", "}"], "docstring": "return sorted catalogs", "docstring_tokens": ["return", "sorted", "catalogs"]}
{"code": "canonicalize();", "comments": "canonicalize thredds metadata", "lines": 25, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.finish", "original_string": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "language": "java", "Allcodes": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "code_tokens": ["public", "boolean", "finish", "(", ")", "{", "boolean", "ok", "=", "true", ";", "java", ".", "util", ".", "Iterator", "iter", ";", "logger", ".", "debug", "(", "\"Now finish \"", "+", "getName", "(", ")", "+", "\" id= \"", "+", "getID", "(", ")", ")", ";", "authorityName", "=", "null", ";", "dataType", "=", "null", ";", "dataFormatType", "=", "null", ";", "defaultService", "=", "null", ";", "gc", "=", "null", ";", "tc", "=", "null", ";", "docs", "=", "new", "ArrayList", "<>", "(", ")", ";", "metadata", "=", "new", "ArrayList", "<>", "(", ")", ";", "properties", "=", "new", "ArrayList", "<>", "(", ")", ";", "creators", "=", "new", "ArrayList", "<>", "(", ")", ";", "contributors", "=", "new", "ArrayList", "<>", "(", ")", ";", "dates", "=", "new", "ArrayList", "<>", "(", ")", ";", "keywords", "=", "new", "ArrayList", "<>", "(", ")", ";", "projects", "=", "new", "ArrayList", "<>", "(", ")", ";", "publishers", "=", "new", "ArrayList", "<>", "(", ")", ";", "variables", "=", "new", "ArrayList", "<>", "(", ")", ";", "canonicalize", "(", ")", ";", "// canonicalize thredds metadata", "transfer2PublicMetadata", "(", "tm", ",", "true", ")", ";", "// add local metadata", "transfer2PublicMetadata", "(", "tmi", ",", "true", ")", ";", "// add local inherited metadata", "transferInheritable2PublicMetadata", "(", "(", "InvDatasetImpl", ")", "getParent", "(", ")", ")", ";", "// add inheritable metadata from parents", "// build the expanded access list", "access", "=", "new", "ArrayList", "<>", "(", ")", ";", "// add access element if urlPath is specified", "if", "(", "(", "urlPath", "!=", "null", ")", "&&", "(", "getServiceDefault", "(", ")", "!=", "null", ")", ")", "{", "InvAccessImpl", "a", "=", "new", "InvAccessImpl", "(", "this", ",", "urlPath", ",", "getServiceDefault", "(", ")", ")", ";", "a", ".", "setSize", "(", "size", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// add local access elements", "iter", "=", "accessLocal", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "InvAccessImpl", "a", "=", "(", "InvAccessImpl", ")", "iter", ".", "next", "(", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// recurse into child datasets.", "if", "(", "!", "(", "this", "instanceof", "InvCatalogRef", ")", ")", "{", "for", "(", "InvDataset", "invDataset", ":", "this", ".", "getDatasets", "(", ")", ")", "{", "InvDatasetImpl", "curDs", "=", "(", "InvDatasetImpl", ")", "invDataset", ";", "ok", "&=", "curDs", ".", "finish", "(", ")", ";", "}", "}", "return", "ok", ";", "}"], "docstring": "Finish constructing after all elements have been added.\nThis does the inheritence thing\nThis can be called again if new elements are added.\n\n@return true if successful.", "docstring_tokens": ["Finish", "constructing", "after", "all", "elements", "have", "been", "added", ".", "This", "does", "the", "inheritence", "thing", "This", "can", "be", "called", "again", "if", "new", "elements", "are", "added", "."]}
{"code": "transfer2PublicMetadata(tm, true);", "comments": "add local metadata", "lines": 26, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.finish", "original_string": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "language": "java", "Allcodes": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "code_tokens": ["public", "boolean", "finish", "(", ")", "{", "boolean", "ok", "=", "true", ";", "java", ".", "util", ".", "Iterator", "iter", ";", "logger", ".", "debug", "(", "\"Now finish \"", "+", "getName", "(", ")", "+", "\" id= \"", "+", "getID", "(", ")", ")", ";", "authorityName", "=", "null", ";", "dataType", "=", "null", ";", "dataFormatType", "=", "null", ";", "defaultService", "=", "null", ";", "gc", "=", "null", ";", "tc", "=", "null", ";", "docs", "=", "new", "ArrayList", "<>", "(", ")", ";", "metadata", "=", "new", "ArrayList", "<>", "(", ")", ";", "properties", "=", "new", "ArrayList", "<>", "(", ")", ";", "creators", "=", "new", "ArrayList", "<>", "(", ")", ";", "contributors", "=", "new", "ArrayList", "<>", "(", ")", ";", "dates", "=", "new", "ArrayList", "<>", "(", ")", ";", "keywords", "=", "new", "ArrayList", "<>", "(", ")", ";", "projects", "=", "new", "ArrayList", "<>", "(", ")", ";", "publishers", "=", "new", "ArrayList", "<>", "(", ")", ";", "variables", "=", "new", "ArrayList", "<>", "(", ")", ";", "canonicalize", "(", ")", ";", "// canonicalize thredds metadata", "transfer2PublicMetadata", "(", "tm", ",", "true", ")", ";", "// add local metadata", "transfer2PublicMetadata", "(", "tmi", ",", "true", ")", ";", "// add local inherited metadata", "transferInheritable2PublicMetadata", "(", "(", "InvDatasetImpl", ")", "getParent", "(", ")", ")", ";", "// add inheritable metadata from parents", "// build the expanded access list", "access", "=", "new", "ArrayList", "<>", "(", ")", ";", "// add access element if urlPath is specified", "if", "(", "(", "urlPath", "!=", "null", ")", "&&", "(", "getServiceDefault", "(", ")", "!=", "null", ")", ")", "{", "InvAccessImpl", "a", "=", "new", "InvAccessImpl", "(", "this", ",", "urlPath", ",", "getServiceDefault", "(", ")", ")", ";", "a", ".", "setSize", "(", "size", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// add local access elements", "iter", "=", "accessLocal", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "InvAccessImpl", "a", "=", "(", "InvAccessImpl", ")", "iter", ".", "next", "(", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// recurse into child datasets.", "if", "(", "!", "(", "this", "instanceof", "InvCatalogRef", ")", ")", "{", "for", "(", "InvDataset", "invDataset", ":", "this", ".", "getDatasets", "(", ")", ")", "{", "InvDatasetImpl", "curDs", "=", "(", "InvDatasetImpl", ")", "invDataset", ";", "ok", "&=", "curDs", ".", "finish", "(", ")", ";", "}", "}", "return", "ok", ";", "}"], "docstring": "Finish constructing after all elements have been added.\nThis does the inheritence thing\nThis can be called again if new elements are added.\n\n@return true if successful.", "docstring_tokens": ["Finish", "constructing", "after", "all", "elements", "have", "been", "added", ".", "This", "does", "the", "inheritence", "thing", "This", "can", "be", "called", "again", "if", "new", "elements", "are", "added", "."]}
{"code": "transfer2PublicMetadata(tmi, true);", "comments": "add local inherited metadata", "lines": 27, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.finish", "original_string": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "language": "java", "Allcodes": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "code_tokens": ["public", "boolean", "finish", "(", ")", "{", "boolean", "ok", "=", "true", ";", "java", ".", "util", ".", "Iterator", "iter", ";", "logger", ".", "debug", "(", "\"Now finish \"", "+", "getName", "(", ")", "+", "\" id= \"", "+", "getID", "(", ")", ")", ";", "authorityName", "=", "null", ";", "dataType", "=", "null", ";", "dataFormatType", "=", "null", ";", "defaultService", "=", "null", ";", "gc", "=", "null", ";", "tc", "=", "null", ";", "docs", "=", "new", "ArrayList", "<>", "(", ")", ";", "metadata", "=", "new", "ArrayList", "<>", "(", ")", ";", "properties", "=", "new", "ArrayList", "<>", "(", ")", ";", "creators", "=", "new", "ArrayList", "<>", "(", ")", ";", "contributors", "=", "new", "ArrayList", "<>", "(", ")", ";", "dates", "=", "new", "ArrayList", "<>", "(", ")", ";", "keywords", "=", "new", "ArrayList", "<>", "(", ")", ";", "projects", "=", "new", "ArrayList", "<>", "(", ")", ";", "publishers", "=", "new", "ArrayList", "<>", "(", ")", ";", "variables", "=", "new", "ArrayList", "<>", "(", ")", ";", "canonicalize", "(", ")", ";", "// canonicalize thredds metadata", "transfer2PublicMetadata", "(", "tm", ",", "true", ")", ";", "// add local metadata", "transfer2PublicMetadata", "(", "tmi", ",", "true", ")", ";", "// add local inherited metadata", "transferInheritable2PublicMetadata", "(", "(", "InvDatasetImpl", ")", "getParent", "(", ")", ")", ";", "// add inheritable metadata from parents", "// build the expanded access list", "access", "=", "new", "ArrayList", "<>", "(", ")", ";", "// add access element if urlPath is specified", "if", "(", "(", "urlPath", "!=", "null", ")", "&&", "(", "getServiceDefault", "(", ")", "!=", "null", ")", ")", "{", "InvAccessImpl", "a", "=", "new", "InvAccessImpl", "(", "this", ",", "urlPath", ",", "getServiceDefault", "(", ")", ")", ";", "a", ".", "setSize", "(", "size", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// add local access elements", "iter", "=", "accessLocal", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "InvAccessImpl", "a", "=", "(", "InvAccessImpl", ")", "iter", ".", "next", "(", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// recurse into child datasets.", "if", "(", "!", "(", "this", "instanceof", "InvCatalogRef", ")", ")", "{", "for", "(", "InvDataset", "invDataset", ":", "this", ".", "getDatasets", "(", ")", ")", "{", "InvDatasetImpl", "curDs", "=", "(", "InvDatasetImpl", ")", "invDataset", ";", "ok", "&=", "curDs", ".", "finish", "(", ")", ";", "}", "}", "return", "ok", ";", "}"], "docstring": "Finish constructing after all elements have been added.\nThis does the inheritence thing\nThis can be called again if new elements are added.\n\n@return true if successful.", "docstring_tokens": ["Finish", "constructing", "after", "all", "elements", "have", "been", "added", ".", "This", "does", "the", "inheritence", "thing", "This", "can", "be", "called", "again", "if", "new", "elements", "are", "added", "."]}
{"code": "transferInheritable2PublicMetadata((InvDatasetImpl) getParent());", "comments": "add inheritable metadata from parents", "lines": 28, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.finish", "original_string": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "language": "java", "Allcodes": "public boolean finish() {\n    boolean ok = true;\n    java.util.Iterator iter;\n    logger.debug(\"Now finish \" + getName() + \" id= \" + getID());\n\n    authorityName = null;\n    dataType = null;\n    dataFormatType = null;\n    defaultService = null;\n\n    gc = null;\n    tc = null;\n    docs = new ArrayList<>();\n    metadata = new ArrayList<>();\n    properties = new ArrayList<>();\n\n    creators = new ArrayList<>();\n    contributors = new ArrayList<>();\n    dates = new ArrayList<>();\n    keywords = new ArrayList<>();\n    projects = new ArrayList<>();\n    publishers = new ArrayList<>();\n    variables = new ArrayList<>();\n\n    canonicalize(); // canonicalize thredds metadata\n    transfer2PublicMetadata(tm, true); // add local metadata\n    transfer2PublicMetadata(tmi, true); // add local inherited metadata\n    transferInheritable2PublicMetadata((InvDatasetImpl) getParent()); // add inheritable metadata from parents\n\n    // build the expanded access list\n    access = new ArrayList<>();\n\n    // add access element if urlPath is specified\n    if ((urlPath != null) && (getServiceDefault() != null)) {\n      InvAccessImpl a = new InvAccessImpl(this, urlPath, getServiceDefault());\n      a.setSize(size);\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // add local access elements\n    iter = accessLocal.iterator();\n    while (iter.hasNext()) {\n      InvAccessImpl a = (InvAccessImpl) iter.next();\n      a.finish();\n      addExpandedAccess(a);\n    }\n\n    // recurse into child datasets.\n    if (!(this instanceof InvCatalogRef)) {\n      for (InvDataset invDataset : this.getDatasets()) {\n        InvDatasetImpl curDs = (InvDatasetImpl) invDataset;\n        ok &= curDs.finish();\n      }\n    }\n\n    return ok;\n  }", "code_tokens": ["public", "boolean", "finish", "(", ")", "{", "boolean", "ok", "=", "true", ";", "java", ".", "util", ".", "Iterator", "iter", ";", "logger", ".", "debug", "(", "\"Now finish \"", "+", "getName", "(", ")", "+", "\" id= \"", "+", "getID", "(", ")", ")", ";", "authorityName", "=", "null", ";", "dataType", "=", "null", ";", "dataFormatType", "=", "null", ";", "defaultService", "=", "null", ";", "gc", "=", "null", ";", "tc", "=", "null", ";", "docs", "=", "new", "ArrayList", "<>", "(", ")", ";", "metadata", "=", "new", "ArrayList", "<>", "(", ")", ";", "properties", "=", "new", "ArrayList", "<>", "(", ")", ";", "creators", "=", "new", "ArrayList", "<>", "(", ")", ";", "contributors", "=", "new", "ArrayList", "<>", "(", ")", ";", "dates", "=", "new", "ArrayList", "<>", "(", ")", ";", "keywords", "=", "new", "ArrayList", "<>", "(", ")", ";", "projects", "=", "new", "ArrayList", "<>", "(", ")", ";", "publishers", "=", "new", "ArrayList", "<>", "(", ")", ";", "variables", "=", "new", "ArrayList", "<>", "(", ")", ";", "canonicalize", "(", ")", ";", "// canonicalize thredds metadata", "transfer2PublicMetadata", "(", "tm", ",", "true", ")", ";", "// add local metadata", "transfer2PublicMetadata", "(", "tmi", ",", "true", ")", ";", "// add local inherited metadata", "transferInheritable2PublicMetadata", "(", "(", "InvDatasetImpl", ")", "getParent", "(", ")", ")", ";", "// add inheritable metadata from parents", "// build the expanded access list", "access", "=", "new", "ArrayList", "<>", "(", ")", ";", "// add access element if urlPath is specified", "if", "(", "(", "urlPath", "!=", "null", ")", "&&", "(", "getServiceDefault", "(", ")", "!=", "null", ")", ")", "{", "InvAccessImpl", "a", "=", "new", "InvAccessImpl", "(", "this", ",", "urlPath", ",", "getServiceDefault", "(", ")", ")", ";", "a", ".", "setSize", "(", "size", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// add local access elements", "iter", "=", "accessLocal", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "InvAccessImpl", "a", "=", "(", "InvAccessImpl", ")", "iter", ".", "next", "(", ")", ";", "a", ".", "finish", "(", ")", ";", "addExpandedAccess", "(", "a", ")", ";", "}", "// recurse into child datasets.", "if", "(", "!", "(", "this", "instanceof", "InvCatalogRef", ")", ")", "{", "for", "(", "InvDataset", "invDataset", ":", "this", ".", "getDatasets", "(", ")", ")", "{", "InvDatasetImpl", "curDs", "=", "(", "InvDatasetImpl", ")", "invDataset", ";", "ok", "&=", "curDs", ".", "finish", "(", ")", ";", "}", "}", "return", "ok", ";", "}"], "docstring": "Finish constructing after all elements have been added.\nThis does the inheritence thing\nThis can be called again if new elements are added.\n\n@return true if successful.", "docstring_tokens": ["Finish", "constructing", "after", "all", "elements", "have", "been", "added", ".", "This", "does", "the", "inheritence", "thing", "This", "can", "be", "called", "again", "if", "new", "elements", "are", "added", "."]}
{"code": "meta.finish();", "comments": "make sure XLink is read in.", "lines": 18, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.transferInheritable2PublicMetadata", "original_string": "private void transferInheritable2PublicMetadata(InvDatasetImpl parent) {\n    if (parent == null) return;\n    logger.debug(\" inheritFromParent= \" + parent.getID());\n\n    transfer2PublicMetadata(parent.getLocalMetadataInheritable(), true);\n    //transfer2PublicMetadata(parent.getCat6Metadata(), true);\n\n    /* look through local metadata, find inherited InvMetadata elements\n    ThreddsMetadata tmd = parent.getLocalMetadata();\n    Iterator iter = tmd.getMetadata().iterator();\n    while (iter.hasNext()) {\n      InvMetadata meta = (InvMetadata) iter.next();\n      if (meta.isInherited()) {\n        if (!meta.isThreddsMetadata()) {\n          metadata.add(meta);\n        } else {\n          if (debugInherit) System.out.println(\"  inheritMetadata Element \" + tmd.isInherited() + \" \" + meta.isInherited());\n          meta.finish(); // make sure XLink is read in.\n          transfer2PublicMetadata(meta.getThreddsMetadata(), false);\n        }\n      }\n    } */\n\n    // recurse\n    transferInheritable2PublicMetadata((InvDatasetImpl) parent.getParent());\n  }", "language": "java", "Allcodes": "private void transferInheritable2PublicMetadata(InvDatasetImpl parent) {\n    if (parent == null) return;\n    logger.debug(\" inheritFromParent= \" + parent.getID());\n\n    transfer2PublicMetadata(parent.getLocalMetadataInheritable(), true);\n    //transfer2PublicMetadata(parent.getCat6Metadata(), true);\n\n    /* look through local metadata, find inherited InvMetadata elements\n    ThreddsMetadata tmd = parent.getLocalMetadata();\n    Iterator iter = tmd.getMetadata().iterator();\n    while (iter.hasNext()) {\n      InvMetadata meta = (InvMetadata) iter.next();\n      if (meta.isInherited()) {\n        if (!meta.isThreddsMetadata()) {\n          metadata.add(meta);\n        } else {\n          if (debugInherit) System.out.println(\"  inheritMetadata Element \" + tmd.isInherited() + \" \" + meta.isInherited());\n          meta.finish(); // make sure XLink is read in.\n          transfer2PublicMetadata(meta.getThreddsMetadata(), false);\n        }\n      }\n    } */\n\n    // recurse\n    transferInheritable2PublicMetadata((InvDatasetImpl) parent.getParent());\n  }", "code_tokens": ["private", "void", "transferInheritable2PublicMetadata", "(", "InvDatasetImpl", "parent", ")", "{", "if", "(", "parent", "==", "null", ")", "return", ";", "logger", ".", "debug", "(", "\" inheritFromParent= \"", "+", "parent", ".", "getID", "(", ")", ")", ";", "transfer2PublicMetadata", "(", "parent", ".", "getLocalMetadataInheritable", "(", ")", ",", "true", ")", ";", "//transfer2PublicMetadata(parent.getCat6Metadata(), true);", "/* look through local metadata, find inherited InvMetadata elements\n    ThreddsMetadata tmd = parent.getLocalMetadata();\n    Iterator iter = tmd.getMetadata().iterator();\n    while (iter.hasNext()) {\n      InvMetadata meta = (InvMetadata) iter.next();\n      if (meta.isInherited()) {\n        if (!meta.isThreddsMetadata()) {\n          metadata.add(meta);\n        } else {\n          if (debugInherit) System.out.println(\"  inheritMetadata Element \" + tmd.isInherited() + \" \" + meta.isInherited());\n          meta.finish(); // make sure XLink is read in.\n          transfer2PublicMetadata(meta.getThreddsMetadata(), false);\n        }\n      }\n    } */", "// recurse", "transferInheritable2PublicMetadata", "(", "(", "InvDatasetImpl", ")", "parent", ".", "getParent", "(", ")", ")", ";", "}"], "docstring": "Look for InvMetadata elements in the parent that need to be added to the public metadata of this dataset.\nRecurse up through all ancestors.\n\n@param parent transfer from here", "docstring_tokens": ["Look", "for", "InvMetadata", "elements", "in", "the", "parent", "that", "need", "to", "be", "added", "to", "the", "public", "metadata", "of", "this", "dataset", ".", "Recurse", "up", "through", "all", "ancestors", "."]}
{"code": "meta.finish();", "comments": "LOOK ?? make sure XLink is read in.", "lines": 18, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.transferInheritableMetadata", "original_string": "private void transferInheritableMetadata(InvDatasetImpl fromDs, ThreddsMetadata target,\n                                           boolean copyInheritedMetadataFromParents) {\n    if (fromDs == null) return;\n    logger.debug(\" transferInheritedMetadata= \" + fromDs.getName());\n\n    target.add(fromDs.getLocalMetadataInheritable(), true);\n\n    /* look through local metadata, find inherited InvMetadata elements\n    ThreddsMetadata tmd = fromDs.getLocalMetadata();\n    Iterator iter = tmd.getMetadata().iterator();\n    while (iter.hasNext()) {\n      InvMetadata meta = (InvMetadata) iter.next();\n      if (meta.isInherited()) {\n        if (!meta.isThreddsMetadata()) {\n          tmc.addMetadata( meta);\n        } else {\n          logger.debug(\"  transferInheritedMetadata \"+meta.hashCode()+\" = \"+meta);\n          meta.finish(); // LOOK ?? make sure XLink is read in.\n          tmc.add( meta.getThreddsMetadata(), true);\n        }\n      }\n    }   */\n\n    // now do the same for the parents\n    if (copyInheritedMetadataFromParents)\n      transferInheritableMetadata((InvDatasetImpl) fromDs.getParent(), target, true);\n  }", "language": "java", "Allcodes": "private void transferInheritableMetadata(InvDatasetImpl fromDs, ThreddsMetadata target,\n                                           boolean copyInheritedMetadataFromParents) {\n    if (fromDs == null) return;\n    logger.debug(\" transferInheritedMetadata= \" + fromDs.getName());\n\n    target.add(fromDs.getLocalMetadataInheritable(), true);\n\n    /* look through local metadata, find inherited InvMetadata elements\n    ThreddsMetadata tmd = fromDs.getLocalMetadata();\n    Iterator iter = tmd.getMetadata().iterator();\n    while (iter.hasNext()) {\n      InvMetadata meta = (InvMetadata) iter.next();\n      if (meta.isInherited()) {\n        if (!meta.isThreddsMetadata()) {\n          tmc.addMetadata( meta);\n        } else {\n          logger.debug(\"  transferInheritedMetadata \"+meta.hashCode()+\" = \"+meta);\n          meta.finish(); // LOOK ?? make sure XLink is read in.\n          tmc.add( meta.getThreddsMetadata(), true);\n        }\n      }\n    }   */\n\n    // now do the same for the parents\n    if (copyInheritedMetadataFromParents)\n      transferInheritableMetadata((InvDatasetImpl) fromDs.getParent(), target, true);\n  }", "code_tokens": ["private", "void", "transferInheritableMetadata", "(", "InvDatasetImpl", "fromDs", ",", "ThreddsMetadata", "target", ",", "boolean", "copyInheritedMetadataFromParents", ")", "{", "if", "(", "fromDs", "==", "null", ")", "return", ";", "logger", ".", "debug", "(", "\" transferInheritedMetadata= \"", "+", "fromDs", ".", "getName", "(", ")", ")", ";", "target", ".", "add", "(", "fromDs", ".", "getLocalMetadataInheritable", "(", ")", ",", "true", ")", ";", "/* look through local metadata, find inherited InvMetadata elements\n    ThreddsMetadata tmd = fromDs.getLocalMetadata();\n    Iterator iter = tmd.getMetadata().iterator();\n    while (iter.hasNext()) {\n      InvMetadata meta = (InvMetadata) iter.next();\n      if (meta.isInherited()) {\n        if (!meta.isThreddsMetadata()) {\n          tmc.addMetadata( meta);\n        } else {\n          logger.debug(\"  transferInheritedMetadata \"+meta.hashCode()+\" = \"+meta);\n          meta.finish(); // LOOK ?? make sure XLink is read in.\n          tmc.add( meta.getThreddsMetadata(), true);\n        }\n      }\n    }   */", "// now do the same for the parents", "if", "(", "copyInheritedMetadataFromParents", ")", "transferInheritableMetadata", "(", "(", "InvDatasetImpl", ")", "fromDs", ".", "getParent", "(", ")", ",", "target", ",", "true", ")", ";", "}"], "docstring": "transfer inherited metadata, consolidating it into target\n\n@param fromDs transfer from here, plus its parents\n@param target transfer to here", "docstring_tokens": ["transfer", "inherited", "metadata", "consolidating", "it", "into", "target"]}
{"code": "hashCode = 0;", "comments": "Need to recalculate the hash code.", "lines": 6, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/InvDatasetImpl.java", "func_name": "InvDatasetImpl.removeLocalMetadata", "original_string": "public boolean removeLocalMetadata(InvMetadata metadata) {\n    InvDatasetImpl parentDataset = ((InvDatasetImpl) metadata.getParentDataset());\n    List localMdata = parentDataset.getLocalMetadata().getMetadata();\n    if (localMdata.contains(metadata)) {\n      if (localMdata.remove(metadata)) {\n        hashCode = 0; // Need to recalculate the hash code.\n        return (true);\n      }\n    }\n    return (false);\n  }", "language": "java", "Allcodes": "public boolean removeLocalMetadata(InvMetadata metadata) {\n    InvDatasetImpl parentDataset = ((InvDatasetImpl) metadata.getParentDataset());\n    List localMdata = parentDataset.getLocalMetadata().getMetadata();\n    if (localMdata.contains(metadata)) {\n      if (localMdata.remove(metadata)) {\n        hashCode = 0; // Need to recalculate the hash code.\n        return (true);\n      }\n    }\n    return (false);\n  }", "code_tokens": ["public", "boolean", "removeLocalMetadata", "(", "InvMetadata", "metadata", ")", "{", "InvDatasetImpl", "parentDataset", "=", "(", "(", "InvDatasetImpl", ")", "metadata", ".", "getParentDataset", "(", ")", ")", ";", "List", "localMdata", "=", "parentDataset", ".", "getLocalMetadata", "(", ")", ".", "getMetadata", "(", ")", ";", "if", "(", "localMdata", ".", "contains", "(", "metadata", ")", ")", "{", "if", "(", "localMdata", ".", "remove", "(", "metadata", ")", ")", "{", "hashCode", "=", "0", ";", "// Need to recalculate the hash code.", "return", "(", "true", ")", ";", "}", "}", "return", "(", "false", ")", ";", "}"], "docstring": "Remove the given InvMetadata from the set of metadata local to this dataset.\n\n@param metadata remove this\n@return true if an InvMetadata is removed, false otherwise.", "docstring_tokens": ["Remove", "the", "given", "InvMetadata", "from", "the", "set", "of", "metadata", "local", "to", "this", "dataset", "."]}
{"code": "subCounters = new HashMap<DataDescriptor, BitCounterUncompressed[]>(5);", "comments": "assumes DataDescriptor.equals is ==", "lines": 3, "repo": "Unidata/thredds", "path": "bufr/src/main/java/ucar/nc2/iosp/bufr/BitCounterUncompressed.java", "func_name": "BitCounterUncompressed.makeNested", "original_string": "public BitCounterUncompressed makeNested(DataDescriptor subKey, int n, int row, int replicationCountSize) {\r\n    if (subCounters == null)\r\n      subCounters = new HashMap<DataDescriptor, BitCounterUncompressed[]>(5); // assumes DataDescriptor.equals is ==\r\n\r\n    BitCounterUncompressed[] subCounter = subCounters.get(subKey);\r\n    if (subCounter == null) {\r\n      subCounter = new BitCounterUncompressed[nrows]; // one for each row in this table\r\n      subCounters.put(subKey, subCounter);\r\n    }\r\n\r\n    BitCounterUncompressed rc = new BitCounterUncompressed(subKey, n, replicationCountSize);\r\n    subCounter[row] = rc;\r\n\r\n    return rc;\r\n  }", "language": "java", "Allcodes": "public BitCounterUncompressed makeNested(DataDescriptor subKey, int n, int row, int replicationCountSize) {\r\n    if (subCounters == null)\r\n      subCounters = new HashMap<DataDescriptor, BitCounterUncompressed[]>(5); // assumes DataDescriptor.equals is ==\r\n\r\n    BitCounterUncompressed[] subCounter = subCounters.get(subKey);\r\n    if (subCounter == null) {\r\n      subCounter = new BitCounterUncompressed[nrows]; // one for each row in this table\r\n      subCounters.put(subKey, subCounter);\r\n    }\r\n\r\n    BitCounterUncompressed rc = new BitCounterUncompressed(subKey, n, replicationCountSize);\r\n    subCounter[row] = rc;\r\n\r\n    return rc;\r\n  }", "code_tokens": ["public", "BitCounterUncompressed", "makeNested", "(", "DataDescriptor", "subKey", ",", "int", "n", ",", "int", "row", ",", "int", "replicationCountSize", ")", "{", "if", "(", "subCounters", "==", "null", ")", "subCounters", "=", "new", "HashMap", "<", "DataDescriptor", ",", "BitCounterUncompressed", "[", "]", ">", "(", "5", ")", ";", "// assumes DataDescriptor.equals is ==\r", "BitCounterUncompressed", "[", "]", "subCounter", "=", "subCounters", ".", "get", "(", "subKey", ")", ";", "if", "(", "subCounter", "==", "null", ")", "{", "subCounter", "=", "new", "BitCounterUncompressed", "[", "nrows", "]", ";", "// one for each row in this table\r", "subCounters", ".", "put", "(", "subKey", ",", "subCounter", ")", ";", "}", "BitCounterUncompressed", "rc", "=", "new", "BitCounterUncompressed", "(", "subKey", ",", "n", ",", "replicationCountSize", ")", ";", "subCounter", "[", "row", "]", "=", "rc", ";", "return", "rc", ";", "}"], "docstring": "Track nested Tables.\n@param subKey  subKey is a structure or a sequence - so itself has subKeys\n@param n numbers of rows in the nested table\n@param row which row in the parent Table this belongs to\n@param replicationCountSize number of bits taken up by the count (non-zero for sequences)\n@return  nested ReplicationCounter", "docstring_tokens": ["Track", "nested", "Tables", "."]}
{"code": "subCounter = new BitCounterUncompressed[nrows];", "comments": "one for each row in this table", "lines": 7, "repo": "Unidata/thredds", "path": "bufr/src/main/java/ucar/nc2/iosp/bufr/BitCounterUncompressed.java", "func_name": "BitCounterUncompressed.makeNested", "original_string": "public BitCounterUncompressed makeNested(DataDescriptor subKey, int n, int row, int replicationCountSize) {\r\n    if (subCounters == null)\r\n      subCounters = new HashMap<DataDescriptor, BitCounterUncompressed[]>(5); // assumes DataDescriptor.equals is ==\r\n\r\n    BitCounterUncompressed[] subCounter = subCounters.get(subKey);\r\n    if (subCounter == null) {\r\n      subCounter = new BitCounterUncompressed[nrows]; // one for each row in this table\r\n      subCounters.put(subKey, subCounter);\r\n    }\r\n\r\n    BitCounterUncompressed rc = new BitCounterUncompressed(subKey, n, replicationCountSize);\r\n    subCounter[row] = rc;\r\n\r\n    return rc;\r\n  }", "language": "java", "Allcodes": "public BitCounterUncompressed makeNested(DataDescriptor subKey, int n, int row, int replicationCountSize) {\r\n    if (subCounters == null)\r\n      subCounters = new HashMap<DataDescriptor, BitCounterUncompressed[]>(5); // assumes DataDescriptor.equals is ==\r\n\r\n    BitCounterUncompressed[] subCounter = subCounters.get(subKey);\r\n    if (subCounter == null) {\r\n      subCounter = new BitCounterUncompressed[nrows]; // one for each row in this table\r\n      subCounters.put(subKey, subCounter);\r\n    }\r\n\r\n    BitCounterUncompressed rc = new BitCounterUncompressed(subKey, n, replicationCountSize);\r\n    subCounter[row] = rc;\r\n\r\n    return rc;\r\n  }", "code_tokens": ["public", "BitCounterUncompressed", "makeNested", "(", "DataDescriptor", "subKey", ",", "int", "n", ",", "int", "row", ",", "int", "replicationCountSize", ")", "{", "if", "(", "subCounters", "==", "null", ")", "subCounters", "=", "new", "HashMap", "<", "DataDescriptor", ",", "BitCounterUncompressed", "[", "]", ">", "(", "5", ")", ";", "// assumes DataDescriptor.equals is ==\r", "BitCounterUncompressed", "[", "]", "subCounter", "=", "subCounters", ".", "get", "(", "subKey", ")", ";", "if", "(", "subCounter", "==", "null", ")", "{", "subCounter", "=", "new", "BitCounterUncompressed", "[", "nrows", "]", ";", "// one for each row in this table\r", "subCounters", ".", "put", "(", "subKey", ",", "subCounter", ")", ";", "}", "BitCounterUncompressed", "rc", "=", "new", "BitCounterUncompressed", "(", "subKey", ",", "n", ",", "replicationCountSize", ")", ";", "subCounter", "[", "row", "]", "=", "rc", ";", "return", "rc", ";", "}"], "docstring": "Track nested Tables.\n@param subKey  subKey is a structure or a sequence - so itself has subKeys\n@param n numbers of rows in the nested table\n@param row which row in the parent Table this belongs to\n@param replicationCountSize number of bits taken up by the count (non-zero for sequences)\n@return  nested ReplicationCounter", "docstring_tokens": ["Track", "nested", "Tables", "."]}
{"code": "int remove = Math.max(removeIncr, count - nlines);", "comments": "nlines may have changed", "lines": 5, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/TextHistoryPane.java", "func_name": "TextHistoryPane.appendLine", "original_string": "public void appendLine( String line) {\n\n    if (count >= nlines) {\n      try {\n        int remove = Math.max(removeIncr, count - nlines); // nlines may have changed\n        int offset = ta.getLineEndOffset( remove);\n        ta.replaceRange( \"\", 0, offset);\n      } catch (Exception e) {\n        log.error(\"Problem in TextHistoryPane\", e);\n      }\n      count = nlines - removeIncr;\n    }\n    ta.append(line);\n    ta.append(\"\\n\");\n    count++;\n\n    // scroll to end\n    ta.setCaretPosition(ta.getText().length());\n  }", "language": "java", "Allcodes": "public void appendLine( String line) {\n\n    if (count >= nlines) {\n      try {\n        int remove = Math.max(removeIncr, count - nlines); // nlines may have changed\n        int offset = ta.getLineEndOffset( remove);\n        ta.replaceRange( \"\", 0, offset);\n      } catch (Exception e) {\n        log.error(\"Problem in TextHistoryPane\", e);\n      }\n      count = nlines - removeIncr;\n    }\n    ta.append(line);\n    ta.append(\"\\n\");\n    count++;\n\n    // scroll to end\n    ta.setCaretPosition(ta.getText().length());\n  }", "code_tokens": ["public", "void", "appendLine", "(", "String", "line", ")", "{", "if", "(", "count", ">=", "nlines", ")", "{", "try", "{", "int", "remove", "=", "Math", ".", "max", "(", "removeIncr", ",", "count", "-", "nlines", ")", ";", "// nlines may have changed", "int", "offset", "=", "ta", ".", "getLineEndOffset", "(", "remove", ")", ";", "ta", ".", "replaceRange", "(", "\"\"", ",", "0", ",", "offset", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "log", ".", "error", "(", "\"Problem in TextHistoryPane\"", ",", "e", ")", ";", "}", "count", "=", "nlines", "-", "removeIncr", ";", "}", "ta", ".", "append", "(", "line", ")", ";", "ta", ".", "append", "(", "\"\\n\"", ")", ";", "count", "++", ";", "// scroll to end", "ta", ".", "setCaretPosition", "(", "ta", ".", "getText", "(", ")", ".", "length", "(", ")", ")", ";", "}"], "docstring": "Append this line to the bottom of the JTextArea.\nA newline is added and JTextArea is scrolled to bottom;\nremove lines at top if needed.\n@param line append this line. Ok to have multiple lines (ie embedded newlines)\nbut not too many.", "docstring_tokens": ["Append", "this", "line", "to", "the", "bottom", "of", "the", "JTextArea", ".", "A", "newline", "is", "added", "and", "JTextArea", "is", "scrolled", "to", "bottom", ";", "remove", "lines", "at", "top", "if", "needed", "."]}
{"code": "DsgFeatureCollection fc = list.get(0);", "comments": "LOOK maybe should pass in the dsg?", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/writer/FeatureDatasetCapabilitiesWriter.java", "func_name": "FeatureDatasetCapabilitiesWriter.makeStationCollectionDocument", "original_string": "public Document makeStationCollectionDocument(LatLonRect bb, String[] names) throws IOException {\r\n\r\n    List<DsgFeatureCollection> list = fdp.getPointFeatureCollectionList();\r\n    DsgFeatureCollection fc = list.get(0); // LOOK maybe should pass in the dsg?\r\n\r\n    if (!(fc instanceof StationTimeSeriesFeatureCollection)) {\r\n      throw new UnsupportedOperationException(fc.getClass().getName() + \" not a StationTimeSeriesFeatureCollection\");\r\n    }\r\n    StationTimeSeriesFeatureCollection sobs = (StationTimeSeriesFeatureCollection) fc;\r\n\r\n    Element rootElem = new Element(\"stationCollection\");\r\n    Document doc = new Document(rootElem);\r\n\r\n    List<StationFeature> stations;\r\n    if (bb != null)\r\n      stations = sobs.getStationFeatures(bb);\r\n    else if (names != null)\r\n      stations = sobs.getStationFeatures(Arrays.asList(names));\r\n    else\r\n      stations = sobs.getStationFeatures();\r\n\r\n    for (Station s : stations) {\r\n      Element sElem = new Element(\"station\");\r\n      sElem.setAttribute(\"name\", s.getName());\r\n      if (s.getWmoId() != null)\r\n        sElem.setAttribute(\"wmo_id\", s.getWmoId());\r\n      if ((s.getDescription() != null) && (s.getDescription().length() > 0))\r\n        sElem.addContent(new Element(\"description\").addContent(s.getDescription()));\r\n\r\n      sElem.addContent(new Element(\"longitude\").addContent(Double.toString(s.getLongitude())));\r\n      sElem.addContent(new Element(\"latitide\").addContent(Double.toString(s.getLatitude())));\r\n      if (!Double.isNaN(s.getAltitude()))\r\n        sElem.addContent(new Element(\"altitude\").addContent(Double.toString(s.getAltitude())));\r\n      rootElem.addContent(sElem);\r\n    }\r\n\r\n    return doc;\r\n  }", "language": "java", "Allcodes": "public Document makeStationCollectionDocument(LatLonRect bb, String[] names) throws IOException {\r\n\r\n    List<DsgFeatureCollection> list = fdp.getPointFeatureCollectionList();\r\n    DsgFeatureCollection fc = list.get(0); // LOOK maybe should pass in the dsg?\r\n\r\n    if (!(fc instanceof StationTimeSeriesFeatureCollection)) {\r\n      throw new UnsupportedOperationException(fc.getClass().getName() + \" not a StationTimeSeriesFeatureCollection\");\r\n    }\r\n    StationTimeSeriesFeatureCollection sobs = (StationTimeSeriesFeatureCollection) fc;\r\n\r\n    Element rootElem = new Element(\"stationCollection\");\r\n    Document doc = new Document(rootElem);\r\n\r\n    List<StationFeature> stations;\r\n    if (bb != null)\r\n      stations = sobs.getStationFeatures(bb);\r\n    else if (names != null)\r\n      stations = sobs.getStationFeatures(Arrays.asList(names));\r\n    else\r\n      stations = sobs.getStationFeatures();\r\n\r\n    for (Station s : stations) {\r\n      Element sElem = new Element(\"station\");\r\n      sElem.setAttribute(\"name\", s.getName());\r\n      if (s.getWmoId() != null)\r\n        sElem.setAttribute(\"wmo_id\", s.getWmoId());\r\n      if ((s.getDescription() != null) && (s.getDescription().length() > 0))\r\n        sElem.addContent(new Element(\"description\").addContent(s.getDescription()));\r\n\r\n      sElem.addContent(new Element(\"longitude\").addContent(Double.toString(s.getLongitude())));\r\n      sElem.addContent(new Element(\"latitide\").addContent(Double.toString(s.getLatitude())));\r\n      if (!Double.isNaN(s.getAltitude()))\r\n        sElem.addContent(new Element(\"altitude\").addContent(Double.toString(s.getAltitude())));\r\n      rootElem.addContent(sElem);\r\n    }\r\n\r\n    return doc;\r\n  }", "code_tokens": ["public", "Document", "makeStationCollectionDocument", "(", "LatLonRect", "bb", ",", "String", "[", "]", "names", ")", "throws", "IOException", "{", "List", "<", "DsgFeatureCollection", ">", "list", "=", "fdp", ".", "getPointFeatureCollectionList", "(", ")", ";", "DsgFeatureCollection", "fc", "=", "list", ".", "get", "(", "0", ")", ";", "// LOOK maybe should pass in the dsg?\r", "if", "(", "!", "(", "fc", "instanceof", "StationTimeSeriesFeatureCollection", ")", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "fc", ".", "getClass", "(", ")", ".", "getName", "(", ")", "+", "\" not a StationTimeSeriesFeatureCollection\"", ")", ";", "}", "StationTimeSeriesFeatureCollection", "sobs", "=", "(", "StationTimeSeriesFeatureCollection", ")", "fc", ";", "Element", "rootElem", "=", "new", "Element", "(", "\"stationCollection\"", ")", ";", "Document", "doc", "=", "new", "Document", "(", "rootElem", ")", ";", "List", "<", "StationFeature", ">", "stations", ";", "if", "(", "bb", "!=", "null", ")", "stations", "=", "sobs", ".", "getStationFeatures", "(", "bb", ")", ";", "else", "if", "(", "names", "!=", "null", ")", "stations", "=", "sobs", ".", "getStationFeatures", "(", "Arrays", ".", "asList", "(", "names", ")", ")", ";", "else", "stations", "=", "sobs", ".", "getStationFeatures", "(", ")", ";", "for", "(", "Station", "s", ":", "stations", ")", "{", "Element", "sElem", "=", "new", "Element", "(", "\"station\"", ")", ";", "sElem", ".", "setAttribute", "(", "\"name\"", ",", "s", ".", "getName", "(", ")", ")", ";", "if", "(", "s", ".", "getWmoId", "(", ")", "!=", "null", ")", "sElem", ".", "setAttribute", "(", "\"wmo_id\"", ",", "s", ".", "getWmoId", "(", ")", ")", ";", "if", "(", "(", "s", ".", "getDescription", "(", ")", "!=", "null", ")", "&&", "(", "s", ".", "getDescription", "(", ")", ".", "length", "(", ")", ">", "0", ")", ")", "sElem", ".", "addContent", "(", "new", "Element", "(", "\"description\"", ")", ".", "addContent", "(", "s", ".", "getDescription", "(", ")", ")", ")", ";", "sElem", ".", "addContent", "(", "new", "Element", "(", "\"longitude\"", ")", ".", "addContent", "(", "Double", ".", "toString", "(", "s", ".", "getLongitude", "(", ")", ")", ")", ")", ";", "sElem", ".", "addContent", "(", "new", "Element", "(", "\"latitide\"", ")", ".", "addContent", "(", "Double", ".", "toString", "(", "s", ".", "getLatitude", "(", ")", ")", ")", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "s", ".", "getAltitude", "(", ")", ")", ")", "sElem", ".", "addContent", "(", "new", "Element", "(", "\"altitude\"", ")", ".", "addContent", "(", "Double", ".", "toString", "(", "s", ".", "getAltitude", "(", ")", ")", ")", ")", ";", "rootElem", ".", "addContent", "(", "sElem", ")", ";", "}", "return", "doc", ";", "}"], "docstring": "Create an XML document for the stations in this dataset, possible subsetted by bb.\nMust be a station dataset.\n\n@param bb    restrict stations to this bounding box, may be null\n@param names restrict stations to these names, may be null\n@return XML document for the stations\n@throws IOException on read error", "docstring_tokens": ["Create", "an", "XML", "document", "for", "the", "stations", "in", "this", "dataset", "possible", "subsetted", "by", "bb", ".", "Must", "be", "a", "station", "dataset", "."]}
{"code": "Element drElem = new Element(\"TimeSpan\");", "comments": "from KML", "lines": 41, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/writer/FeatureDatasetCapabilitiesWriter.java", "func_name": "FeatureDatasetCapabilitiesWriter.getCapabilitiesDocument", "original_string": "public Document getCapabilitiesDocument() {\r\n    Element rootElem = new Element(\"capabilities\");\r\n    Document doc = new Document(rootElem);\r\n    if (null != path) {\r\n      rootElem.setAttribute(\"location\", path);\r\n      Element elem = new Element(\"featureDataset\");\r\n      FeatureType ft = fdp.getFeatureType();\r\n      elem.setAttribute(\"type\", ft.toString().toLowerCase());\r\n      String url = path.replace(\"dataset.xml\", ft.toString().toLowerCase() + \".xml\");\r\n      elem.setAttribute(\"url\", url);\r\n      rootElem.addContent(elem);\r\n    }\r\n\r\n    List<DsgFeatureCollection> list = fdp.getPointFeatureCollectionList();\r\n    DsgFeatureCollection fc = list.get(0); // LOOK maybe should pass in the dsg?\r\n\r\n    rootElem.addContent(writeTimeUnit(fc.getTimeUnit()));\r\n    rootElem.addContent(new Element(\"AltitudeUnits\").addContent(fc.getAltUnits()));\r\n\r\n    // data variables\r\n    List<? extends VariableSimpleIF> vars = fdp.getDataVariables();\r\n    Collections.sort(vars);\r\n    for (VariableSimpleIF v : vars) {\r\n      rootElem.addContent(writeVariable(v));\r\n    }\r\n\r\n    /* CollectionInfo info;\r\n    try {\r\n      info = new DsgCollectionHelper(fc).calcBounds();\r\n    } catch (IOException e) {\r\n      throw new RuntimeException(e);\r\n    } */\r\n\r\n    LatLonRect bb = fc.getBoundingBox();\r\n    if (bb != null)\r\n      rootElem.addContent(writeBoundingBox(bb));\r\n\r\n    // add date range\r\n    CalendarDateRange dateRange = fc.getCalendarDateRange();\r\n    if (dateRange != null) {\r\n      Element drElem = new Element(\"TimeSpan\"); // from KML\r\n      drElem.addContent(new Element(\"begin\").addContent(dateRange.getStart().toString()));\r\n      drElem.addContent(new Element(\"end\").addContent(dateRange.getEnd().toString()));\r\n      if (dateRange.getResolution() != null)\r\n        drElem.addContent(new Element(\"resolution\").addContent(dateRange.getResolution().toString()));\r\n\r\n      rootElem.addContent(drElem);\r\n    }\r\n\r\n    /* add accept list\r\n    Element elem = new Element(\"AcceptList\");\r\n    //elem.addContent(new Element(\"accept\").addContent(\"raw\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"csv\").setAttribute(\"displayName\", \"csv\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"text/csv\").setAttribute(\"displayName\", \"csv (file)\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"xml\").setAttribute(\"displayName\", \"xml\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"text/xml\").setAttribute(\"displayName\", \"xml (file)\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"waterml2\").setAttribute(\"displayName\", \"WaterML 2.0\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"netcdf\").setAttribute(\"displayName\", \"CF/NetCDF-3\"));\r\n    //elem.addContent(new Element(\"accept\").addContent(\"ncstream\"));\r\n    rootElem.addContent(elem); */\r\n\r\n    return doc;\r\n  }", "language": "java", "Allcodes": "public Document getCapabilitiesDocument() {\r\n    Element rootElem = new Element(\"capabilities\");\r\n    Document doc = new Document(rootElem);\r\n    if (null != path) {\r\n      rootElem.setAttribute(\"location\", path);\r\n      Element elem = new Element(\"featureDataset\");\r\n      FeatureType ft = fdp.getFeatureType();\r\n      elem.setAttribute(\"type\", ft.toString().toLowerCase());\r\n      String url = path.replace(\"dataset.xml\", ft.toString().toLowerCase() + \".xml\");\r\n      elem.setAttribute(\"url\", url);\r\n      rootElem.addContent(elem);\r\n    }\r\n\r\n    List<DsgFeatureCollection> list = fdp.getPointFeatureCollectionList();\r\n    DsgFeatureCollection fc = list.get(0); // LOOK maybe should pass in the dsg?\r\n\r\n    rootElem.addContent(writeTimeUnit(fc.getTimeUnit()));\r\n    rootElem.addContent(new Element(\"AltitudeUnits\").addContent(fc.getAltUnits()));\r\n\r\n    // data variables\r\n    List<? extends VariableSimpleIF> vars = fdp.getDataVariables();\r\n    Collections.sort(vars);\r\n    for (VariableSimpleIF v : vars) {\r\n      rootElem.addContent(writeVariable(v));\r\n    }\r\n\r\n    /* CollectionInfo info;\r\n    try {\r\n      info = new DsgCollectionHelper(fc).calcBounds();\r\n    } catch (IOException e) {\r\n      throw new RuntimeException(e);\r\n    } */\r\n\r\n    LatLonRect bb = fc.getBoundingBox();\r\n    if (bb != null)\r\n      rootElem.addContent(writeBoundingBox(bb));\r\n\r\n    // add date range\r\n    CalendarDateRange dateRange = fc.getCalendarDateRange();\r\n    if (dateRange != null) {\r\n      Element drElem = new Element(\"TimeSpan\"); // from KML\r\n      drElem.addContent(new Element(\"begin\").addContent(dateRange.getStart().toString()));\r\n      drElem.addContent(new Element(\"end\").addContent(dateRange.getEnd().toString()));\r\n      if (dateRange.getResolution() != null)\r\n        drElem.addContent(new Element(\"resolution\").addContent(dateRange.getResolution().toString()));\r\n\r\n      rootElem.addContent(drElem);\r\n    }\r\n\r\n    /* add accept list\r\n    Element elem = new Element(\"AcceptList\");\r\n    //elem.addContent(new Element(\"accept\").addContent(\"raw\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"csv\").setAttribute(\"displayName\", \"csv\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"text/csv\").setAttribute(\"displayName\", \"csv (file)\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"xml\").setAttribute(\"displayName\", \"xml\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"text/xml\").setAttribute(\"displayName\", \"xml (file)\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"waterml2\").setAttribute(\"displayName\", \"WaterML 2.0\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"netcdf\").setAttribute(\"displayName\", \"CF/NetCDF-3\"));\r\n    //elem.addContent(new Element(\"accept\").addContent(\"ncstream\"));\r\n    rootElem.addContent(elem); */\r\n\r\n    return doc;\r\n  }", "code_tokens": ["public", "Document", "getCapabilitiesDocument", "(", ")", "{", "Element", "rootElem", "=", "new", "Element", "(", "\"capabilities\"", ")", ";", "Document", "doc", "=", "new", "Document", "(", "rootElem", ")", ";", "if", "(", "null", "!=", "path", ")", "{", "rootElem", ".", "setAttribute", "(", "\"location\"", ",", "path", ")", ";", "Element", "elem", "=", "new", "Element", "(", "\"featureDataset\"", ")", ";", "FeatureType", "ft", "=", "fdp", ".", "getFeatureType", "(", ")", ";", "elem", ".", "setAttribute", "(", "\"type\"", ",", "ft", ".", "toString", "(", ")", ".", "toLowerCase", "(", ")", ")", ";", "String", "url", "=", "path", ".", "replace", "(", "\"dataset.xml\"", ",", "ft", ".", "toString", "(", ")", ".", "toLowerCase", "(", ")", "+", "\".xml\"", ")", ";", "elem", ".", "setAttribute", "(", "\"url\"", ",", "url", ")", ";", "rootElem", ".", "addContent", "(", "elem", ")", ";", "}", "List", "<", "DsgFeatureCollection", ">", "list", "=", "fdp", ".", "getPointFeatureCollectionList", "(", ")", ";", "DsgFeatureCollection", "fc", "=", "list", ".", "get", "(", "0", ")", ";", "// LOOK maybe should pass in the dsg?\r", "rootElem", ".", "addContent", "(", "writeTimeUnit", "(", "fc", ".", "getTimeUnit", "(", ")", ")", ")", ";", "rootElem", ".", "addContent", "(", "new", "Element", "(", "\"AltitudeUnits\"", ")", ".", "addContent", "(", "fc", ".", "getAltUnits", "(", ")", ")", ")", ";", "// data variables\r", "List", "<", "?", "extends", "VariableSimpleIF", ">", "vars", "=", "fdp", ".", "getDataVariables", "(", ")", ";", "Collections", ".", "sort", "(", "vars", ")", ";", "for", "(", "VariableSimpleIF", "v", ":", "vars", ")", "{", "rootElem", ".", "addContent", "(", "writeVariable", "(", "v", ")", ")", ";", "}", "/* CollectionInfo info;\r\n    try {\r\n      info = new DsgCollectionHelper(fc).calcBounds();\r\n    } catch (IOException e) {\r\n      throw new RuntimeException(e);\r\n    } */", "LatLonRect", "bb", "=", "fc", ".", "getBoundingBox", "(", ")", ";", "if", "(", "bb", "!=", "null", ")", "rootElem", ".", "addContent", "(", "writeBoundingBox", "(", "bb", ")", ")", ";", "// add date range\r", "CalendarDateRange", "dateRange", "=", "fc", ".", "getCalendarDateRange", "(", ")", ";", "if", "(", "dateRange", "!=", "null", ")", "{", "Element", "drElem", "=", "new", "Element", "(", "\"TimeSpan\"", ")", ";", "// from KML\r", "drElem", ".", "addContent", "(", "new", "Element", "(", "\"begin\"", ")", ".", "addContent", "(", "dateRange", ".", "getStart", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "drElem", ".", "addContent", "(", "new", "Element", "(", "\"end\"", ")", ".", "addContent", "(", "dateRange", ".", "getEnd", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "if", "(", "dateRange", ".", "getResolution", "(", ")", "!=", "null", ")", "drElem", ".", "addContent", "(", "new", "Element", "(", "\"resolution\"", ")", ".", "addContent", "(", "dateRange", ".", "getResolution", "(", ")", ".", "toString", "(", ")", ")", ")", ";", "rootElem", ".", "addContent", "(", "drElem", ")", ";", "}", "/* add accept list\r\n    Element elem = new Element(\"AcceptList\");\r\n    //elem.addContent(new Element(\"accept\").addContent(\"raw\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"csv\").setAttribute(\"displayName\", \"csv\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"text/csv\").setAttribute(\"displayName\", \"csv (file)\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"xml\").setAttribute(\"displayName\", \"xml\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"text/xml\").setAttribute(\"displayName\", \"xml (file)\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"waterml2\").setAttribute(\"displayName\", \"WaterML 2.0\"));\r\n    elem.addContent(new Element(\"accept\").addContent(\"netcdf\").setAttribute(\"displayName\", \"CF/NetCDF-3\"));\r\n    //elem.addContent(new Element(\"accept\").addContent(\"ncstream\"));\r\n    rootElem.addContent(elem); */", "return", "doc", ";", "}"], "docstring": "Create the capabilities XML document for this dataset\n\n@return capabilities XML document", "docstring_tokens": ["Create", "the", "capabilities", "XML", "document", "for", "this", "dataset"]}
{"code": "Double timeOffset = coords.getTimeOffset();", "comments": "Double", "lines": 21, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribCollectionImmutable.java", "func_name": "VariableIndex.getRecordAt", "original_string": "@Nullable\n    synchronized Record getRecordAt(SubsetParams coords) {\n      int[] want = new int[getRank()];\n      int count = 0;\n      int runIdx = -1;\n      for (Coordinate coord : getCoordinates()) {\n        int idx = -1;\n        switch (coord.getType()) {\n          case runtime:\n            CalendarDate runtimeCooord = coords.getRunTime();\n            idx = coord.getIndex(runtimeCooord);\n            runIdx = idx;\n            break;\n\n          case timeIntv:\n            double[] timeIntv = coords.getTimeOffsetIntv();\n            idx = coord.getIndex(new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]));\n            break;\n\n          case time:\n            Double timeOffset = coords.getTimeOffset(); // Double\n            int coordInt = timeOffset.intValue();\n            idx = coord.getIndex(coordInt);\n            break;\n\n          case time2D:\n            timeIntv = coords.getTimeOffsetIntv();\n            if (timeIntv != null) {\n              TimeCoordIntvValue coordTinv = new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]);\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordTinv); // LOOK can only use if orthogonal\n              break;\n            }\n            Double timeCoord = coords.getTimeOffset();\n            if (timeCoord != null) {\n              coordInt = timeCoord.intValue();\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordInt);\n              break;\n            }\n\n          // the OneTime case\n          CoordinateTime2D coord2D = (CoordinateTime2D) coord;\n          if (coord2D.getNtimes() == 1) {\n            idx = 0;\n            break;\n          }\n          throw new IllegalStateException(\"time2D must have timeOffset ot timeOffsetIntv coordinare\");\n\n          case vert:\n            double[] vertIntv = coords.getVertCoordIntv();\n            if (vertIntv != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertIntv[0], vertIntv[1]);\n              idx = coord.getIndex(coordVert);\n              break;\n            }\n            Double vertCoord = coords.getVertCoord();\n            if (vertCoord != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertCoord);\n              idx = coord.getIndex(coordVert);\n            }\n            break;\n\n          case ens:\n            Double ensVal = coords.getEnsCoord();\n            idx = ((CoordinateEns) coord).getIndexByMember(ensVal);\n            break;\n\n          default:\n            logger.warn(\"GribCollectionImmutable: missing CoordVal for {}%n\", coord.getName());\n        }\n\n        if (idx < 0) {\n          logger.debug(\"Cant find index for value in axis {} in variable {}\", coord.getName(), name);\n          return null;\n        }\n\n        want[count++] = idx;\n      }\n      return sa.getContent(want);\n    }", "language": "java", "Allcodes": "@Nullable\n    synchronized Record getRecordAt(SubsetParams coords) {\n      int[] want = new int[getRank()];\n      int count = 0;\n      int runIdx = -1;\n      for (Coordinate coord : getCoordinates()) {\n        int idx = -1;\n        switch (coord.getType()) {\n          case runtime:\n            CalendarDate runtimeCooord = coords.getRunTime();\n            idx = coord.getIndex(runtimeCooord);\n            runIdx = idx;\n            break;\n\n          case timeIntv:\n            double[] timeIntv = coords.getTimeOffsetIntv();\n            idx = coord.getIndex(new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]));\n            break;\n\n          case time:\n            Double timeOffset = coords.getTimeOffset(); // Double\n            int coordInt = timeOffset.intValue();\n            idx = coord.getIndex(coordInt);\n            break;\n\n          case time2D:\n            timeIntv = coords.getTimeOffsetIntv();\n            if (timeIntv != null) {\n              TimeCoordIntvValue coordTinv = new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]);\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordTinv); // LOOK can only use if orthogonal\n              break;\n            }\n            Double timeCoord = coords.getTimeOffset();\n            if (timeCoord != null) {\n              coordInt = timeCoord.intValue();\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordInt);\n              break;\n            }\n\n          // the OneTime case\n          CoordinateTime2D coord2D = (CoordinateTime2D) coord;\n          if (coord2D.getNtimes() == 1) {\n            idx = 0;\n            break;\n          }\n          throw new IllegalStateException(\"time2D must have timeOffset ot timeOffsetIntv coordinare\");\n\n          case vert:\n            double[] vertIntv = coords.getVertCoordIntv();\n            if (vertIntv != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertIntv[0], vertIntv[1]);\n              idx = coord.getIndex(coordVert);\n              break;\n            }\n            Double vertCoord = coords.getVertCoord();\n            if (vertCoord != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertCoord);\n              idx = coord.getIndex(coordVert);\n            }\n            break;\n\n          case ens:\n            Double ensVal = coords.getEnsCoord();\n            idx = ((CoordinateEns) coord).getIndexByMember(ensVal);\n            break;\n\n          default:\n            logger.warn(\"GribCollectionImmutable: missing CoordVal for {}%n\", coord.getName());\n        }\n\n        if (idx < 0) {\n          logger.debug(\"Cant find index for value in axis {} in variable {}\", coord.getName(), name);\n          return null;\n        }\n\n        want[count++] = idx;\n      }\n      return sa.getContent(want);\n    }", "code_tokens": ["@", "Nullable", "synchronized", "Record", "getRecordAt", "(", "SubsetParams", "coords", ")", "{", "int", "[", "]", "want", "=", "new", "int", "[", "getRank", "(", ")", "]", ";", "int", "count", "=", "0", ";", "int", "runIdx", "=", "-", "1", ";", "for", "(", "Coordinate", "coord", ":", "getCoordinates", "(", ")", ")", "{", "int", "idx", "=", "-", "1", ";", "switch", "(", "coord", ".", "getType", "(", ")", ")", "{", "case", "runtime", ":", "CalendarDate", "runtimeCooord", "=", "coords", ".", "getRunTime", "(", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "runtimeCooord", ")", ";", "runIdx", "=", "idx", ";", "break", ";", "case", "timeIntv", ":", "double", "[", "]", "timeIntv", "=", "coords", ".", "getTimeOffsetIntv", "(", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "new", "TimeCoordIntvValue", "(", "(", "int", ")", "timeIntv", "[", "0", "]", ",", "(", "int", ")", "timeIntv", "[", "1", "]", ")", ")", ";", "break", ";", "case", "time", ":", "Double", "timeOffset", "=", "coords", ".", "getTimeOffset", "(", ")", ";", "// Double", "int", "coordInt", "=", "timeOffset", ".", "intValue", "(", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "coordInt", ")", ";", "break", ";", "case", "time2D", ":", "timeIntv", "=", "coords", ".", "getTimeOffsetIntv", "(", ")", ";", "if", "(", "timeIntv", "!=", "null", ")", "{", "TimeCoordIntvValue", "coordTinv", "=", "new", "TimeCoordIntvValue", "(", "(", "int", ")", "timeIntv", "[", "0", "]", ",", "(", "int", ")", "timeIntv", "[", "1", "]", ")", ";", "idx", "=", "(", "(", "CoordinateTime2D", ")", "coord", ")", ".", "findTimeIndexFromVal", "(", "runIdx", ",", "coordTinv", ")", ";", "// LOOK can only use if orthogonal", "break", ";", "}", "Double", "timeCoord", "=", "coords", ".", "getTimeOffset", "(", ")", ";", "if", "(", "timeCoord", "!=", "null", ")", "{", "coordInt", "=", "timeCoord", ".", "intValue", "(", ")", ";", "idx", "=", "(", "(", "CoordinateTime2D", ")", "coord", ")", ".", "findTimeIndexFromVal", "(", "runIdx", ",", "coordInt", ")", ";", "break", ";", "}", "// the OneTime case", "CoordinateTime2D", "coord2D", "=", "(", "CoordinateTime2D", ")", "coord", ";", "if", "(", "coord2D", ".", "getNtimes", "(", ")", "==", "1", ")", "{", "idx", "=", "0", ";", "break", ";", "}", "throw", "new", "IllegalStateException", "(", "\"time2D must have timeOffset ot timeOffsetIntv coordinare\"", ")", ";", "case", "vert", ":", "double", "[", "]", "vertIntv", "=", "coords", ".", "getVertCoordIntv", "(", ")", ";", "if", "(", "vertIntv", "!=", "null", ")", "{", "VertCoordValue", "coordVert", "=", "new", "VertCoordValue", "(", "vertIntv", "[", "0", "]", ",", "vertIntv", "[", "1", "]", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "coordVert", ")", ";", "break", ";", "}", "Double", "vertCoord", "=", "coords", ".", "getVertCoord", "(", ")", ";", "if", "(", "vertCoord", "!=", "null", ")", "{", "VertCoordValue", "coordVert", "=", "new", "VertCoordValue", "(", "vertCoord", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "coordVert", ")", ";", "}", "break", ";", "case", "ens", ":", "Double", "ensVal", "=", "coords", ".", "getEnsCoord", "(", ")", ";", "idx", "=", "(", "(", "CoordinateEns", ")", "coord", ")", ".", "getIndexByMember", "(", "ensVal", ")", ";", "break", ";", "default", ":", "logger", ".", "warn", "(", "\"GribCollectionImmutable: missing CoordVal for {}%n\"", ",", "coord", ".", "getName", "(", ")", ")", ";", "}", "if", "(", "idx", "<", "0", ")", "{", "logger", ".", "debug", "(", "\"Cant find index for value in axis {} in variable {}\"", ",", "coord", ".", "getName", "(", ")", ",", "name", ")", ";", "return", "null", ";", "}", "want", "[", "count", "++", "]", "=", "idx", ";", "}", "return", "sa", ".", "getContent", "(", "want", ")", ";", "}"], "docstring": "coord based record finding. note only one record at a time", "docstring_tokens": ["coord", "based", "record", "finding", ".", "note", "only", "one", "record", "at", "a", "time"]}
{"code": "idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordTinv);", "comments": "LOOK can only use if orthogonal", "lines": 30, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribCollectionImmutable.java", "func_name": "VariableIndex.getRecordAt", "original_string": "@Nullable\n    synchronized Record getRecordAt(SubsetParams coords) {\n      int[] want = new int[getRank()];\n      int count = 0;\n      int runIdx = -1;\n      for (Coordinate coord : getCoordinates()) {\n        int idx = -1;\n        switch (coord.getType()) {\n          case runtime:\n            CalendarDate runtimeCooord = coords.getRunTime();\n            idx = coord.getIndex(runtimeCooord);\n            runIdx = idx;\n            break;\n\n          case timeIntv:\n            double[] timeIntv = coords.getTimeOffsetIntv();\n            idx = coord.getIndex(new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]));\n            break;\n\n          case time:\n            Double timeOffset = coords.getTimeOffset(); // Double\n            int coordInt = timeOffset.intValue();\n            idx = coord.getIndex(coordInt);\n            break;\n\n          case time2D:\n            timeIntv = coords.getTimeOffsetIntv();\n            if (timeIntv != null) {\n              TimeCoordIntvValue coordTinv = new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]);\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordTinv); // LOOK can only use if orthogonal\n              break;\n            }\n            Double timeCoord = coords.getTimeOffset();\n            if (timeCoord != null) {\n              coordInt = timeCoord.intValue();\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordInt);\n              break;\n            }\n\n          // the OneTime case\n          CoordinateTime2D coord2D = (CoordinateTime2D) coord;\n          if (coord2D.getNtimes() == 1) {\n            idx = 0;\n            break;\n          }\n          throw new IllegalStateException(\"time2D must have timeOffset ot timeOffsetIntv coordinare\");\n\n          case vert:\n            double[] vertIntv = coords.getVertCoordIntv();\n            if (vertIntv != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertIntv[0], vertIntv[1]);\n              idx = coord.getIndex(coordVert);\n              break;\n            }\n            Double vertCoord = coords.getVertCoord();\n            if (vertCoord != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertCoord);\n              idx = coord.getIndex(coordVert);\n            }\n            break;\n\n          case ens:\n            Double ensVal = coords.getEnsCoord();\n            idx = ((CoordinateEns) coord).getIndexByMember(ensVal);\n            break;\n\n          default:\n            logger.warn(\"GribCollectionImmutable: missing CoordVal for {}%n\", coord.getName());\n        }\n\n        if (idx < 0) {\n          logger.debug(\"Cant find index for value in axis {} in variable {}\", coord.getName(), name);\n          return null;\n        }\n\n        want[count++] = idx;\n      }\n      return sa.getContent(want);\n    }", "language": "java", "Allcodes": "@Nullable\n    synchronized Record getRecordAt(SubsetParams coords) {\n      int[] want = new int[getRank()];\n      int count = 0;\n      int runIdx = -1;\n      for (Coordinate coord : getCoordinates()) {\n        int idx = -1;\n        switch (coord.getType()) {\n          case runtime:\n            CalendarDate runtimeCooord = coords.getRunTime();\n            idx = coord.getIndex(runtimeCooord);\n            runIdx = idx;\n            break;\n\n          case timeIntv:\n            double[] timeIntv = coords.getTimeOffsetIntv();\n            idx = coord.getIndex(new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]));\n            break;\n\n          case time:\n            Double timeOffset = coords.getTimeOffset(); // Double\n            int coordInt = timeOffset.intValue();\n            idx = coord.getIndex(coordInt);\n            break;\n\n          case time2D:\n            timeIntv = coords.getTimeOffsetIntv();\n            if (timeIntv != null) {\n              TimeCoordIntvValue coordTinv = new TimeCoordIntvValue((int) timeIntv[0], (int) timeIntv[1]);\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordTinv); // LOOK can only use if orthogonal\n              break;\n            }\n            Double timeCoord = coords.getTimeOffset();\n            if (timeCoord != null) {\n              coordInt = timeCoord.intValue();\n              idx = ((CoordinateTime2D) coord).findTimeIndexFromVal(runIdx, coordInt);\n              break;\n            }\n\n          // the OneTime case\n          CoordinateTime2D coord2D = (CoordinateTime2D) coord;\n          if (coord2D.getNtimes() == 1) {\n            idx = 0;\n            break;\n          }\n          throw new IllegalStateException(\"time2D must have timeOffset ot timeOffsetIntv coordinare\");\n\n          case vert:\n            double[] vertIntv = coords.getVertCoordIntv();\n            if (vertIntv != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertIntv[0], vertIntv[1]);\n              idx = coord.getIndex(coordVert);\n              break;\n            }\n            Double vertCoord = coords.getVertCoord();\n            if (vertCoord != null) {\n              VertCoordValue coordVert = new VertCoordValue(vertCoord);\n              idx = coord.getIndex(coordVert);\n            }\n            break;\n\n          case ens:\n            Double ensVal = coords.getEnsCoord();\n            idx = ((CoordinateEns) coord).getIndexByMember(ensVal);\n            break;\n\n          default:\n            logger.warn(\"GribCollectionImmutable: missing CoordVal for {}%n\", coord.getName());\n        }\n\n        if (idx < 0) {\n          logger.debug(\"Cant find index for value in axis {} in variable {}\", coord.getName(), name);\n          return null;\n        }\n\n        want[count++] = idx;\n      }\n      return sa.getContent(want);\n    }", "code_tokens": ["@", "Nullable", "synchronized", "Record", "getRecordAt", "(", "SubsetParams", "coords", ")", "{", "int", "[", "]", "want", "=", "new", "int", "[", "getRank", "(", ")", "]", ";", "int", "count", "=", "0", ";", "int", "runIdx", "=", "-", "1", ";", "for", "(", "Coordinate", "coord", ":", "getCoordinates", "(", ")", ")", "{", "int", "idx", "=", "-", "1", ";", "switch", "(", "coord", ".", "getType", "(", ")", ")", "{", "case", "runtime", ":", "CalendarDate", "runtimeCooord", "=", "coords", ".", "getRunTime", "(", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "runtimeCooord", ")", ";", "runIdx", "=", "idx", ";", "break", ";", "case", "timeIntv", ":", "double", "[", "]", "timeIntv", "=", "coords", ".", "getTimeOffsetIntv", "(", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "new", "TimeCoordIntvValue", "(", "(", "int", ")", "timeIntv", "[", "0", "]", ",", "(", "int", ")", "timeIntv", "[", "1", "]", ")", ")", ";", "break", ";", "case", "time", ":", "Double", "timeOffset", "=", "coords", ".", "getTimeOffset", "(", ")", ";", "// Double", "int", "coordInt", "=", "timeOffset", ".", "intValue", "(", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "coordInt", ")", ";", "break", ";", "case", "time2D", ":", "timeIntv", "=", "coords", ".", "getTimeOffsetIntv", "(", ")", ";", "if", "(", "timeIntv", "!=", "null", ")", "{", "TimeCoordIntvValue", "coordTinv", "=", "new", "TimeCoordIntvValue", "(", "(", "int", ")", "timeIntv", "[", "0", "]", ",", "(", "int", ")", "timeIntv", "[", "1", "]", ")", ";", "idx", "=", "(", "(", "CoordinateTime2D", ")", "coord", ")", ".", "findTimeIndexFromVal", "(", "runIdx", ",", "coordTinv", ")", ";", "// LOOK can only use if orthogonal", "break", ";", "}", "Double", "timeCoord", "=", "coords", ".", "getTimeOffset", "(", ")", ";", "if", "(", "timeCoord", "!=", "null", ")", "{", "coordInt", "=", "timeCoord", ".", "intValue", "(", ")", ";", "idx", "=", "(", "(", "CoordinateTime2D", ")", "coord", ")", ".", "findTimeIndexFromVal", "(", "runIdx", ",", "coordInt", ")", ";", "break", ";", "}", "// the OneTime case", "CoordinateTime2D", "coord2D", "=", "(", "CoordinateTime2D", ")", "coord", ";", "if", "(", "coord2D", ".", "getNtimes", "(", ")", "==", "1", ")", "{", "idx", "=", "0", ";", "break", ";", "}", "throw", "new", "IllegalStateException", "(", "\"time2D must have timeOffset ot timeOffsetIntv coordinare\"", ")", ";", "case", "vert", ":", "double", "[", "]", "vertIntv", "=", "coords", ".", "getVertCoordIntv", "(", ")", ";", "if", "(", "vertIntv", "!=", "null", ")", "{", "VertCoordValue", "coordVert", "=", "new", "VertCoordValue", "(", "vertIntv", "[", "0", "]", ",", "vertIntv", "[", "1", "]", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "coordVert", ")", ";", "break", ";", "}", "Double", "vertCoord", "=", "coords", ".", "getVertCoord", "(", ")", ";", "if", "(", "vertCoord", "!=", "null", ")", "{", "VertCoordValue", "coordVert", "=", "new", "VertCoordValue", "(", "vertCoord", ")", ";", "idx", "=", "coord", ".", "getIndex", "(", "coordVert", ")", ";", "}", "break", ";", "case", "ens", ":", "Double", "ensVal", "=", "coords", ".", "getEnsCoord", "(", ")", ";", "idx", "=", "(", "(", "CoordinateEns", ")", "coord", ")", ".", "getIndexByMember", "(", "ensVal", ")", ";", "break", ";", "default", ":", "logger", ".", "warn", "(", "\"GribCollectionImmutable: missing CoordVal for {}%n\"", ",", "coord", ".", "getName", "(", ")", ")", ";", "}", "if", "(", "idx", "<", "0", ")", "{", "logger", ".", "debug", "(", "\"Cant find index for value in axis {} in variable {}\"", ",", "coord", ".", "getName", "(", ")", ",", "name", ")", ";", "return", "null", ";", "}", "want", "[", "count", "++", "]", "=", "idx", ";", "}", "return", "sa", ".", "getContent", "(", "want", ")", ";", "}"], "docstring": "coord based record finding. note only one record at a time", "docstring_tokens": ["coord", "based", "record", "finding", ".", "note", "only", "one", "record", "at", "a", "time"]}
{"code": "return;", "comments": "already there", "lines": 7, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/util/prefs/ui/ComboBox.java", "func_name": "ComboBox.addItem", "original_string": "public void addItem( Object item) {\r\n    if (item == null) return;\r\n    for (int i=0; i<getItemCount(); i++) {\r\n      if (item.equals( getItemAt(i))) {\r\n        if (i == 0) {\r\n          setSelectedIndex(0);\r\n          return; // already there\r\n        }\r\n        removeItemAt(i);\r\n      }\r\n    }\r\n\r\n    // add as first in the list\r\n    insertItemAt( item, 0);\r\n    setSelectedIndex(0);\r\n  }", "language": "java", "Allcodes": "public void addItem( Object item) {\r\n    if (item == null) return;\r\n    for (int i=0; i<getItemCount(); i++) {\r\n      if (item.equals( getItemAt(i))) {\r\n        if (i == 0) {\r\n          setSelectedIndex(0);\r\n          return; // already there\r\n        }\r\n        removeItemAt(i);\r\n      }\r\n    }\r\n\r\n    // add as first in the list\r\n    insertItemAt( item, 0);\r\n    setSelectedIndex(0);\r\n  }", "code_tokens": ["public", "void", "addItem", "(", "Object", "item", ")", "{", "if", "(", "item", "==", "null", ")", "return", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "getItemCount", "(", ")", ";", "i", "++", ")", "{", "if", "(", "item", ".", "equals", "(", "getItemAt", "(", "i", ")", ")", ")", "{", "if", "(", "i", "==", "0", ")", "{", "setSelectedIndex", "(", "0", ")", ";", "return", ";", "// already there\r", "}", "removeItemAt", "(", "i", ")", ";", "}", "}", "// add as first in the list\r", "insertItemAt", "(", "item", ",", "0", ")", ";", "setSelectedIndex", "(", "0", ")", ";", "}"], "docstring": "Add the item to the top of the list. If it already exists, move it to the top.\n@param item to be added.", "docstring_tokens": ["Add", "the", "item", "to", "the", "top", "of", "the", "list", ".", "If", "it", "already", "exists", "move", "it", "to", "the", "top", "."]}
{"code": "this.index.indices[i] = this.slices.get(i).getFirst();", "comments": "reset this position", "lines": 6, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Odometer.java", "func_name": "Odometer.step", "original_string": "public int\n    step(int firstpos, int lastpos)\n    {\n        for(int i = lastpos - 1; i >= firstpos; i--) { // walk backwards\n            if(this.index.indices[i] > this.endpoint[i])\n                this.index.indices[i] = this.slices.get(i).getFirst(); // reset this position\n            else {\n                this.index.indices[i] += this.slices.get(i).getStride();  // move to next indices\n                return i;\n            }\n        }\n        return -1;\n    }", "language": "java", "Allcodes": "public int\n    step(int firstpos, int lastpos)\n    {\n        for(int i = lastpos - 1; i >= firstpos; i--) { // walk backwards\n            if(this.index.indices[i] > this.endpoint[i])\n                this.index.indices[i] = this.slices.get(i).getFirst(); // reset this position\n            else {\n                this.index.indices[i] += this.slices.get(i).getStride();  // move to next indices\n                return i;\n            }\n        }\n        return -1;\n    }", "code_tokens": ["public", "int", "step", "(", "int", "firstpos", ",", "int", "lastpos", ")", "{", "for", "(", "int", "i", "=", "lastpos", "-", "1", ";", "i", ">=", "firstpos", ";", "i", "--", ")", "{", "// walk backwards", "if", "(", "this", ".", "index", ".", "indices", "[", "i", "]", ">", "this", ".", "endpoint", "[", "i", "]", ")", "this", ".", "index", ".", "indices", "[", "i", "]", "=", "this", ".", "slices", ".", "get", "(", "i", ")", ".", "getFirst", "(", ")", ";", "// reset this position", "else", "{", "this", ".", "index", ".", "indices", "[", "i", "]", "+=", "this", ".", "slices", ".", "get", "(", "i", ")", ".", "getStride", "(", ")", ";", "// move to next indices", "return", "i", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "return -1 if we have completed.", "docstring_tokens": ["return", "-", "1", "if", "we", "have", "completed", "."]}
{"code": "this.index.indices[i] += this.slices.get(i).getStride();", "comments": "move to next indices", "lines": 8, "repo": "Unidata/thredds", "path": "dap4/d4core/src/main/java/dap4/core/util/Odometer.java", "func_name": "Odometer.step", "original_string": "public int\n    step(int firstpos, int lastpos)\n    {\n        for(int i = lastpos - 1; i >= firstpos; i--) { // walk backwards\n            if(this.index.indices[i] > this.endpoint[i])\n                this.index.indices[i] = this.slices.get(i).getFirst(); // reset this position\n            else {\n                this.index.indices[i] += this.slices.get(i).getStride();  // move to next indices\n                return i;\n            }\n        }\n        return -1;\n    }", "language": "java", "Allcodes": "public int\n    step(int firstpos, int lastpos)\n    {\n        for(int i = lastpos - 1; i >= firstpos; i--) { // walk backwards\n            if(this.index.indices[i] > this.endpoint[i])\n                this.index.indices[i] = this.slices.get(i).getFirst(); // reset this position\n            else {\n                this.index.indices[i] += this.slices.get(i).getStride();  // move to next indices\n                return i;\n            }\n        }\n        return -1;\n    }", "code_tokens": ["public", "int", "step", "(", "int", "firstpos", ",", "int", "lastpos", ")", "{", "for", "(", "int", "i", "=", "lastpos", "-", "1", ";", "i", ">=", "firstpos", ";", "i", "--", ")", "{", "// walk backwards", "if", "(", "this", ".", "index", ".", "indices", "[", "i", "]", ">", "this", ".", "endpoint", "[", "i", "]", ")", "this", ".", "index", ".", "indices", "[", "i", "]", "=", "this", ".", "slices", ".", "get", "(", "i", ")", ".", "getFirst", "(", ")", ";", "// reset this position", "else", "{", "this", ".", "index", ".", "indices", "[", "i", "]", "+=", "this", ".", "slices", ".", "get", "(", "i", ")", ".", "getStride", "(", ")", ";", "// move to next indices", "return", "i", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "return -1 if we have completed.", "docstring_tokens": ["return", "-", "1", "if", "we", "have", "completed", "."]}
{"code": "return Collections.unmodifiableMap(result);", "comments": "all at once - thread safe", "lines": 17, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib1/tables/NcepTables.java", "func_name": "NcepTables.getNcepGenProcess", "original_string": "@Nullable\r\n  public static Map<Integer, String> getNcepGenProcess() {\r\n    if (genProcessMap != null) return genProcessMap;\r\n    String path = \"resources/grib1/ncep/ncepTableA.xml\";\r\n    try (InputStream is = GribResourceReader.getInputStream(path)) {\r\n      SAXBuilder builder = new SAXBuilder();\r\n      org.jdom2.Document doc = builder.build(is);\r\n      Element root = doc.getRootElement();\r\n\r\n      HashMap<Integer, String> result = new HashMap<>(200);\r\n      List<Element> params = root.getChildren(\"parameter\");\r\n      for (Element elem1 : params) {\r\n        int code = Integer.parseInt(elem1.getAttributeValue(\"code\"));\r\n        String desc = elem1.getChildText(\"description\");\r\n        result.put(code, desc);\r\n      }\r\n      return Collections.unmodifiableMap(result);  // all at once - thread safe\r\n\r\n    } catch (IOException | JDOMException ioe) {\r\n      logger.error(\"Cant read NCEP Table 1 = \" + path, ioe);\r\n      return null;\r\n    }\r\n  }", "language": "java", "Allcodes": "@Nullable\r\n  public static Map<Integer, String> getNcepGenProcess() {\r\n    if (genProcessMap != null) return genProcessMap;\r\n    String path = \"resources/grib1/ncep/ncepTableA.xml\";\r\n    try (InputStream is = GribResourceReader.getInputStream(path)) {\r\n      SAXBuilder builder = new SAXBuilder();\r\n      org.jdom2.Document doc = builder.build(is);\r\n      Element root = doc.getRootElement();\r\n\r\n      HashMap<Integer, String> result = new HashMap<>(200);\r\n      List<Element> params = root.getChildren(\"parameter\");\r\n      for (Element elem1 : params) {\r\n        int code = Integer.parseInt(elem1.getAttributeValue(\"code\"));\r\n        String desc = elem1.getChildText(\"description\");\r\n        result.put(code, desc);\r\n      }\r\n      return Collections.unmodifiableMap(result);  // all at once - thread safe\r\n\r\n    } catch (IOException | JDOMException ioe) {\r\n      logger.error(\"Cant read NCEP Table 1 = \" + path, ioe);\r\n      return null;\r\n    }\r\n  }", "code_tokens": ["@", "Nullable", "public", "static", "Map", "<", "Integer", ",", "String", ">", "getNcepGenProcess", "(", ")", "{", "if", "(", "genProcessMap", "!=", "null", ")", "return", "genProcessMap", ";", "String", "path", "=", "\"resources/grib1/ncep/ncepTableA.xml\"", ";", "try", "(", "InputStream", "is", "=", "GribResourceReader", ".", "getInputStream", "(", "path", ")", ")", "{", "SAXBuilder", "builder", "=", "new", "SAXBuilder", "(", ")", ";", "org", ".", "jdom2", ".", "Document", "doc", "=", "builder", ".", "build", "(", "is", ")", ";", "Element", "root", "=", "doc", ".", "getRootElement", "(", ")", ";", "HashMap", "<", "Integer", ",", "String", ">", "result", "=", "new", "HashMap", "<>", "(", "200", ")", ";", "List", "<", "Element", ">", "params", "=", "root", ".", "getChildren", "(", "\"parameter\"", ")", ";", "for", "(", "Element", "elem1", ":", "params", ")", "{", "int", "code", "=", "Integer", ".", "parseInt", "(", "elem1", ".", "getAttributeValue", "(", "\"code\"", ")", ")", ";", "String", "desc", "=", "elem1", ".", "getChildText", "(", "\"description\"", ")", ";", "result", ".", "put", "(", "code", ",", "desc", ")", ";", "}", "return", "Collections", ".", "unmodifiableMap", "(", "result", ")", ";", "// all at once - thread safe\r", "}", "catch", "(", "IOException", "|", "JDOMException", "ioe", ")", "{", "logger", ".", "error", "(", "\"Cant read NCEP Table 1 = \"", "+", "path", ",", "ioe", ")", ";", "return", "null", ";", "}", "}"], "docstring": "public so can be called from Grib2", "docstring_tokens": ["public", "so", "can", "be", "called", "from", "Grib2"]}
{"code": "i++;", "comments": "/ skip further whitespace", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/util/StringUtil2.java", "func_name": "StringUtil2.collapseWhitespace", "original_string": "static public String collapseWhitespace(String s) {\r\n    int len = s.length();\r\n    StringBuilder b = new StringBuilder(len);\r\n    for (int i = 0; i < len; i++) {\r\n      char c = s.charAt(i);\r\n      if (!Character.isWhitespace(c)) {\r\n        b.append(c);\r\n      } else {\r\n        b.append(' ');\r\n        while ((i + 1 < len) && Character.isWhitespace(s.charAt(i + 1))) {\r\n          i++;  /// skip further whitespace\r\n        }\r\n      }\r\n    }\r\n    return b.toString();\r\n  }", "language": "java", "Allcodes": "static public String collapseWhitespace(String s) {\r\n    int len = s.length();\r\n    StringBuilder b = new StringBuilder(len);\r\n    for (int i = 0; i < len; i++) {\r\n      char c = s.charAt(i);\r\n      if (!Character.isWhitespace(c)) {\r\n        b.append(c);\r\n      } else {\r\n        b.append(' ');\r\n        while ((i + 1 < len) && Character.isWhitespace(s.charAt(i + 1))) {\r\n          i++;  /// skip further whitespace\r\n        }\r\n      }\r\n    }\r\n    return b.toString();\r\n  }", "code_tokens": ["static", "public", "String", "collapseWhitespace", "(", "String", "s", ")", "{", "int", "len", "=", "s", ".", "length", "(", ")", ";", "StringBuilder", "b", "=", "new", "StringBuilder", "(", "len", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "c", "=", "s", ".", "charAt", "(", "i", ")", ";", "if", "(", "!", "Character", ".", "isWhitespace", "(", "c", ")", ")", "{", "b", ".", "append", "(", "c", ")", ";", "}", "else", "{", "b", ".", "append", "(", "'", "'", ")", ";", "while", "(", "(", "i", "+", "1", "<", "len", ")", "&&", "Character", ".", "isWhitespace", "(", "s", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "i", "++", ";", "/// skip further whitespace\r", "}", "}", "}", "return", "b", ".", "toString", "(", ")", ";", "}"], "docstring": "Collapse continuous whitespace into one single \" \".\n\n@param s operate on this string\n@return result with collapsed whitespace", "docstring_tokens": ["Collapse", "continuous", "whitespace", "into", "one", "single", "."]}
{"code": "fromIndex = pos + substLen;", "comments": "make sure dont get into an infinite loop", "lines": 7, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/util/StringUtil2.java", "func_name": "StringUtil2.substitute", "original_string": "static public void substitute(StringBuilder sbuff, String match, String subst) {\r\n    int pos, fromIndex = 0;\r\n    int substLen = subst.length();\r\n    int matchLen = match.length();\r\n    while (0 <= (pos = sbuff.indexOf(match, fromIndex))) {\r\n      sbuff.replace(pos, pos + matchLen, subst);\r\n      fromIndex = pos + substLen;  // make sure dont get into an infinite loop\r\n    }\r\n  }", "language": "java", "Allcodes": "static public void substitute(StringBuilder sbuff, String match, String subst) {\r\n    int pos, fromIndex = 0;\r\n    int substLen = subst.length();\r\n    int matchLen = match.length();\r\n    while (0 <= (pos = sbuff.indexOf(match, fromIndex))) {\r\n      sbuff.replace(pos, pos + matchLen, subst);\r\n      fromIndex = pos + substLen;  // make sure dont get into an infinite loop\r\n    }\r\n  }", "code_tokens": ["static", "public", "void", "substitute", "(", "StringBuilder", "sbuff", ",", "String", "match", ",", "String", "subst", ")", "{", "int", "pos", ",", "fromIndex", "=", "0", ";", "int", "substLen", "=", "subst", ".", "length", "(", ")", ";", "int", "matchLen", "=", "match", ".", "length", "(", ")", ";", "while", "(", "0", "<=", "(", "pos", "=", "sbuff", ".", "indexOf", "(", "match", ",", "fromIndex", ")", ")", ")", "{", "sbuff", ".", "replace", "(", "pos", ",", "pos", "+", "matchLen", ",", "subst", ")", ";", "fromIndex", "=", "pos", "+", "substLen", ";", "// make sure dont get into an infinite loop\r", "}", "}"], "docstring": "Find all occurences of the \"match\" in original, and substitute the \"subst\" string,\ndirectly into the original.\n\n@param sbuff starting string buffer\n@param match string to match\n@param subst string to substitute", "docstring_tokens": ["Find", "all", "occurences", "of", "the", "match", "in", "original", "and", "substitute", "the", "subst", "string", "directly", "into", "the", "original", "."]}
{"code": "if (!config.collectionName.equals(event.getCollectionName())) return;", "comments": "not for me", "lines": 3, "repo": "Unidata/thredds", "path": "tds/src/main/java/thredds/featurecollection/InvDatasetFeatureCollection.java", "func_name": "InvDatasetFeatureCollection.processEvent", "original_string": "@Subscribe\n  public void processEvent(CollectionUpdateEvent event) {\n    if (!config.collectionName.equals(event.getCollectionName())) return; // not for me\n\n    try {\n      update(event.getType());\n    } catch (IOException e) {\n      logger.error(\"Error processing event\", e);\n    }\n  }", "language": "java", "Allcodes": "@Subscribe\n  public void processEvent(CollectionUpdateEvent event) {\n    if (!config.collectionName.equals(event.getCollectionName())) return; // not for me\n\n    try {\n      update(event.getType());\n    } catch (IOException e) {\n      logger.error(\"Error processing event\", e);\n    }\n  }", "code_tokens": ["@", "Subscribe", "public", "void", "processEvent", "(", "CollectionUpdateEvent", "event", ")", "{", "if", "(", "!", "config", ".", "collectionName", ".", "equals", "(", "event", ".", "getCollectionName", "(", ")", ")", ")", "return", ";", "// not for me", "try", "{", "update", "(", "event", ".", "getType", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "logger", ".", "error", "(", "\"Error processing event\"", ",", "e", ")", ";", "}", "}"], "docstring": "called by eventBus, this is where the trigger comes in", "docstring_tokens": ["called", "by", "eventBus", "this", "is", "where", "the", "trigger", "comes", "in"]}
{"code": "ArrayStructureBB.setOffsets(sm);", "comments": "this makes the packing canonical", "lines": 12, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/StructureDataDeep.java", "func_name": "StructureDataDeep.copyToArrayBB", "original_string": "static public ArrayStructureBB copyToArrayBB(ArrayStructure as, ByteOrder bo, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (bo == null || bo.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (bo != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(bo);\n    }\n\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyToArrayBB(iter.next(), abb);\n    }\n    return abb;\n  }", "language": "java", "Allcodes": "static public ArrayStructureBB copyToArrayBB(ArrayStructure as, ByteOrder bo, boolean canonical) throws IOException {\n    if (!canonical && as.getClass().equals(ArrayStructureBB.class)) { // no subclasses, LOOK detect already canonical later\n      ArrayStructureBB abb = (ArrayStructureBB) as;\n      ByteBuffer bb = abb.getByteBuffer();\n      if (bo == null || bo.equals(bb.order()))\n        return abb;\n    }\n\n    StructureMembers smo = as.getStructureMembers();\n    StructureMembers sm = new StructureMembers(smo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, as.getShape());\n    ArrayStructureBB.setOffsets(sm);  // this makes the packing canonical\n    if (bo != null) {\n      ByteBuffer bb = abb.getByteBuffer();\n      bb.order(bo);\n    }\n\n    try (StructureDataIterator iter = as.getStructureDataIterator()) {\n      while (iter.hasNext())\n        copyToArrayBB(iter.next(), abb);\n    }\n    return abb;\n  }", "code_tokens": ["static", "public", "ArrayStructureBB", "copyToArrayBB", "(", "ArrayStructure", "as", ",", "ByteOrder", "bo", ",", "boolean", "canonical", ")", "throws", "IOException", "{", "if", "(", "!", "canonical", "&&", "as", ".", "getClass", "(", ")", ".", "equals", "(", "ArrayStructureBB", ".", "class", ")", ")", "{", "// no subclasses, LOOK detect already canonical later", "ArrayStructureBB", "abb", "=", "(", "ArrayStructureBB", ")", "as", ";", "ByteBuffer", "bb", "=", "abb", ".", "getByteBuffer", "(", ")", ";", "if", "(", "bo", "==", "null", "||", "bo", ".", "equals", "(", "bb", ".", "order", "(", ")", ")", ")", "return", "abb", ";", "}", "StructureMembers", "smo", "=", "as", ".", "getStructureMembers", "(", ")", ";", "StructureMembers", "sm", "=", "new", "StructureMembers", "(", "smo", ")", ";", "ArrayStructureBB", "abb", "=", "new", "ArrayStructureBB", "(", "sm", ",", "as", ".", "getShape", "(", ")", ")", ";", "ArrayStructureBB", ".", "setOffsets", "(", "sm", ")", ";", "// this makes the packing canonical", "if", "(", "bo", "!=", "null", ")", "{", "ByteBuffer", "bb", "=", "abb", ".", "getByteBuffer", "(", ")", ";", "bb", ".", "order", "(", "bo", ")", ";", "}", "try", "(", "StructureDataIterator", "iter", "=", "as", ".", "getStructureDataIterator", "(", ")", ")", "{", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "copyToArrayBB", "(", "iter", ".", "next", "(", ")", ",", "abb", ")", ";", "}", "return", "abb", ";", "}"], "docstring": "Make deep copy from an ArrayStructure to a ArrayStructureBB whose data is contained in a ByteBuffer\n@param as    original ArrayStructure\n@param bo    what byte order to use ? (null for any)\n@param canonical  packing must be canonical\n@return ArrayStructureBB with all data self contained", "docstring_tokens": ["Make", "deep", "copy", "from", "an", "ArrayStructure", "to", "a", "ArrayStructureBB", "whose", "data", "is", "contained", "in", "a", "ByteBuffer"]}
{"code": "ByteBuffer bb = ByteBuffer.allocate(size);", "comments": "default is big endian", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/StructureDataDeep.java", "func_name": "StructureDataDeep.copyToArrayBB", "original_string": "static public ArrayStructureBB copyToArrayBB(StructureData sdata, StructureMembers sm, ByteOrder bo) {\n    int size = sm.getStructureSize();\n    ByteBuffer bb = ByteBuffer.allocate(size); // default is big endian\n    bb.order(bo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, new int[]{1}, bb, 0);\n    ArrayStructureBB.setOffsets(sm);\n    copyToArrayBB(sdata, abb);\n    return abb;\n  }", "language": "java", "Allcodes": "static public ArrayStructureBB copyToArrayBB(StructureData sdata, StructureMembers sm, ByteOrder bo) {\n    int size = sm.getStructureSize();\n    ByteBuffer bb = ByteBuffer.allocate(size); // default is big endian\n    bb.order(bo);\n    ArrayStructureBB abb = new ArrayStructureBB(sm, new int[]{1}, bb, 0);\n    ArrayStructureBB.setOffsets(sm);\n    copyToArrayBB(sdata, abb);\n    return abb;\n  }", "code_tokens": ["static", "public", "ArrayStructureBB", "copyToArrayBB", "(", "StructureData", "sdata", ",", "StructureMembers", "sm", ",", "ByteOrder", "bo", ")", "{", "int", "size", "=", "sm", ".", "getStructureSize", "(", ")", ";", "ByteBuffer", "bb", "=", "ByteBuffer", ".", "allocate", "(", "size", ")", ";", "// default is big endian", "bb", ".", "order", "(", "bo", ")", ";", "ArrayStructureBB", "abb", "=", "new", "ArrayStructureBB", "(", "sm", ",", "new", "int", "[", "]", "{", "1", "}", ",", "bb", ",", "0", ")", ";", "ArrayStructureBB", ".", "setOffsets", "(", "sm", ")", ";", "copyToArrayBB", "(", "sdata", ",", "abb", ")", ";", "return", "abb", ";", "}"], "docstring": "Make deep copy from a StructureData to a ArrayStructureBB whose data is contained in a ByteBuffer\n@param sdata    original ArrayStructure\n@param sm       the StructureData members. a reference is kept to this object\n@param bo       Byte Order of the ByteBuffer\n@return ArrayStructureBB with all data self contained", "docstring_tokens": ["Make", "deep", "copy", "from", "a", "StructureData", "to", "a", "ArrayStructureBB", "whose", "data", "is", "contained", "in", "a", "ByteBuffer"]}
{"code": "new_edge[idx + 1] = bound2[old_idx];", "comments": "all but last are overwritten", "lines": 24, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/CoordinateAxis1D.java", "func_name": "CoordinateAxis1D.section", "original_string": "public CoordinateAxis1D section(Range r) throws InvalidRangeException {\n    Section section = new Section().appendRange(r);\n    CoordinateAxis1D result = (CoordinateAxis1D) section(section);\n    int len = r.length();\n\n    // deal with the midpoints, bounds\n    if (isNumeric()) {\n      double[] new_mids = new double[len];\n      for (int idx = 0; idx < len; idx++) {\n        int old_idx = r.element(idx);\n        new_mids[idx] = coords[old_idx];\n      }\n      result.coords = new_mids;\n\n      if (isInterval) {\n        double[] new_bound1 = new double[len];\n        double[] new_bound2 = new double[len];\n        double[] new_edge = new double[len + 1];\n        for (int idx = 0; idx < len; idx++) {\n          int old_idx = r.element(idx);\n          new_bound1[idx] = bound1[old_idx];\n          new_bound2[idx] = bound2[old_idx];\n          new_edge[idx] = bound1[old_idx];\n          new_edge[idx + 1] = bound2[old_idx]; // all but last are overwritten\n        }\n        result.bound1 = new_bound1;\n        result.bound2 = new_bound2;\n        result.edge = new_edge;\n\n      } else {\n        double[] new_edge = new double[len + 1];\n        for (int idx = 0; idx < len; idx++) {\n          int old_idx = r.element(idx);\n          new_edge[idx] = edge[old_idx];\n          new_edge[idx + 1] = edge[old_idx + 1]; // all but last are overwritten\n        }\n        result.edge = new_edge;\n      }\n    }\n\n    if (names != null) {\n      String[] new_names = new String[len];\n      for (int idx = 0; idx < len; idx++) {\n        int old_idx = r.element(idx);\n        new_names[idx] = names[old_idx];\n      }\n      result.names = new_names;\n    }\n\n    result.wasCalcRegular = false;\n    result.calcIsRegular();\n\n    return result;\n  }", "language": "java", "Allcodes": "public CoordinateAxis1D section(Range r) throws InvalidRangeException {\n    Section section = new Section().appendRange(r);\n    CoordinateAxis1D result = (CoordinateAxis1D) section(section);\n    int len = r.length();\n\n    // deal with the midpoints, bounds\n    if (isNumeric()) {\n      double[] new_mids = new double[len];\n      for (int idx = 0; idx < len; idx++) {\n        int old_idx = r.element(idx);\n        new_mids[idx] = coords[old_idx];\n      }\n      result.coords = new_mids;\n\n      if (isInterval) {\n        double[] new_bound1 = new double[len];\n        double[] new_bound2 = new double[len];\n        double[] new_edge = new double[len + 1];\n        for (int idx = 0; idx < len; idx++) {\n          int old_idx = r.element(idx);\n          new_bound1[idx] = bound1[old_idx];\n          new_bound2[idx] = bound2[old_idx];\n          new_edge[idx] = bound1[old_idx];\n          new_edge[idx + 1] = bound2[old_idx]; // all but last are overwritten\n        }\n        result.bound1 = new_bound1;\n        result.bound2 = new_bound2;\n        result.edge = new_edge;\n\n      } else {\n        double[] new_edge = new double[len + 1];\n        for (int idx = 0; idx < len; idx++) {\n          int old_idx = r.element(idx);\n          new_edge[idx] = edge[old_idx];\n          new_edge[idx + 1] = edge[old_idx + 1]; // all but last are overwritten\n        }\n        result.edge = new_edge;\n      }\n    }\n\n    if (names != null) {\n      String[] new_names = new String[len];\n      for (int idx = 0; idx < len; idx++) {\n        int old_idx = r.element(idx);\n        new_names[idx] = names[old_idx];\n      }\n      result.names = new_names;\n    }\n\n    result.wasCalcRegular = false;\n    result.calcIsRegular();\n\n    return result;\n  }", "code_tokens": ["public", "CoordinateAxis1D", "section", "(", "Range", "r", ")", "throws", "InvalidRangeException", "{", "Section", "section", "=", "new", "Section", "(", ")", ".", "appendRange", "(", "r", ")", ";", "CoordinateAxis1D", "result", "=", "(", "CoordinateAxis1D", ")", "section", "(", "section", ")", ";", "int", "len", "=", "r", ".", "length", "(", ")", ";", "// deal with the midpoints, bounds", "if", "(", "isNumeric", "(", ")", ")", "{", "double", "[", "]", "new_mids", "=", "new", "double", "[", "len", "]", ";", "for", "(", "int", "idx", "=", "0", ";", "idx", "<", "len", ";", "idx", "++", ")", "{", "int", "old_idx", "=", "r", ".", "element", "(", "idx", ")", ";", "new_mids", "[", "idx", "]", "=", "coords", "[", "old_idx", "]", ";", "}", "result", ".", "coords", "=", "new_mids", ";", "if", "(", "isInterval", ")", "{", "double", "[", "]", "new_bound1", "=", "new", "double", "[", "len", "]", ";", "double", "[", "]", "new_bound2", "=", "new", "double", "[", "len", "]", ";", "double", "[", "]", "new_edge", "=", "new", "double", "[", "len", "+", "1", "]", ";", "for", "(", "int", "idx", "=", "0", ";", "idx", "<", "len", ";", "idx", "++", ")", "{", "int", "old_idx", "=", "r", ".", "element", "(", "idx", ")", ";", "new_bound1", "[", "idx", "]", "=", "bound1", "[", "old_idx", "]", ";", "new_bound2", "[", "idx", "]", "=", "bound2", "[", "old_idx", "]", ";", "new_edge", "[", "idx", "]", "=", "bound1", "[", "old_idx", "]", ";", "new_edge", "[", "idx", "+", "1", "]", "=", "bound2", "[", "old_idx", "]", ";", "// all but last are overwritten", "}", "result", ".", "bound1", "=", "new_bound1", ";", "result", ".", "bound2", "=", "new_bound2", ";", "result", ".", "edge", "=", "new_edge", ";", "}", "else", "{", "double", "[", "]", "new_edge", "=", "new", "double", "[", "len", "+", "1", "]", ";", "for", "(", "int", "idx", "=", "0", ";", "idx", "<", "len", ";", "idx", "++", ")", "{", "int", "old_idx", "=", "r", ".", "element", "(", "idx", ")", ";", "new_edge", "[", "idx", "]", "=", "edge", "[", "old_idx", "]", ";", "new_edge", "[", "idx", "+", "1", "]", "=", "edge", "[", "old_idx", "+", "1", "]", ";", "// all but last are overwritten", "}", "result", ".", "edge", "=", "new_edge", ";", "}", "}", "if", "(", "names", "!=", "null", ")", "{", "String", "[", "]", "new_names", "=", "new", "String", "[", "len", "]", ";", "for", "(", "int", "idx", "=", "0", ";", "idx", "<", "len", ";", "idx", "++", ")", "{", "int", "old_idx", "=", "r", ".", "element", "(", "idx", ")", ";", "new_names", "[", "idx", "]", "=", "names", "[", "old_idx", "]", ";", "}", "result", ".", "names", "=", "new_names", ";", "}", "result", ".", "wasCalcRegular", "=", "false", ";", "result", ".", "calcIsRegular", "(", ")", ";", "return", "result", ";", "}"], "docstring": "Create a new CoordinateAxis1D as a section of this CoordinateAxis1D.\n\n@param r the section range\n@return a new CoordinateAxis1D as a section of this CoordinateAxis1D\n@throws InvalidRangeException if IllegalRange", "docstring_tokens": ["Create", "a", "new", "CoordinateAxis1D", "as", "a", "section", "of", "this", "CoordinateAxis1D", "."]}
{"code": "addTableRecurse( configResult);", "comments": "kinda stupid", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/TableAnalyzer.java", "func_name": "TableAnalyzer.analyze", "original_string": "private void analyze(FeatureType wantFeatureType) throws IOException {\r\n    // for netcdf-3 files, convert record dimension to structure\r\n    // LOOK may be problems when served via opendap\r\n    boolean structAdded = (Boolean) ds.sendIospMessage(NetcdfFile.IOSP_MESSAGE_ADD_RECORD_STRUCTURE);\r\n\r\n    if (tc == null) {\r\n      makeTablesDefault(structAdded);\r\n      makeNestedTables();\r\n\r\n    } else {\r\n      configResult = tc.getConfig(wantFeatureType, ds, errlog);\r\n      if (configResult != null)\r\n        addTableRecurse( configResult); // kinda stupid\r\n      else { // use default\r\n        makeTablesDefault(structAdded);\r\n        makeNestedTables();\r\n      }\r\n    }\r\n\r\n    // find the leaves\r\n    for (TableConfig config : tableSet) {\r\n      if (config.children == null) { // its a leaf\r\n        NestedTable flatTable = new NestedTable(ds, config, errlog);\r\n        leaves.add(flatTable);\r\n      }\r\n    }\r\n\r\n    if (PointDatasetStandardFactory.showTables)\r\n      getDetailInfo( new Formatter( System.out));\r\n  }", "language": "java", "Allcodes": "private void analyze(FeatureType wantFeatureType) throws IOException {\r\n    // for netcdf-3 files, convert record dimension to structure\r\n    // LOOK may be problems when served via opendap\r\n    boolean structAdded = (Boolean) ds.sendIospMessage(NetcdfFile.IOSP_MESSAGE_ADD_RECORD_STRUCTURE);\r\n\r\n    if (tc == null) {\r\n      makeTablesDefault(structAdded);\r\n      makeNestedTables();\r\n\r\n    } else {\r\n      configResult = tc.getConfig(wantFeatureType, ds, errlog);\r\n      if (configResult != null)\r\n        addTableRecurse( configResult); // kinda stupid\r\n      else { // use default\r\n        makeTablesDefault(structAdded);\r\n        makeNestedTables();\r\n      }\r\n    }\r\n\r\n    // find the leaves\r\n    for (TableConfig config : tableSet) {\r\n      if (config.children == null) { // its a leaf\r\n        NestedTable flatTable = new NestedTable(ds, config, errlog);\r\n        leaves.add(flatTable);\r\n      }\r\n    }\r\n\r\n    if (PointDatasetStandardFactory.showTables)\r\n      getDetailInfo( new Formatter( System.out));\r\n  }", "code_tokens": ["private", "void", "analyze", "(", "FeatureType", "wantFeatureType", ")", "throws", "IOException", "{", "// for netcdf-3 files, convert record dimension to structure\r", "// LOOK may be problems when served via opendap\r", "boolean", "structAdded", "=", "(", "Boolean", ")", "ds", ".", "sendIospMessage", "(", "NetcdfFile", ".", "IOSP_MESSAGE_ADD_RECORD_STRUCTURE", ")", ";", "if", "(", "tc", "==", "null", ")", "{", "makeTablesDefault", "(", "structAdded", ")", ";", "makeNestedTables", "(", ")", ";", "}", "else", "{", "configResult", "=", "tc", ".", "getConfig", "(", "wantFeatureType", ",", "ds", ",", "errlog", ")", ";", "if", "(", "configResult", "!=", "null", ")", "addTableRecurse", "(", "configResult", ")", ";", "// kinda stupid\r", "else", "{", "// use default\r", "makeTablesDefault", "(", "structAdded", ")", ";", "makeNestedTables", "(", ")", ";", "}", "}", "// find the leaves\r", "for", "(", "TableConfig", "config", ":", "tableSet", ")", "{", "if", "(", "config", ".", "children", "==", "null", ")", "{", "// its a leaf\r", "NestedTable", "flatTable", "=", "new", "NestedTable", "(", "ds", ",", "config", ",", "errlog", ")", ";", "leaves", ".", "add", "(", "flatTable", ")", ";", "}", "}", "if", "(", "PointDatasetStandardFactory", ".", "showTables", ")", "getDetailInfo", "(", "new", "Formatter", "(", "System", ".", "out", ")", ")", ";", "}"], "docstring": "Make a NestedTable object for the dataset.\n@param wantFeatureType want this FeatureType\n@throws IOException on read error", "docstring_tokens": ["Make", "a", "NestedTable", "object", "for", "the", "dataset", "."]}
{"code": "start--;", "comments": "it's one based", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/iosp/grads/GradsUtil.java", "func_name": "GradsUtil.getGaussianLatitudes", "original_string": "public static double[] getGaussianLatitudes(String type, int start,\n            int num)\n            throws IllegalArgumentException {\n        double[] baseArray = null;\n        start--;  // it's one based\n        if (type.equalsIgnoreCase(GAUST62)) {\n            baseArray = gltst62;\n        } else if (type.equalsIgnoreCase(GAUSR15)) {\n            baseArray = glts15;\n        } else if (type.equalsIgnoreCase(GAUSR20)) {\n            baseArray = glts20;\n        } else if (type.equalsIgnoreCase(GAUSR30)) {\n            baseArray = glts30;\n        } else if (type.equalsIgnoreCase(GAUSR40)) {\n            baseArray = glats;\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + type);\n        }\n        if (start + num > baseArray.length) {\n            throw new IllegalArgumentException(\"Maximum \" + baseArray.length\n                    + \" latitudes exceeded\");\n        }\n        double[] retVals = new double[num];\n        for (int i = 0; i < num; i++) {\n            retVals[i] = baseArray[start + i];\n        }\n        return retVals;\n    }", "language": "java", "Allcodes": "public static double[] getGaussianLatitudes(String type, int start,\n            int num)\n            throws IllegalArgumentException {\n        double[] baseArray = null;\n        start--;  // it's one based\n        if (type.equalsIgnoreCase(GAUST62)) {\n            baseArray = gltst62;\n        } else if (type.equalsIgnoreCase(GAUSR15)) {\n            baseArray = glts15;\n        } else if (type.equalsIgnoreCase(GAUSR20)) {\n            baseArray = glts20;\n        } else if (type.equalsIgnoreCase(GAUSR30)) {\n            baseArray = glts30;\n        } else if (type.equalsIgnoreCase(GAUSR40)) {\n            baseArray = glats;\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + type);\n        }\n        if (start + num > baseArray.length) {\n            throw new IllegalArgumentException(\"Maximum \" + baseArray.length\n                    + \" latitudes exceeded\");\n        }\n        double[] retVals = new double[num];\n        for (int i = 0; i < num; i++) {\n            retVals[i] = baseArray[start + i];\n        }\n        return retVals;\n    }", "code_tokens": ["public", "static", "double", "[", "]", "getGaussianLatitudes", "(", "String", "type", ",", "int", "start", ",", "int", "num", ")", "throws", "IllegalArgumentException", "{", "double", "[", "]", "baseArray", "=", "null", ";", "start", "--", ";", "// it's one based", "if", "(", "type", ".", "equalsIgnoreCase", "(", "GAUST62", ")", ")", "{", "baseArray", "=", "gltst62", ";", "}", "else", "if", "(", "type", ".", "equalsIgnoreCase", "(", "GAUSR15", ")", ")", "{", "baseArray", "=", "glts15", ";", "}", "else", "if", "(", "type", ".", "equalsIgnoreCase", "(", "GAUSR20", ")", ")", "{", "baseArray", "=", "glts20", ";", "}", "else", "if", "(", "type", ".", "equalsIgnoreCase", "(", "GAUSR30", ")", ")", "{", "baseArray", "=", "glts30", ";", "}", "else", "if", "(", "type", ".", "equalsIgnoreCase", "(", "GAUSR40", ")", ")", "{", "baseArray", "=", "glats", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"Unsupported type: \"", "+", "type", ")", ";", "}", "if", "(", "start", "+", "num", ">", "baseArray", ".", "length", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Maximum \"", "+", "baseArray", ".", "length", "+", "\" latitudes exceeded\"", ")", ";", "}", "double", "[", "]", "retVals", "=", "new", "double", "[", "num", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "num", ";", "i", "++", ")", "{", "retVals", "[", "i", "]", "=", "baseArray", "[", "start", "+", "i", "]", ";", "}", "return", "retVals", ";", "}"], "docstring": "Get the latitude values for the given type.\n\n@param type gaussian type\n@param start  starting index (1 based)\n@param num  number of values\n\n@return the values\n\n@throws IllegalArgumentException  invalid or unsupported type", "docstring_tokens": ["Get", "the", "latitude", "values", "for", "the", "given", "type", "."]}
{"code": "g.setParentGroup(this);", "comments": "groups are a tree - only one parent", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Group.java", "func_name": "Group.addGroup", "original_string": "public void addGroup(Group g) {\n    if (immutable) throw new IllegalStateException(\"Cant modify\");\n\n    if (findGroup(g.getShortName()) != null)\n      throw new IllegalArgumentException(\"Group name (\" + g.getShortName() + \") must be unique within Group \" + getShortName());\n\n    groups.add(g);\n    g.setParentGroup(this); // groups are a tree - only one parent\n  }", "language": "java", "Allcodes": "public void addGroup(Group g) {\n    if (immutable) throw new IllegalStateException(\"Cant modify\");\n\n    if (findGroup(g.getShortName()) != null)\n      throw new IllegalArgumentException(\"Group name (\" + g.getShortName() + \") must be unique within Group \" + getShortName());\n\n    groups.add(g);\n    g.setParentGroup(this); // groups are a tree - only one parent\n  }", "code_tokens": ["public", "void", "addGroup", "(", "Group", "g", ")", "{", "if", "(", "immutable", ")", "throw", "new", "IllegalStateException", "(", "\"Cant modify\"", ")", ";", "if", "(", "findGroup", "(", "g", ".", "getShortName", "(", ")", ")", "!=", "null", ")", "throw", "new", "IllegalArgumentException", "(", "\"Group name (\"", "+", "g", ".", "getShortName", "(", ")", "+", "\") must be unique within Group \"", "+", "getShortName", "(", ")", ")", ";", "groups", ".", "add", "(", "g", ")", ";", "g", ".", "setParentGroup", "(", "this", ")", ";", "// groups are a tree - only one parent", "}"], "docstring": "Add a nested Group\n\n@param g add this Group.", "docstring_tokens": ["Add", "a", "nested", "Group"]}
{"code": "v.setParentGroup(this);", "comments": "variable can only be in one group", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Group.java", "func_name": "Group.addVariable", "original_string": "public void addVariable(Variable v) {\n    if (immutable) throw new IllegalStateException(\"Cant modify\");\n    if (v == null) return;\n\n    if (findVariable(v.getShortName()) != null) {\n      //Variable other = findVariable(v.getShortName()); // debug\n      throw new IllegalArgumentException(\"Variable name (\" + v.getShortName() + \") must be unique within Group \" + getShortName());\n    }\n\n    variables.add(v);\n    v.setParentGroup(this); // variable can only be in one group\n  }", "language": "java", "Allcodes": "public void addVariable(Variable v) {\n    if (immutable) throw new IllegalStateException(\"Cant modify\");\n    if (v == null) return;\n\n    if (findVariable(v.getShortName()) != null) {\n      //Variable other = findVariable(v.getShortName()); // debug\n      throw new IllegalArgumentException(\"Variable name (\" + v.getShortName() + \") must be unique within Group \" + getShortName());\n    }\n\n    variables.add(v);\n    v.setParentGroup(this); // variable can only be in one group\n  }", "code_tokens": ["public", "void", "addVariable", "(", "Variable", "v", ")", "{", "if", "(", "immutable", ")", "throw", "new", "IllegalStateException", "(", "\"Cant modify\"", ")", ";", "if", "(", "v", "==", "null", ")", "return", ";", "if", "(", "findVariable", "(", "v", ".", "getShortName", "(", ")", ")", "!=", "null", ")", "{", "//Variable other = findVariable(v.getShortName()); // debug", "throw", "new", "IllegalArgumentException", "(", "\"Variable name (\"", "+", "v", ".", "getShortName", "(", ")", "+", "\") must be unique within Group \"", "+", "getShortName", "(", ")", ")", ";", "}", "variables", ".", "add", "(", "v", ")", ";", "v", ".", "setParentGroup", "(", "this", ")", ";", "// variable can only be in one group", "}"], "docstring": "Add a Variable\n\n@param v add this Variable.", "docstring_tokens": ["Add", "a", "Variable"]}
{"code": "int height = data.getShape()[0];", "comments": "Y", "lines": 50, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/geotiff/GeotiffWriter.java", "func_name": "GeotiffWriter.writeGrid", "original_string": "public void writeGrid(GeoReferencedArray array, boolean greyScale) throws IOException {\n\n    CoverageCoordSys gcs = array.getCoordSysForData();\n    if (!gcs.isRegularSpatial())\n      throw new IllegalArgumentException(\"Must have 1D x and y axes for \" + array.getCoverageName());\n\n    Projection proj = gcs.getProjection();\n    CoverageCoordAxis1D xaxis = (CoverageCoordAxis1D) gcs.getXAxis();\n    CoverageCoordAxis1D yaxis = (CoverageCoordAxis1D) gcs.getYAxis();\n\n    // latlon coord does not need to be scaled\n    double scaler = (xaxis.getUnits().equalsIgnoreCase(\"km\")) ? 1000.0 : 1.0;\n\n    // data must go from top to bottom\n    double xStart = xaxis.getCoordEdge1(0) * scaler;\n    double yStart = yaxis.getCoordEdge1(0) * scaler;\n    double xInc = xaxis.getResolution() * scaler;\n    double yInc = Math.abs(yaxis.getResolution()) * scaler;\n\n    Array data = array.getData().reduce();\n    if (yaxis.getCoordMidpoint(0) < yaxis.getCoordMidpoint(1)) {\n      data = data.flip(0);\n      yStart = yaxis.getCoordEdgeLast();\n    }\n\n    /*  remove - i think unneeded, monotonic lon handled in CoordinateAxis1D. JC 3/18/2013\n     if (gcs.isLatLon()) {\n      Array lon = xaxis.read();\n      data = geoShiftDataAtLon(data, lon);\n      xStart = geoShiftGetXstart(lon, xInc);\n      //xStart = -180.0;\n    }  */\n\n    if (pageNumber > 1) {\n      geotiff.initTags();\n    }\n\n    // write the data first\n    int nextStart = 0;\n    MAMath.MinMax dataMinMax = MAMath.getMinMaxSkipMissingData(data, array);\n    if (greyScale) {\n      ArrayByte result = replaceMissingValuesAndScale(array, data, dataMinMax);\n      nextStart = geotiff.writeData((byte[]) result.getStorage(), pageNumber);\n    } else {\n      ArrayFloat result = replaceMissingValues(array, data, dataMinMax);\n      nextStart = geotiff.writeData((float[]) result.getStorage(), pageNumber);\n    }\n\n    // set the width and the height\n    int height = data.getShape()[0];         // Y\n    int width = data.getShape()[1];         // X\n\n    writeMetadata(greyScale, xStart, yStart, xInc, yInc, height, width, pageNumber, nextStart, dataMinMax, proj);\n    pageNumber++;\n  }", "language": "java", "Allcodes": "public void writeGrid(GeoReferencedArray array, boolean greyScale) throws IOException {\n\n    CoverageCoordSys gcs = array.getCoordSysForData();\n    if (!gcs.isRegularSpatial())\n      throw new IllegalArgumentException(\"Must have 1D x and y axes for \" + array.getCoverageName());\n\n    Projection proj = gcs.getProjection();\n    CoverageCoordAxis1D xaxis = (CoverageCoordAxis1D) gcs.getXAxis();\n    CoverageCoordAxis1D yaxis = (CoverageCoordAxis1D) gcs.getYAxis();\n\n    // latlon coord does not need to be scaled\n    double scaler = (xaxis.getUnits().equalsIgnoreCase(\"km\")) ? 1000.0 : 1.0;\n\n    // data must go from top to bottom\n    double xStart = xaxis.getCoordEdge1(0) * scaler;\n    double yStart = yaxis.getCoordEdge1(0) * scaler;\n    double xInc = xaxis.getResolution() * scaler;\n    double yInc = Math.abs(yaxis.getResolution()) * scaler;\n\n    Array data = array.getData().reduce();\n    if (yaxis.getCoordMidpoint(0) < yaxis.getCoordMidpoint(1)) {\n      data = data.flip(0);\n      yStart = yaxis.getCoordEdgeLast();\n    }\n\n    /*  remove - i think unneeded, monotonic lon handled in CoordinateAxis1D. JC 3/18/2013\n     if (gcs.isLatLon()) {\n      Array lon = xaxis.read();\n      data = geoShiftDataAtLon(data, lon);\n      xStart = geoShiftGetXstart(lon, xInc);\n      //xStart = -180.0;\n    }  */\n\n    if (pageNumber > 1) {\n      geotiff.initTags();\n    }\n\n    // write the data first\n    int nextStart = 0;\n    MAMath.MinMax dataMinMax = MAMath.getMinMaxSkipMissingData(data, array);\n    if (greyScale) {\n      ArrayByte result = replaceMissingValuesAndScale(array, data, dataMinMax);\n      nextStart = geotiff.writeData((byte[]) result.getStorage(), pageNumber);\n    } else {\n      ArrayFloat result = replaceMissingValues(array, data, dataMinMax);\n      nextStart = geotiff.writeData((float[]) result.getStorage(), pageNumber);\n    }\n\n    // set the width and the height\n    int height = data.getShape()[0];         // Y\n    int width = data.getShape()[1];         // X\n\n    writeMetadata(greyScale, xStart, yStart, xInc, yInc, height, width, pageNumber, nextStart, dataMinMax, proj);\n    pageNumber++;\n  }", "code_tokens": ["public", "void", "writeGrid", "(", "GeoReferencedArray", "array", ",", "boolean", "greyScale", ")", "throws", "IOException", "{", "CoverageCoordSys", "gcs", "=", "array", ".", "getCoordSysForData", "(", ")", ";", "if", "(", "!", "gcs", ".", "isRegularSpatial", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Must have 1D x and y axes for \"", "+", "array", ".", "getCoverageName", "(", ")", ")", ";", "Projection", "proj", "=", "gcs", ".", "getProjection", "(", ")", ";", "CoverageCoordAxis1D", "xaxis", "=", "(", "CoverageCoordAxis1D", ")", "gcs", ".", "getXAxis", "(", ")", ";", "CoverageCoordAxis1D", "yaxis", "=", "(", "CoverageCoordAxis1D", ")", "gcs", ".", "getYAxis", "(", ")", ";", "// latlon coord does not need to be scaled", "double", "scaler", "=", "(", "xaxis", ".", "getUnits", "(", ")", ".", "equalsIgnoreCase", "(", "\"km\"", ")", ")", "?", "1000.0", ":", "1.0", ";", "// data must go from top to bottom", "double", "xStart", "=", "xaxis", ".", "getCoordEdge1", "(", "0", ")", "*", "scaler", ";", "double", "yStart", "=", "yaxis", ".", "getCoordEdge1", "(", "0", ")", "*", "scaler", ";", "double", "xInc", "=", "xaxis", ".", "getResolution", "(", ")", "*", "scaler", ";", "double", "yInc", "=", "Math", ".", "abs", "(", "yaxis", ".", "getResolution", "(", ")", ")", "*", "scaler", ";", "Array", "data", "=", "array", ".", "getData", "(", ")", ".", "reduce", "(", ")", ";", "if", "(", "yaxis", ".", "getCoordMidpoint", "(", "0", ")", "<", "yaxis", ".", "getCoordMidpoint", "(", "1", ")", ")", "{", "data", "=", "data", ".", "flip", "(", "0", ")", ";", "yStart", "=", "yaxis", ".", "getCoordEdgeLast", "(", ")", ";", "}", "/*  remove - i think unneeded, monotonic lon handled in CoordinateAxis1D. JC 3/18/2013\n     if (gcs.isLatLon()) {\n      Array lon = xaxis.read();\n      data = geoShiftDataAtLon(data, lon);\n      xStart = geoShiftGetXstart(lon, xInc);\n      //xStart = -180.0;\n    }  */", "if", "(", "pageNumber", ">", "1", ")", "{", "geotiff", ".", "initTags", "(", ")", ";", "}", "// write the data first", "int", "nextStart", "=", "0", ";", "MAMath", ".", "MinMax", "dataMinMax", "=", "MAMath", ".", "getMinMaxSkipMissingData", "(", "data", ",", "array", ")", ";", "if", "(", "greyScale", ")", "{", "ArrayByte", "result", "=", "replaceMissingValuesAndScale", "(", "array", ",", "data", ",", "dataMinMax", ")", ";", "nextStart", "=", "geotiff", ".", "writeData", "(", "(", "byte", "[", "]", ")", "result", ".", "getStorage", "(", ")", ",", "pageNumber", ")", ";", "}", "else", "{", "ArrayFloat", "result", "=", "replaceMissingValues", "(", "array", ",", "data", ",", "dataMinMax", ")", ";", "nextStart", "=", "geotiff", ".", "writeData", "(", "(", "float", "[", "]", ")", "result", ".", "getStorage", "(", ")", ",", "pageNumber", ")", ";", "}", "// set the width and the height", "int", "height", "=", "data", ".", "getShape", "(", ")", "[", "0", "]", ";", "// Y", "int", "width", "=", "data", ".", "getShape", "(", ")", "[", "1", "]", ";", "// X", "writeMetadata", "(", "greyScale", ",", "xStart", ",", "yStart", ",", "xInc", ",", "yInc", ",", "height", ",", "width", ",", "pageNumber", ",", "nextStart", ",", "dataMinMax", ",", "proj", ")", ";", "pageNumber", "++", ";", "}"], "docstring": "Write GridCoverage data to the geotiff file.\n\n@param array      GeoReferencedArray array in YX order\n@param greyScale if true, write greyScale image, else dataSample.\n@throws IOException on i/o error", "docstring_tokens": ["Write", "GridCoverage", "data", "to", "the", "geotiff", "file", "."]}
{"code": "int width = data.getShape()[1];", "comments": "X", "lines": 51, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/geotiff/GeotiffWriter.java", "func_name": "GeotiffWriter.writeGrid", "original_string": "public void writeGrid(GeoReferencedArray array, boolean greyScale) throws IOException {\n\n    CoverageCoordSys gcs = array.getCoordSysForData();\n    if (!gcs.isRegularSpatial())\n      throw new IllegalArgumentException(\"Must have 1D x and y axes for \" + array.getCoverageName());\n\n    Projection proj = gcs.getProjection();\n    CoverageCoordAxis1D xaxis = (CoverageCoordAxis1D) gcs.getXAxis();\n    CoverageCoordAxis1D yaxis = (CoverageCoordAxis1D) gcs.getYAxis();\n\n    // latlon coord does not need to be scaled\n    double scaler = (xaxis.getUnits().equalsIgnoreCase(\"km\")) ? 1000.0 : 1.0;\n\n    // data must go from top to bottom\n    double xStart = xaxis.getCoordEdge1(0) * scaler;\n    double yStart = yaxis.getCoordEdge1(0) * scaler;\n    double xInc = xaxis.getResolution() * scaler;\n    double yInc = Math.abs(yaxis.getResolution()) * scaler;\n\n    Array data = array.getData().reduce();\n    if (yaxis.getCoordMidpoint(0) < yaxis.getCoordMidpoint(1)) {\n      data = data.flip(0);\n      yStart = yaxis.getCoordEdgeLast();\n    }\n\n    /*  remove - i think unneeded, monotonic lon handled in CoordinateAxis1D. JC 3/18/2013\n     if (gcs.isLatLon()) {\n      Array lon = xaxis.read();\n      data = geoShiftDataAtLon(data, lon);\n      xStart = geoShiftGetXstart(lon, xInc);\n      //xStart = -180.0;\n    }  */\n\n    if (pageNumber > 1) {\n      geotiff.initTags();\n    }\n\n    // write the data first\n    int nextStart = 0;\n    MAMath.MinMax dataMinMax = MAMath.getMinMaxSkipMissingData(data, array);\n    if (greyScale) {\n      ArrayByte result = replaceMissingValuesAndScale(array, data, dataMinMax);\n      nextStart = geotiff.writeData((byte[]) result.getStorage(), pageNumber);\n    } else {\n      ArrayFloat result = replaceMissingValues(array, data, dataMinMax);\n      nextStart = geotiff.writeData((float[]) result.getStorage(), pageNumber);\n    }\n\n    // set the width and the height\n    int height = data.getShape()[0];         // Y\n    int width = data.getShape()[1];         // X\n\n    writeMetadata(greyScale, xStart, yStart, xInc, yInc, height, width, pageNumber, nextStart, dataMinMax, proj);\n    pageNumber++;\n  }", "language": "java", "Allcodes": "public void writeGrid(GeoReferencedArray array, boolean greyScale) throws IOException {\n\n    CoverageCoordSys gcs = array.getCoordSysForData();\n    if (!gcs.isRegularSpatial())\n      throw new IllegalArgumentException(\"Must have 1D x and y axes for \" + array.getCoverageName());\n\n    Projection proj = gcs.getProjection();\n    CoverageCoordAxis1D xaxis = (CoverageCoordAxis1D) gcs.getXAxis();\n    CoverageCoordAxis1D yaxis = (CoverageCoordAxis1D) gcs.getYAxis();\n\n    // latlon coord does not need to be scaled\n    double scaler = (xaxis.getUnits().equalsIgnoreCase(\"km\")) ? 1000.0 : 1.0;\n\n    // data must go from top to bottom\n    double xStart = xaxis.getCoordEdge1(0) * scaler;\n    double yStart = yaxis.getCoordEdge1(0) * scaler;\n    double xInc = xaxis.getResolution() * scaler;\n    double yInc = Math.abs(yaxis.getResolution()) * scaler;\n\n    Array data = array.getData().reduce();\n    if (yaxis.getCoordMidpoint(0) < yaxis.getCoordMidpoint(1)) {\n      data = data.flip(0);\n      yStart = yaxis.getCoordEdgeLast();\n    }\n\n    /*  remove - i think unneeded, monotonic lon handled in CoordinateAxis1D. JC 3/18/2013\n     if (gcs.isLatLon()) {\n      Array lon = xaxis.read();\n      data = geoShiftDataAtLon(data, lon);\n      xStart = geoShiftGetXstart(lon, xInc);\n      //xStart = -180.0;\n    }  */\n\n    if (pageNumber > 1) {\n      geotiff.initTags();\n    }\n\n    // write the data first\n    int nextStart = 0;\n    MAMath.MinMax dataMinMax = MAMath.getMinMaxSkipMissingData(data, array);\n    if (greyScale) {\n      ArrayByte result = replaceMissingValuesAndScale(array, data, dataMinMax);\n      nextStart = geotiff.writeData((byte[]) result.getStorage(), pageNumber);\n    } else {\n      ArrayFloat result = replaceMissingValues(array, data, dataMinMax);\n      nextStart = geotiff.writeData((float[]) result.getStorage(), pageNumber);\n    }\n\n    // set the width and the height\n    int height = data.getShape()[0];         // Y\n    int width = data.getShape()[1];         // X\n\n    writeMetadata(greyScale, xStart, yStart, xInc, yInc, height, width, pageNumber, nextStart, dataMinMax, proj);\n    pageNumber++;\n  }", "code_tokens": ["public", "void", "writeGrid", "(", "GeoReferencedArray", "array", ",", "boolean", "greyScale", ")", "throws", "IOException", "{", "CoverageCoordSys", "gcs", "=", "array", ".", "getCoordSysForData", "(", ")", ";", "if", "(", "!", "gcs", ".", "isRegularSpatial", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Must have 1D x and y axes for \"", "+", "array", ".", "getCoverageName", "(", ")", ")", ";", "Projection", "proj", "=", "gcs", ".", "getProjection", "(", ")", ";", "CoverageCoordAxis1D", "xaxis", "=", "(", "CoverageCoordAxis1D", ")", "gcs", ".", "getXAxis", "(", ")", ";", "CoverageCoordAxis1D", "yaxis", "=", "(", "CoverageCoordAxis1D", ")", "gcs", ".", "getYAxis", "(", ")", ";", "// latlon coord does not need to be scaled", "double", "scaler", "=", "(", "xaxis", ".", "getUnits", "(", ")", ".", "equalsIgnoreCase", "(", "\"km\"", ")", ")", "?", "1000.0", ":", "1.0", ";", "// data must go from top to bottom", "double", "xStart", "=", "xaxis", ".", "getCoordEdge1", "(", "0", ")", "*", "scaler", ";", "double", "yStart", "=", "yaxis", ".", "getCoordEdge1", "(", "0", ")", "*", "scaler", ";", "double", "xInc", "=", "xaxis", ".", "getResolution", "(", ")", "*", "scaler", ";", "double", "yInc", "=", "Math", ".", "abs", "(", "yaxis", ".", "getResolution", "(", ")", ")", "*", "scaler", ";", "Array", "data", "=", "array", ".", "getData", "(", ")", ".", "reduce", "(", ")", ";", "if", "(", "yaxis", ".", "getCoordMidpoint", "(", "0", ")", "<", "yaxis", ".", "getCoordMidpoint", "(", "1", ")", ")", "{", "data", "=", "data", ".", "flip", "(", "0", ")", ";", "yStart", "=", "yaxis", ".", "getCoordEdgeLast", "(", ")", ";", "}", "/*  remove - i think unneeded, monotonic lon handled in CoordinateAxis1D. JC 3/18/2013\n     if (gcs.isLatLon()) {\n      Array lon = xaxis.read();\n      data = geoShiftDataAtLon(data, lon);\n      xStart = geoShiftGetXstart(lon, xInc);\n      //xStart = -180.0;\n    }  */", "if", "(", "pageNumber", ">", "1", ")", "{", "geotiff", ".", "initTags", "(", ")", ";", "}", "// write the data first", "int", "nextStart", "=", "0", ";", "MAMath", ".", "MinMax", "dataMinMax", "=", "MAMath", ".", "getMinMaxSkipMissingData", "(", "data", ",", "array", ")", ";", "if", "(", "greyScale", ")", "{", "ArrayByte", "result", "=", "replaceMissingValuesAndScale", "(", "array", ",", "data", ",", "dataMinMax", ")", ";", "nextStart", "=", "geotiff", ".", "writeData", "(", "(", "byte", "[", "]", ")", "result", ".", "getStorage", "(", ")", ",", "pageNumber", ")", ";", "}", "else", "{", "ArrayFloat", "result", "=", "replaceMissingValues", "(", "array", ",", "data", ",", "dataMinMax", ")", ";", "nextStart", "=", "geotiff", ".", "writeData", "(", "(", "float", "[", "]", ")", "result", ".", "getStorage", "(", ")", ",", "pageNumber", ")", ";", "}", "// set the width and the height", "int", "height", "=", "data", ".", "getShape", "(", ")", "[", "0", "]", ";", "// Y", "int", "width", "=", "data", ".", "getShape", "(", ")", "[", "1", "]", ";", "// X", "writeMetadata", "(", "greyScale", ",", "xStart", ",", "yStart", ",", "xInc", ",", "yInc", ",", "height", ",", "width", ",", "pageNumber", ",", "nextStart", ",", "dataMinMax", ",", "proj", ")", ";", "pageNumber", "++", ";", "}"], "docstring": "Write GridCoverage data to the geotiff file.\n\n@param array      GeoReferencedArray array in YX order\n@param greyScale if true, write greyScale image, else dataSample.\n@throws IOException on i/o error", "docstring_tokens": ["Write", "GridCoverage", "data", "to", "the", "geotiff", "file", "."]}
{"code": "Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);", "comments": "LOOK ignoring partition type", "lines": 8, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribCdmIndex.java", "func_name": "GribCdmIndex.openGribCollectionFromDataFile", "original_string": "@Nullable\n  public static GribCollectionImmutable openGribCollectionFromDataFile(boolean isGrib1, MFile mfile, CollectionUpdateType updateType,\n                                                                       FeatureCollectionConfig config, Formatter errlog, org.slf4j.Logger logger) throws IOException {\n\n    MCollection dcm = new CollectionSingleFile(mfile, logger);\n    dcm.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, config);\n    if (isGrib1) {\n      Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);       // LOOK ignoring partition type\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    } else {\n      Grib2CollectionBuilder builder = new Grib2CollectionBuilder(dcm.getCollectionName(), dcm, logger);\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    }\n\n    // the index file should now exist, open it\n    GribCollectionImmutable result = openCdmIndex(dcm.getIndexFilename(NCX_SUFFIX), config, true, logger);\n    if (result != null) return result;\n\n    // if open fails, force recreate the index\n    if (updateType == CollectionUpdateType.never) return null; // not allowed to write\n    if (updateType == CollectionUpdateType.always) return null;// already tried to force write, give up\n    return openGribCollectionFromDataFile(isGrib1, mfile, CollectionUpdateType.always, config, errlog, logger);\n  }", "language": "java", "Allcodes": "@Nullable\n  public static GribCollectionImmutable openGribCollectionFromDataFile(boolean isGrib1, MFile mfile, CollectionUpdateType updateType,\n                                                                       FeatureCollectionConfig config, Formatter errlog, org.slf4j.Logger logger) throws IOException {\n\n    MCollection dcm = new CollectionSingleFile(mfile, logger);\n    dcm.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, config);\n    if (isGrib1) {\n      Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);       // LOOK ignoring partition type\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    } else {\n      Grib2CollectionBuilder builder = new Grib2CollectionBuilder(dcm.getCollectionName(), dcm, logger);\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    }\n\n    // the index file should now exist, open it\n    GribCollectionImmutable result = openCdmIndex(dcm.getIndexFilename(NCX_SUFFIX), config, true, logger);\n    if (result != null) return result;\n\n    // if open fails, force recreate the index\n    if (updateType == CollectionUpdateType.never) return null; // not allowed to write\n    if (updateType == CollectionUpdateType.always) return null;// already tried to force write, give up\n    return openGribCollectionFromDataFile(isGrib1, mfile, CollectionUpdateType.always, config, errlog, logger);\n  }", "code_tokens": ["@", "Nullable", "public", "static", "GribCollectionImmutable", "openGribCollectionFromDataFile", "(", "boolean", "isGrib1", ",", "MFile", "mfile", ",", "CollectionUpdateType", "updateType", ",", "FeatureCollectionConfig", "config", ",", "Formatter", "errlog", ",", "org", ".", "slf4j", ".", "Logger", "logger", ")", "throws", "IOException", "{", "MCollection", "dcm", "=", "new", "CollectionSingleFile", "(", "mfile", ",", "logger", ")", ";", "dcm", ".", "putAuxInfo", "(", "FeatureCollectionConfig", ".", "AUX_CONFIG", ",", "config", ")", ";", "if", "(", "isGrib1", ")", "{", "Grib1CollectionBuilder", "builder", "=", "new", "Grib1CollectionBuilder", "(", "dcm", ".", "getCollectionName", "(", ")", ",", "dcm", ",", "logger", ")", ";", "// LOOK ignoring partition type", "boolean", "changed", "=", "(", "builder", ".", "updateNeeded", "(", "updateType", ")", "&&", "builder", ".", "createIndex", "(", "FeatureCollectionConfig", ".", "PartitionType", ".", "file", ",", "errlog", ")", ")", ";", "}", "else", "{", "Grib2CollectionBuilder", "builder", "=", "new", "Grib2CollectionBuilder", "(", "dcm", ".", "getCollectionName", "(", ")", ",", "dcm", ",", "logger", ")", ";", "boolean", "changed", "=", "(", "builder", ".", "updateNeeded", "(", "updateType", ")", "&&", "builder", ".", "createIndex", "(", "FeatureCollectionConfig", ".", "PartitionType", ".", "file", ",", "errlog", ")", ")", ";", "}", "// the index file should now exist, open it", "GribCollectionImmutable", "result", "=", "openCdmIndex", "(", "dcm", ".", "getIndexFilename", "(", "NCX_SUFFIX", ")", ",", "config", ",", "true", ",", "logger", ")", ";", "if", "(", "result", "!=", "null", ")", "return", "result", ";", "// if open fails, force recreate the index", "if", "(", "updateType", "==", "CollectionUpdateType", ".", "never", ")", "return", "null", ";", "// not allowed to write", "if", "(", "updateType", "==", "CollectionUpdateType", ".", "always", ")", "return", "null", ";", "// already tried to force write, give up", "return", "openGribCollectionFromDataFile", "(", "isGrib1", ",", "mfile", ",", "CollectionUpdateType", ".", "always", ",", "config", ",", "errlog", ",", "logger", ")", ";", "}"], "docstring": "from a single file, read in the index, create if it doesnt exist; return null on failure", "docstring_tokens": ["from", "a", "single", "file", "read", "in", "the", "index", "create", "if", "it", "doesnt", "exist", ";", "return", "null", "on", "failure"]}
{"code": "if (updateType == CollectionUpdateType.never) return null;", "comments": "not allowed to write", "lines": 20, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribCdmIndex.java", "func_name": "GribCdmIndex.openGribCollectionFromDataFile", "original_string": "@Nullable\n  public static GribCollectionImmutable openGribCollectionFromDataFile(boolean isGrib1, MFile mfile, CollectionUpdateType updateType,\n                                                                       FeatureCollectionConfig config, Formatter errlog, org.slf4j.Logger logger) throws IOException {\n\n    MCollection dcm = new CollectionSingleFile(mfile, logger);\n    dcm.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, config);\n    if (isGrib1) {\n      Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);       // LOOK ignoring partition type\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    } else {\n      Grib2CollectionBuilder builder = new Grib2CollectionBuilder(dcm.getCollectionName(), dcm, logger);\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    }\n\n    // the index file should now exist, open it\n    GribCollectionImmutable result = openCdmIndex(dcm.getIndexFilename(NCX_SUFFIX), config, true, logger);\n    if (result != null) return result;\n\n    // if open fails, force recreate the index\n    if (updateType == CollectionUpdateType.never) return null; // not allowed to write\n    if (updateType == CollectionUpdateType.always) return null;// already tried to force write, give up\n    return openGribCollectionFromDataFile(isGrib1, mfile, CollectionUpdateType.always, config, errlog, logger);\n  }", "language": "java", "Allcodes": "@Nullable\n  public static GribCollectionImmutable openGribCollectionFromDataFile(boolean isGrib1, MFile mfile, CollectionUpdateType updateType,\n                                                                       FeatureCollectionConfig config, Formatter errlog, org.slf4j.Logger logger) throws IOException {\n\n    MCollection dcm = new CollectionSingleFile(mfile, logger);\n    dcm.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, config);\n    if (isGrib1) {\n      Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);       // LOOK ignoring partition type\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    } else {\n      Grib2CollectionBuilder builder = new Grib2CollectionBuilder(dcm.getCollectionName(), dcm, logger);\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    }\n\n    // the index file should now exist, open it\n    GribCollectionImmutable result = openCdmIndex(dcm.getIndexFilename(NCX_SUFFIX), config, true, logger);\n    if (result != null) return result;\n\n    // if open fails, force recreate the index\n    if (updateType == CollectionUpdateType.never) return null; // not allowed to write\n    if (updateType == CollectionUpdateType.always) return null;// already tried to force write, give up\n    return openGribCollectionFromDataFile(isGrib1, mfile, CollectionUpdateType.always, config, errlog, logger);\n  }", "code_tokens": ["@", "Nullable", "public", "static", "GribCollectionImmutable", "openGribCollectionFromDataFile", "(", "boolean", "isGrib1", ",", "MFile", "mfile", ",", "CollectionUpdateType", "updateType", ",", "FeatureCollectionConfig", "config", ",", "Formatter", "errlog", ",", "org", ".", "slf4j", ".", "Logger", "logger", ")", "throws", "IOException", "{", "MCollection", "dcm", "=", "new", "CollectionSingleFile", "(", "mfile", ",", "logger", ")", ";", "dcm", ".", "putAuxInfo", "(", "FeatureCollectionConfig", ".", "AUX_CONFIG", ",", "config", ")", ";", "if", "(", "isGrib1", ")", "{", "Grib1CollectionBuilder", "builder", "=", "new", "Grib1CollectionBuilder", "(", "dcm", ".", "getCollectionName", "(", ")", ",", "dcm", ",", "logger", ")", ";", "// LOOK ignoring partition type", "boolean", "changed", "=", "(", "builder", ".", "updateNeeded", "(", "updateType", ")", "&&", "builder", ".", "createIndex", "(", "FeatureCollectionConfig", ".", "PartitionType", ".", "file", ",", "errlog", ")", ")", ";", "}", "else", "{", "Grib2CollectionBuilder", "builder", "=", "new", "Grib2CollectionBuilder", "(", "dcm", ".", "getCollectionName", "(", ")", ",", "dcm", ",", "logger", ")", ";", "boolean", "changed", "=", "(", "builder", ".", "updateNeeded", "(", "updateType", ")", "&&", "builder", ".", "createIndex", "(", "FeatureCollectionConfig", ".", "PartitionType", ".", "file", ",", "errlog", ")", ")", ";", "}", "// the index file should now exist, open it", "GribCollectionImmutable", "result", "=", "openCdmIndex", "(", "dcm", ".", "getIndexFilename", "(", "NCX_SUFFIX", ")", ",", "config", ",", "true", ",", "logger", ")", ";", "if", "(", "result", "!=", "null", ")", "return", "result", ";", "// if open fails, force recreate the index", "if", "(", "updateType", "==", "CollectionUpdateType", ".", "never", ")", "return", "null", ";", "// not allowed to write", "if", "(", "updateType", "==", "CollectionUpdateType", ".", "always", ")", "return", "null", ";", "// already tried to force write, give up", "return", "openGribCollectionFromDataFile", "(", "isGrib1", ",", "mfile", ",", "CollectionUpdateType", ".", "always", ",", "config", ",", "errlog", ",", "logger", ")", ";", "}"], "docstring": "from a single file, read in the index, create if it doesnt exist; return null on failure", "docstring_tokens": ["from", "a", "single", "file", "read", "in", "the", "index", "create", "if", "it", "doesnt", "exist", ";", "return", "null", "on", "failure"]}
{"code": "if (updateType == CollectionUpdateType.always) return null;", "comments": "already tried to force write, give up", "lines": 21, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribCdmIndex.java", "func_name": "GribCdmIndex.openGribCollectionFromDataFile", "original_string": "@Nullable\n  public static GribCollectionImmutable openGribCollectionFromDataFile(boolean isGrib1, MFile mfile, CollectionUpdateType updateType,\n                                                                       FeatureCollectionConfig config, Formatter errlog, org.slf4j.Logger logger) throws IOException {\n\n    MCollection dcm = new CollectionSingleFile(mfile, logger);\n    dcm.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, config);\n    if (isGrib1) {\n      Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);       // LOOK ignoring partition type\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    } else {\n      Grib2CollectionBuilder builder = new Grib2CollectionBuilder(dcm.getCollectionName(), dcm, logger);\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    }\n\n    // the index file should now exist, open it\n    GribCollectionImmutable result = openCdmIndex(dcm.getIndexFilename(NCX_SUFFIX), config, true, logger);\n    if (result != null) return result;\n\n    // if open fails, force recreate the index\n    if (updateType == CollectionUpdateType.never) return null; // not allowed to write\n    if (updateType == CollectionUpdateType.always) return null;// already tried to force write, give up\n    return openGribCollectionFromDataFile(isGrib1, mfile, CollectionUpdateType.always, config, errlog, logger);\n  }", "language": "java", "Allcodes": "@Nullable\n  public static GribCollectionImmutable openGribCollectionFromDataFile(boolean isGrib1, MFile mfile, CollectionUpdateType updateType,\n                                                                       FeatureCollectionConfig config, Formatter errlog, org.slf4j.Logger logger) throws IOException {\n\n    MCollection dcm = new CollectionSingleFile(mfile, logger);\n    dcm.putAuxInfo(FeatureCollectionConfig.AUX_CONFIG, config);\n    if (isGrib1) {\n      Grib1CollectionBuilder builder = new Grib1CollectionBuilder(dcm.getCollectionName(), dcm, logger);       // LOOK ignoring partition type\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    } else {\n      Grib2CollectionBuilder builder = new Grib2CollectionBuilder(dcm.getCollectionName(), dcm, logger);\n      boolean changed = (builder.updateNeeded(updateType) && builder.createIndex(FeatureCollectionConfig.PartitionType.file, errlog));\n    }\n\n    // the index file should now exist, open it\n    GribCollectionImmutable result = openCdmIndex(dcm.getIndexFilename(NCX_SUFFIX), config, true, logger);\n    if (result != null) return result;\n\n    // if open fails, force recreate the index\n    if (updateType == CollectionUpdateType.never) return null; // not allowed to write\n    if (updateType == CollectionUpdateType.always) return null;// already tried to force write, give up\n    return openGribCollectionFromDataFile(isGrib1, mfile, CollectionUpdateType.always, config, errlog, logger);\n  }", "code_tokens": ["@", "Nullable", "public", "static", "GribCollectionImmutable", "openGribCollectionFromDataFile", "(", "boolean", "isGrib1", ",", "MFile", "mfile", ",", "CollectionUpdateType", "updateType", ",", "FeatureCollectionConfig", "config", ",", "Formatter", "errlog", ",", "org", ".", "slf4j", ".", "Logger", "logger", ")", "throws", "IOException", "{", "MCollection", "dcm", "=", "new", "CollectionSingleFile", "(", "mfile", ",", "logger", ")", ";", "dcm", ".", "putAuxInfo", "(", "FeatureCollectionConfig", ".", "AUX_CONFIG", ",", "config", ")", ";", "if", "(", "isGrib1", ")", "{", "Grib1CollectionBuilder", "builder", "=", "new", "Grib1CollectionBuilder", "(", "dcm", ".", "getCollectionName", "(", ")", ",", "dcm", ",", "logger", ")", ";", "// LOOK ignoring partition type", "boolean", "changed", "=", "(", "builder", ".", "updateNeeded", "(", "updateType", ")", "&&", "builder", ".", "createIndex", "(", "FeatureCollectionConfig", ".", "PartitionType", ".", "file", ",", "errlog", ")", ")", ";", "}", "else", "{", "Grib2CollectionBuilder", "builder", "=", "new", "Grib2CollectionBuilder", "(", "dcm", ".", "getCollectionName", "(", ")", ",", "dcm", ",", "logger", ")", ";", "boolean", "changed", "=", "(", "builder", ".", "updateNeeded", "(", "updateType", ")", "&&", "builder", ".", "createIndex", "(", "FeatureCollectionConfig", ".", "PartitionType", ".", "file", ",", "errlog", ")", ")", ";", "}", "// the index file should now exist, open it", "GribCollectionImmutable", "result", "=", "openCdmIndex", "(", "dcm", ".", "getIndexFilename", "(", "NCX_SUFFIX", ")", ",", "config", ",", "true", ",", "logger", ")", ";", "if", "(", "result", "!=", "null", ")", "return", "result", ";", "// if open fails, force recreate the index", "if", "(", "updateType", "==", "CollectionUpdateType", ".", "never", ")", "return", "null", ";", "// not allowed to write", "if", "(", "updateType", "==", "CollectionUpdateType", ".", "always", ")", "return", "null", ";", "// already tried to force write, give up", "return", "openGribCollectionFromDataFile", "(", "isGrib1", ",", "mfile", ",", "CollectionUpdateType", ".", "always", ",", "config", ",", "errlog", ",", "logger", ")", ";", "}"], "docstring": "from a single file, read in the index, create if it doesnt exist; return null on failure", "docstring_tokens": ["from", "a", "single", "file", "read", "in", "the", "index", "create", "if", "it", "doesnt", "exist", ";", "return", "null", "on", "failure"]}
{"code": "return false;", "comments": "e.g. pattern=x.y.org url=y.org", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/rc/RC.java", "func_name": "RC.urlMatch", "original_string": "static boolean\n  urlMatch(URL pattern, URL url) {\n    int relation;\n\n    if (pattern == null)\n      return (url == null);\n\n    if (!(url.getHost().endsWith(pattern.getHost())))\n      return false; // e.g. pattern=x.y.org url=y.org\n\n    if (!(url.getPath().startsWith(pattern.getPath())))\n      return false; // e.g. pattern=y.org/a/b url=y.org/a\n\n    if (pattern.getPort() > 0 && pattern.getPort() != url.getPort())\n      return false;\n\n    // note: all other fields are ignored\n\n    return true;\n  }", "language": "java", "Allcodes": "static boolean\n  urlMatch(URL pattern, URL url) {\n    int relation;\n\n    if (pattern == null)\n      return (url == null);\n\n    if (!(url.getHost().endsWith(pattern.getHost())))\n      return false; // e.g. pattern=x.y.org url=y.org\n\n    if (!(url.getPath().startsWith(pattern.getPath())))\n      return false; // e.g. pattern=y.org/a/b url=y.org/a\n\n    if (pattern.getPort() > 0 && pattern.getPort() != url.getPort())\n      return false;\n\n    // note: all other fields are ignored\n\n    return true;\n  }", "code_tokens": ["static", "boolean", "urlMatch", "(", "URL", "pattern", ",", "URL", "url", ")", "{", "int", "relation", ";", "if", "(", "pattern", "==", "null", ")", "return", "(", "url", "==", "null", ")", ";", "if", "(", "!", "(", "url", ".", "getHost", "(", ")", ".", "endsWith", "(", "pattern", ".", "getHost", "(", ")", ")", ")", ")", "return", "false", ";", "// e.g. pattern=x.y.org url=y.org", "if", "(", "!", "(", "url", ".", "getPath", "(", ")", ".", "startsWith", "(", "pattern", ".", "getPath", "(", ")", ")", ")", ")", "return", "false", ";", "// e.g. pattern=y.org/a/b url=y.org/a", "if", "(", "pattern", ".", "getPort", "(", ")", ">", "0", "&&", "pattern", ".", "getPort", "(", ")", "!=", "url", ".", "getPort", "(", ")", ")", "return", "false", ";", "// note: all other fields are ignored", "return", "true", ";", "}"], "docstring": "Match has different semantics than urlCompare", "docstring_tokens": ["Match", "has", "different", "semantics", "than", "urlCompare"]}
{"code": "return false;", "comments": "e.g. pattern=y.org/a/b url=y.org/a", "lines": 12, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/rc/RC.java", "func_name": "RC.urlMatch", "original_string": "static boolean\n  urlMatch(URL pattern, URL url) {\n    int relation;\n\n    if (pattern == null)\n      return (url == null);\n\n    if (!(url.getHost().endsWith(pattern.getHost())))\n      return false; // e.g. pattern=x.y.org url=y.org\n\n    if (!(url.getPath().startsWith(pattern.getPath())))\n      return false; // e.g. pattern=y.org/a/b url=y.org/a\n\n    if (pattern.getPort() > 0 && pattern.getPort() != url.getPort())\n      return false;\n\n    // note: all other fields are ignored\n\n    return true;\n  }", "language": "java", "Allcodes": "static boolean\n  urlMatch(URL pattern, URL url) {\n    int relation;\n\n    if (pattern == null)\n      return (url == null);\n\n    if (!(url.getHost().endsWith(pattern.getHost())))\n      return false; // e.g. pattern=x.y.org url=y.org\n\n    if (!(url.getPath().startsWith(pattern.getPath())))\n      return false; // e.g. pattern=y.org/a/b url=y.org/a\n\n    if (pattern.getPort() > 0 && pattern.getPort() != url.getPort())\n      return false;\n\n    // note: all other fields are ignored\n\n    return true;\n  }", "code_tokens": ["static", "boolean", "urlMatch", "(", "URL", "pattern", ",", "URL", "url", ")", "{", "int", "relation", ";", "if", "(", "pattern", "==", "null", ")", "return", "(", "url", "==", "null", ")", ";", "if", "(", "!", "(", "url", ".", "getHost", "(", ")", ".", "endsWith", "(", "pattern", ".", "getHost", "(", ")", ")", ")", ")", "return", "false", ";", "// e.g. pattern=x.y.org url=y.org", "if", "(", "!", "(", "url", ".", "getPath", "(", ")", ".", "startsWith", "(", "pattern", ".", "getPath", "(", ")", ")", ")", ")", "return", "false", ";", "// e.g. pattern=y.org/a/b url=y.org/a", "if", "(", "pattern", ".", "getPort", "(", ")", ">", "0", "&&", "pattern", ".", "getPort", "(", ")", "!=", "url", ".", "getPort", "(", ")", ")", "return", "false", ";", "// note: all other fields are ignored", "return", "true", ";", "}"], "docstring": "Match has different semantics than urlCompare", "docstring_tokens": ["Match", "has", "different", "semantics", "than", "urlCompare"]}
{"code": "RC.set(key, triple.value);", "comments": "let set sort it out", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/rc/RC.java", "func_name": "RC.setWellKnown", "original_string": "static void\n  setWellKnown() {\n    if (dfaltRC.triplestore.size() == 0) return;\n    // Walk the set of triples looking for those that have no url\n    for (String key : dfaltRC.keySet()) {\n      Triple triple = dfaltRC.lookup(key);\n      if (triple.url == null) {\n        RC.set(key, triple.value); // let set sort it out\n      }\n    }\n  }", "language": "java", "Allcodes": "static void\n  setWellKnown() {\n    if (dfaltRC.triplestore.size() == 0) return;\n    // Walk the set of triples looking for those that have no url\n    for (String key : dfaltRC.keySet()) {\n      Triple triple = dfaltRC.lookup(key);\n      if (triple.url == null) {\n        RC.set(key, triple.value); // let set sort it out\n      }\n    }\n  }", "code_tokens": ["static", "void", "setWellKnown", "(", ")", "{", "if", "(", "dfaltRC", ".", "triplestore", ".", "size", "(", ")", "==", "0", ")", "return", ";", "// Walk the set of triples looking for those that have no url", "for", "(", "String", "key", ":", "dfaltRC", ".", "keySet", "(", ")", ")", "{", "Triple", "triple", "=", "dfaltRC", ".", "lookup", "(", "key", ")", ";", "if", "(", "triple", ".", "url", "==", "null", ")", "{", "RC", ".", "set", "(", "key", ",", "triple", ".", "value", ")", ";", "// let set sort it out", "}", "}", "}"], "docstring": "Record some well known parameters", "docstring_tokens": ["Record", "some", "well", "known", "parameters"]}
{"code": "if (line.length() == 0) continue;", "comments": "empty line", "lines": 16, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/rc/RC.java", "func_name": "RC.load", "original_string": "public boolean\n  load(String abspath) {\n    abspath = abspath.replace('\\\\', '/');\n    File rcFile = new File(abspath);\n    if (!rcFile.exists() || !rcFile.canRead()) {\n      return false;\n    }\n    if (showlog) log.debug(\"Loading rc file: \" + abspath);\n    try (BufferedReader rdr = new BufferedReader(new InputStreamReader(new FileInputStream(rcFile), CDM.UTF8))) {\n        for (int lineno = 1; ; lineno++) {\n          URL url = null;\n          String line = rdr.readLine();\n          if (line == null) break;\n          // trim leading blanks\n          line = line.trim();\n          if (line.length() == 0) continue; // empty line\n          if (line.charAt(0) == '#') continue; // check for comment\n          // parse the line\n          if (line.charAt(0) == LTAG) {\n            int rindex = line.indexOf(RTAG);\n            if (rindex < 0) return false;\n            if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            String surl = line.substring(1, rindex);\n            try {\n              url = new URL(surl);\n            } catch (MalformedURLException mue) {\n              if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            }\n            line = line.substring(rindex + 1);\n            // trim again\n            line = line.trim();\n          }\n          // Get the key,value part\n          String[] pieces = line.split(\"\\\\s*=\\\\s*\");\n          assert (pieces.length == 1 || pieces.length == 2);\n          // Create the triple\n          String value = \"1\";\n          if (pieces.length == 2) value = pieces[1].trim();\n          Triple triple = new Triple(pieces[0].trim(), value, url);\n          List<Triple> list = triplestore.get(triple.key);\n          if (list == null) list = new ArrayList<Triple>();\n          Triple prev = addtriple(list, triple);\n          triplestore.put(triple.key, list);\n        }\n\n      } catch (FileNotFoundException fe) {\n        if (showlog) log.debug(\"Loading rc file: \" + abspath);\n        return false;\n\n      } catch (IOException ioe) {\n        if (showlog) log.error(\"File \" + abspath + \": IO exception: \" + ioe.getMessage());\n        return false;\n      }\n      return true;\n    }", "language": "java", "Allcodes": "public boolean\n  load(String abspath) {\n    abspath = abspath.replace('\\\\', '/');\n    File rcFile = new File(abspath);\n    if (!rcFile.exists() || !rcFile.canRead()) {\n      return false;\n    }\n    if (showlog) log.debug(\"Loading rc file: \" + abspath);\n    try (BufferedReader rdr = new BufferedReader(new InputStreamReader(new FileInputStream(rcFile), CDM.UTF8))) {\n        for (int lineno = 1; ; lineno++) {\n          URL url = null;\n          String line = rdr.readLine();\n          if (line == null) break;\n          // trim leading blanks\n          line = line.trim();\n          if (line.length() == 0) continue; // empty line\n          if (line.charAt(0) == '#') continue; // check for comment\n          // parse the line\n          if (line.charAt(0) == LTAG) {\n            int rindex = line.indexOf(RTAG);\n            if (rindex < 0) return false;\n            if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            String surl = line.substring(1, rindex);\n            try {\n              url = new URL(surl);\n            } catch (MalformedURLException mue) {\n              if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            }\n            line = line.substring(rindex + 1);\n            // trim again\n            line = line.trim();\n          }\n          // Get the key,value part\n          String[] pieces = line.split(\"\\\\s*=\\\\s*\");\n          assert (pieces.length == 1 || pieces.length == 2);\n          // Create the triple\n          String value = \"1\";\n          if (pieces.length == 2) value = pieces[1].trim();\n          Triple triple = new Triple(pieces[0].trim(), value, url);\n          List<Triple> list = triplestore.get(triple.key);\n          if (list == null) list = new ArrayList<Triple>();\n          Triple prev = addtriple(list, triple);\n          triplestore.put(triple.key, list);\n        }\n\n      } catch (FileNotFoundException fe) {\n        if (showlog) log.debug(\"Loading rc file: \" + abspath);\n        return false;\n\n      } catch (IOException ioe) {\n        if (showlog) log.error(\"File \" + abspath + \": IO exception: \" + ioe.getMessage());\n        return false;\n      }\n      return true;\n    }", "code_tokens": ["public", "boolean", "load", "(", "String", "abspath", ")", "{", "abspath", "=", "abspath", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "File", "rcFile", "=", "new", "File", "(", "abspath", ")", ";", "if", "(", "!", "rcFile", ".", "exists", "(", ")", "||", "!", "rcFile", ".", "canRead", "(", ")", ")", "{", "return", "false", ";", "}", "if", "(", "showlog", ")", "log", ".", "debug", "(", "\"Loading rc file: \"", "+", "abspath", ")", ";", "try", "(", "BufferedReader", "rdr", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "new", "FileInputStream", "(", "rcFile", ")", ",", "CDM", ".", "UTF8", ")", ")", ")", "{", "for", "(", "int", "lineno", "=", "1", ";", ";", "lineno", "++", ")", "{", "URL", "url", "=", "null", ";", "String", "line", "=", "rdr", ".", "readLine", "(", ")", ";", "if", "(", "line", "==", "null", ")", "break", ";", "// trim leading blanks", "line", "=", "line", ".", "trim", "(", ")", ";", "if", "(", "line", ".", "length", "(", ")", "==", "0", ")", "continue", ";", "// empty line", "if", "(", "line", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "continue", ";", "// check for comment", "// parse the line", "if", "(", "line", ".", "charAt", "(", "0", ")", "==", "LTAG", ")", "{", "int", "rindex", "=", "line", ".", "indexOf", "(", "RTAG", ")", ";", "if", "(", "rindex", "<", "0", ")", "return", "false", ";", "if", "(", "showlog", ")", "log", ".", "error", "(", "\"Malformed [url] at \"", "+", "abspath", "+", "\".\"", "+", "lineno", ")", ";", "String", "surl", "=", "line", ".", "substring", "(", "1", ",", "rindex", ")", ";", "try", "{", "url", "=", "new", "URL", "(", "surl", ")", ";", "}", "catch", "(", "MalformedURLException", "mue", ")", "{", "if", "(", "showlog", ")", "log", ".", "error", "(", "\"Malformed [url] at \"", "+", "abspath", "+", "\".\"", "+", "lineno", ")", ";", "}", "line", "=", "line", ".", "substring", "(", "rindex", "+", "1", ")", ";", "// trim again", "line", "=", "line", ".", "trim", "(", ")", ";", "}", "// Get the key,value part", "String", "[", "]", "pieces", "=", "line", ".", "split", "(", "\"\\\\s*=\\\\s*\"", ")", ";", "assert", "(", "pieces", ".", "length", "==", "1", "||", "pieces", ".", "length", "==", "2", ")", ";", "// Create the triple", "String", "value", "=", "\"1\"", ";", "if", "(", "pieces", ".", "length", "==", "2", ")", "value", "=", "pieces", "[", "1", "]", ".", "trim", "(", ")", ";", "Triple", "triple", "=", "new", "Triple", "(", "pieces", "[", "0", "]", ".", "trim", "(", ")", ",", "value", ",", "url", ")", ";", "List", "<", "Triple", ">", "list", "=", "triplestore", ".", "get", "(", "triple", ".", "key", ")", ";", "if", "(", "list", "==", "null", ")", "list", "=", "new", "ArrayList", "<", "Triple", ">", "(", ")", ";", "Triple", "prev", "=", "addtriple", "(", "list", ",", "triple", ")", ";", "triplestore", ".", "put", "(", "triple", ".", "key", ",", "list", ")", ";", "}", "}", "catch", "(", "FileNotFoundException", "fe", ")", "{", "if", "(", "showlog", ")", "log", ".", "debug", "(", "\"Loading rc file: \"", "+", "abspath", ")", ";", "return", "false", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "if", "(", "showlog", ")", "log", ".", "error", "(", "\"File \"", "+", "abspath", "+", "\": IO exception: \"", "+", "ioe", ".", "getMessage", "(", ")", ")", ";", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "overwrite existing entries", "docstring_tokens": ["overwrite", "existing", "entries"]}
{"code": "if (line.charAt(0) == '#') continue;", "comments": "check for comment", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/rc/RC.java", "func_name": "RC.load", "original_string": "public boolean\n  load(String abspath) {\n    abspath = abspath.replace('\\\\', '/');\n    File rcFile = new File(abspath);\n    if (!rcFile.exists() || !rcFile.canRead()) {\n      return false;\n    }\n    if (showlog) log.debug(\"Loading rc file: \" + abspath);\n    try (BufferedReader rdr = new BufferedReader(new InputStreamReader(new FileInputStream(rcFile), CDM.UTF8))) {\n        for (int lineno = 1; ; lineno++) {\n          URL url = null;\n          String line = rdr.readLine();\n          if (line == null) break;\n          // trim leading blanks\n          line = line.trim();\n          if (line.length() == 0) continue; // empty line\n          if (line.charAt(0) == '#') continue; // check for comment\n          // parse the line\n          if (line.charAt(0) == LTAG) {\n            int rindex = line.indexOf(RTAG);\n            if (rindex < 0) return false;\n            if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            String surl = line.substring(1, rindex);\n            try {\n              url = new URL(surl);\n            } catch (MalformedURLException mue) {\n              if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            }\n            line = line.substring(rindex + 1);\n            // trim again\n            line = line.trim();\n          }\n          // Get the key,value part\n          String[] pieces = line.split(\"\\\\s*=\\\\s*\");\n          assert (pieces.length == 1 || pieces.length == 2);\n          // Create the triple\n          String value = \"1\";\n          if (pieces.length == 2) value = pieces[1].trim();\n          Triple triple = new Triple(pieces[0].trim(), value, url);\n          List<Triple> list = triplestore.get(triple.key);\n          if (list == null) list = new ArrayList<Triple>();\n          Triple prev = addtriple(list, triple);\n          triplestore.put(triple.key, list);\n        }\n\n      } catch (FileNotFoundException fe) {\n        if (showlog) log.debug(\"Loading rc file: \" + abspath);\n        return false;\n\n      } catch (IOException ioe) {\n        if (showlog) log.error(\"File \" + abspath + \": IO exception: \" + ioe.getMessage());\n        return false;\n      }\n      return true;\n    }", "language": "java", "Allcodes": "public boolean\n  load(String abspath) {\n    abspath = abspath.replace('\\\\', '/');\n    File rcFile = new File(abspath);\n    if (!rcFile.exists() || !rcFile.canRead()) {\n      return false;\n    }\n    if (showlog) log.debug(\"Loading rc file: \" + abspath);\n    try (BufferedReader rdr = new BufferedReader(new InputStreamReader(new FileInputStream(rcFile), CDM.UTF8))) {\n        for (int lineno = 1; ; lineno++) {\n          URL url = null;\n          String line = rdr.readLine();\n          if (line == null) break;\n          // trim leading blanks\n          line = line.trim();\n          if (line.length() == 0) continue; // empty line\n          if (line.charAt(0) == '#') continue; // check for comment\n          // parse the line\n          if (line.charAt(0) == LTAG) {\n            int rindex = line.indexOf(RTAG);\n            if (rindex < 0) return false;\n            if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            String surl = line.substring(1, rindex);\n            try {\n              url = new URL(surl);\n            } catch (MalformedURLException mue) {\n              if (showlog) log.error(\"Malformed [url] at \" + abspath + \".\" + lineno);\n            }\n            line = line.substring(rindex + 1);\n            // trim again\n            line = line.trim();\n          }\n          // Get the key,value part\n          String[] pieces = line.split(\"\\\\s*=\\\\s*\");\n          assert (pieces.length == 1 || pieces.length == 2);\n          // Create the triple\n          String value = \"1\";\n          if (pieces.length == 2) value = pieces[1].trim();\n          Triple triple = new Triple(pieces[0].trim(), value, url);\n          List<Triple> list = triplestore.get(triple.key);\n          if (list == null) list = new ArrayList<Triple>();\n          Triple prev = addtriple(list, triple);\n          triplestore.put(triple.key, list);\n        }\n\n      } catch (FileNotFoundException fe) {\n        if (showlog) log.debug(\"Loading rc file: \" + abspath);\n        return false;\n\n      } catch (IOException ioe) {\n        if (showlog) log.error(\"File \" + abspath + \": IO exception: \" + ioe.getMessage());\n        return false;\n      }\n      return true;\n    }", "code_tokens": ["public", "boolean", "load", "(", "String", "abspath", ")", "{", "abspath", "=", "abspath", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "File", "rcFile", "=", "new", "File", "(", "abspath", ")", ";", "if", "(", "!", "rcFile", ".", "exists", "(", ")", "||", "!", "rcFile", ".", "canRead", "(", ")", ")", "{", "return", "false", ";", "}", "if", "(", "showlog", ")", "log", ".", "debug", "(", "\"Loading rc file: \"", "+", "abspath", ")", ";", "try", "(", "BufferedReader", "rdr", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "new", "FileInputStream", "(", "rcFile", ")", ",", "CDM", ".", "UTF8", ")", ")", ")", "{", "for", "(", "int", "lineno", "=", "1", ";", ";", "lineno", "++", ")", "{", "URL", "url", "=", "null", ";", "String", "line", "=", "rdr", ".", "readLine", "(", ")", ";", "if", "(", "line", "==", "null", ")", "break", ";", "// trim leading blanks", "line", "=", "line", ".", "trim", "(", ")", ";", "if", "(", "line", ".", "length", "(", ")", "==", "0", ")", "continue", ";", "// empty line", "if", "(", "line", ".", "charAt", "(", "0", ")", "==", "'", "'", ")", "continue", ";", "// check for comment", "// parse the line", "if", "(", "line", ".", "charAt", "(", "0", ")", "==", "LTAG", ")", "{", "int", "rindex", "=", "line", ".", "indexOf", "(", "RTAG", ")", ";", "if", "(", "rindex", "<", "0", ")", "return", "false", ";", "if", "(", "showlog", ")", "log", ".", "error", "(", "\"Malformed [url] at \"", "+", "abspath", "+", "\".\"", "+", "lineno", ")", ";", "String", "surl", "=", "line", ".", "substring", "(", "1", ",", "rindex", ")", ";", "try", "{", "url", "=", "new", "URL", "(", "surl", ")", ";", "}", "catch", "(", "MalformedURLException", "mue", ")", "{", "if", "(", "showlog", ")", "log", ".", "error", "(", "\"Malformed [url] at \"", "+", "abspath", "+", "\".\"", "+", "lineno", ")", ";", "}", "line", "=", "line", ".", "substring", "(", "rindex", "+", "1", ")", ";", "// trim again", "line", "=", "line", ".", "trim", "(", ")", ";", "}", "// Get the key,value part", "String", "[", "]", "pieces", "=", "line", ".", "split", "(", "\"\\\\s*=\\\\s*\"", ")", ";", "assert", "(", "pieces", ".", "length", "==", "1", "||", "pieces", ".", "length", "==", "2", ")", ";", "// Create the triple", "String", "value", "=", "\"1\"", ";", "if", "(", "pieces", ".", "length", "==", "2", ")", "value", "=", "pieces", "[", "1", "]", ".", "trim", "(", ")", ";", "Triple", "triple", "=", "new", "Triple", "(", "pieces", "[", "0", "]", ".", "trim", "(", ")", ",", "value", ",", "url", ")", ";", "List", "<", "Triple", ">", "list", "=", "triplestore", ".", "get", "(", "triple", ".", "key", ")", ";", "if", "(", "list", "==", "null", ")", "list", "=", "new", "ArrayList", "<", "Triple", ">", "(", ")", ";", "Triple", "prev", "=", "addtriple", "(", "list", ",", "triple", ")", ";", "triplestore", ".", "put", "(", "triple", ".", "key", ",", "list", ")", ";", "}", "}", "catch", "(", "FileNotFoundException", "fe", ")", "{", "if", "(", "showlog", ")", "log", ".", "debug", "(", "\"Loading rc file: \"", "+", "abspath", ")", ";", "return", "false", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "if", "(", "showlog", ")", "log", ".", "error", "(", "\"File \"", "+", "abspath", "+", "\": IO exception: \"", "+", "ioe", ".", "getMessage", "(", ")", ")", ";", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "overwrite existing entries", "docstring_tokens": ["overwrite", "existing", "entries"]}
{"code": "scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));", "comments": "drawing or printing", "lines": 18, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/gis/GisFeatureRendererMulti.java", "func_name": "GisFeatureRendererMulti.getShapes", "original_string": "protected Iterator getShapes(java.awt.Graphics2D g, AffineTransform normal2device) {\n    long startTime = System.currentTimeMillis();\n\n    if (featSetList == null) {\n      initFeatSetList();\n      assert !featSetList.isEmpty();\n    }\n\n    // which featureSet should we ue?\n    FeatureSet fs = (FeatureSet) featSetList.get(0);\n    if (featSetList.size() > 1) {\n        // compute scale\n      double scale = 1.0;\n      try {\n        AffineTransform world2device = g.getTransform();\n        AffineTransform world2normal = normal2device.createInverse();\n        world2normal.concatenate( world2device);\n        scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));   // drawing or printing\n        if (Debug.isSet(\"GisFeature/showTransform\")) {\n          System.out.println(\"GisFeature/showTransform: \"+world2normal+ \"\\n scale = \"+ scale);\n        }\n      } catch ( java.awt.geom.NoninvertibleTransformException e) {\n        System.out.println( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device);\n      }\n      if (!displayProject.isLatLon())\n        scale *= 111.0;  // km/deg\n      double minD = Double.MAX_VALUE;\n      for (Object aFeatSetList : featSetList) {\n        FeatureSet tryfs = (FeatureSet) aFeatSetList;\n        double d = Math.abs(scale * tryfs.minDist - pixelMatch);  // we want min features ~ 2 pixels\n        if (d < minD) {\n          minD = d;\n          fs = tryfs;\n        }\n      }\n      if (Debug.isSet(\"GisFeature/MapResolution\")) {\n        System.out.println(\"GisFeature/MapResolution: scale = \"+scale+\" minDist = \"+fs.minDist);\n      }\n    }\n\n    // we may have deferred the actual creation of the points\n    if (fs.featureList == null)\n      fs.createFeatures();\n\n    // ok, now see if we need to project\n    if (!displayProject.equals(fs.project)) {\n      fs.setProjection( displayProject);\n    } else {    // deal with LatLon\n      if (fs.newProjection && displayProject.isLatLon()) {\n        fs.setProjection( displayProject);\n      }\n    }\n    fs.newProjection = false;\n\n    if (Debug.isSet(\"GisFeature/timing/getShapes\")) {\n      long tookTime = System.currentTimeMillis() - startTime;\n      System.out.println(\"timing.getShapes: \" + tookTime*.001 + \" seconds\");\n    }\n\n      // so return it, already\n    return fs.getShapes();\n  }", "language": "java", "Allcodes": "protected Iterator getShapes(java.awt.Graphics2D g, AffineTransform normal2device) {\n    long startTime = System.currentTimeMillis();\n\n    if (featSetList == null) {\n      initFeatSetList();\n      assert !featSetList.isEmpty();\n    }\n\n    // which featureSet should we ue?\n    FeatureSet fs = (FeatureSet) featSetList.get(0);\n    if (featSetList.size() > 1) {\n        // compute scale\n      double scale = 1.0;\n      try {\n        AffineTransform world2device = g.getTransform();\n        AffineTransform world2normal = normal2device.createInverse();\n        world2normal.concatenate( world2device);\n        scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));   // drawing or printing\n        if (Debug.isSet(\"GisFeature/showTransform\")) {\n          System.out.println(\"GisFeature/showTransform: \"+world2normal+ \"\\n scale = \"+ scale);\n        }\n      } catch ( java.awt.geom.NoninvertibleTransformException e) {\n        System.out.println( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device);\n      }\n      if (!displayProject.isLatLon())\n        scale *= 111.0;  // km/deg\n      double minD = Double.MAX_VALUE;\n      for (Object aFeatSetList : featSetList) {\n        FeatureSet tryfs = (FeatureSet) aFeatSetList;\n        double d = Math.abs(scale * tryfs.minDist - pixelMatch);  // we want min features ~ 2 pixels\n        if (d < minD) {\n          minD = d;\n          fs = tryfs;\n        }\n      }\n      if (Debug.isSet(\"GisFeature/MapResolution\")) {\n        System.out.println(\"GisFeature/MapResolution: scale = \"+scale+\" minDist = \"+fs.minDist);\n      }\n    }\n\n    // we may have deferred the actual creation of the points\n    if (fs.featureList == null)\n      fs.createFeatures();\n\n    // ok, now see if we need to project\n    if (!displayProject.equals(fs.project)) {\n      fs.setProjection( displayProject);\n    } else {    // deal with LatLon\n      if (fs.newProjection && displayProject.isLatLon()) {\n        fs.setProjection( displayProject);\n      }\n    }\n    fs.newProjection = false;\n\n    if (Debug.isSet(\"GisFeature/timing/getShapes\")) {\n      long tookTime = System.currentTimeMillis() - startTime;\n      System.out.println(\"timing.getShapes: \" + tookTime*.001 + \" seconds\");\n    }\n\n      // so return it, already\n    return fs.getShapes();\n  }", "code_tokens": ["protected", "Iterator", "getShapes", "(", "java", ".", "awt", ".", "Graphics2D", "g", ",", "AffineTransform", "normal2device", ")", "{", "long", "startTime", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "if", "(", "featSetList", "==", "null", ")", "{", "initFeatSetList", "(", ")", ";", "assert", "!", "featSetList", ".", "isEmpty", "(", ")", ";", "}", "// which featureSet should we ue?", "FeatureSet", "fs", "=", "(", "FeatureSet", ")", "featSetList", ".", "get", "(", "0", ")", ";", "if", "(", "featSetList", ".", "size", "(", ")", ">", "1", ")", "{", "// compute scale", "double", "scale", "=", "1.0", ";", "try", "{", "AffineTransform", "world2device", "=", "g", ".", "getTransform", "(", ")", ";", "AffineTransform", "world2normal", "=", "normal2device", ".", "createInverse", "(", ")", ";", "world2normal", ".", "concatenate", "(", "world2device", ")", ";", "scale", "=", "Math", ".", "max", "(", "Math", ".", "abs", "(", "world2normal", ".", "getScaleX", "(", ")", ")", ",", "Math", ".", "abs", "(", "world2normal", ".", "getShearX", "(", ")", ")", ")", ";", "// drawing or printing", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/showTransform\"", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"GisFeature/showTransform: \"", "+", "world2normal", "+", "\"\\n scale = \"", "+", "scale", ")", ";", "}", "}", "catch", "(", "java", ".", "awt", ".", "geom", ".", "NoninvertibleTransformException", "e", ")", "{", "System", ".", "out", ".", "println", "(", "\" GisRenderFeature: NoninvertibleTransformException on \"", "+", "normal2device", ")", ";", "}", "if", "(", "!", "displayProject", ".", "isLatLon", "(", ")", ")", "scale", "*=", "111.0", ";", "// km/deg", "double", "minD", "=", "Double", ".", "MAX_VALUE", ";", "for", "(", "Object", "aFeatSetList", ":", "featSetList", ")", "{", "FeatureSet", "tryfs", "=", "(", "FeatureSet", ")", "aFeatSetList", ";", "double", "d", "=", "Math", ".", "abs", "(", "scale", "*", "tryfs", ".", "minDist", "-", "pixelMatch", ")", ";", "// we want min features ~ 2 pixels", "if", "(", "d", "<", "minD", ")", "{", "minD", "=", "d", ";", "fs", "=", "tryfs", ";", "}", "}", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/MapResolution\"", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"GisFeature/MapResolution: scale = \"", "+", "scale", "+", "\" minDist = \"", "+", "fs", ".", "minDist", ")", ";", "}", "}", "// we may have deferred the actual creation of the points", "if", "(", "fs", ".", "featureList", "==", "null", ")", "fs", ".", "createFeatures", "(", ")", ";", "// ok, now see if we need to project", "if", "(", "!", "displayProject", ".", "equals", "(", "fs", ".", "project", ")", ")", "{", "fs", ".", "setProjection", "(", "displayProject", ")", ";", "}", "else", "{", "// deal with LatLon", "if", "(", "fs", ".", "newProjection", "&&", "displayProject", ".", "isLatLon", "(", ")", ")", "{", "fs", ".", "setProjection", "(", "displayProject", ")", ";", "}", "}", "fs", ".", "newProjection", "=", "false", ";", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/timing/getShapes\"", ")", ")", "{", "long", "tookTime", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "startTime", ";", "System", ".", "out", ".", "println", "(", "\"timing.getShapes: \"", "+", "tookTime", "*", ".001", "+", "\" seconds\"", ")", ";", "}", "// so return it, already", "return", "fs", ".", "getShapes", "(", ")", ";", "}"], "docstring": "we have to deal with both projections and resolution-dependence", "docstring_tokens": ["we", "have", "to", "deal", "with", "both", "projections", "and", "resolution", "-", "dependence"]}
{"code": "scale *= 111.0;", "comments": "km/deg", "lines": 26, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/gis/GisFeatureRendererMulti.java", "func_name": "GisFeatureRendererMulti.getShapes", "original_string": "protected Iterator getShapes(java.awt.Graphics2D g, AffineTransform normal2device) {\n    long startTime = System.currentTimeMillis();\n\n    if (featSetList == null) {\n      initFeatSetList();\n      assert !featSetList.isEmpty();\n    }\n\n    // which featureSet should we ue?\n    FeatureSet fs = (FeatureSet) featSetList.get(0);\n    if (featSetList.size() > 1) {\n        // compute scale\n      double scale = 1.0;\n      try {\n        AffineTransform world2device = g.getTransform();\n        AffineTransform world2normal = normal2device.createInverse();\n        world2normal.concatenate( world2device);\n        scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));   // drawing or printing\n        if (Debug.isSet(\"GisFeature/showTransform\")) {\n          System.out.println(\"GisFeature/showTransform: \"+world2normal+ \"\\n scale = \"+ scale);\n        }\n      } catch ( java.awt.geom.NoninvertibleTransformException e) {\n        System.out.println( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device);\n      }\n      if (!displayProject.isLatLon())\n        scale *= 111.0;  // km/deg\n      double minD = Double.MAX_VALUE;\n      for (Object aFeatSetList : featSetList) {\n        FeatureSet tryfs = (FeatureSet) aFeatSetList;\n        double d = Math.abs(scale * tryfs.minDist - pixelMatch);  // we want min features ~ 2 pixels\n        if (d < minD) {\n          minD = d;\n          fs = tryfs;\n        }\n      }\n      if (Debug.isSet(\"GisFeature/MapResolution\")) {\n        System.out.println(\"GisFeature/MapResolution: scale = \"+scale+\" minDist = \"+fs.minDist);\n      }\n    }\n\n    // we may have deferred the actual creation of the points\n    if (fs.featureList == null)\n      fs.createFeatures();\n\n    // ok, now see if we need to project\n    if (!displayProject.equals(fs.project)) {\n      fs.setProjection( displayProject);\n    } else {    // deal with LatLon\n      if (fs.newProjection && displayProject.isLatLon()) {\n        fs.setProjection( displayProject);\n      }\n    }\n    fs.newProjection = false;\n\n    if (Debug.isSet(\"GisFeature/timing/getShapes\")) {\n      long tookTime = System.currentTimeMillis() - startTime;\n      System.out.println(\"timing.getShapes: \" + tookTime*.001 + \" seconds\");\n    }\n\n      // so return it, already\n    return fs.getShapes();\n  }", "language": "java", "Allcodes": "protected Iterator getShapes(java.awt.Graphics2D g, AffineTransform normal2device) {\n    long startTime = System.currentTimeMillis();\n\n    if (featSetList == null) {\n      initFeatSetList();\n      assert !featSetList.isEmpty();\n    }\n\n    // which featureSet should we ue?\n    FeatureSet fs = (FeatureSet) featSetList.get(0);\n    if (featSetList.size() > 1) {\n        // compute scale\n      double scale = 1.0;\n      try {\n        AffineTransform world2device = g.getTransform();\n        AffineTransform world2normal = normal2device.createInverse();\n        world2normal.concatenate( world2device);\n        scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));   // drawing or printing\n        if (Debug.isSet(\"GisFeature/showTransform\")) {\n          System.out.println(\"GisFeature/showTransform: \"+world2normal+ \"\\n scale = \"+ scale);\n        }\n      } catch ( java.awt.geom.NoninvertibleTransformException e) {\n        System.out.println( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device);\n      }\n      if (!displayProject.isLatLon())\n        scale *= 111.0;  // km/deg\n      double minD = Double.MAX_VALUE;\n      for (Object aFeatSetList : featSetList) {\n        FeatureSet tryfs = (FeatureSet) aFeatSetList;\n        double d = Math.abs(scale * tryfs.minDist - pixelMatch);  // we want min features ~ 2 pixels\n        if (d < minD) {\n          minD = d;\n          fs = tryfs;\n        }\n      }\n      if (Debug.isSet(\"GisFeature/MapResolution\")) {\n        System.out.println(\"GisFeature/MapResolution: scale = \"+scale+\" minDist = \"+fs.minDist);\n      }\n    }\n\n    // we may have deferred the actual creation of the points\n    if (fs.featureList == null)\n      fs.createFeatures();\n\n    // ok, now see if we need to project\n    if (!displayProject.equals(fs.project)) {\n      fs.setProjection( displayProject);\n    } else {    // deal with LatLon\n      if (fs.newProjection && displayProject.isLatLon()) {\n        fs.setProjection( displayProject);\n      }\n    }\n    fs.newProjection = false;\n\n    if (Debug.isSet(\"GisFeature/timing/getShapes\")) {\n      long tookTime = System.currentTimeMillis() - startTime;\n      System.out.println(\"timing.getShapes: \" + tookTime*.001 + \" seconds\");\n    }\n\n      // so return it, already\n    return fs.getShapes();\n  }", "code_tokens": ["protected", "Iterator", "getShapes", "(", "java", ".", "awt", ".", "Graphics2D", "g", ",", "AffineTransform", "normal2device", ")", "{", "long", "startTime", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "if", "(", "featSetList", "==", "null", ")", "{", "initFeatSetList", "(", ")", ";", "assert", "!", "featSetList", ".", "isEmpty", "(", ")", ";", "}", "// which featureSet should we ue?", "FeatureSet", "fs", "=", "(", "FeatureSet", ")", "featSetList", ".", "get", "(", "0", ")", ";", "if", "(", "featSetList", ".", "size", "(", ")", ">", "1", ")", "{", "// compute scale", "double", "scale", "=", "1.0", ";", "try", "{", "AffineTransform", "world2device", "=", "g", ".", "getTransform", "(", ")", ";", "AffineTransform", "world2normal", "=", "normal2device", ".", "createInverse", "(", ")", ";", "world2normal", ".", "concatenate", "(", "world2device", ")", ";", "scale", "=", "Math", ".", "max", "(", "Math", ".", "abs", "(", "world2normal", ".", "getScaleX", "(", ")", ")", ",", "Math", ".", "abs", "(", "world2normal", ".", "getShearX", "(", ")", ")", ")", ";", "// drawing or printing", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/showTransform\"", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"GisFeature/showTransform: \"", "+", "world2normal", "+", "\"\\n scale = \"", "+", "scale", ")", ";", "}", "}", "catch", "(", "java", ".", "awt", ".", "geom", ".", "NoninvertibleTransformException", "e", ")", "{", "System", ".", "out", ".", "println", "(", "\" GisRenderFeature: NoninvertibleTransformException on \"", "+", "normal2device", ")", ";", "}", "if", "(", "!", "displayProject", ".", "isLatLon", "(", ")", ")", "scale", "*=", "111.0", ";", "// km/deg", "double", "minD", "=", "Double", ".", "MAX_VALUE", ";", "for", "(", "Object", "aFeatSetList", ":", "featSetList", ")", "{", "FeatureSet", "tryfs", "=", "(", "FeatureSet", ")", "aFeatSetList", ";", "double", "d", "=", "Math", ".", "abs", "(", "scale", "*", "tryfs", ".", "minDist", "-", "pixelMatch", ")", ";", "// we want min features ~ 2 pixels", "if", "(", "d", "<", "minD", ")", "{", "minD", "=", "d", ";", "fs", "=", "tryfs", ";", "}", "}", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/MapResolution\"", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"GisFeature/MapResolution: scale = \"", "+", "scale", "+", "\" minDist = \"", "+", "fs", ".", "minDist", ")", ";", "}", "}", "// we may have deferred the actual creation of the points", "if", "(", "fs", ".", "featureList", "==", "null", ")", "fs", ".", "createFeatures", "(", ")", ";", "// ok, now see if we need to project", "if", "(", "!", "displayProject", ".", "equals", "(", "fs", ".", "project", ")", ")", "{", "fs", ".", "setProjection", "(", "displayProject", ")", ";", "}", "else", "{", "// deal with LatLon", "if", "(", "fs", ".", "newProjection", "&&", "displayProject", ".", "isLatLon", "(", ")", ")", "{", "fs", ".", "setProjection", "(", "displayProject", ")", ";", "}", "}", "fs", ".", "newProjection", "=", "false", ";", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/timing/getShapes\"", ")", ")", "{", "long", "tookTime", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "startTime", ";", "System", ".", "out", ".", "println", "(", "\"timing.getShapes: \"", "+", "tookTime", "*", ".001", "+", "\" seconds\"", ")", ";", "}", "// so return it, already", "return", "fs", ".", "getShapes", "(", ")", ";", "}"], "docstring": "we have to deal with both projections and resolution-dependence", "docstring_tokens": ["we", "have", "to", "deal", "with", "both", "projections", "and", "resolution", "-", "dependence"]}
{"code": "double d = Math.abs(scale * tryfs.minDist - pixelMatch);", "comments": "we want min features ~ 2 pixels", "lines": 30, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/gis/GisFeatureRendererMulti.java", "func_name": "GisFeatureRendererMulti.getShapes", "original_string": "protected Iterator getShapes(java.awt.Graphics2D g, AffineTransform normal2device) {\n    long startTime = System.currentTimeMillis();\n\n    if (featSetList == null) {\n      initFeatSetList();\n      assert !featSetList.isEmpty();\n    }\n\n    // which featureSet should we ue?\n    FeatureSet fs = (FeatureSet) featSetList.get(0);\n    if (featSetList.size() > 1) {\n        // compute scale\n      double scale = 1.0;\n      try {\n        AffineTransform world2device = g.getTransform();\n        AffineTransform world2normal = normal2device.createInverse();\n        world2normal.concatenate( world2device);\n        scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));   // drawing or printing\n        if (Debug.isSet(\"GisFeature/showTransform\")) {\n          System.out.println(\"GisFeature/showTransform: \"+world2normal+ \"\\n scale = \"+ scale);\n        }\n      } catch ( java.awt.geom.NoninvertibleTransformException e) {\n        System.out.println( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device);\n      }\n      if (!displayProject.isLatLon())\n        scale *= 111.0;  // km/deg\n      double minD = Double.MAX_VALUE;\n      for (Object aFeatSetList : featSetList) {\n        FeatureSet tryfs = (FeatureSet) aFeatSetList;\n        double d = Math.abs(scale * tryfs.minDist - pixelMatch);  // we want min features ~ 2 pixels\n        if (d < minD) {\n          minD = d;\n          fs = tryfs;\n        }\n      }\n      if (Debug.isSet(\"GisFeature/MapResolution\")) {\n        System.out.println(\"GisFeature/MapResolution: scale = \"+scale+\" minDist = \"+fs.minDist);\n      }\n    }\n\n    // we may have deferred the actual creation of the points\n    if (fs.featureList == null)\n      fs.createFeatures();\n\n    // ok, now see if we need to project\n    if (!displayProject.equals(fs.project)) {\n      fs.setProjection( displayProject);\n    } else {    // deal with LatLon\n      if (fs.newProjection && displayProject.isLatLon()) {\n        fs.setProjection( displayProject);\n      }\n    }\n    fs.newProjection = false;\n\n    if (Debug.isSet(\"GisFeature/timing/getShapes\")) {\n      long tookTime = System.currentTimeMillis() - startTime;\n      System.out.println(\"timing.getShapes: \" + tookTime*.001 + \" seconds\");\n    }\n\n      // so return it, already\n    return fs.getShapes();\n  }", "language": "java", "Allcodes": "protected Iterator getShapes(java.awt.Graphics2D g, AffineTransform normal2device) {\n    long startTime = System.currentTimeMillis();\n\n    if (featSetList == null) {\n      initFeatSetList();\n      assert !featSetList.isEmpty();\n    }\n\n    // which featureSet should we ue?\n    FeatureSet fs = (FeatureSet) featSetList.get(0);\n    if (featSetList.size() > 1) {\n        // compute scale\n      double scale = 1.0;\n      try {\n        AffineTransform world2device = g.getTransform();\n        AffineTransform world2normal = normal2device.createInverse();\n        world2normal.concatenate( world2device);\n        scale = Math.max(Math.abs(world2normal.getScaleX()), Math.abs(world2normal.getShearX()));   // drawing or printing\n        if (Debug.isSet(\"GisFeature/showTransform\")) {\n          System.out.println(\"GisFeature/showTransform: \"+world2normal+ \"\\n scale = \"+ scale);\n        }\n      } catch ( java.awt.geom.NoninvertibleTransformException e) {\n        System.out.println( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device);\n      }\n      if (!displayProject.isLatLon())\n        scale *= 111.0;  // km/deg\n      double minD = Double.MAX_VALUE;\n      for (Object aFeatSetList : featSetList) {\n        FeatureSet tryfs = (FeatureSet) aFeatSetList;\n        double d = Math.abs(scale * tryfs.minDist - pixelMatch);  // we want min features ~ 2 pixels\n        if (d < minD) {\n          minD = d;\n          fs = tryfs;\n        }\n      }\n      if (Debug.isSet(\"GisFeature/MapResolution\")) {\n        System.out.println(\"GisFeature/MapResolution: scale = \"+scale+\" minDist = \"+fs.minDist);\n      }\n    }\n\n    // we may have deferred the actual creation of the points\n    if (fs.featureList == null)\n      fs.createFeatures();\n\n    // ok, now see if we need to project\n    if (!displayProject.equals(fs.project)) {\n      fs.setProjection( displayProject);\n    } else {    // deal with LatLon\n      if (fs.newProjection && displayProject.isLatLon()) {\n        fs.setProjection( displayProject);\n      }\n    }\n    fs.newProjection = false;\n\n    if (Debug.isSet(\"GisFeature/timing/getShapes\")) {\n      long tookTime = System.currentTimeMillis() - startTime;\n      System.out.println(\"timing.getShapes: \" + tookTime*.001 + \" seconds\");\n    }\n\n      // so return it, already\n    return fs.getShapes();\n  }", "code_tokens": ["protected", "Iterator", "getShapes", "(", "java", ".", "awt", ".", "Graphics2D", "g", ",", "AffineTransform", "normal2device", ")", "{", "long", "startTime", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "if", "(", "featSetList", "==", "null", ")", "{", "initFeatSetList", "(", ")", ";", "assert", "!", "featSetList", ".", "isEmpty", "(", ")", ";", "}", "// which featureSet should we ue?", "FeatureSet", "fs", "=", "(", "FeatureSet", ")", "featSetList", ".", "get", "(", "0", ")", ";", "if", "(", "featSetList", ".", "size", "(", ")", ">", "1", ")", "{", "// compute scale", "double", "scale", "=", "1.0", ";", "try", "{", "AffineTransform", "world2device", "=", "g", ".", "getTransform", "(", ")", ";", "AffineTransform", "world2normal", "=", "normal2device", ".", "createInverse", "(", ")", ";", "world2normal", ".", "concatenate", "(", "world2device", ")", ";", "scale", "=", "Math", ".", "max", "(", "Math", ".", "abs", "(", "world2normal", ".", "getScaleX", "(", ")", ")", ",", "Math", ".", "abs", "(", "world2normal", ".", "getShearX", "(", ")", ")", ")", ";", "// drawing or printing", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/showTransform\"", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"GisFeature/showTransform: \"", "+", "world2normal", "+", "\"\\n scale = \"", "+", "scale", ")", ";", "}", "}", "catch", "(", "java", ".", "awt", ".", "geom", ".", "NoninvertibleTransformException", "e", ")", "{", "System", ".", "out", ".", "println", "(", "\" GisRenderFeature: NoninvertibleTransformException on \"", "+", "normal2device", ")", ";", "}", "if", "(", "!", "displayProject", ".", "isLatLon", "(", ")", ")", "scale", "*=", "111.0", ";", "// km/deg", "double", "minD", "=", "Double", ".", "MAX_VALUE", ";", "for", "(", "Object", "aFeatSetList", ":", "featSetList", ")", "{", "FeatureSet", "tryfs", "=", "(", "FeatureSet", ")", "aFeatSetList", ";", "double", "d", "=", "Math", ".", "abs", "(", "scale", "*", "tryfs", ".", "minDist", "-", "pixelMatch", ")", ";", "// we want min features ~ 2 pixels", "if", "(", "d", "<", "minD", ")", "{", "minD", "=", "d", ";", "fs", "=", "tryfs", ";", "}", "}", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/MapResolution\"", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"GisFeature/MapResolution: scale = \"", "+", "scale", "+", "\" minDist = \"", "+", "fs", ".", "minDist", ")", ";", "}", "}", "// we may have deferred the actual creation of the points", "if", "(", "fs", ".", "featureList", "==", "null", ")", "fs", ".", "createFeatures", "(", ")", ";", "// ok, now see if we need to project", "if", "(", "!", "displayProject", ".", "equals", "(", "fs", ".", "project", ")", ")", "{", "fs", ".", "setProjection", "(", "displayProject", ")", ";", "}", "else", "{", "// deal with LatLon", "if", "(", "fs", ".", "newProjection", "&&", "displayProject", ".", "isLatLon", "(", ")", ")", "{", "fs", ".", "setProjection", "(", "displayProject", ")", ";", "}", "}", "fs", ".", "newProjection", "=", "false", ";", "if", "(", "Debug", ".", "isSet", "(", "\"GisFeature/timing/getShapes\"", ")", ")", "{", "long", "tookTime", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "startTime", ";", "System", ".", "out", ".", "println", "(", "\"timing.getShapes: \"", "+", "tookTime", "*", ".001", "+", "\" seconds\"", ")", ";", "}", "// so return it, already", "return", "fs", ".", "getShapes", "(", ")", ";", "}"], "docstring": "we have to deal with both projections and resolution-dependence", "docstring_tokens": ["we", "have", "to", "deal", "with", "both", "projections", "and", "resolution", "-", "dependence"]}
{"code": "return;", "comments": "give it a chance to finish up", "lines": 18, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/StopButton.java", "func_name": "StopButton.startProgressMonitorTask", "original_string": "public boolean startProgressMonitorTask( ProgressMonitorTask pmt) {\n    if (busy) return false;\n    busy = true;\n\n    this.task = pmt;\n    isCancelled = false;\n    count = 0;\n    setIcon(icon[0]);\n\n    // create timer, whose events happen on the awt event Thread\n    ActionListener watcher = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n        //System.out.println(\"timer event\"+evt);\n\n        if (isCancelled && !task.isCancel()) {\n          task.cancel();\n          if (debug) System.out.println(\" task.cancel\");\n          return; // give it a chance to finish up\n        } else {\n          // indicate progress\n          count++;\n          setIcon( icon[count % 2]);\n          if (debug) System.out.println(\" stop count=\"+count);\n        }\n\n        // need to make sure task acknowledges the cancel; so dont shut down\n        // until the task is done\n        if (task.isDone()) {\n          if (myTimer != null)\n            myTimer.stop();\n          myTimer = null;\n\n          if (task.isError())\n            javax.swing.JOptionPane.showMessageDialog(null, task.getErrorMessage());\n\n          if (task.isSuccess())\n            fireEvent( new ActionEvent(this, 0, \"success\"));\n          else if (task.isError())\n            fireEvent( new ActionEvent(this, 0, \"error\"));\n          else if (task.isCancel())\n            fireEvent( new ActionEvent(this, 0, \"cancel\"));\n          else\n            fireEvent( new ActionEvent(this, 0, \"done\"));\n\n          busy = false;\n        }\n      }\n    };\n    myTimer = new javax.swing.Timer(1000, watcher); // every second\n    myTimer.start();\n\n    // do task in a seperate, non-event, thread\n    Thread taskThread = new Thread(task);\n    taskThread.start();\n\n    return true;\n  }", "language": "java", "Allcodes": "public boolean startProgressMonitorTask( ProgressMonitorTask pmt) {\n    if (busy) return false;\n    busy = true;\n\n    this.task = pmt;\n    isCancelled = false;\n    count = 0;\n    setIcon(icon[0]);\n\n    // create timer, whose events happen on the awt event Thread\n    ActionListener watcher = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n        //System.out.println(\"timer event\"+evt);\n\n        if (isCancelled && !task.isCancel()) {\n          task.cancel();\n          if (debug) System.out.println(\" task.cancel\");\n          return; // give it a chance to finish up\n        } else {\n          // indicate progress\n          count++;\n          setIcon( icon[count % 2]);\n          if (debug) System.out.println(\" stop count=\"+count);\n        }\n\n        // need to make sure task acknowledges the cancel; so dont shut down\n        // until the task is done\n        if (task.isDone()) {\n          if (myTimer != null)\n            myTimer.stop();\n          myTimer = null;\n\n          if (task.isError())\n            javax.swing.JOptionPane.showMessageDialog(null, task.getErrorMessage());\n\n          if (task.isSuccess())\n            fireEvent( new ActionEvent(this, 0, \"success\"));\n          else if (task.isError())\n            fireEvent( new ActionEvent(this, 0, \"error\"));\n          else if (task.isCancel())\n            fireEvent( new ActionEvent(this, 0, \"cancel\"));\n          else\n            fireEvent( new ActionEvent(this, 0, \"done\"));\n\n          busy = false;\n        }\n      }\n    };\n    myTimer = new javax.swing.Timer(1000, watcher); // every second\n    myTimer.start();\n\n    // do task in a seperate, non-event, thread\n    Thread taskThread = new Thread(task);\n    taskThread.start();\n\n    return true;\n  }", "code_tokens": ["public", "boolean", "startProgressMonitorTask", "(", "ProgressMonitorTask", "pmt", ")", "{", "if", "(", "busy", ")", "return", "false", ";", "busy", "=", "true", ";", "this", ".", "task", "=", "pmt", ";", "isCancelled", "=", "false", ";", "count", "=", "0", ";", "setIcon", "(", "icon", "[", "0", "]", ")", ";", "// create timer, whose events happen on the awt event Thread", "ActionListener", "watcher", "=", "new", "ActionListener", "(", ")", "{", "public", "void", "actionPerformed", "(", "ActionEvent", "evt", ")", "{", "//System.out.println(\"timer event\"+evt);", "if", "(", "isCancelled", "&&", "!", "task", ".", "isCancel", "(", ")", ")", "{", "task", ".", "cancel", "(", ")", ";", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\" task.cancel\"", ")", ";", "return", ";", "// give it a chance to finish up", "}", "else", "{", "// indicate progress", "count", "++", ";", "setIcon", "(", "icon", "[", "count", "%", "2", "]", ")", ";", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\" stop count=\"", "+", "count", ")", ";", "}", "// need to make sure task acknowledges the cancel; so dont shut down", "// until the task is done", "if", "(", "task", ".", "isDone", "(", ")", ")", "{", "if", "(", "myTimer", "!=", "null", ")", "myTimer", ".", "stop", "(", ")", ";", "myTimer", "=", "null", ";", "if", "(", "task", ".", "isError", "(", ")", ")", "javax", ".", "swing", ".", "JOptionPane", ".", "showMessageDialog", "(", "null", ",", "task", ".", "getErrorMessage", "(", ")", ")", ";", "if", "(", "task", ".", "isSuccess", "(", ")", ")", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"success\"", ")", ")", ";", "else", "if", "(", "task", ".", "isError", "(", ")", ")", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"error\"", ")", ")", ";", "else", "if", "(", "task", ".", "isCancel", "(", ")", ")", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"cancel\"", ")", ")", ";", "else", "fireEvent", "(", "new", "ActionEvent", "(", "this", ",", "0", ",", "\"done\"", ")", ")", ";", "busy", "=", "false", ";", "}", "}", "}", ";", "myTimer", "=", "new", "javax", ".", "swing", ".", "Timer", "(", "1000", ",", "watcher", ")", ";", "// every second", "myTimer", ".", "start", "(", ")", ";", "// do task in a seperate, non-event, thread", "Thread", "taskThread", "=", "new", "Thread", "(", "task", ")", ";", "taskThread", ".", "start", "(", ")", ";", "return", "true", ";", "}"], "docstring": "The given task is run in a background thread.\nProgress is indicated once a second.\nYou cannot call this method again till the task is completed.\n@param pmt heres where the work is done.\n@return true task was started, false if still busy with previous task.", "docstring_tokens": ["The", "given", "task", "is", "run", "in", "a", "background", "thread", ".", "Progress", "is", "indicated", "once", "a", "second", ".", "You", "cannot", "call", "this", "method", "again", "till", "the", "task", "is", "completed", "."]}
{"code": "return true;", "comments": "got deleted - must recreate the index", "lines": 23, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribPartitionBuilder.java", "func_name": "GribPartitionBuilder.needsUpdate", "original_string": "private boolean needsUpdate(CollectionUpdateType ff, File collectionIndexFile) throws IOException {\n    long collectionLastModified = collectionIndexFile.lastModified();\n    Set<String> newFileSet = new HashSet<>();\n    for (MCollection dcm : partitionManager.makePartitions(CollectionUpdateType.test)) {\n      String partitionIndexFilename = StringUtil2.replace(dcm.getIndexFilename(GribCdmIndex.NCX_SUFFIX), '\\\\', \"/\");\n      File partitionIndexFile = GribIndexCache.getExistingFileOrCache(partitionIndexFilename);\n      if (partitionIndexFile == null)                                 // make sure each partition has an index\n        return true;\n      if (collectionLastModified < partitionIndexFile.lastModified())  // and the partition index is earlier than the collection index\n        return true;\n      newFileSet.add(partitionIndexFilename);\n    }\n\n    if (ff == CollectionUpdateType.testIndexOnly) return false;\n\n    // now see if any files were deleted\n    GribCdmIndex reader = new GribCdmIndex(logger);\n    List<MFile> oldFiles = new ArrayList<>();\n    reader.readMFiles(collectionIndexFile.toPath(), oldFiles);\n    Set<String> oldFileSet = new HashSet<>();\n    for (MFile oldFile : oldFiles) {\n      if (!newFileSet.contains(oldFile.getPath()))\n        return true;  // got deleted - must recreate the index\n      oldFileSet.add(oldFile.getPath());\n    }\n\n    // now see if any files were added\n    for (String newFilename : newFileSet) {\n      if (!oldFileSet.contains(newFilename))\n        return true;  // got added - must recreate the index\n    }\n\n    return false;\n  }", "language": "java", "Allcodes": "private boolean needsUpdate(CollectionUpdateType ff, File collectionIndexFile) throws IOException {\n    long collectionLastModified = collectionIndexFile.lastModified();\n    Set<String> newFileSet = new HashSet<>();\n    for (MCollection dcm : partitionManager.makePartitions(CollectionUpdateType.test)) {\n      String partitionIndexFilename = StringUtil2.replace(dcm.getIndexFilename(GribCdmIndex.NCX_SUFFIX), '\\\\', \"/\");\n      File partitionIndexFile = GribIndexCache.getExistingFileOrCache(partitionIndexFilename);\n      if (partitionIndexFile == null)                                 // make sure each partition has an index\n        return true;\n      if (collectionLastModified < partitionIndexFile.lastModified())  // and the partition index is earlier than the collection index\n        return true;\n      newFileSet.add(partitionIndexFilename);\n    }\n\n    if (ff == CollectionUpdateType.testIndexOnly) return false;\n\n    // now see if any files were deleted\n    GribCdmIndex reader = new GribCdmIndex(logger);\n    List<MFile> oldFiles = new ArrayList<>();\n    reader.readMFiles(collectionIndexFile.toPath(), oldFiles);\n    Set<String> oldFileSet = new HashSet<>();\n    for (MFile oldFile : oldFiles) {\n      if (!newFileSet.contains(oldFile.getPath()))\n        return true;  // got deleted - must recreate the index\n      oldFileSet.add(oldFile.getPath());\n    }\n\n    // now see if any files were added\n    for (String newFilename : newFileSet) {\n      if (!oldFileSet.contains(newFilename))\n        return true;  // got added - must recreate the index\n    }\n\n    return false;\n  }", "code_tokens": ["private", "boolean", "needsUpdate", "(", "CollectionUpdateType", "ff", ",", "File", "collectionIndexFile", ")", "throws", "IOException", "{", "long", "collectionLastModified", "=", "collectionIndexFile", ".", "lastModified", "(", ")", ";", "Set", "<", "String", ">", "newFileSet", "=", "new", "HashSet", "<>", "(", ")", ";", "for", "(", "MCollection", "dcm", ":", "partitionManager", ".", "makePartitions", "(", "CollectionUpdateType", ".", "test", ")", ")", "{", "String", "partitionIndexFilename", "=", "StringUtil2", ".", "replace", "(", "dcm", ".", "getIndexFilename", "(", "GribCdmIndex", ".", "NCX_SUFFIX", ")", ",", "'", "'", ",", "\"/\"", ")", ";", "File", "partitionIndexFile", "=", "GribIndexCache", ".", "getExistingFileOrCache", "(", "partitionIndexFilename", ")", ";", "if", "(", "partitionIndexFile", "==", "null", ")", "// make sure each partition has an index", "return", "true", ";", "if", "(", "collectionLastModified", "<", "partitionIndexFile", ".", "lastModified", "(", ")", ")", "// and the partition index is earlier than the collection index", "return", "true", ";", "newFileSet", ".", "add", "(", "partitionIndexFilename", ")", ";", "}", "if", "(", "ff", "==", "CollectionUpdateType", ".", "testIndexOnly", ")", "return", "false", ";", "// now see if any files were deleted", "GribCdmIndex", "reader", "=", "new", "GribCdmIndex", "(", "logger", ")", ";", "List", "<", "MFile", ">", "oldFiles", "=", "new", "ArrayList", "<>", "(", ")", ";", "reader", ".", "readMFiles", "(", "collectionIndexFile", ".", "toPath", "(", ")", ",", "oldFiles", ")", ";", "Set", "<", "String", ">", "oldFileSet", "=", "new", "HashSet", "<>", "(", ")", ";", "for", "(", "MFile", "oldFile", ":", "oldFiles", ")", "{", "if", "(", "!", "newFileSet", ".", "contains", "(", "oldFile", ".", "getPath", "(", ")", ")", ")", "return", "true", ";", "// got deleted - must recreate the index", "oldFileSet", ".", "add", "(", "oldFile", ".", "getPath", "(", ")", ")", ";", "}", "// now see if any files were added", "for", "(", "String", "newFilename", ":", "newFileSet", ")", "{", "if", "(", "!", "oldFileSet", ".", "contains", "(", "newFilename", ")", ")", "return", "true", ";", "// got added - must recreate the index", "}", "return", "false", ";", "}"], "docstring": "LOOK need an option to only scan latest last partition or something", "docstring_tokens": ["LOOK", "need", "an", "option", "to", "only", "scan", "latest", "last", "partition", "or", "something"]}
{"code": "return true;", "comments": "got added - must recreate the index", "lines": 30, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/collection/GribPartitionBuilder.java", "func_name": "GribPartitionBuilder.needsUpdate", "original_string": "private boolean needsUpdate(CollectionUpdateType ff, File collectionIndexFile) throws IOException {\n    long collectionLastModified = collectionIndexFile.lastModified();\n    Set<String> newFileSet = new HashSet<>();\n    for (MCollection dcm : partitionManager.makePartitions(CollectionUpdateType.test)) {\n      String partitionIndexFilename = StringUtil2.replace(dcm.getIndexFilename(GribCdmIndex.NCX_SUFFIX), '\\\\', \"/\");\n      File partitionIndexFile = GribIndexCache.getExistingFileOrCache(partitionIndexFilename);\n      if (partitionIndexFile == null)                                 // make sure each partition has an index\n        return true;\n      if (collectionLastModified < partitionIndexFile.lastModified())  // and the partition index is earlier than the collection index\n        return true;\n      newFileSet.add(partitionIndexFilename);\n    }\n\n    if (ff == CollectionUpdateType.testIndexOnly) return false;\n\n    // now see if any files were deleted\n    GribCdmIndex reader = new GribCdmIndex(logger);\n    List<MFile> oldFiles = new ArrayList<>();\n    reader.readMFiles(collectionIndexFile.toPath(), oldFiles);\n    Set<String> oldFileSet = new HashSet<>();\n    for (MFile oldFile : oldFiles) {\n      if (!newFileSet.contains(oldFile.getPath()))\n        return true;  // got deleted - must recreate the index\n      oldFileSet.add(oldFile.getPath());\n    }\n\n    // now see if any files were added\n    for (String newFilename : newFileSet) {\n      if (!oldFileSet.contains(newFilename))\n        return true;  // got added - must recreate the index\n    }\n\n    return false;\n  }", "language": "java", "Allcodes": "private boolean needsUpdate(CollectionUpdateType ff, File collectionIndexFile) throws IOException {\n    long collectionLastModified = collectionIndexFile.lastModified();\n    Set<String> newFileSet = new HashSet<>();\n    for (MCollection dcm : partitionManager.makePartitions(CollectionUpdateType.test)) {\n      String partitionIndexFilename = StringUtil2.replace(dcm.getIndexFilename(GribCdmIndex.NCX_SUFFIX), '\\\\', \"/\");\n      File partitionIndexFile = GribIndexCache.getExistingFileOrCache(partitionIndexFilename);\n      if (partitionIndexFile == null)                                 // make sure each partition has an index\n        return true;\n      if (collectionLastModified < partitionIndexFile.lastModified())  // and the partition index is earlier than the collection index\n        return true;\n      newFileSet.add(partitionIndexFilename);\n    }\n\n    if (ff == CollectionUpdateType.testIndexOnly) return false;\n\n    // now see if any files were deleted\n    GribCdmIndex reader = new GribCdmIndex(logger);\n    List<MFile> oldFiles = new ArrayList<>();\n    reader.readMFiles(collectionIndexFile.toPath(), oldFiles);\n    Set<String> oldFileSet = new HashSet<>();\n    for (MFile oldFile : oldFiles) {\n      if (!newFileSet.contains(oldFile.getPath()))\n        return true;  // got deleted - must recreate the index\n      oldFileSet.add(oldFile.getPath());\n    }\n\n    // now see if any files were added\n    for (String newFilename : newFileSet) {\n      if (!oldFileSet.contains(newFilename))\n        return true;  // got added - must recreate the index\n    }\n\n    return false;\n  }", "code_tokens": ["private", "boolean", "needsUpdate", "(", "CollectionUpdateType", "ff", ",", "File", "collectionIndexFile", ")", "throws", "IOException", "{", "long", "collectionLastModified", "=", "collectionIndexFile", ".", "lastModified", "(", ")", ";", "Set", "<", "String", ">", "newFileSet", "=", "new", "HashSet", "<>", "(", ")", ";", "for", "(", "MCollection", "dcm", ":", "partitionManager", ".", "makePartitions", "(", "CollectionUpdateType", ".", "test", ")", ")", "{", "String", "partitionIndexFilename", "=", "StringUtil2", ".", "replace", "(", "dcm", ".", "getIndexFilename", "(", "GribCdmIndex", ".", "NCX_SUFFIX", ")", ",", "'", "'", ",", "\"/\"", ")", ";", "File", "partitionIndexFile", "=", "GribIndexCache", ".", "getExistingFileOrCache", "(", "partitionIndexFilename", ")", ";", "if", "(", "partitionIndexFile", "==", "null", ")", "// make sure each partition has an index", "return", "true", ";", "if", "(", "collectionLastModified", "<", "partitionIndexFile", ".", "lastModified", "(", ")", ")", "// and the partition index is earlier than the collection index", "return", "true", ";", "newFileSet", ".", "add", "(", "partitionIndexFilename", ")", ";", "}", "if", "(", "ff", "==", "CollectionUpdateType", ".", "testIndexOnly", ")", "return", "false", ";", "// now see if any files were deleted", "GribCdmIndex", "reader", "=", "new", "GribCdmIndex", "(", "logger", ")", ";", "List", "<", "MFile", ">", "oldFiles", "=", "new", "ArrayList", "<>", "(", ")", ";", "reader", ".", "readMFiles", "(", "collectionIndexFile", ".", "toPath", "(", ")", ",", "oldFiles", ")", ";", "Set", "<", "String", ">", "oldFileSet", "=", "new", "HashSet", "<>", "(", ")", ";", "for", "(", "MFile", "oldFile", ":", "oldFiles", ")", "{", "if", "(", "!", "newFileSet", ".", "contains", "(", "oldFile", ".", "getPath", "(", ")", ")", ")", "return", "true", ";", "// got deleted - must recreate the index", "oldFileSet", ".", "add", "(", "oldFile", ".", "getPath", "(", ")", ")", ";", "}", "// now see if any files were added", "for", "(", "String", "newFilename", ":", "newFileSet", ")", "{", "if", "(", "!", "oldFileSet", ".", "contains", "(", "newFilename", ")", ")", "return", "true", ";", "// got added - must recreate the index", "}", "return", "false", ";", "}"], "docstring": "LOOK need an option to only scan latest last partition or something", "docstring_tokens": ["LOOK", "need", "an", "option", "to", "only", "scan", "latest", "last", "partition", "or", "something"]}
{"code": "return data.getObject(recno * m.getSize());", "comments": "LOOK ??", "lines": 33, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/ArrayStructure.java", "func_name": "ArrayStructure.getScalarObject", "original_string": "public Object getScalarObject(int recno, StructureMembers.Member m) {\r\n    DataType dataType = m.getDataType();\r\n\r\n    if (dataType == DataType.DOUBLE) {\r\n      return getScalarDouble(recno, m);\r\n\r\n    } else if (dataType == DataType.FLOAT) {\r\n      return getScalarFloat(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == byte.class) {\r\n      return getScalarByte(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == short.class) {\r\n      return getScalarShort(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == int.class) {\r\n      return getScalarInt(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == long.class) {\r\n      return getScalarLong(recno, m);\r\n\r\n    } else if (dataType == DataType.CHAR) {\r\n      return getScalarString(recno, m);\r\n\r\n    } else if (dataType == DataType.STRING) {\r\n      return getScalarString(recno, m);\r\n\r\n    } else if (dataType == DataType.STRUCTURE) {\r\n      return getScalarStructure(recno, m);\r\n\r\n    } else if (dataType == DataType.OPAQUE) {\r\n      ArrayObject data = (ArrayObject) m.getDataArray();\r\n      return data.getObject(recno * m.getSize()); // LOOK ?? \r\n    }\r\n\r\n    throw new RuntimeException(\"Dont have implementation for \" + dataType);\r\n  }", "language": "java", "Allcodes": "public Object getScalarObject(int recno, StructureMembers.Member m) {\r\n    DataType dataType = m.getDataType();\r\n\r\n    if (dataType == DataType.DOUBLE) {\r\n      return getScalarDouble(recno, m);\r\n\r\n    } else if (dataType == DataType.FLOAT) {\r\n      return getScalarFloat(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == byte.class) {\r\n      return getScalarByte(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == short.class) {\r\n      return getScalarShort(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == int.class) {\r\n      return getScalarInt(recno, m);\r\n\r\n    } else if (dataType.getPrimitiveClassType() == long.class) {\r\n      return getScalarLong(recno, m);\r\n\r\n    } else if (dataType == DataType.CHAR) {\r\n      return getScalarString(recno, m);\r\n\r\n    } else if (dataType == DataType.STRING) {\r\n      return getScalarString(recno, m);\r\n\r\n    } else if (dataType == DataType.STRUCTURE) {\r\n      return getScalarStructure(recno, m);\r\n\r\n    } else if (dataType == DataType.OPAQUE) {\r\n      ArrayObject data = (ArrayObject) m.getDataArray();\r\n      return data.getObject(recno * m.getSize()); // LOOK ?? \r\n    }\r\n\r\n    throw new RuntimeException(\"Dont have implementation for \" + dataType);\r\n  }", "code_tokens": ["public", "Object", "getScalarObject", "(", "int", "recno", ",", "StructureMembers", ".", "Member", "m", ")", "{", "DataType", "dataType", "=", "m", ".", "getDataType", "(", ")", ";", "if", "(", "dataType", "==", "DataType", ".", "DOUBLE", ")", "{", "return", "getScalarDouble", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "FLOAT", ")", "{", "return", "getScalarFloat", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", ".", "getPrimitiveClassType", "(", ")", "==", "byte", ".", "class", ")", "{", "return", "getScalarByte", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", ".", "getPrimitiveClassType", "(", ")", "==", "short", ".", "class", ")", "{", "return", "getScalarShort", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", ".", "getPrimitiveClassType", "(", ")", "==", "int", ".", "class", ")", "{", "return", "getScalarInt", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", ".", "getPrimitiveClassType", "(", ")", "==", "long", ".", "class", ")", "{", "return", "getScalarLong", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "CHAR", ")", "{", "return", "getScalarString", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "STRING", ")", "{", "return", "getScalarString", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "STRUCTURE", ")", "{", "return", "getScalarStructure", "(", "recno", ",", "m", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "OPAQUE", ")", "{", "ArrayObject", "data", "=", "(", "ArrayObject", ")", "m", ".", "getDataArray", "(", ")", ";", "return", "data", ".", "getObject", "(", "recno", "*", "m", ".", "getSize", "(", ")", ")", ";", "// LOOK ?? \r", "}", "throw", "new", "RuntimeException", "(", "\"Dont have implementation for \"", "+", "dataType", ")", ";", "}"], "docstring": "Get member data array of any type as an Object, eg, Float, Double, String, StructureData etc.\n\n@param recno get data from the recnum-th StructureData of the ArrayStructure. Must be less than getSize();\n@param m     get data from this StructureMembers.Member.\n@return value as Float, Double, etc..", "docstring_tokens": ["Get", "member", "data", "array", "of", "any", "type", "as", "an", "Object", "eg", "Float", "Double", "String", "StructureData", "etc", "."]}
{"code": "return data.getFloat(recnum * m.getSize());", "comments": "gets first one in the array", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/ma2/ArrayStructure.java", "func_name": "ArrayStructure.getScalarFloat", "original_string": "public float getScalarFloat(int recnum, StructureMembers.Member m) {\r\n    if (m.getDataType() != DataType.FLOAT)\r\n      throw new IllegalArgumentException(\"Type is \" + m.getDataType() + \", must be float\");\r\n    Array data = m.getDataArray();\r\n    return data.getFloat(recnum * m.getSize()); // gets first one in the array\r\n  }", "language": "java", "Allcodes": "public float getScalarFloat(int recnum, StructureMembers.Member m) {\r\n    if (m.getDataType() != DataType.FLOAT)\r\n      throw new IllegalArgumentException(\"Type is \" + m.getDataType() + \", must be float\");\r\n    Array data = m.getDataArray();\r\n    return data.getFloat(recnum * m.getSize()); // gets first one in the array\r\n  }", "code_tokens": ["public", "float", "getScalarFloat", "(", "int", "recnum", ",", "StructureMembers", ".", "Member", "m", ")", "{", "if", "(", "m", ".", "getDataType", "(", ")", "!=", "DataType", ".", "FLOAT", ")", "throw", "new", "IllegalArgumentException", "(", "\"Type is \"", "+", "m", ".", "getDataType", "(", ")", "+", "\", must be float\"", ")", ";", "Array", "data", "=", "m", ".", "getDataArray", "(", ")", ";", "return", "data", ".", "getFloat", "(", "recnum", "*", "m", ".", "getSize", "(", ")", ")", ";", "// gets first one in the array\r", "}"], "docstring": "Get scalar member data of type float.\n\n@param recnum get data from the recnum-th StructureData of the ArrayStructure. Must be less than getSize();\n@param m      get data from this StructureMembers.Member. Must be of type float.\n@return scalar double value", "docstring_tokens": ["Get", "scalar", "member", "data", "of", "type", "float", "."]}
{"code": "int knt = fileHeaderInfo.indexOf(fh);", "comments": "0 based", "lines": 6, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/gempak/GempakFileReader.java", "func_name": "GempakFileReader.getFileHeader", "original_string": "public float[] getFileHeader(String name) throws IOException {\n    DMFileHeaderInfo fh = findFileHeader(name);\n    if ((fh == null) || (fh.kfhtyp != MDREAL)) {\n      return null;\n    }\n    int knt = fileHeaderInfo.indexOf(fh);  // 0 based\n    int iread = dmLabel.kpfile + 3 * dmLabel.kfhdrs;\n    for (int i = 0; i < knt; i++) {\n      DMFileHeaderInfo fhi = fileHeaderInfo.get(i);\n      iread = iread + fhi.kfhlen + 1;\n    }\n    int nword = DM_RINT(iread);\n    if (nword <= 0) {\n      logError(\"Invalid header length for \" + name);\n      return null;\n    }\n    iread++;\n    float[] rheader = new float[nword];\n    if (name.equals(\"NAVB\") && needToSwap) {\n      DM_RFLT(iread, 1, rheader, 0);\n      needToSwap = false;\n      iread++;\n      DM_RFLT(iread, 1, rheader, 1);\n      needToSwap = true;\n      iread++;\n      DM_RFLT(iread, nword - 2, rheader, 2);\n\n    } else {\n      DM_RFLT(iread, rheader);\n    }\n    return rheader;\n  }", "language": "java", "Allcodes": "public float[] getFileHeader(String name) throws IOException {\n    DMFileHeaderInfo fh = findFileHeader(name);\n    if ((fh == null) || (fh.kfhtyp != MDREAL)) {\n      return null;\n    }\n    int knt = fileHeaderInfo.indexOf(fh);  // 0 based\n    int iread = dmLabel.kpfile + 3 * dmLabel.kfhdrs;\n    for (int i = 0; i < knt; i++) {\n      DMFileHeaderInfo fhi = fileHeaderInfo.get(i);\n      iread = iread + fhi.kfhlen + 1;\n    }\n    int nword = DM_RINT(iread);\n    if (nword <= 0) {\n      logError(\"Invalid header length for \" + name);\n      return null;\n    }\n    iread++;\n    float[] rheader = new float[nword];\n    if (name.equals(\"NAVB\") && needToSwap) {\n      DM_RFLT(iread, 1, rheader, 0);\n      needToSwap = false;\n      iread++;\n      DM_RFLT(iread, 1, rheader, 1);\n      needToSwap = true;\n      iread++;\n      DM_RFLT(iread, nword - 2, rheader, 2);\n\n    } else {\n      DM_RFLT(iread, rheader);\n    }\n    return rheader;\n  }", "code_tokens": ["public", "float", "[", "]", "getFileHeader", "(", "String", "name", ")", "throws", "IOException", "{", "DMFileHeaderInfo", "fh", "=", "findFileHeader", "(", "name", ")", ";", "if", "(", "(", "fh", "==", "null", ")", "||", "(", "fh", ".", "kfhtyp", "!=", "MDREAL", ")", ")", "{", "return", "null", ";", "}", "int", "knt", "=", "fileHeaderInfo", ".", "indexOf", "(", "fh", ")", ";", "// 0 based", "int", "iread", "=", "dmLabel", ".", "kpfile", "+", "3", "*", "dmLabel", ".", "kfhdrs", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "knt", ";", "i", "++", ")", "{", "DMFileHeaderInfo", "fhi", "=", "fileHeaderInfo", ".", "get", "(", "i", ")", ";", "iread", "=", "iread", "+", "fhi", ".", "kfhlen", "+", "1", ";", "}", "int", "nword", "=", "DM_RINT", "(", "iread", ")", ";", "if", "(", "nword", "<=", "0", ")", "{", "logError", "(", "\"Invalid header length for \"", "+", "name", ")", ";", "return", "null", ";", "}", "iread", "++", ";", "float", "[", "]", "rheader", "=", "new", "float", "[", "nword", "]", ";", "if", "(", "name", ".", "equals", "(", "\"NAVB\"", ")", "&&", "needToSwap", ")", "{", "DM_RFLT", "(", "iread", ",", "1", ",", "rheader", ",", "0", ")", ";", "needToSwap", "=", "false", ";", "iread", "++", ";", "DM_RFLT", "(", "iread", ",", "1", ",", "rheader", ",", "1", ")", ";", "needToSwap", "=", "true", ";", "iread", "++", ";", "DM_RFLT", "(", "iread", ",", "nword", "-", "2", ",", "rheader", ",", "2", ")", ";", "}", "else", "{", "DM_RFLT", "(", "iread", ",", "rheader", ")", ";", "}", "return", "rheader", ";", "}"], "docstring": "Read in the values for the file header\n\n@param name name of header\n@return values or null if not found\n@throws IOException problem reading file", "docstring_tokens": ["Read", "in", "the", "values", "for", "the", "file", "header"]}
{"code": "rf.order(RandomAccessFile.LITTLE_ENDIAN);", "comments": "swap", "lines": 14, "repo": "Unidata/thredds", "path": "visad/src/main/java/ucar/nc2/iosp/gempak/GempakFileReader.java", "func_name": "GempakFileReader.DM_RFLT", "original_string": "public float DM_RFLT(int word) throws IOException {\n    if (rf == null) {\n      throw new IOException(\"DM_RFLT: no file to read from\");\n    }\n    if (dmLabel == null) {\n      throw new IOException(\"DM_RFLT: reader not initialized\");\n    }\n    rf.seek(getOffset(word));\n    if (needToSwap) {\n      // set the order\n      //if ((dmLabel.kmachn != MTMACH) &&\n      //   ((dmLabel.kvmst && ! mvmst) ||\n      //   (mvmst && !dmLabel.kvmst))) {\n      rf.order(RandomAccessFile.LITTLE_ENDIAN);  // swap\n    } else {\n      rf.order(RandomAccessFile.BIG_ENDIAN);\n    }\n    float rdata = rf.readFloat();\n    if (RMISSD != dmLabel.smissd) {\n      if (Math.abs(rdata - dmLabel.smissd) < RDIFFD) {\n        rdata = RMISSD;\n      }\n    }\n    // reset to read normally\n    rf.order(RandomAccessFile.BIG_ENDIAN);\n    return rdata;\n  }", "language": "java", "Allcodes": "public float DM_RFLT(int word) throws IOException {\n    if (rf == null) {\n      throw new IOException(\"DM_RFLT: no file to read from\");\n    }\n    if (dmLabel == null) {\n      throw new IOException(\"DM_RFLT: reader not initialized\");\n    }\n    rf.seek(getOffset(word));\n    if (needToSwap) {\n      // set the order\n      //if ((dmLabel.kmachn != MTMACH) &&\n      //   ((dmLabel.kvmst && ! mvmst) ||\n      //   (mvmst && !dmLabel.kvmst))) {\n      rf.order(RandomAccessFile.LITTLE_ENDIAN);  // swap\n    } else {\n      rf.order(RandomAccessFile.BIG_ENDIAN);\n    }\n    float rdata = rf.readFloat();\n    if (RMISSD != dmLabel.smissd) {\n      if (Math.abs(rdata - dmLabel.smissd) < RDIFFD) {\n        rdata = RMISSD;\n      }\n    }\n    // reset to read normally\n    rf.order(RandomAccessFile.BIG_ENDIAN);\n    return rdata;\n  }", "code_tokens": ["public", "float", "DM_RFLT", "(", "int", "word", ")", "throws", "IOException", "{", "if", "(", "rf", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"DM_RFLT: no file to read from\"", ")", ";", "}", "if", "(", "dmLabel", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"DM_RFLT: reader not initialized\"", ")", ";", "}", "rf", ".", "seek", "(", "getOffset", "(", "word", ")", ")", ";", "if", "(", "needToSwap", ")", "{", "// set the order", "//if ((dmLabel.kmachn != MTMACH) &&", "//   ((dmLabel.kvmst && ! mvmst) ||", "//   (mvmst && !dmLabel.kvmst))) {", "rf", ".", "order", "(", "RandomAccessFile", ".", "LITTLE_ENDIAN", ")", ";", "// swap", "}", "else", "{", "rf", ".", "order", "(", "RandomAccessFile", ".", "BIG_ENDIAN", ")", ";", "}", "float", "rdata", "=", "rf", ".", "readFloat", "(", ")", ";", "if", "(", "RMISSD", "!=", "dmLabel", ".", "smissd", ")", "{", "if", "(", "Math", ".", "abs", "(", "rdata", "-", "dmLabel", ".", "smissd", ")", "<", "RDIFFD", ")", "{", "rdata", "=", "RMISSD", ";", "}", "}", "// reset to read normally", "rf", ".", "order", "(", "RandomAccessFile", ".", "BIG_ENDIAN", ")", ";", "return", "rdata", ";", "}"], "docstring": "Read a float\n\n@param word word in file (1 based) to read\n@return float read\n@throws IOException problem reading file", "docstring_tokens": ["Read", "a", "float"]}
{"code": "dk.replication = dk.y;", "comments": "replication count", "lines": 8, "repo": "Unidata/thredds", "path": "bufr/src/main/java/ucar/nc2/iosp/bufr/DataDescriptorTreeConstructor.java", "func_name": "DataDescriptorTreeConstructor.replicate", "original_string": "private List<DataDescriptor> replicate(List<DataDescriptor> keys) {\r\n    List<DataDescriptor> tree = new ArrayList<DataDescriptor>();\r\n    Iterator<DataDescriptor> dkIter = keys.iterator();\r\n    while (dkIter.hasNext()) {\r\n      DataDescriptor dk = dkIter.next();\r\n      if (dk.f == 1) {\r\n        dk.subKeys = new ArrayList<DataDescriptor>();\r\n        dk.replication = dk.y; // replication count\r\n\r\n        if (dk.replication == 0) { // delayed replication\r\n          root.isVarLength = true; // variable sized data == deferred replication == sequence data\r\n\r\n          // the next one is the replication count size : does not count in field count (x)\r\n          DataDescriptor replication = dkIter.next();\r\n          if (replication.y == 0)\r\n            dk.replicationCountSize = 1; // ??\r\n          else if (replication.y == 1)\r\n            dk.replicationCountSize = 8;\r\n          else if (replication.y == 2)\r\n            dk.replicationCountSize = 16;\r\n          else if (replication.y == 11)\r\n            dk.repetitionCountSize = 8;\r\n          else if (replication.y == 12)\r\n            dk.repetitionCountSize = 16;\r\n          else\r\n            log.error(\"Unknown replication type= \"+replication);\r\n        }\r\n\r\n        // transfer to the subKey list\r\n        for (int j = 0; j < dk.x && dkIter.hasNext(); j++) {\r\n          dk.subKeys.add( dkIter.next());\r\n        }\r\n\r\n        // recurse\r\n        dk.subKeys = replicate(dk.subKeys);\r\n\r\n      } else if ((dk.f == 3) && (dk.subKeys != null)) {\r\n        dk.subKeys = replicate( dk.subKeys); // do at all levels\r\n      }\r\n\r\n      tree.add(dk);\r\n    }\r\n\r\n    return tree;\r\n  }", "language": "java", "Allcodes": "private List<DataDescriptor> replicate(List<DataDescriptor> keys) {\r\n    List<DataDescriptor> tree = new ArrayList<DataDescriptor>();\r\n    Iterator<DataDescriptor> dkIter = keys.iterator();\r\n    while (dkIter.hasNext()) {\r\n      DataDescriptor dk = dkIter.next();\r\n      if (dk.f == 1) {\r\n        dk.subKeys = new ArrayList<DataDescriptor>();\r\n        dk.replication = dk.y; // replication count\r\n\r\n        if (dk.replication == 0) { // delayed replication\r\n          root.isVarLength = true; // variable sized data == deferred replication == sequence data\r\n\r\n          // the next one is the replication count size : does not count in field count (x)\r\n          DataDescriptor replication = dkIter.next();\r\n          if (replication.y == 0)\r\n            dk.replicationCountSize = 1; // ??\r\n          else if (replication.y == 1)\r\n            dk.replicationCountSize = 8;\r\n          else if (replication.y == 2)\r\n            dk.replicationCountSize = 16;\r\n          else if (replication.y == 11)\r\n            dk.repetitionCountSize = 8;\r\n          else if (replication.y == 12)\r\n            dk.repetitionCountSize = 16;\r\n          else\r\n            log.error(\"Unknown replication type= \"+replication);\r\n        }\r\n\r\n        // transfer to the subKey list\r\n        for (int j = 0; j < dk.x && dkIter.hasNext(); j++) {\r\n          dk.subKeys.add( dkIter.next());\r\n        }\r\n\r\n        // recurse\r\n        dk.subKeys = replicate(dk.subKeys);\r\n\r\n      } else if ((dk.f == 3) && (dk.subKeys != null)) {\r\n        dk.subKeys = replicate( dk.subKeys); // do at all levels\r\n      }\r\n\r\n      tree.add(dk);\r\n    }\r\n\r\n    return tree;\r\n  }", "code_tokens": ["private", "List", "<", "DataDescriptor", ">", "replicate", "(", "List", "<", "DataDescriptor", ">", "keys", ")", "{", "List", "<", "DataDescriptor", ">", "tree", "=", "new", "ArrayList", "<", "DataDescriptor", ">", "(", ")", ";", "Iterator", "<", "DataDescriptor", ">", "dkIter", "=", "keys", ".", "iterator", "(", ")", ";", "while", "(", "dkIter", ".", "hasNext", "(", ")", ")", "{", "DataDescriptor", "dk", "=", "dkIter", ".", "next", "(", ")", ";", "if", "(", "dk", ".", "f", "==", "1", ")", "{", "dk", ".", "subKeys", "=", "new", "ArrayList", "<", "DataDescriptor", ">", "(", ")", ";", "dk", ".", "replication", "=", "dk", ".", "y", ";", "// replication count\r", "if", "(", "dk", ".", "replication", "==", "0", ")", "{", "// delayed replication\r", "root", ".", "isVarLength", "=", "true", ";", "// variable sized data == deferred replication == sequence data\r", "// the next one is the replication count size : does not count in field count (x)\r", "DataDescriptor", "replication", "=", "dkIter", ".", "next", "(", ")", ";", "if", "(", "replication", ".", "y", "==", "0", ")", "dk", ".", "replicationCountSize", "=", "1", ";", "// ??\r", "else", "if", "(", "replication", ".", "y", "==", "1", ")", "dk", ".", "replicationCountSize", "=", "8", ";", "else", "if", "(", "replication", ".", "y", "==", "2", ")", "dk", ".", "replicationCountSize", "=", "16", ";", "else", "if", "(", "replication", ".", "y", "==", "11", ")", "dk", ".", "repetitionCountSize", "=", "8", ";", "else", "if", "(", "replication", ".", "y", "==", "12", ")", "dk", ".", "repetitionCountSize", "=", "16", ";", "else", "log", ".", "error", "(", "\"Unknown replication type= \"", "+", "replication", ")", ";", "}", "// transfer to the subKey list\r", "for", "(", "int", "j", "=", "0", ";", "j", "<", "dk", ".", "x", "&&", "dkIter", ".", "hasNext", "(", ")", ";", "j", "++", ")", "{", "dk", ".", "subKeys", ".", "add", "(", "dkIter", ".", "next", "(", ")", ")", ";", "}", "// recurse\r", "dk", ".", "subKeys", "=", "replicate", "(", "dk", ".", "subKeys", ")", ";", "}", "else", "if", "(", "(", "dk", ".", "f", "==", "3", ")", "&&", "(", "dk", ".", "subKeys", "!=", "null", ")", ")", "{", "dk", ".", "subKeys", "=", "replicate", "(", "dk", ".", "subKeys", ")", ";", "// do at all levels\r", "}", "tree", ".", "add", "(", "dk", ")", ";", "}", "return", "tree", ";", "}"], "docstring": "look for replication, move replicated items into subtree", "docstring_tokens": ["look", "for", "replication", "move", "replicated", "items", "into", "subtree"]}
{"code": "root.isVarLength = true;", "comments": "variable sized data == deferred replication == sequence data", "lines": 11, "repo": "Unidata/thredds", "path": "bufr/src/main/java/ucar/nc2/iosp/bufr/DataDescriptorTreeConstructor.java", "func_name": "DataDescriptorTreeConstructor.replicate", "original_string": "private List<DataDescriptor> replicate(List<DataDescriptor> keys) {\r\n    List<DataDescriptor> tree = new ArrayList<DataDescriptor>();\r\n    Iterator<DataDescriptor> dkIter = keys.iterator();\r\n    while (dkIter.hasNext()) {\r\n      DataDescriptor dk = dkIter.next();\r\n      if (dk.f == 1) {\r\n        dk.subKeys = new ArrayList<DataDescriptor>();\r\n        dk.replication = dk.y; // replication count\r\n\r\n        if (dk.replication == 0) { // delayed replication\r\n          root.isVarLength = true; // variable sized data == deferred replication == sequence data\r\n\r\n          // the next one is the replication count size : does not count in field count (x)\r\n          DataDescriptor replication = dkIter.next();\r\n          if (replication.y == 0)\r\n            dk.replicationCountSize = 1; // ??\r\n          else if (replication.y == 1)\r\n            dk.replicationCountSize = 8;\r\n          else if (replication.y == 2)\r\n            dk.replicationCountSize = 16;\r\n          else if (replication.y == 11)\r\n            dk.repetitionCountSize = 8;\r\n          else if (replication.y == 12)\r\n            dk.repetitionCountSize = 16;\r\n          else\r\n            log.error(\"Unknown replication type= \"+replication);\r\n        }\r\n\r\n        // transfer to the subKey list\r\n        for (int j = 0; j < dk.x && dkIter.hasNext(); j++) {\r\n          dk.subKeys.add( dkIter.next());\r\n        }\r\n\r\n        // recurse\r\n        dk.subKeys = replicate(dk.subKeys);\r\n\r\n      } else if ((dk.f == 3) && (dk.subKeys != null)) {\r\n        dk.subKeys = replicate( dk.subKeys); // do at all levels\r\n      }\r\n\r\n      tree.add(dk);\r\n    }\r\n\r\n    return tree;\r\n  }", "language": "java", "Allcodes": "private List<DataDescriptor> replicate(List<DataDescriptor> keys) {\r\n    List<DataDescriptor> tree = new ArrayList<DataDescriptor>();\r\n    Iterator<DataDescriptor> dkIter = keys.iterator();\r\n    while (dkIter.hasNext()) {\r\n      DataDescriptor dk = dkIter.next();\r\n      if (dk.f == 1) {\r\n        dk.subKeys = new ArrayList<DataDescriptor>();\r\n        dk.replication = dk.y; // replication count\r\n\r\n        if (dk.replication == 0) { // delayed replication\r\n          root.isVarLength = true; // variable sized data == deferred replication == sequence data\r\n\r\n          // the next one is the replication count size : does not count in field count (x)\r\n          DataDescriptor replication = dkIter.next();\r\n          if (replication.y == 0)\r\n            dk.replicationCountSize = 1; // ??\r\n          else if (replication.y == 1)\r\n            dk.replicationCountSize = 8;\r\n          else if (replication.y == 2)\r\n            dk.replicationCountSize = 16;\r\n          else if (replication.y == 11)\r\n            dk.repetitionCountSize = 8;\r\n          else if (replication.y == 12)\r\n            dk.repetitionCountSize = 16;\r\n          else\r\n            log.error(\"Unknown replication type= \"+replication);\r\n        }\r\n\r\n        // transfer to the subKey list\r\n        for (int j = 0; j < dk.x && dkIter.hasNext(); j++) {\r\n          dk.subKeys.add( dkIter.next());\r\n        }\r\n\r\n        // recurse\r\n        dk.subKeys = replicate(dk.subKeys);\r\n\r\n      } else if ((dk.f == 3) && (dk.subKeys != null)) {\r\n        dk.subKeys = replicate( dk.subKeys); // do at all levels\r\n      }\r\n\r\n      tree.add(dk);\r\n    }\r\n\r\n    return tree;\r\n  }", "code_tokens": ["private", "List", "<", "DataDescriptor", ">", "replicate", "(", "List", "<", "DataDescriptor", ">", "keys", ")", "{", "List", "<", "DataDescriptor", ">", "tree", "=", "new", "ArrayList", "<", "DataDescriptor", ">", "(", ")", ";", "Iterator", "<", "DataDescriptor", ">", "dkIter", "=", "keys", ".", "iterator", "(", ")", ";", "while", "(", "dkIter", ".", "hasNext", "(", ")", ")", "{", "DataDescriptor", "dk", "=", "dkIter", ".", "next", "(", ")", ";", "if", "(", "dk", ".", "f", "==", "1", ")", "{", "dk", ".", "subKeys", "=", "new", "ArrayList", "<", "DataDescriptor", ">", "(", ")", ";", "dk", ".", "replication", "=", "dk", ".", "y", ";", "// replication count\r", "if", "(", "dk", ".", "replication", "==", "0", ")", "{", "// delayed replication\r", "root", ".", "isVarLength", "=", "true", ";", "// variable sized data == deferred replication == sequence data\r", "// the next one is the replication count size : does not count in field count (x)\r", "DataDescriptor", "replication", "=", "dkIter", ".", "next", "(", ")", ";", "if", "(", "replication", ".", "y", "==", "0", ")", "dk", ".", "replicationCountSize", "=", "1", ";", "// ??\r", "else", "if", "(", "replication", ".", "y", "==", "1", ")", "dk", ".", "replicationCountSize", "=", "8", ";", "else", "if", "(", "replication", ".", "y", "==", "2", ")", "dk", ".", "replicationCountSize", "=", "16", ";", "else", "if", "(", "replication", ".", "y", "==", "11", ")", "dk", ".", "repetitionCountSize", "=", "8", ";", "else", "if", "(", "replication", ".", "y", "==", "12", ")", "dk", ".", "repetitionCountSize", "=", "16", ";", "else", "log", ".", "error", "(", "\"Unknown replication type= \"", "+", "replication", ")", ";", "}", "// transfer to the subKey list\r", "for", "(", "int", "j", "=", "0", ";", "j", "<", "dk", ".", "x", "&&", "dkIter", ".", "hasNext", "(", ")", ";", "j", "++", ")", "{", "dk", ".", "subKeys", ".", "add", "(", "dkIter", ".", "next", "(", ")", ")", ";", "}", "// recurse\r", "dk", ".", "subKeys", "=", "replicate", "(", "dk", ".", "subKeys", ")", ";", "}", "else", "if", "(", "(", "dk", ".", "f", "==", "3", ")", "&&", "(", "dk", ".", "subKeys", "!=", "null", ")", ")", "{", "dk", ".", "subKeys", "=", "replicate", "(", "dk", ".", "subKeys", ")", ";", "// do at all levels\r", "}", "tree", ".", "add", "(", "dk", ")", ";", "}", "return", "tree", ";", "}"], "docstring": "look for replication, move replicated items into subtree", "docstring_tokens": ["look", "for", "replication", "move", "replicated", "items", "into", "subtree"]}
{"code": "dk.subKeys = replicate( dk.subKeys);", "comments": "do at all levels", "lines": 38, "repo": "Unidata/thredds", "path": "bufr/src/main/java/ucar/nc2/iosp/bufr/DataDescriptorTreeConstructor.java", "func_name": "DataDescriptorTreeConstructor.replicate", "original_string": "private List<DataDescriptor> replicate(List<DataDescriptor> keys) {\r\n    List<DataDescriptor> tree = new ArrayList<DataDescriptor>();\r\n    Iterator<DataDescriptor> dkIter = keys.iterator();\r\n    while (dkIter.hasNext()) {\r\n      DataDescriptor dk = dkIter.next();\r\n      if (dk.f == 1) {\r\n        dk.subKeys = new ArrayList<DataDescriptor>();\r\n        dk.replication = dk.y; // replication count\r\n\r\n        if (dk.replication == 0) { // delayed replication\r\n          root.isVarLength = true; // variable sized data == deferred replication == sequence data\r\n\r\n          // the next one is the replication count size : does not count in field count (x)\r\n          DataDescriptor replication = dkIter.next();\r\n          if (replication.y == 0)\r\n            dk.replicationCountSize = 1; // ??\r\n          else if (replication.y == 1)\r\n            dk.replicationCountSize = 8;\r\n          else if (replication.y == 2)\r\n            dk.replicationCountSize = 16;\r\n          else if (replication.y == 11)\r\n            dk.repetitionCountSize = 8;\r\n          else if (replication.y == 12)\r\n            dk.repetitionCountSize = 16;\r\n          else\r\n            log.error(\"Unknown replication type= \"+replication);\r\n        }\r\n\r\n        // transfer to the subKey list\r\n        for (int j = 0; j < dk.x && dkIter.hasNext(); j++) {\r\n          dk.subKeys.add( dkIter.next());\r\n        }\r\n\r\n        // recurse\r\n        dk.subKeys = replicate(dk.subKeys);\r\n\r\n      } else if ((dk.f == 3) && (dk.subKeys != null)) {\r\n        dk.subKeys = replicate( dk.subKeys); // do at all levels\r\n      }\r\n\r\n      tree.add(dk);\r\n    }\r\n\r\n    return tree;\r\n  }", "language": "java", "Allcodes": "private List<DataDescriptor> replicate(List<DataDescriptor> keys) {\r\n    List<DataDescriptor> tree = new ArrayList<DataDescriptor>();\r\n    Iterator<DataDescriptor> dkIter = keys.iterator();\r\n    while (dkIter.hasNext()) {\r\n      DataDescriptor dk = dkIter.next();\r\n      if (dk.f == 1) {\r\n        dk.subKeys = new ArrayList<DataDescriptor>();\r\n        dk.replication = dk.y; // replication count\r\n\r\n        if (dk.replication == 0) { // delayed replication\r\n          root.isVarLength = true; // variable sized data == deferred replication == sequence data\r\n\r\n          // the next one is the replication count size : does not count in field count (x)\r\n          DataDescriptor replication = dkIter.next();\r\n          if (replication.y == 0)\r\n            dk.replicationCountSize = 1; // ??\r\n          else if (replication.y == 1)\r\n            dk.replicationCountSize = 8;\r\n          else if (replication.y == 2)\r\n            dk.replicationCountSize = 16;\r\n          else if (replication.y == 11)\r\n            dk.repetitionCountSize = 8;\r\n          else if (replication.y == 12)\r\n            dk.repetitionCountSize = 16;\r\n          else\r\n            log.error(\"Unknown replication type= \"+replication);\r\n        }\r\n\r\n        // transfer to the subKey list\r\n        for (int j = 0; j < dk.x && dkIter.hasNext(); j++) {\r\n          dk.subKeys.add( dkIter.next());\r\n        }\r\n\r\n        // recurse\r\n        dk.subKeys = replicate(dk.subKeys);\r\n\r\n      } else if ((dk.f == 3) && (dk.subKeys != null)) {\r\n        dk.subKeys = replicate( dk.subKeys); // do at all levels\r\n      }\r\n\r\n      tree.add(dk);\r\n    }\r\n\r\n    return tree;\r\n  }", "code_tokens": ["private", "List", "<", "DataDescriptor", ">", "replicate", "(", "List", "<", "DataDescriptor", ">", "keys", ")", "{", "List", "<", "DataDescriptor", ">", "tree", "=", "new", "ArrayList", "<", "DataDescriptor", ">", "(", ")", ";", "Iterator", "<", "DataDescriptor", ">", "dkIter", "=", "keys", ".", "iterator", "(", ")", ";", "while", "(", "dkIter", ".", "hasNext", "(", ")", ")", "{", "DataDescriptor", "dk", "=", "dkIter", ".", "next", "(", ")", ";", "if", "(", "dk", ".", "f", "==", "1", ")", "{", "dk", ".", "subKeys", "=", "new", "ArrayList", "<", "DataDescriptor", ">", "(", ")", ";", "dk", ".", "replication", "=", "dk", ".", "y", ";", "// replication count\r", "if", "(", "dk", ".", "replication", "==", "0", ")", "{", "// delayed replication\r", "root", ".", "isVarLength", "=", "true", ";", "// variable sized data == deferred replication == sequence data\r", "// the next one is the replication count size : does not count in field count (x)\r", "DataDescriptor", "replication", "=", "dkIter", ".", "next", "(", ")", ";", "if", "(", "replication", ".", "y", "==", "0", ")", "dk", ".", "replicationCountSize", "=", "1", ";", "// ??\r", "else", "if", "(", "replication", ".", "y", "==", "1", ")", "dk", ".", "replicationCountSize", "=", "8", ";", "else", "if", "(", "replication", ".", "y", "==", "2", ")", "dk", ".", "replicationCountSize", "=", "16", ";", "else", "if", "(", "replication", ".", "y", "==", "11", ")", "dk", ".", "repetitionCountSize", "=", "8", ";", "else", "if", "(", "replication", ".", "y", "==", "12", ")", "dk", ".", "repetitionCountSize", "=", "16", ";", "else", "log", ".", "error", "(", "\"Unknown replication type= \"", "+", "replication", ")", ";", "}", "// transfer to the subKey list\r", "for", "(", "int", "j", "=", "0", ";", "j", "<", "dk", ".", "x", "&&", "dkIter", ".", "hasNext", "(", ")", ";", "j", "++", ")", "{", "dk", ".", "subKeys", ".", "add", "(", "dkIter", ".", "next", "(", ")", ")", ";", "}", "// recurse\r", "dk", ".", "subKeys", "=", "replicate", "(", "dk", ".", "subKeys", ")", ";", "}", "else", "if", "(", "(", "dk", ".", "f", "==", "3", ")", "&&", "(", "dk", ".", "subKeys", "!=", "null", ")", ")", "{", "dk", ".", "subKeys", "=", "replicate", "(", "dk", ".", "subKeys", ")", ";", "// do at all levels\r", "}", "tree", ".", "add", "(", "dk", ")", ";", "}", "return", "tree", ";", "}"], "docstring": "look for replication, move replicated items into subtree", "docstring_tokens": ["look", "for", "replication", "move", "replicated", "items", "into", "subtree"]}
{"code": "String intervalS = \"5 minute\";", "comments": "interval.getText().trim();", "lines": 6, "repo": "Unidata/thredds", "path": "ui/src/main/java/thredds/ui/monitor/AccessLogTable.java", "func_name": "AccessLogTable.showTimeSeriesAll", "original_string": "private void showTimeSeriesAll(java.util.List<LogReader.Log> logs) {\n    TimeSeries bytesSentData = new TimeSeries(\"Bytes Sent\", Minute.class);\n    TimeSeries timeTookData = new TimeSeries(\"Average Latency\", Minute.class);\n    TimeSeries nreqData = new TimeSeries(\"Number of Requests\", Minute.class);\n\n    String intervalS = \"5 minute\"; // interval.getText().trim();\n    // if (intervalS.length() == 0) intervalS = \"5 minute\";\n    long period = 1000 * 60 * 5;\n    try {\n      TimeDuration tu = new TimeDuration(intervalS);\n      period = (long) (1000 * tu.getValueInSeconds());\n    } catch (Exception e) {\n      System.out.printf(\"Illegal Time interval=%s %n\", intervalS);\n    }\n\n    long current = 0;\n    long bytes = 0;\n    long timeTook = 0;\n    long total_count = 0;\n    long count = 0;\n    for (LogReader.Log log : logs) {\n      long msecs = log.date;\n      if (msecs - current > period) {\n        if (current > 0) {\n          total_count += count;\n          addPoint(bytesSentData, timeTookData, nreqData, new Date(current), bytes, count, timeTook);\n        }\n        bytes = 0;\n        count = 0;\n        timeTook = 0;\n        current = msecs;\n      }\n      bytes += log.getBytes();\n      timeTook += log.getMsecs();\n      count++;\n    }\n    if (count > 0)\n        addPoint(bytesSentData, timeTookData, nreqData, new Date(current), bytes, count, timeTook);\n    total_count += count;\n    System.out.printf(\"showTimeSeriesAll: total_count = %d logs = %d%n\", total_count, logs.size());\n\n    MultipleAxisChart mc = new MultipleAxisChart(\"Access Logs\", intervalS + \" average\", \"Mbytes Sent\", bytesSentData);\n    mc.addSeries(\"Number of Requests\", nreqData);\n    mc.addSeries(\"Average Latency (secs)\", timeTookData);\n    mc.finish(new java.awt.Dimension(1000, 1000));\n\n    //MultipleAxisChart mc = new MultipleAxisChart(\"Bytes Sent\", \"5 min average\", \"Mbytes/sec\", bytesSentData);\n    //Chart c2 = new Chart(\"Average Latency\", \"5 min average\", \"Millisecs\", timeTookData);\n    //Chart c3 = new Chart(\"Number of Requests/sec\", \"5 min average\", \"\", nreqData);\n\n    timeSeriesPanel.removeAll();\n    timeSeriesPanel.add(mc);\n  }", "language": "java", "Allcodes": "private void showTimeSeriesAll(java.util.List<LogReader.Log> logs) {\n    TimeSeries bytesSentData = new TimeSeries(\"Bytes Sent\", Minute.class);\n    TimeSeries timeTookData = new TimeSeries(\"Average Latency\", Minute.class);\n    TimeSeries nreqData = new TimeSeries(\"Number of Requests\", Minute.class);\n\n    String intervalS = \"5 minute\"; // interval.getText().trim();\n    // if (intervalS.length() == 0) intervalS = \"5 minute\";\n    long period = 1000 * 60 * 5;\n    try {\n      TimeDuration tu = new TimeDuration(intervalS);\n      period = (long) (1000 * tu.getValueInSeconds());\n    } catch (Exception e) {\n      System.out.printf(\"Illegal Time interval=%s %n\", intervalS);\n    }\n\n    long current = 0;\n    long bytes = 0;\n    long timeTook = 0;\n    long total_count = 0;\n    long count = 0;\n    for (LogReader.Log log : logs) {\n      long msecs = log.date;\n      if (msecs - current > period) {\n        if (current > 0) {\n          total_count += count;\n          addPoint(bytesSentData, timeTookData, nreqData, new Date(current), bytes, count, timeTook);\n        }\n        bytes = 0;\n        count = 0;\n        timeTook = 0;\n        current = msecs;\n      }\n      bytes += log.getBytes();\n      timeTook += log.getMsecs();\n      count++;\n    }\n    if (count > 0)\n        addPoint(bytesSentData, timeTookData, nreqData, new Date(current), bytes, count, timeTook);\n    total_count += count;\n    System.out.printf(\"showTimeSeriesAll: total_count = %d logs = %d%n\", total_count, logs.size());\n\n    MultipleAxisChart mc = new MultipleAxisChart(\"Access Logs\", intervalS + \" average\", \"Mbytes Sent\", bytesSentData);\n    mc.addSeries(\"Number of Requests\", nreqData);\n    mc.addSeries(\"Average Latency (secs)\", timeTookData);\n    mc.finish(new java.awt.Dimension(1000, 1000));\n\n    //MultipleAxisChart mc = new MultipleAxisChart(\"Bytes Sent\", \"5 min average\", \"Mbytes/sec\", bytesSentData);\n    //Chart c2 = new Chart(\"Average Latency\", \"5 min average\", \"Millisecs\", timeTookData);\n    //Chart c3 = new Chart(\"Number of Requests/sec\", \"5 min average\", \"\", nreqData);\n\n    timeSeriesPanel.removeAll();\n    timeSeriesPanel.add(mc);\n  }", "code_tokens": ["private", "void", "showTimeSeriesAll", "(", "java", ".", "util", ".", "List", "<", "LogReader", ".", "Log", ">", "logs", ")", "{", "TimeSeries", "bytesSentData", "=", "new", "TimeSeries", "(", "\"Bytes Sent\"", ",", "Minute", ".", "class", ")", ";", "TimeSeries", "timeTookData", "=", "new", "TimeSeries", "(", "\"Average Latency\"", ",", "Minute", ".", "class", ")", ";", "TimeSeries", "nreqData", "=", "new", "TimeSeries", "(", "\"Number of Requests\"", ",", "Minute", ".", "class", ")", ";", "String", "intervalS", "=", "\"5 minute\"", ";", "// interval.getText().trim();", "// if (intervalS.length() == 0) intervalS = \"5 minute\";", "long", "period", "=", "1000", "*", "60", "*", "5", ";", "try", "{", "TimeDuration", "tu", "=", "new", "TimeDuration", "(", "intervalS", ")", ";", "period", "=", "(", "long", ")", "(", "1000", "*", "tu", ".", "getValueInSeconds", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "System", ".", "out", ".", "printf", "(", "\"Illegal Time interval=%s %n\"", ",", "intervalS", ")", ";", "}", "long", "current", "=", "0", ";", "long", "bytes", "=", "0", ";", "long", "timeTook", "=", "0", ";", "long", "total_count", "=", "0", ";", "long", "count", "=", "0", ";", "for", "(", "LogReader", ".", "Log", "log", ":", "logs", ")", "{", "long", "msecs", "=", "log", ".", "date", ";", "if", "(", "msecs", "-", "current", ">", "period", ")", "{", "if", "(", "current", ">", "0", ")", "{", "total_count", "+=", "count", ";", "addPoint", "(", "bytesSentData", ",", "timeTookData", ",", "nreqData", ",", "new", "Date", "(", "current", ")", ",", "bytes", ",", "count", ",", "timeTook", ")", ";", "}", "bytes", "=", "0", ";", "count", "=", "0", ";", "timeTook", "=", "0", ";", "current", "=", "msecs", ";", "}", "bytes", "+=", "log", ".", "getBytes", "(", ")", ";", "timeTook", "+=", "log", ".", "getMsecs", "(", ")", ";", "count", "++", ";", "}", "if", "(", "count", ">", "0", ")", "addPoint", "(", "bytesSentData", ",", "timeTookData", ",", "nreqData", ",", "new", "Date", "(", "current", ")", ",", "bytes", ",", "count", ",", "timeTook", ")", ";", "total_count", "+=", "count", ";", "System", ".", "out", ".", "printf", "(", "\"showTimeSeriesAll: total_count = %d logs = %d%n\"", ",", "total_count", ",", "logs", ".", "size", "(", ")", ")", ";", "MultipleAxisChart", "mc", "=", "new", "MultipleAxisChart", "(", "\"Access Logs\"", ",", "intervalS", "+", "\" average\"", ",", "\"Mbytes Sent\"", ",", "bytesSentData", ")", ";", "mc", ".", "addSeries", "(", "\"Number of Requests\"", ",", "nreqData", ")", ";", "mc", ".", "addSeries", "(", "\"Average Latency (secs)\"", ",", "timeTookData", ")", ";", "mc", ".", "finish", "(", "new", "java", ".", "awt", ".", "Dimension", "(", "1000", ",", "1000", ")", ")", ";", "//MultipleAxisChart mc = new MultipleAxisChart(\"Bytes Sent\", \"5 min average\", \"Mbytes/sec\", bytesSentData);", "//Chart c2 = new Chart(\"Average Latency\", \"5 min average\", \"Millisecs\", timeTookData);", "//Chart c3 = new Chart(\"Number of Requests/sec\", \"5 min average\", \"\", nreqData);", "timeSeriesPanel", ".", "removeAll", "(", ")", ";", "timeSeriesPanel", ".", "add", "(", "mc", ")", ";", "}"], "docstring": "construct the TImeSeries plot for the list of logs passed in", "docstring_tokens": ["construct", "the", "TImeSeries", "plot", "for", "the", "list", "of", "logs", "passed", "in"]}
{"code": "f.format(\"string \");", "comments": "note lower case and trailing blank", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Attribute.java", "func_name": "Attribute.writeCDL", "original_string": "protected void writeCDL(Formatter f, boolean strict, String parentname) {\n    if(strict && (isString() || this.getEnumType() != null))\n      // Force type explicitly for string.\n      f.format(\"string \"); //note lower case and trailing blank\n    if(strict && parentname != null) f.format(NetcdfFile.makeValidCDLName(parentname));\n    f.format(\":\");\n    f.format(\"%s\", strict ? NetcdfFile.makeValidCDLName(getShortName()) : getShortName());\n    if (isString()) {\n      f.format(\" = \");\n      for(int i = 0; i < getLength(); i++) {\n        if(i != 0) f.format(\", \");\n        String val = getStringValue(i);\n        if(val != null)\n          f.format(\"\\\"%s\\\"\", encodeString(val));\n      }\n    } else if(getEnumType() != null) {\n      f.format(\" = \");\n      for (int i = 0; i < getLength(); i++) {\n        if(i != 0) f.format(\", \");\n        EnumTypedef en = getEnumType();\n        String econst = getStringValue(i);\n        Integer ecint = en.lookupEnumInt(econst);\n        if(ecint == null)\n           throw new ForbiddenConversionException(\"Illegal enum constant: \"+econst);\n        f.format(\"\\\"%s\\\"\", encodeString(econst));\n      }\n    } else {\n      f.format(\" = \");\n      for (int i = 0; i < getLength(); i++) {\n        if (i != 0) f.format(\", \");\n\n        Number number = getNumericValue(i);\n        if (dataType.isUnsigned()) {\n          // 'number' is unsigned, but will be treated as signed when we print it below, because Java only has signed\n          // types. If it is large enough ( >= 2^(BIT_WIDTH-1) ), its most-significant bit will be interpreted as the\n          // sign bit, which will result in an invalid (negative) value being printed. To prevent that, we're going\n          // to widen the number before printing it.\n          number = DataType.widenNumber(number);\n        }\n        f.format(\"%s\", number);\n\n        if (dataType.isUnsigned()) {\n          f.format(\"U\");\n        }\n\n        if (dataType == DataType.FLOAT)\n          f.format(\"f\");\n        else if (dataType == DataType.SHORT || dataType == DataType.USHORT) {\n          f.format(\"S\");\n        } else if (dataType == DataType.BYTE || dataType == DataType.UBYTE) {\n          f.format(\"B\");\n        } else if (dataType == DataType.LONG || dataType == DataType.ULONG) {\n          f.format(\"L\");\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "protected void writeCDL(Formatter f, boolean strict, String parentname) {\n    if(strict && (isString() || this.getEnumType() != null))\n      // Force type explicitly for string.\n      f.format(\"string \"); //note lower case and trailing blank\n    if(strict && parentname != null) f.format(NetcdfFile.makeValidCDLName(parentname));\n    f.format(\":\");\n    f.format(\"%s\", strict ? NetcdfFile.makeValidCDLName(getShortName()) : getShortName());\n    if (isString()) {\n      f.format(\" = \");\n      for(int i = 0; i < getLength(); i++) {\n        if(i != 0) f.format(\", \");\n        String val = getStringValue(i);\n        if(val != null)\n          f.format(\"\\\"%s\\\"\", encodeString(val));\n      }\n    } else if(getEnumType() != null) {\n      f.format(\" = \");\n      for (int i = 0; i < getLength(); i++) {\n        if(i != 0) f.format(\", \");\n        EnumTypedef en = getEnumType();\n        String econst = getStringValue(i);\n        Integer ecint = en.lookupEnumInt(econst);\n        if(ecint == null)\n           throw new ForbiddenConversionException(\"Illegal enum constant: \"+econst);\n        f.format(\"\\\"%s\\\"\", encodeString(econst));\n      }\n    } else {\n      f.format(\" = \");\n      for (int i = 0; i < getLength(); i++) {\n        if (i != 0) f.format(\", \");\n\n        Number number = getNumericValue(i);\n        if (dataType.isUnsigned()) {\n          // 'number' is unsigned, but will be treated as signed when we print it below, because Java only has signed\n          // types. If it is large enough ( >= 2^(BIT_WIDTH-1) ), its most-significant bit will be interpreted as the\n          // sign bit, which will result in an invalid (negative) value being printed. To prevent that, we're going\n          // to widen the number before printing it.\n          number = DataType.widenNumber(number);\n        }\n        f.format(\"%s\", number);\n\n        if (dataType.isUnsigned()) {\n          f.format(\"U\");\n        }\n\n        if (dataType == DataType.FLOAT)\n          f.format(\"f\");\n        else if (dataType == DataType.SHORT || dataType == DataType.USHORT) {\n          f.format(\"S\");\n        } else if (dataType == DataType.BYTE || dataType == DataType.UBYTE) {\n          f.format(\"B\");\n        } else if (dataType == DataType.LONG || dataType == DataType.ULONG) {\n          f.format(\"L\");\n        }\n      }\n    }\n  }", "code_tokens": ["protected", "void", "writeCDL", "(", "Formatter", "f", ",", "boolean", "strict", ",", "String", "parentname", ")", "{", "if", "(", "strict", "&&", "(", "isString", "(", ")", "||", "this", ".", "getEnumType", "(", ")", "!=", "null", ")", ")", "// Force type explicitly for string.", "f", ".", "format", "(", "\"string \"", ")", ";", "//note lower case and trailing blank", "if", "(", "strict", "&&", "parentname", "!=", "null", ")", "f", ".", "format", "(", "NetcdfFile", ".", "makeValidCDLName", "(", "parentname", ")", ")", ";", "f", ".", "format", "(", "\":\"", ")", ";", "f", ".", "format", "(", "\"%s\"", ",", "strict", "?", "NetcdfFile", ".", "makeValidCDLName", "(", "getShortName", "(", ")", ")", ":", "getShortName", "(", ")", ")", ";", "if", "(", "isString", "(", ")", ")", "{", "f", ".", "format", "(", "\" = \"", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "getLength", "(", ")", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "0", ")", "f", ".", "format", "(", "\", \"", ")", ";", "String", "val", "=", "getStringValue", "(", "i", ")", ";", "if", "(", "val", "!=", "null", ")", "f", ".", "format", "(", "\"\\\"%s\\\"\"", ",", "encodeString", "(", "val", ")", ")", ";", "}", "}", "else", "if", "(", "getEnumType", "(", ")", "!=", "null", ")", "{", "f", ".", "format", "(", "\" = \"", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "getLength", "(", ")", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "0", ")", "f", ".", "format", "(", "\", \"", ")", ";", "EnumTypedef", "en", "=", "getEnumType", "(", ")", ";", "String", "econst", "=", "getStringValue", "(", "i", ")", ";", "Integer", "ecint", "=", "en", ".", "lookupEnumInt", "(", "econst", ")", ";", "if", "(", "ecint", "==", "null", ")", "throw", "new", "ForbiddenConversionException", "(", "\"Illegal enum constant: \"", "+", "econst", ")", ";", "f", ".", "format", "(", "\"\\\"%s\\\"\"", ",", "encodeString", "(", "econst", ")", ")", ";", "}", "}", "else", "{", "f", ".", "format", "(", "\" = \"", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "getLength", "(", ")", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "0", ")", "f", ".", "format", "(", "\", \"", ")", ";", "Number", "number", "=", "getNumericValue", "(", "i", ")", ";", "if", "(", "dataType", ".", "isUnsigned", "(", ")", ")", "{", "// 'number' is unsigned, but will be treated as signed when we print it below, because Java only has signed", "// types. If it is large enough ( >= 2^(BIT_WIDTH-1) ), its most-significant bit will be interpreted as the", "// sign bit, which will result in an invalid (negative) value being printed. To prevent that, we're going", "// to widen the number before printing it.", "number", "=", "DataType", ".", "widenNumber", "(", "number", ")", ";", "}", "f", ".", "format", "(", "\"%s\"", ",", "number", ")", ";", "if", "(", "dataType", ".", "isUnsigned", "(", ")", ")", "{", "f", ".", "format", "(", "\"U\"", ")", ";", "}", "if", "(", "dataType", "==", "DataType", ".", "FLOAT", ")", "f", ".", "format", "(", "\"f\"", ")", ";", "else", "if", "(", "dataType", "==", "DataType", ".", "SHORT", "||", "dataType", "==", "DataType", ".", "USHORT", ")", "{", "f", ".", "format", "(", "\"S\"", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "BYTE", "||", "dataType", "==", "DataType", ".", "UBYTE", ")", "{", "f", ".", "format", "(", "\"B\"", ")", ";", "}", "else", "if", "(", "dataType", "==", "DataType", ".", "LONG", "||", "dataType", "==", "DataType", ".", "ULONG", ")", "{", "f", ".", "format", "(", "\"L\"", ")", ";", "}", "}", "}", "}"], "docstring": "Write CDL representation into f\n\n@param f      write into this\n@param strict if true, create strict CDL, escaping names", "docstring_tokens": ["Write", "CDL", "representation", "into", "f"]}
{"code": "arr = arr.reshape(new int[]{(int) arr.getSize()});", "comments": "make sure 1D", "lines": 44, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Attribute.java", "func_name": "Attribute.setValues", "original_string": "public void setValues(Array arr) {\n    if (immutable) throw new IllegalStateException(\"Cant modify\");\n\n    if (arr == null) {\n      dataType = DataType.STRING;\n      return;\n    }\n\n    if (arr.getElementType() == char.class) { // turn CHAR into STRING\n      ArrayChar carr = (ArrayChar) arr;\n      if (carr.getRank() == 1) { // common case\n        svalue = carr.getString();\n        this.nelems = 1;\n        this.dataType = DataType.STRING;\n        return;\n      }\n      // otherwise its an array of Strings\n      arr = carr.make1DStringArray();\n    }\n\n    // this should be a utility somewhere\n    if (arr.getElementType() == ByteBuffer.class) { // turn OPAQUE into BYTE\n      int totalLen = 0;\n      arr.resetLocalIterator();\n      while (arr.hasNext()) {\n        ByteBuffer bb = (ByteBuffer) arr.next();\n        totalLen += bb.limit();\n      }\n      byte[] ba = new byte[totalLen];\n      int pos = 0;\n      arr.resetLocalIterator();\n      while (arr.hasNext()) {\n        ByteBuffer bb = (ByteBuffer) arr.next();\n        System.arraycopy(bb.array(), 0, ba, pos, bb.limit());\n        pos += bb.limit();\n      }\n      arr = Array.factory(DataType.BYTE, new int[]{totalLen}, ba);\n    }\n\n    if (DataType.getType(arr) == DataType.OBJECT)\n      throw new IllegalArgumentException(\"Cant set Attribute with type \" + arr.getElementType());\n\n    if (arr.getRank() > 1)\n      arr = arr.reshape(new int[]{(int) arr.getSize()}); // make sure 1D\n\n    this.values = arr;\n    this.nelems = (int) arr.getSize();\n    this.dataType = DataType.getType(arr);\n  }", "language": "java", "Allcodes": "public void setValues(Array arr) {\n    if (immutable) throw new IllegalStateException(\"Cant modify\");\n\n    if (arr == null) {\n      dataType = DataType.STRING;\n      return;\n    }\n\n    if (arr.getElementType() == char.class) { // turn CHAR into STRING\n      ArrayChar carr = (ArrayChar) arr;\n      if (carr.getRank() == 1) { // common case\n        svalue = carr.getString();\n        this.nelems = 1;\n        this.dataType = DataType.STRING;\n        return;\n      }\n      // otherwise its an array of Strings\n      arr = carr.make1DStringArray();\n    }\n\n    // this should be a utility somewhere\n    if (arr.getElementType() == ByteBuffer.class) { // turn OPAQUE into BYTE\n      int totalLen = 0;\n      arr.resetLocalIterator();\n      while (arr.hasNext()) {\n        ByteBuffer bb = (ByteBuffer) arr.next();\n        totalLen += bb.limit();\n      }\n      byte[] ba = new byte[totalLen];\n      int pos = 0;\n      arr.resetLocalIterator();\n      while (arr.hasNext()) {\n        ByteBuffer bb = (ByteBuffer) arr.next();\n        System.arraycopy(bb.array(), 0, ba, pos, bb.limit());\n        pos += bb.limit();\n      }\n      arr = Array.factory(DataType.BYTE, new int[]{totalLen}, ba);\n    }\n\n    if (DataType.getType(arr) == DataType.OBJECT)\n      throw new IllegalArgumentException(\"Cant set Attribute with type \" + arr.getElementType());\n\n    if (arr.getRank() > 1)\n      arr = arr.reshape(new int[]{(int) arr.getSize()}); // make sure 1D\n\n    this.values = arr;\n    this.nelems = (int) arr.getSize();\n    this.dataType = DataType.getType(arr);\n  }", "code_tokens": ["public", "void", "setValues", "(", "Array", "arr", ")", "{", "if", "(", "immutable", ")", "throw", "new", "IllegalStateException", "(", "\"Cant modify\"", ")", ";", "if", "(", "arr", "==", "null", ")", "{", "dataType", "=", "DataType", ".", "STRING", ";", "return", ";", "}", "if", "(", "arr", ".", "getElementType", "(", ")", "==", "char", ".", "class", ")", "{", "// turn CHAR into STRING", "ArrayChar", "carr", "=", "(", "ArrayChar", ")", "arr", ";", "if", "(", "carr", ".", "getRank", "(", ")", "==", "1", ")", "{", "// common case", "svalue", "=", "carr", ".", "getString", "(", ")", ";", "this", ".", "nelems", "=", "1", ";", "this", ".", "dataType", "=", "DataType", ".", "STRING", ";", "return", ";", "}", "// otherwise its an array of Strings", "arr", "=", "carr", ".", "make1DStringArray", "(", ")", ";", "}", "// this should be a utility somewhere", "if", "(", "arr", ".", "getElementType", "(", ")", "==", "ByteBuffer", ".", "class", ")", "{", "// turn OPAQUE into BYTE", "int", "totalLen", "=", "0", ";", "arr", ".", "resetLocalIterator", "(", ")", ";", "while", "(", "arr", ".", "hasNext", "(", ")", ")", "{", "ByteBuffer", "bb", "=", "(", "ByteBuffer", ")", "arr", ".", "next", "(", ")", ";", "totalLen", "+=", "bb", ".", "limit", "(", ")", ";", "}", "byte", "[", "]", "ba", "=", "new", "byte", "[", "totalLen", "]", ";", "int", "pos", "=", "0", ";", "arr", ".", "resetLocalIterator", "(", ")", ";", "while", "(", "arr", ".", "hasNext", "(", ")", ")", "{", "ByteBuffer", "bb", "=", "(", "ByteBuffer", ")", "arr", ".", "next", "(", ")", ";", "System", ".", "arraycopy", "(", "bb", ".", "array", "(", ")", ",", "0", ",", "ba", ",", "pos", ",", "bb", ".", "limit", "(", ")", ")", ";", "pos", "+=", "bb", ".", "limit", "(", ")", ";", "}", "arr", "=", "Array", ".", "factory", "(", "DataType", ".", "BYTE", ",", "new", "int", "[", "]", "{", "totalLen", "}", ",", "ba", ")", ";", "}", "if", "(", "DataType", ".", "getType", "(", "arr", ")", "==", "DataType", ".", "OBJECT", ")", "throw", "new", "IllegalArgumentException", "(", "\"Cant set Attribute with type \"", "+", "arr", ".", "getElementType", "(", ")", ")", ";", "if", "(", "arr", ".", "getRank", "(", ")", ">", "1", ")", "arr", "=", "arr", ".", "reshape", "(", "new", "int", "[", "]", "{", "(", "int", ")", "arr", ".", "getSize", "(", ")", "}", ")", ";", "// make sure 1D", "this", ".", "values", "=", "arr", ";", "this", ".", "nelems", "=", "(", "int", ")", "arr", ".", "getSize", "(", ")", ";", "this", ".", "dataType", "=", "DataType", ".", "getType", "(", "arr", ")", ";", "}"], "docstring": "set the values from an Array\n\n@param arr value of Attribute", "docstring_tokens": ["set", "the", "values", "from", "an", "Array"]}
{"code": "return catalog;", "comments": "TODO Test this case in TestDataRootHandler.", "lines": 13, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/cataloggen/CollectionLevelScanner.java", "func_name": "CollectionLevelScanner.generateProxyDsResolverCatalog", "original_string": "public InvCatalogImpl generateProxyDsResolverCatalog( ProxyDatasetHandler pdh )\n  {\n    if ( state != 2 ) throw new IllegalStateException( \"Scan has not been performed.\" );\n    if ( ! proxyDsHandlers.containsValue( pdh )) throw new IllegalArgumentException( \"Unknown ProxyDatasetHandler.\");\n\n    // Create a skeleton catalog.\n    InvCatalogImpl catalog = createSkeletonCatalog( currentLevel );\n    InvDatasetImpl topDs = (InvDatasetImpl) catalog.getDatasets().get( 0 );\n\n    // Find actual dataset in the list of atomic dataset InvCrawlablePairs.\n    InvCrawlablePair actualDsInfo = pdh.getActualDataset( atomicDsInfo );\n    if ( actualDsInfo == null )\n      return catalog; // TODO Test this case in TestDataRootHandler.\n    InvDatasetImpl actualInvDs = (InvDatasetImpl) actualDsInfo.getInvDataset();\n\n    actualInvDs.setName( pdh.getActualDatasetName( actualDsInfo, topDs.getName() ) );\n\n    // Add current InvDataset to top dataset.\n    catalog.removeDataset( topDs );\n    catalog.addDataset( actualInvDs );\n    // topDs.addDataset( actualInvDs );\n\n    // Finish catalog.\n    catalog.finish();\n\n    // Add any top-level metadata.\n    this.addTopLevelMetadata( catalog, false );\n\n    return catalog;\n  }", "language": "java", "Allcodes": "public InvCatalogImpl generateProxyDsResolverCatalog( ProxyDatasetHandler pdh )\n  {\n    if ( state != 2 ) throw new IllegalStateException( \"Scan has not been performed.\" );\n    if ( ! proxyDsHandlers.containsValue( pdh )) throw new IllegalArgumentException( \"Unknown ProxyDatasetHandler.\");\n\n    // Create a skeleton catalog.\n    InvCatalogImpl catalog = createSkeletonCatalog( currentLevel );\n    InvDatasetImpl topDs = (InvDatasetImpl) catalog.getDatasets().get( 0 );\n\n    // Find actual dataset in the list of atomic dataset InvCrawlablePairs.\n    InvCrawlablePair actualDsInfo = pdh.getActualDataset( atomicDsInfo );\n    if ( actualDsInfo == null )\n      return catalog; // TODO Test this case in TestDataRootHandler.\n    InvDatasetImpl actualInvDs = (InvDatasetImpl) actualDsInfo.getInvDataset();\n\n    actualInvDs.setName( pdh.getActualDatasetName( actualDsInfo, topDs.getName() ) );\n\n    // Add current InvDataset to top dataset.\n    catalog.removeDataset( topDs );\n    catalog.addDataset( actualInvDs );\n    // topDs.addDataset( actualInvDs );\n\n    // Finish catalog.\n    catalog.finish();\n\n    // Add any top-level metadata.\n    this.addTopLevelMetadata( catalog, false );\n\n    return catalog;\n  }", "code_tokens": ["public", "InvCatalogImpl", "generateProxyDsResolverCatalog", "(", "ProxyDatasetHandler", "pdh", ")", "{", "if", "(", "state", "!=", "2", ")", "throw", "new", "IllegalStateException", "(", "\"Scan has not been performed.\"", ")", ";", "if", "(", "!", "proxyDsHandlers", ".", "containsValue", "(", "pdh", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"Unknown ProxyDatasetHandler.\"", ")", ";", "// Create a skeleton catalog.", "InvCatalogImpl", "catalog", "=", "createSkeletonCatalog", "(", "currentLevel", ")", ";", "InvDatasetImpl", "topDs", "=", "(", "InvDatasetImpl", ")", "catalog", ".", "getDatasets", "(", ")", ".", "get", "(", "0", ")", ";", "// Find actual dataset in the list of atomic dataset InvCrawlablePairs.", "InvCrawlablePair", "actualDsInfo", "=", "pdh", ".", "getActualDataset", "(", "atomicDsInfo", ")", ";", "if", "(", "actualDsInfo", "==", "null", ")", "return", "catalog", ";", "// TODO Test this case in TestDataRootHandler.", "InvDatasetImpl", "actualInvDs", "=", "(", "InvDatasetImpl", ")", "actualDsInfo", ".", "getInvDataset", "(", ")", ";", "actualInvDs", ".", "setName", "(", "pdh", ".", "getActualDatasetName", "(", "actualDsInfo", ",", "topDs", ".", "getName", "(", ")", ")", ")", ";", "// Add current InvDataset to top dataset.", "catalog", ".", "removeDataset", "(", "topDs", ")", ";", "catalog", ".", "addDataset", "(", "actualInvDs", ")", ";", "// topDs.addDataset( actualInvDs );", "// Finish catalog.", "catalog", ".", "finish", "(", ")", ";", "// Add any top-level metadata.", "this", ".", "addTopLevelMetadata", "(", "catalog", ",", "false", ")", ";", "return", "catalog", ";", "}"], "docstring": "Generate the catalog for a resolver request of the given ProxyDatasetHandler.\n\n@param pdh the ProxyDatasetHandler corresponding to the resolver request.\n@return the catalog for a resolver request of the given proxy dataset.\n@throws IllegalStateException if this collection has not yet been scanned.\n@throws IllegalArgumentException if the given ProxyDatasetHandler is not known by this CollectionLevelScanner.", "docstring_tokens": ["Generate", "the", "catalog", "for", "a", "resolver", "request", "of", "the", "given", "ProxyDatasetHandler", "."]}
{"code": "ncd.enhance();", "comments": "make sure its enhanced", "lines": 16, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/ToolsUI.java", "func_name": "ToolsUI.setThreddsDatatype", "original_string": "private void setThreddsDatatype(thredds.client.catalog.Dataset invDataset, String wants) {\r\n    if (invDataset == null) return;\r\n\r\n    boolean wantsViewer = wants.equals(\"File\");\r\n    boolean wantsCoordSys = wants.equals(\"CoordSys\");\r\n\r\n    try {\r\n      // just open as a NetcdfDataset\r\n      if (wantsViewer) {\r\n        openNetcdfFile(threddsDataFactory.openDataset(invDataset, true, null, null));\r\n        return;\r\n      }\r\n\r\n      if (wantsCoordSys) {\r\n        NetcdfDataset ncd = threddsDataFactory.openDataset(invDataset, true, null, null);\r\n        ncd.enhance(); // make sure its enhanced\r\n        openCoordSystems(ncd);\r\n        return;\r\n      }\r\n\r\n      // otherwise do the datatype thing\r\n      DataFactory.Result threddsData = threddsDataFactory.openFeatureDataset(invDataset, null);\r\n      if (threddsData.fatalError) {\r\n        JOptionPane.showMessageDialog(null, \"Failed to open err=\"+threddsData.errLog);\r\n        return;\r\n      }\r\n      jumptoThreddsDatatype(threddsData);\r\n\r\n    }\r\n    catch (IOException ioe) {\r\n      JOptionPane.showMessageDialog(null, \"Error on setThreddsDatatype = \" + ioe.getMessage());\r\n      ioe.printStackTrace();\r\n    }\r\n\r\n  }", "language": "java", "Allcodes": "private void setThreddsDatatype(thredds.client.catalog.Dataset invDataset, String wants) {\r\n    if (invDataset == null) return;\r\n\r\n    boolean wantsViewer = wants.equals(\"File\");\r\n    boolean wantsCoordSys = wants.equals(\"CoordSys\");\r\n\r\n    try {\r\n      // just open as a NetcdfDataset\r\n      if (wantsViewer) {\r\n        openNetcdfFile(threddsDataFactory.openDataset(invDataset, true, null, null));\r\n        return;\r\n      }\r\n\r\n      if (wantsCoordSys) {\r\n        NetcdfDataset ncd = threddsDataFactory.openDataset(invDataset, true, null, null);\r\n        ncd.enhance(); // make sure its enhanced\r\n        openCoordSystems(ncd);\r\n        return;\r\n      }\r\n\r\n      // otherwise do the datatype thing\r\n      DataFactory.Result threddsData = threddsDataFactory.openFeatureDataset(invDataset, null);\r\n      if (threddsData.fatalError) {\r\n        JOptionPane.showMessageDialog(null, \"Failed to open err=\"+threddsData.errLog);\r\n        return;\r\n      }\r\n      jumptoThreddsDatatype(threddsData);\r\n\r\n    }\r\n    catch (IOException ioe) {\r\n      JOptionPane.showMessageDialog(null, \"Error on setThreddsDatatype = \" + ioe.getMessage());\r\n      ioe.printStackTrace();\r\n    }\r\n\r\n  }", "code_tokens": ["private", "void", "setThreddsDatatype", "(", "thredds", ".", "client", ".", "catalog", ".", "Dataset", "invDataset", ",", "String", "wants", ")", "{", "if", "(", "invDataset", "==", "null", ")", "return", ";", "boolean", "wantsViewer", "=", "wants", ".", "equals", "(", "\"File\"", ")", ";", "boolean", "wantsCoordSys", "=", "wants", ".", "equals", "(", "\"CoordSys\"", ")", ";", "try", "{", "// just open as a NetcdfDataset\r", "if", "(", "wantsViewer", ")", "{", "openNetcdfFile", "(", "threddsDataFactory", ".", "openDataset", "(", "invDataset", ",", "true", ",", "null", ",", "null", ")", ")", ";", "return", ";", "}", "if", "(", "wantsCoordSys", ")", "{", "NetcdfDataset", "ncd", "=", "threddsDataFactory", ".", "openDataset", "(", "invDataset", ",", "true", ",", "null", ",", "null", ")", ";", "ncd", ".", "enhance", "(", ")", ";", "// make sure its enhanced\r", "openCoordSystems", "(", "ncd", ")", ";", "return", ";", "}", "// otherwise do the datatype thing\r", "DataFactory", ".", "Result", "threddsData", "=", "threddsDataFactory", ".", "openFeatureDataset", "(", "invDataset", ",", "null", ")", ";", "if", "(", "threddsData", ".", "fatalError", ")", "{", "JOptionPane", ".", "showMessageDialog", "(", "null", ",", "\"Failed to open err=\"", "+", "threddsData", ".", "errLog", ")", ";", "return", ";", "}", "jumptoThreddsDatatype", "(", "threddsData", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "JOptionPane", ".", "showMessageDialog", "(", "null", ",", "\"Error on setThreddsDatatype = \"", "+", "ioe", ".", "getMessage", "(", ")", ")", ";", "ioe", ".", "printStackTrace", "(", ")", ";", "}", "}"], "docstring": "Jump to the appropriate tab based on datatype of InvDataset", "docstring_tokens": ["Jump", "to", "the", "appropriate", "tab", "based", "on", "datatype", "of", "InvDataset"]}
{"code": "final String catName = wantDataset.substring(0, pos);", "comments": "{catalog}#{dataset}", "lines": 6, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/ToolsUI.java", "func_name": "ToolsUI.setDataset", "original_string": "private static void setDataset() {\r\n        // do it in the swing event thread\r\n        SwingUtilities.invokeLater(( ) -> {\r\n            int pos = wantDataset.indexOf('#');\r\n            if (pos > 0) {\r\n                final String catName = wantDataset.substring(0, pos); // {catalog}#{dataset}\r\n                if (catName.endsWith(\".xml\")) {\r\n                    ui.makeComponent(null, \"THREDDS\");\r\n                    ui.threddsUI.setDataset(wantDataset);\r\n                    ui.tabbedPane.setSelectedComponent(ui.threddsUI);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // default\r\n            ui.openNetcdfFile(wantDataset);\r\n        });\r\n    }", "language": "java", "Allcodes": "private static void setDataset() {\r\n        // do it in the swing event thread\r\n        SwingUtilities.invokeLater(( ) -> {\r\n            int pos = wantDataset.indexOf('#');\r\n            if (pos > 0) {\r\n                final String catName = wantDataset.substring(0, pos); // {catalog}#{dataset}\r\n                if (catName.endsWith(\".xml\")) {\r\n                    ui.makeComponent(null, \"THREDDS\");\r\n                    ui.threddsUI.setDataset(wantDataset);\r\n                    ui.tabbedPane.setSelectedComponent(ui.threddsUI);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // default\r\n            ui.openNetcdfFile(wantDataset);\r\n        });\r\n    }", "code_tokens": ["private", "static", "void", "setDataset", "(", ")", "{", "// do it in the swing event thread\r", "SwingUtilities", ".", "invokeLater", "(", "(", ")", "->", "{", "int", "pos", "=", "wantDataset", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "pos", ">", "0", ")", "{", "final", "String", "catName", "=", "wantDataset", ".", "substring", "(", "0", ",", "pos", ")", ";", "// {catalog}#{dataset}\r", "if", "(", "catName", ".", "endsWith", "(", "\".xml\"", ")", ")", "{", "ui", ".", "makeComponent", "(", "null", ",", "\"THREDDS\"", ")", ";", "ui", ".", "threddsUI", ".", "setDataset", "(", "wantDataset", ")", ";", "ui", ".", "tabbedPane", ".", "setSelectedComponent", "(", "ui", ".", "threddsUI", ")", ";", "}", "return", ";", "}", "// default\r", "ui", ".", "openNetcdfFile", "(", "wantDataset", ")", ";", "}", ")", ";", "}"], "docstring": "Handle messages.", "docstring_tokens": ["Handle", "messages", "."]}
{"code": "DAPNode node = (DAPNode)super.clone();", "comments": "Object.clone", "lines": 4, "repo": "Unidata/thredds", "path": "opendap/src/main/java/opendap/dap/DAPNode.java", "func_name": "DAPNode.cloneDAG", "original_string": "public DAPNode cloneDAG(CloneMap map)\r\n        throws CloneNotSupportedException\r\n    {\r\n        DAPNode node = (DAPNode)super.clone(); // Object.clone\r\n\tmap.nodes.put(this,node);\r\n\r\n        DAPNode tmp = map.nodes.get(_myParent);\r\n        if(tmp != node)\r\n            _myParent = tmp;\r\n        return node;\r\n    }", "language": "java", "Allcodes": "public DAPNode cloneDAG(CloneMap map)\r\n        throws CloneNotSupportedException\r\n    {\r\n        DAPNode node = (DAPNode)super.clone(); // Object.clone\r\n\tmap.nodes.put(this,node);\r\n\r\n        DAPNode tmp = map.nodes.get(_myParent);\r\n        if(tmp != node)\r\n            _myParent = tmp;\r\n        return node;\r\n    }", "code_tokens": ["public", "DAPNode", "cloneDAG", "(", "CloneMap", "map", ")", "throws", "CloneNotSupportedException", "{", "DAPNode", "node", "=", "(", "DAPNode", ")", "super", ".", "clone", "(", ")", ";", "// Object.clone\r", "map", ".", "nodes", ".", "put", "(", "this", ",", "node", ")", ";", "DAPNode", "tmp", "=", "map", ".", "nodes", ".", "get", "(", "_myParent", ")", ";", "if", "(", "tmp", "!=", "node", ")", "_myParent", "=", "tmp", ";", "return", "node", ";", "}"], "docstring": "This procedure does the actual recursive clone.\n@param map  list of previously cloned nodes\n@return  clone of this node\n@throws CloneNotSupportedException", "docstring_tokens": ["This", "procedure", "does", "the", "actual", "recursive", "clone", "."]}
{"code": "int currentViewIndex = tableColumnModel.getColumnIndex(propCol.getName());", "comments": "May throw IAE.", "lines": 13, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/util/prefs/ui/BeanTable.java", "func_name": "BeanTable.restoreState", "original_string": "protected void restoreState() {\n    if (store == null) {\n      return;\n    }\n\n    ArrayList propColObjs = (ArrayList) store.getBean(\"propertyCol\", new ArrayList());\n    HidableTableColumnModel tableColumnModel = (HidableTableColumnModel) jtable.getColumnModel();\n    int newViewIndex = 0;\n\n    for (Object propColObj : propColObjs) {\n      PropertyCol propCol = (PropertyCol) propColObj;\n      try {\n        int currentViewIndex = tableColumnModel.getColumnIndex(propCol.getName());  // May throw IAE.\n\n        TableColumn column = tableColumnModel.getColumn(currentViewIndex);\n        column.setPreferredWidth(propCol.getWidth());\n\n        tableColumnModel.moveColumn(currentViewIndex, newViewIndex);\n        assert tableColumnModel.getColumn(newViewIndex) == column : \"tableColumn wasn't successfully moved.\";\n\n        // We must do this last, since moveColumn() only works on visible columns.\n        tableColumnModel.setColumnVisible(column, propCol.isVisible());\n        if (propCol.isVisible()) {\n          ++newViewIndex;  // Don't increment for hidden columns.\n        }\n      } catch (IllegalArgumentException e) {\n        logger.debug(String.format(\n                \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\", propCol.getName()), e);\n      }\n    }\n  }", "language": "java", "Allcodes": "protected void restoreState() {\n    if (store == null) {\n      return;\n    }\n\n    ArrayList propColObjs = (ArrayList) store.getBean(\"propertyCol\", new ArrayList());\n    HidableTableColumnModel tableColumnModel = (HidableTableColumnModel) jtable.getColumnModel();\n    int newViewIndex = 0;\n\n    for (Object propColObj : propColObjs) {\n      PropertyCol propCol = (PropertyCol) propColObj;\n      try {\n        int currentViewIndex = tableColumnModel.getColumnIndex(propCol.getName());  // May throw IAE.\n\n        TableColumn column = tableColumnModel.getColumn(currentViewIndex);\n        column.setPreferredWidth(propCol.getWidth());\n\n        tableColumnModel.moveColumn(currentViewIndex, newViewIndex);\n        assert tableColumnModel.getColumn(newViewIndex) == column : \"tableColumn wasn't successfully moved.\";\n\n        // We must do this last, since moveColumn() only works on visible columns.\n        tableColumnModel.setColumnVisible(column, propCol.isVisible());\n        if (propCol.isVisible()) {\n          ++newViewIndex;  // Don't increment for hidden columns.\n        }\n      } catch (IllegalArgumentException e) {\n        logger.debug(String.format(\n                \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\", propCol.getName()), e);\n      }\n    }\n  }", "code_tokens": ["protected", "void", "restoreState", "(", ")", "{", "if", "(", "store", "==", "null", ")", "{", "return", ";", "}", "ArrayList", "propColObjs", "=", "(", "ArrayList", ")", "store", ".", "getBean", "(", "\"propertyCol\"", ",", "new", "ArrayList", "(", ")", ")", ";", "HidableTableColumnModel", "tableColumnModel", "=", "(", "HidableTableColumnModel", ")", "jtable", ".", "getColumnModel", "(", ")", ";", "int", "newViewIndex", "=", "0", ";", "for", "(", "Object", "propColObj", ":", "propColObjs", ")", "{", "PropertyCol", "propCol", "=", "(", "PropertyCol", ")", "propColObj", ";", "try", "{", "int", "currentViewIndex", "=", "tableColumnModel", ".", "getColumnIndex", "(", "propCol", ".", "getName", "(", ")", ")", ";", "// May throw IAE.", "TableColumn", "column", "=", "tableColumnModel", ".", "getColumn", "(", "currentViewIndex", ")", ";", "column", ".", "setPreferredWidth", "(", "propCol", ".", "getWidth", "(", ")", ")", ";", "tableColumnModel", ".", "moveColumn", "(", "currentViewIndex", ",", "newViewIndex", ")", ";", "assert", "tableColumnModel", ".", "getColumn", "(", "newViewIndex", ")", "==", "column", ":", "\"tableColumn wasn't successfully moved.\"", ";", "// We must do this last, since moveColumn() only works on visible columns.", "tableColumnModel", ".", "setColumnVisible", "(", "column", ",", "propCol", ".", "isVisible", "(", ")", ")", ";", "if", "(", "propCol", ".", "isVisible", "(", ")", ")", "{", "++", "newViewIndex", ";", "// Don't increment for hidden columns.", "}", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "logger", ".", "debug", "(", "String", ".", "format", "(", "\"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\"", ",", "propCol", ".", "getName", "(", ")", ")", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Restore state from PreferencesExt", "docstring_tokens": ["Restore", "state", "from", "PreferencesExt"]}
{"code": "++newViewIndex;", "comments": "Don't increment for hidden columns.", "lines": 24, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/util/prefs/ui/BeanTable.java", "func_name": "BeanTable.restoreState", "original_string": "protected void restoreState() {\n    if (store == null) {\n      return;\n    }\n\n    ArrayList propColObjs = (ArrayList) store.getBean(\"propertyCol\", new ArrayList());\n    HidableTableColumnModel tableColumnModel = (HidableTableColumnModel) jtable.getColumnModel();\n    int newViewIndex = 0;\n\n    for (Object propColObj : propColObjs) {\n      PropertyCol propCol = (PropertyCol) propColObj;\n      try {\n        int currentViewIndex = tableColumnModel.getColumnIndex(propCol.getName());  // May throw IAE.\n\n        TableColumn column = tableColumnModel.getColumn(currentViewIndex);\n        column.setPreferredWidth(propCol.getWidth());\n\n        tableColumnModel.moveColumn(currentViewIndex, newViewIndex);\n        assert tableColumnModel.getColumn(newViewIndex) == column : \"tableColumn wasn't successfully moved.\";\n\n        // We must do this last, since moveColumn() only works on visible columns.\n        tableColumnModel.setColumnVisible(column, propCol.isVisible());\n        if (propCol.isVisible()) {\n          ++newViewIndex;  // Don't increment for hidden columns.\n        }\n      } catch (IllegalArgumentException e) {\n        logger.debug(String.format(\n                \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\", propCol.getName()), e);\n      }\n    }\n  }", "language": "java", "Allcodes": "protected void restoreState() {\n    if (store == null) {\n      return;\n    }\n\n    ArrayList propColObjs = (ArrayList) store.getBean(\"propertyCol\", new ArrayList());\n    HidableTableColumnModel tableColumnModel = (HidableTableColumnModel) jtable.getColumnModel();\n    int newViewIndex = 0;\n\n    for (Object propColObj : propColObjs) {\n      PropertyCol propCol = (PropertyCol) propColObj;\n      try {\n        int currentViewIndex = tableColumnModel.getColumnIndex(propCol.getName());  // May throw IAE.\n\n        TableColumn column = tableColumnModel.getColumn(currentViewIndex);\n        column.setPreferredWidth(propCol.getWidth());\n\n        tableColumnModel.moveColumn(currentViewIndex, newViewIndex);\n        assert tableColumnModel.getColumn(newViewIndex) == column : \"tableColumn wasn't successfully moved.\";\n\n        // We must do this last, since moveColumn() only works on visible columns.\n        tableColumnModel.setColumnVisible(column, propCol.isVisible());\n        if (propCol.isVisible()) {\n          ++newViewIndex;  // Don't increment for hidden columns.\n        }\n      } catch (IllegalArgumentException e) {\n        logger.debug(String.format(\n                \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\", propCol.getName()), e);\n      }\n    }\n  }", "code_tokens": ["protected", "void", "restoreState", "(", ")", "{", "if", "(", "store", "==", "null", ")", "{", "return", ";", "}", "ArrayList", "propColObjs", "=", "(", "ArrayList", ")", "store", ".", "getBean", "(", "\"propertyCol\"", ",", "new", "ArrayList", "(", ")", ")", ";", "HidableTableColumnModel", "tableColumnModel", "=", "(", "HidableTableColumnModel", ")", "jtable", ".", "getColumnModel", "(", ")", ";", "int", "newViewIndex", "=", "0", ";", "for", "(", "Object", "propColObj", ":", "propColObjs", ")", "{", "PropertyCol", "propCol", "=", "(", "PropertyCol", ")", "propColObj", ";", "try", "{", "int", "currentViewIndex", "=", "tableColumnModel", ".", "getColumnIndex", "(", "propCol", ".", "getName", "(", ")", ")", ";", "// May throw IAE.", "TableColumn", "column", "=", "tableColumnModel", ".", "getColumn", "(", "currentViewIndex", ")", ";", "column", ".", "setPreferredWidth", "(", "propCol", ".", "getWidth", "(", ")", ")", ";", "tableColumnModel", ".", "moveColumn", "(", "currentViewIndex", ",", "newViewIndex", ")", ";", "assert", "tableColumnModel", ".", "getColumn", "(", "newViewIndex", ")", "==", "column", ":", "\"tableColumn wasn't successfully moved.\"", ";", "// We must do this last, since moveColumn() only works on visible columns.", "tableColumnModel", ".", "setColumnVisible", "(", "column", ",", "propCol", ".", "isVisible", "(", ")", ")", ";", "if", "(", "propCol", ".", "isVisible", "(", ")", ")", "{", "++", "newViewIndex", ";", "// Don't increment for hidden columns.", "}", "}", "catch", "(", "IllegalArgumentException", "e", ")", "{", "logger", ".", "debug", "(", "String", ".", "format", "(", "\"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\"", ",", "propCol", ".", "getName", "(", ")", ")", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Restore state from PreferencesExt", "docstring_tokens": ["Restore", "state", "from", "PreferencesExt"]}
{"code": "return new CoordVarConstant(coordName.toString(), \"\", axisName);", "comments": "assume its the actual value", "lines": 32, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/NestedTable.java", "func_name": "NestedTable.findCoordinateAxis", "original_string": "private CoordVarExtractor findCoordinateAxis(Table.CoordName coordName, Table t, int nestingLevel) {\n    if (t == null) return null;\n\n    String axisName = t.findCoordinateVariableName(coordName);\n\n    if (axisName != null) {\n      VariableDS v = t.findVariable(axisName);\n      if (v != null)\n        return new CoordVarExtractorVariable(v, axisName, nestingLevel);\n\n      if (t.extraJoins != null) {\n        for (Join j : t.extraJoins) {\n          v = j.findVariable(axisName);\n          if (v != null)\n            return new CoordVarExtractorVariable(v, axisName, nestingLevel);\n        }\n      }\n\n      // see if its in the StructureData\n      if (t instanceof Table.TableSingleton) {\n        Table.TableSingleton ts = (Table.TableSingleton) t;\n        return new CoordVarStructureData(axisName, ts.sdata);\n      }\n\n      // see if its at the top level\n      if (t instanceof Table.TableTop) {\n        v = (VariableDS) ds.findVariable(axisName);\n\n        if (v != null)\n          return new CoordVarTop(v);\n        else\n          return new CoordVarConstant(coordName.toString(), \"\", axisName); // assume its the actual value\n      }\n\n      errlog.format(\"NestedTable: cant find variable '%s' for coordinate type %s %n\", axisName, coordName);\n    }\n\n    // check the parent\n    return findCoordinateAxis(coordName, t.parent, nestingLevel + 1);\n  }", "language": "java", "Allcodes": "private CoordVarExtractor findCoordinateAxis(Table.CoordName coordName, Table t, int nestingLevel) {\n    if (t == null) return null;\n\n    String axisName = t.findCoordinateVariableName(coordName);\n\n    if (axisName != null) {\n      VariableDS v = t.findVariable(axisName);\n      if (v != null)\n        return new CoordVarExtractorVariable(v, axisName, nestingLevel);\n\n      if (t.extraJoins != null) {\n        for (Join j : t.extraJoins) {\n          v = j.findVariable(axisName);\n          if (v != null)\n            return new CoordVarExtractorVariable(v, axisName, nestingLevel);\n        }\n      }\n\n      // see if its in the StructureData\n      if (t instanceof Table.TableSingleton) {\n        Table.TableSingleton ts = (Table.TableSingleton) t;\n        return new CoordVarStructureData(axisName, ts.sdata);\n      }\n\n      // see if its at the top level\n      if (t instanceof Table.TableTop) {\n        v = (VariableDS) ds.findVariable(axisName);\n\n        if (v != null)\n          return new CoordVarTop(v);\n        else\n          return new CoordVarConstant(coordName.toString(), \"\", axisName); // assume its the actual value\n      }\n\n      errlog.format(\"NestedTable: cant find variable '%s' for coordinate type %s %n\", axisName, coordName);\n    }\n\n    // check the parent\n    return findCoordinateAxis(coordName, t.parent, nestingLevel + 1);\n  }", "code_tokens": ["private", "CoordVarExtractor", "findCoordinateAxis", "(", "Table", ".", "CoordName", "coordName", ",", "Table", "t", ",", "int", "nestingLevel", ")", "{", "if", "(", "t", "==", "null", ")", "return", "null", ";", "String", "axisName", "=", "t", ".", "findCoordinateVariableName", "(", "coordName", ")", ";", "if", "(", "axisName", "!=", "null", ")", "{", "VariableDS", "v", "=", "t", ".", "findVariable", "(", "axisName", ")", ";", "if", "(", "v", "!=", "null", ")", "return", "new", "CoordVarExtractorVariable", "(", "v", ",", "axisName", ",", "nestingLevel", ")", ";", "if", "(", "t", ".", "extraJoins", "!=", "null", ")", "{", "for", "(", "Join", "j", ":", "t", ".", "extraJoins", ")", "{", "v", "=", "j", ".", "findVariable", "(", "axisName", ")", ";", "if", "(", "v", "!=", "null", ")", "return", "new", "CoordVarExtractorVariable", "(", "v", ",", "axisName", ",", "nestingLevel", ")", ";", "}", "}", "// see if its in the StructureData", "if", "(", "t", "instanceof", "Table", ".", "TableSingleton", ")", "{", "Table", ".", "TableSingleton", "ts", "=", "(", "Table", ".", "TableSingleton", ")", "t", ";", "return", "new", "CoordVarStructureData", "(", "axisName", ",", "ts", ".", "sdata", ")", ";", "}", "// see if its at the top level", "if", "(", "t", "instanceof", "Table", ".", "TableTop", ")", "{", "v", "=", "(", "VariableDS", ")", "ds", ".", "findVariable", "(", "axisName", ")", ";", "if", "(", "v", "!=", "null", ")", "return", "new", "CoordVarTop", "(", "v", ")", ";", "else", "return", "new", "CoordVarConstant", "(", "coordName", ".", "toString", "(", ")", ",", "\"\"", ",", "axisName", ")", ";", "// assume its the actual value", "}", "errlog", ".", "format", "(", "\"NestedTable: cant find variable '%s' for coordinate type %s %n\"", ",", "axisName", ",", "coordName", ")", ";", "}", "// check the parent", "return", "findCoordinateAxis", "(", "coordName", ",", "t", ".", "parent", ",", "nestingLevel", "+", "1", ")", ";", "}"], "docstring": "find a coord axis of the given type in the table and its parents", "docstring_tokens": ["find", "a", "coord", "axis", "of", "the", "given", "type", "in", "the", "table", "and", "its", "parents"]}
{"code": "if (t.nondataVars.contains(col.getShortName())) continue;", "comments": "fishy", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/NestedTable.java", "func_name": "NestedTable.addDataVariables", "original_string": "private void addDataVariables(List<VariableSimpleIF> list, Table t) {\n    if (t.parent != null) addDataVariables(list, t.parent);\n    for (VariableSimpleIF col : t.cols.values()) {\n      if (t.nondataVars.contains(col.getFullName())) continue;\n      if (t.nondataVars.contains(col.getShortName())) continue;  // fishy\n      list.add(col);\n    }\n  }", "language": "java", "Allcodes": "private void addDataVariables(List<VariableSimpleIF> list, Table t) {\n    if (t.parent != null) addDataVariables(list, t.parent);\n    for (VariableSimpleIF col : t.cols.values()) {\n      if (t.nondataVars.contains(col.getFullName())) continue;\n      if (t.nondataVars.contains(col.getShortName())) continue;  // fishy\n      list.add(col);\n    }\n  }", "code_tokens": ["private", "void", "addDataVariables", "(", "List", "<", "VariableSimpleIF", ">", "list", ",", "Table", "t", ")", "{", "if", "(", "t", ".", "parent", "!=", "null", ")", "addDataVariables", "(", "list", ",", "t", ".", "parent", ")", ";", "for", "(", "VariableSimpleIF", "col", ":", "t", ".", "cols", ".", "values", "(", ")", ")", "{", "if", "(", "t", ".", "nondataVars", ".", "contains", "(", "col", ".", "getFullName", "(", ")", ")", ")", "continue", ";", "if", "(", "t", ".", "nondataVars", ".", "contains", "(", "col", ".", "getShortName", "(", ")", ")", ")", "continue", ";", "// fishy", "list", ".", "add", "(", "col", ")", ";", "}", "}"], "docstring": "use recursion so that parent variables come first", "docstring_tokens": ["use", "recursion", "so", "that", "parent", "variables", "come", "first"]}
{"code": "cursor.tableData[level] = StructureDataFactory.make(sdata.toArray(new StructureData[sdata.size()]));", "comments": "LOOK should try to consolidate", "lines": 10, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/standard/NestedTable.java", "func_name": "NestedTable.addParentJoin", "original_string": "void addParentJoin(Cursor cursor) throws IOException {\n    int level = cursor.currentIndex;\n    Table t = getTable(level);\n    if (t.extraJoins != null) {\n      List<StructureData> sdata = new ArrayList<>(3);\n      sdata.add(cursor.tableData[level]);\n      for (Join j : t.extraJoins) {\n        sdata.add(j.getJoinData(cursor));\n      }\n      cursor.tableData[level] = StructureDataFactory.make(sdata.toArray(new StructureData[sdata.size()]));  // LOOK should try to consolidate\n    }\n  }", "language": "java", "Allcodes": "void addParentJoin(Cursor cursor) throws IOException {\n    int level = cursor.currentIndex;\n    Table t = getTable(level);\n    if (t.extraJoins != null) {\n      List<StructureData> sdata = new ArrayList<>(3);\n      sdata.add(cursor.tableData[level]);\n      for (Join j : t.extraJoins) {\n        sdata.add(j.getJoinData(cursor));\n      }\n      cursor.tableData[level] = StructureDataFactory.make(sdata.toArray(new StructureData[sdata.size()]));  // LOOK should try to consolidate\n    }\n  }", "code_tokens": ["void", "addParentJoin", "(", "Cursor", "cursor", ")", "throws", "IOException", "{", "int", "level", "=", "cursor", ".", "currentIndex", ";", "Table", "t", "=", "getTable", "(", "level", ")", ";", "if", "(", "t", ".", "extraJoins", "!=", "null", ")", "{", "List", "<", "StructureData", ">", "sdata", "=", "new", "ArrayList", "<>", "(", "3", ")", ";", "sdata", ".", "add", "(", "cursor", ".", "tableData", "[", "level", "]", ")", ";", "for", "(", "Join", "j", ":", "t", ".", "extraJoins", ")", "{", "sdata", ".", "add", "(", "j", ".", "getJoinData", "(", "cursor", ")", ")", ";", "}", "cursor", ".", "tableData", "[", "level", "]", "=", "StructureDataFactory", ".", "make", "(", "sdata", ".", "toArray", "(", "new", "StructureData", "[", "sdata", ".", "size", "(", ")", "]", ")", ")", ";", "// LOOK should try to consolidate", "}", "}"], "docstring": "add table join to this cursor level", "docstring_tokens": ["add", "table", "join", "to", "this", "cursor", "level"]}
{"code": "ma = ma.slice( 0, 0);", "comments": "we need 2D", "lines": 8, "repo": "Unidata/thredds", "path": "clcommon/src/main/java/ucar/nc2/dt/image/image/ImageArrayAdapter.java", "func_name": "ImageArrayAdapter.makeGrayscaleImage", "original_string": "public static java.awt.image.BufferedImage makeGrayscaleImage( Array ma, IsMissingEvaluator missEval) {\n    if (ma.getRank() < 2) return null;\n\n    if (ma.getRank() == 3)\n      ma = ma.reduce();\n\n    if (ma.getRank() == 3)\n      ma = ma.slice( 0, 0); // we need 2D\n\n    int h = ma.getShape()[0];\n    int w = ma.getShape()[1];\n    DataBuffer dataBuffer = makeDataBuffer(ma, missEval);\n\n    WritableRaster raster = WritableRaster.createInterleavedRaster(dataBuffer,\n        w, h, //   int w, int h,\n        w, //   int scanlineStride,\n        1,      //    int pixelStride,\n        new int[]{0}, //   int bandOffsets[],\n        null);     //   Point location)\n\n    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);\n    ComponentColorModel colorModel = new ComponentColorModel(cs,new int[] {8},\n        false,false,Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n\n    return new BufferedImage( colorModel, raster, false, null);\n  }", "language": "java", "Allcodes": "public static java.awt.image.BufferedImage makeGrayscaleImage( Array ma, IsMissingEvaluator missEval) {\n    if (ma.getRank() < 2) return null;\n\n    if (ma.getRank() == 3)\n      ma = ma.reduce();\n\n    if (ma.getRank() == 3)\n      ma = ma.slice( 0, 0); // we need 2D\n\n    int h = ma.getShape()[0];\n    int w = ma.getShape()[1];\n    DataBuffer dataBuffer = makeDataBuffer(ma, missEval);\n\n    WritableRaster raster = WritableRaster.createInterleavedRaster(dataBuffer,\n        w, h, //   int w, int h,\n        w, //   int scanlineStride,\n        1,      //    int pixelStride,\n        new int[]{0}, //   int bandOffsets[],\n        null);     //   Point location)\n\n    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);\n    ComponentColorModel colorModel = new ComponentColorModel(cs,new int[] {8},\n        false,false,Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n\n    return new BufferedImage( colorModel, raster, false, null);\n  }", "code_tokens": ["public", "static", "java", ".", "awt", ".", "image", ".", "BufferedImage", "makeGrayscaleImage", "(", "Array", "ma", ",", "IsMissingEvaluator", "missEval", ")", "{", "if", "(", "ma", ".", "getRank", "(", ")", "<", "2", ")", "return", "null", ";", "if", "(", "ma", ".", "getRank", "(", ")", "==", "3", ")", "ma", "=", "ma", ".", "reduce", "(", ")", ";", "if", "(", "ma", ".", "getRank", "(", ")", "==", "3", ")", "ma", "=", "ma", ".", "slice", "(", "0", ",", "0", ")", ";", "// we need 2D", "int", "h", "=", "ma", ".", "getShape", "(", ")", "[", "0", "]", ";", "int", "w", "=", "ma", ".", "getShape", "(", ")", "[", "1", "]", ";", "DataBuffer", "dataBuffer", "=", "makeDataBuffer", "(", "ma", ",", "missEval", ")", ";", "WritableRaster", "raster", "=", "WritableRaster", ".", "createInterleavedRaster", "(", "dataBuffer", ",", "w", ",", "h", ",", "//   int w, int h,", "w", ",", "//   int scanlineStride,", "1", ",", "//    int pixelStride,", "new", "int", "[", "]", "{", "0", "}", ",", "//   int bandOffsets[],", "null", ")", ";", "//   Point location)", "ColorSpace", "cs", "=", "ColorSpace", ".", "getInstance", "(", "ColorSpace", ".", "CS_GRAY", ")", ";", "ComponentColorModel", "colorModel", "=", "new", "ComponentColorModel", "(", "cs", ",", "new", "int", "[", "]", "{", "8", "}", ",", "false", ",", "false", ",", "Transparency", ".", "OPAQUE", ",", "DataBuffer", ".", "TYPE_BYTE", ")", ";", "return", "new", "BufferedImage", "(", "colorModel", ",", "raster", ",", "false", ",", "null", ")", ";", "}"], "docstring": "Adapt a rank 2 array into a java.awt.image.BufferedImage.\nIf passed a rank 3 array, take first 2D slice.\n@param ma rank 2 or 3 array.\n@return BufferedImage", "docstring_tokens": ["Adapt", "a", "rank", "2", "array", "into", "a", "java", ".", "awt", ".", "image", ".", "BufferedImage", ".", "If", "passed", "a", "rank", "3", "array", "take", "first", "2D", "slice", "."]}
{"code": "null);", "comments": "Point location)", "lines": 19, "repo": "Unidata/thredds", "path": "clcommon/src/main/java/ucar/nc2/dt/image/image/ImageArrayAdapter.java", "func_name": "ImageArrayAdapter.makeGrayscaleImage", "original_string": "public static java.awt.image.BufferedImage makeGrayscaleImage( Array ma, IsMissingEvaluator missEval) {\n    if (ma.getRank() < 2) return null;\n\n    if (ma.getRank() == 3)\n      ma = ma.reduce();\n\n    if (ma.getRank() == 3)\n      ma = ma.slice( 0, 0); // we need 2D\n\n    int h = ma.getShape()[0];\n    int w = ma.getShape()[1];\n    DataBuffer dataBuffer = makeDataBuffer(ma, missEval);\n\n    WritableRaster raster = WritableRaster.createInterleavedRaster(dataBuffer,\n        w, h, //   int w, int h,\n        w, //   int scanlineStride,\n        1,      //    int pixelStride,\n        new int[]{0}, //   int bandOffsets[],\n        null);     //   Point location)\n\n    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);\n    ComponentColorModel colorModel = new ComponentColorModel(cs,new int[] {8},\n        false,false,Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n\n    return new BufferedImage( colorModel, raster, false, null);\n  }", "language": "java", "Allcodes": "public static java.awt.image.BufferedImage makeGrayscaleImage( Array ma, IsMissingEvaluator missEval) {\n    if (ma.getRank() < 2) return null;\n\n    if (ma.getRank() == 3)\n      ma = ma.reduce();\n\n    if (ma.getRank() == 3)\n      ma = ma.slice( 0, 0); // we need 2D\n\n    int h = ma.getShape()[0];\n    int w = ma.getShape()[1];\n    DataBuffer dataBuffer = makeDataBuffer(ma, missEval);\n\n    WritableRaster raster = WritableRaster.createInterleavedRaster(dataBuffer,\n        w, h, //   int w, int h,\n        w, //   int scanlineStride,\n        1,      //    int pixelStride,\n        new int[]{0}, //   int bandOffsets[],\n        null);     //   Point location)\n\n    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);\n    ComponentColorModel colorModel = new ComponentColorModel(cs,new int[] {8},\n        false,false,Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n\n    return new BufferedImage( colorModel, raster, false, null);\n  }", "code_tokens": ["public", "static", "java", ".", "awt", ".", "image", ".", "BufferedImage", "makeGrayscaleImage", "(", "Array", "ma", ",", "IsMissingEvaluator", "missEval", ")", "{", "if", "(", "ma", ".", "getRank", "(", ")", "<", "2", ")", "return", "null", ";", "if", "(", "ma", ".", "getRank", "(", ")", "==", "3", ")", "ma", "=", "ma", ".", "reduce", "(", ")", ";", "if", "(", "ma", ".", "getRank", "(", ")", "==", "3", ")", "ma", "=", "ma", ".", "slice", "(", "0", ",", "0", ")", ";", "// we need 2D", "int", "h", "=", "ma", ".", "getShape", "(", ")", "[", "0", "]", ";", "int", "w", "=", "ma", ".", "getShape", "(", ")", "[", "1", "]", ";", "DataBuffer", "dataBuffer", "=", "makeDataBuffer", "(", "ma", ",", "missEval", ")", ";", "WritableRaster", "raster", "=", "WritableRaster", ".", "createInterleavedRaster", "(", "dataBuffer", ",", "w", ",", "h", ",", "//   int w, int h,", "w", ",", "//   int scanlineStride,", "1", ",", "//    int pixelStride,", "new", "int", "[", "]", "{", "0", "}", ",", "//   int bandOffsets[],", "null", ")", ";", "//   Point location)", "ColorSpace", "cs", "=", "ColorSpace", ".", "getInstance", "(", "ColorSpace", ".", "CS_GRAY", ")", ";", "ComponentColorModel", "colorModel", "=", "new", "ComponentColorModel", "(", "cs", ",", "new", "int", "[", "]", "{", "8", "}", ",", "false", ",", "false", ",", "Transparency", ".", "OPAQUE", ",", "DataBuffer", ".", "TYPE_BYTE", ")", ";", "return", "new", "BufferedImage", "(", "colorModel", ",", "raster", ",", "false", ",", "null", ")", ";", "}"], "docstring": "Adapt a rank 2 array into a java.awt.image.BufferedImage.\nIf passed a rank 3 array, take first 2D slice.\n@param ma rank 2 or 3 array.\n@return BufferedImage", "docstring_tokens": ["Adapt", "a", "rank", "2", "array", "into", "a", "java", ".", "awt", ".", "image", ".", "BufferedImage", ".", "If", "passed", "a", "rank", "3", "array", "take", "first", "2D", "slice", "."]}
{"code": "listen.getDataset(catref.getProxyDataset(), context);", "comments": "wait till a catref is read, so all metadata is there !", "lines": 30, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/crawl/CatalogCrawler.java", "func_name": "CatalogCrawler.crawlDataset", "original_string": "public void crawlDataset(InvDataset ds, CancelTask task, PrintWriter out, Object context, boolean release) {\n    boolean isCatRef = (ds instanceof InvCatalogRef);\n    if (filter != null && filter.skipAll(ds)) {\n      if (isCatRef && release) ((InvCatalogRef) ds).release();\n      return;\n    }\n\n    boolean isDataScan = ds.findProperty(\"DatasetScan\") != null;\n\n    if (isCatRef) {\n      InvCatalogRef catref = (InvCatalogRef) ds;\n      if (out != null)\n        out.println(\" **CATREF \" + catref.getURI() + \" (\" + ds.getName() + \") \");\n      countCatrefs++;\n\n      if (!listen.getCatalogRef( catref, context)) {\n        if (release) catref.release();\n        return;\n      }\n    }\n\n    if (!isCatRef || isDataScan)\n      listen.getDataset(ds, context);\n\n    // recurse - depth first\n      List<InvDataset> dlist = ds.getDatasets();\n      if (isCatRef) {\n        InvCatalogRef catref = (InvCatalogRef) ds;\n        if (!isDataScan) {\n          listen.getDataset(catref.getProxyDataset(), context); // wait till a catref is read, so all metadata is there !\n        }\n      }\n\n      for (InvDataset dds : dlist) {\n        crawlDataset(dds, task, out, context, release);\n        if ((task != null) && task.isCancel())\n          break;\n      }\n\n    if (isCatRef && release) {\n      InvCatalogRef catref = (InvCatalogRef) ds;\n      catref.release();\n    }\n\n  }", "language": "java", "Allcodes": "public void crawlDataset(InvDataset ds, CancelTask task, PrintWriter out, Object context, boolean release) {\n    boolean isCatRef = (ds instanceof InvCatalogRef);\n    if (filter != null && filter.skipAll(ds)) {\n      if (isCatRef && release) ((InvCatalogRef) ds).release();\n      return;\n    }\n\n    boolean isDataScan = ds.findProperty(\"DatasetScan\") != null;\n\n    if (isCatRef) {\n      InvCatalogRef catref = (InvCatalogRef) ds;\n      if (out != null)\n        out.println(\" **CATREF \" + catref.getURI() + \" (\" + ds.getName() + \") \");\n      countCatrefs++;\n\n      if (!listen.getCatalogRef( catref, context)) {\n        if (release) catref.release();\n        return;\n      }\n    }\n\n    if (!isCatRef || isDataScan)\n      listen.getDataset(ds, context);\n\n    // recurse - depth first\n      List<InvDataset> dlist = ds.getDatasets();\n      if (isCatRef) {\n        InvCatalogRef catref = (InvCatalogRef) ds;\n        if (!isDataScan) {\n          listen.getDataset(catref.getProxyDataset(), context); // wait till a catref is read, so all metadata is there !\n        }\n      }\n\n      for (InvDataset dds : dlist) {\n        crawlDataset(dds, task, out, context, release);\n        if ((task != null) && task.isCancel())\n          break;\n      }\n\n    if (isCatRef && release) {\n      InvCatalogRef catref = (InvCatalogRef) ds;\n      catref.release();\n    }\n\n  }", "code_tokens": ["public", "void", "crawlDataset", "(", "InvDataset", "ds", ",", "CancelTask", "task", ",", "PrintWriter", "out", ",", "Object", "context", ",", "boolean", "release", ")", "{", "boolean", "isCatRef", "=", "(", "ds", "instanceof", "InvCatalogRef", ")", ";", "if", "(", "filter", "!=", "null", "&&", "filter", ".", "skipAll", "(", "ds", ")", ")", "{", "if", "(", "isCatRef", "&&", "release", ")", "(", "(", "InvCatalogRef", ")", "ds", ")", ".", "release", "(", ")", ";", "return", ";", "}", "boolean", "isDataScan", "=", "ds", ".", "findProperty", "(", "\"DatasetScan\"", ")", "!=", "null", ";", "if", "(", "isCatRef", ")", "{", "InvCatalogRef", "catref", "=", "(", "InvCatalogRef", ")", "ds", ";", "if", "(", "out", "!=", "null", ")", "out", ".", "println", "(", "\" **CATREF \"", "+", "catref", ".", "getURI", "(", ")", "+", "\" (\"", "+", "ds", ".", "getName", "(", ")", "+", "\") \"", ")", ";", "countCatrefs", "++", ";", "if", "(", "!", "listen", ".", "getCatalogRef", "(", "catref", ",", "context", ")", ")", "{", "if", "(", "release", ")", "catref", ".", "release", "(", ")", ";", "return", ";", "}", "}", "if", "(", "!", "isCatRef", "||", "isDataScan", ")", "listen", ".", "getDataset", "(", "ds", ",", "context", ")", ";", "// recurse - depth first", "List", "<", "InvDataset", ">", "dlist", "=", "ds", ".", "getDatasets", "(", ")", ";", "if", "(", "isCatRef", ")", "{", "InvCatalogRef", "catref", "=", "(", "InvCatalogRef", ")", "ds", ";", "if", "(", "!", "isDataScan", ")", "{", "listen", ".", "getDataset", "(", "catref", ".", "getProxyDataset", "(", ")", ",", "context", ")", ";", "// wait till a catref is read, so all metadata is there !", "}", "}", "for", "(", "InvDataset", "dds", ":", "dlist", ")", "{", "crawlDataset", "(", "dds", ",", "task", ",", "out", ",", "context", ",", "release", ")", ";", "if", "(", "(", "task", "!=", "null", ")", "&&", "task", ".", "isCancel", "(", ")", ")", "break", ";", "}", "if", "(", "isCatRef", "&&", "release", ")", "{", "InvCatalogRef", "catref", "=", "(", "InvCatalogRef", ")", "ds", ";", "catref", ".", "release", "(", ")", ";", "}", "}"], "docstring": "Crawl this dataset recursively, return all datasets\n\n@param ds   the dataset\n@param task user can cancel the task (may be null)\n@param out  send status messages to here (may be null)\n@param context caller can pass this object in (used for thread safety)", "docstring_tokens": ["Crawl", "this", "dataset", "recursively", "return", "all", "datasets"]}
{"code": "cacheState = 0;", "comments": "release failed, bail out", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java", "func_name": "RandomAccessFile.close", "original_string": "public synchronized void close() throws IOException {\r\n    if (cache != null) {\r\n      if (cacheState > 0) {\r\n        if (cacheState == 1) {\r\n          cacheState = 2;\r\n          if (cache.release(this))  // return true if in the cache, otherwise was opened regular, so must be closed regular\r\n            return;\r\n          cacheState = 0; // release failed, bail out\r\n        } else {\r\n          return; // close has been called more than once - ok\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debugLeaks) {\r\n      openFiles.remove(location);\r\n      if (showOpen) System.out.println(\"  close \" + location);\r\n    }\r\n\r\n    if (file == null)\r\n      return;\r\n\r\n    // If we are writing and the buffer has been modified, flush the contents of the buffer.\r\n    flush();\r\n\r\n    // may need to extend file, in case no fill is being used\r\n    // may need to truncate file in case overwriting a longer file\r\n    // use only if minLength is set (by N3iosp)\r\n    long fileSize = file.length();\r\n    if (!readonly && (minLength != 0) && (minLength != fileSize)) {\r\n      file.setLength(minLength);\r\n      // System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r\n    }\r\n\r\n    // Close the underlying file object.\r\n    file.close();\r\n    file = null;  // help the gc\r\n  }", "language": "java", "Allcodes": "public synchronized void close() throws IOException {\r\n    if (cache != null) {\r\n      if (cacheState > 0) {\r\n        if (cacheState == 1) {\r\n          cacheState = 2;\r\n          if (cache.release(this))  // return true if in the cache, otherwise was opened regular, so must be closed regular\r\n            return;\r\n          cacheState = 0; // release failed, bail out\r\n        } else {\r\n          return; // close has been called more than once - ok\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debugLeaks) {\r\n      openFiles.remove(location);\r\n      if (showOpen) System.out.println(\"  close \" + location);\r\n    }\r\n\r\n    if (file == null)\r\n      return;\r\n\r\n    // If we are writing and the buffer has been modified, flush the contents of the buffer.\r\n    flush();\r\n\r\n    // may need to extend file, in case no fill is being used\r\n    // may need to truncate file in case overwriting a longer file\r\n    // use only if minLength is set (by N3iosp)\r\n    long fileSize = file.length();\r\n    if (!readonly && (minLength != 0) && (minLength != fileSize)) {\r\n      file.setLength(minLength);\r\n      // System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r\n    }\r\n\r\n    // Close the underlying file object.\r\n    file.close();\r\n    file = null;  // help the gc\r\n  }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "cache", "!=", "null", ")", "{", "if", "(", "cacheState", ">", "0", ")", "{", "if", "(", "cacheState", "==", "1", ")", "{", "cacheState", "=", "2", ";", "if", "(", "cache", ".", "release", "(", "this", ")", ")", "// return true if in the cache, otherwise was opened regular, so must be closed regular\r", "return", ";", "cacheState", "=", "0", ";", "// release failed, bail out\r", "}", "else", "{", "return", ";", "// close has been called more than once - ok\r", "}", "}", "}", "if", "(", "debugLeaks", ")", "{", "openFiles", ".", "remove", "(", "location", ")", ";", "if", "(", "showOpen", ")", "System", ".", "out", ".", "println", "(", "\"  close \"", "+", "location", ")", ";", "}", "if", "(", "file", "==", "null", ")", "return", ";", "// If we are writing and the buffer has been modified, flush the contents of the buffer.\r", "flush", "(", ")", ";", "// may need to extend file, in case no fill is being used\r", "// may need to truncate file in case overwriting a longer file\r", "// use only if minLength is set (by N3iosp)\r", "long", "fileSize", "=", "file", ".", "length", "(", ")", ";", "if", "(", "!", "readonly", "&&", "(", "minLength", "!=", "0", ")", "&&", "(", "minLength", "!=", "fileSize", ")", ")", "{", "file", ".", "setLength", "(", "minLength", ")", ";", "// System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r", "}", "// Close the underlying file object.\r", "file", ".", "close", "(", ")", ";", "file", "=", "null", ";", "// help the gc\r", "}"], "docstring": "Close the file, and release any associated system resources.\n\n@throws IOException if an I/O error occurrs.", "docstring_tokens": ["Close", "the", "file", "and", "release", "any", "associated", "system", "resources", "."]}
{"code": "return;", "comments": "close has been called more than once - ok", "lines": 10, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java", "func_name": "RandomAccessFile.close", "original_string": "public synchronized void close() throws IOException {\r\n    if (cache != null) {\r\n      if (cacheState > 0) {\r\n        if (cacheState == 1) {\r\n          cacheState = 2;\r\n          if (cache.release(this))  // return true if in the cache, otherwise was opened regular, so must be closed regular\r\n            return;\r\n          cacheState = 0; // release failed, bail out\r\n        } else {\r\n          return; // close has been called more than once - ok\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debugLeaks) {\r\n      openFiles.remove(location);\r\n      if (showOpen) System.out.println(\"  close \" + location);\r\n    }\r\n\r\n    if (file == null)\r\n      return;\r\n\r\n    // If we are writing and the buffer has been modified, flush the contents of the buffer.\r\n    flush();\r\n\r\n    // may need to extend file, in case no fill is being used\r\n    // may need to truncate file in case overwriting a longer file\r\n    // use only if minLength is set (by N3iosp)\r\n    long fileSize = file.length();\r\n    if (!readonly && (minLength != 0) && (minLength != fileSize)) {\r\n      file.setLength(minLength);\r\n      // System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r\n    }\r\n\r\n    // Close the underlying file object.\r\n    file.close();\r\n    file = null;  // help the gc\r\n  }", "language": "java", "Allcodes": "public synchronized void close() throws IOException {\r\n    if (cache != null) {\r\n      if (cacheState > 0) {\r\n        if (cacheState == 1) {\r\n          cacheState = 2;\r\n          if (cache.release(this))  // return true if in the cache, otherwise was opened regular, so must be closed regular\r\n            return;\r\n          cacheState = 0; // release failed, bail out\r\n        } else {\r\n          return; // close has been called more than once - ok\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debugLeaks) {\r\n      openFiles.remove(location);\r\n      if (showOpen) System.out.println(\"  close \" + location);\r\n    }\r\n\r\n    if (file == null)\r\n      return;\r\n\r\n    // If we are writing and the buffer has been modified, flush the contents of the buffer.\r\n    flush();\r\n\r\n    // may need to extend file, in case no fill is being used\r\n    // may need to truncate file in case overwriting a longer file\r\n    // use only if minLength is set (by N3iosp)\r\n    long fileSize = file.length();\r\n    if (!readonly && (minLength != 0) && (minLength != fileSize)) {\r\n      file.setLength(minLength);\r\n      // System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r\n    }\r\n\r\n    // Close the underlying file object.\r\n    file.close();\r\n    file = null;  // help the gc\r\n  }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "cache", "!=", "null", ")", "{", "if", "(", "cacheState", ">", "0", ")", "{", "if", "(", "cacheState", "==", "1", ")", "{", "cacheState", "=", "2", ";", "if", "(", "cache", ".", "release", "(", "this", ")", ")", "// return true if in the cache, otherwise was opened regular, so must be closed regular\r", "return", ";", "cacheState", "=", "0", ";", "// release failed, bail out\r", "}", "else", "{", "return", ";", "// close has been called more than once - ok\r", "}", "}", "}", "if", "(", "debugLeaks", ")", "{", "openFiles", ".", "remove", "(", "location", ")", ";", "if", "(", "showOpen", ")", "System", ".", "out", ".", "println", "(", "\"  close \"", "+", "location", ")", ";", "}", "if", "(", "file", "==", "null", ")", "return", ";", "// If we are writing and the buffer has been modified, flush the contents of the buffer.\r", "flush", "(", ")", ";", "// may need to extend file, in case no fill is being used\r", "// may need to truncate file in case overwriting a longer file\r", "// use only if minLength is set (by N3iosp)\r", "long", "fileSize", "=", "file", ".", "length", "(", ")", ";", "if", "(", "!", "readonly", "&&", "(", "minLength", "!=", "0", ")", "&&", "(", "minLength", "!=", "fileSize", ")", ")", "{", "file", ".", "setLength", "(", "minLength", ")", ";", "// System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r", "}", "// Close the underlying file object.\r", "file", ".", "close", "(", ")", ";", "file", "=", "null", ";", "// help the gc\r", "}"], "docstring": "Close the file, and release any associated system resources.\n\n@throws IOException if an I/O error occurrs.", "docstring_tokens": ["Close", "the", "file", "and", "release", "any", "associated", "system", "resources", "."]}
{"code": "file = null;", "comments": "help the gc", "lines": 37, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java", "func_name": "RandomAccessFile.close", "original_string": "public synchronized void close() throws IOException {\r\n    if (cache != null) {\r\n      if (cacheState > 0) {\r\n        if (cacheState == 1) {\r\n          cacheState = 2;\r\n          if (cache.release(this))  // return true if in the cache, otherwise was opened regular, so must be closed regular\r\n            return;\r\n          cacheState = 0; // release failed, bail out\r\n        } else {\r\n          return; // close has been called more than once - ok\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debugLeaks) {\r\n      openFiles.remove(location);\r\n      if (showOpen) System.out.println(\"  close \" + location);\r\n    }\r\n\r\n    if (file == null)\r\n      return;\r\n\r\n    // If we are writing and the buffer has been modified, flush the contents of the buffer.\r\n    flush();\r\n\r\n    // may need to extend file, in case no fill is being used\r\n    // may need to truncate file in case overwriting a longer file\r\n    // use only if minLength is set (by N3iosp)\r\n    long fileSize = file.length();\r\n    if (!readonly && (minLength != 0) && (minLength != fileSize)) {\r\n      file.setLength(minLength);\r\n      // System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r\n    }\r\n\r\n    // Close the underlying file object.\r\n    file.close();\r\n    file = null;  // help the gc\r\n  }", "language": "java", "Allcodes": "public synchronized void close() throws IOException {\r\n    if (cache != null) {\r\n      if (cacheState > 0) {\r\n        if (cacheState == 1) {\r\n          cacheState = 2;\r\n          if (cache.release(this))  // return true if in the cache, otherwise was opened regular, so must be closed regular\r\n            return;\r\n          cacheState = 0; // release failed, bail out\r\n        } else {\r\n          return; // close has been called more than once - ok\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debugLeaks) {\r\n      openFiles.remove(location);\r\n      if (showOpen) System.out.println(\"  close \" + location);\r\n    }\r\n\r\n    if (file == null)\r\n      return;\r\n\r\n    // If we are writing and the buffer has been modified, flush the contents of the buffer.\r\n    flush();\r\n\r\n    // may need to extend file, in case no fill is being used\r\n    // may need to truncate file in case overwriting a longer file\r\n    // use only if minLength is set (by N3iosp)\r\n    long fileSize = file.length();\r\n    if (!readonly && (minLength != 0) && (minLength != fileSize)) {\r\n      file.setLength(minLength);\r\n      // System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r\n    }\r\n\r\n    // Close the underlying file object.\r\n    file.close();\r\n    file = null;  // help the gc\r\n  }", "code_tokens": ["public", "synchronized", "void", "close", "(", ")", "throws", "IOException", "{", "if", "(", "cache", "!=", "null", ")", "{", "if", "(", "cacheState", ">", "0", ")", "{", "if", "(", "cacheState", "==", "1", ")", "{", "cacheState", "=", "2", ";", "if", "(", "cache", ".", "release", "(", "this", ")", ")", "// return true if in the cache, otherwise was opened regular, so must be closed regular\r", "return", ";", "cacheState", "=", "0", ";", "// release failed, bail out\r", "}", "else", "{", "return", ";", "// close has been called more than once - ok\r", "}", "}", "}", "if", "(", "debugLeaks", ")", "{", "openFiles", ".", "remove", "(", "location", ")", ";", "if", "(", "showOpen", ")", "System", ".", "out", ".", "println", "(", "\"  close \"", "+", "location", ")", ";", "}", "if", "(", "file", "==", "null", ")", "return", ";", "// If we are writing and the buffer has been modified, flush the contents of the buffer.\r", "flush", "(", ")", ";", "// may need to extend file, in case no fill is being used\r", "// may need to truncate file in case overwriting a longer file\r", "// use only if minLength is set (by N3iosp)\r", "long", "fileSize", "=", "file", ".", "length", "(", ")", ";", "if", "(", "!", "readonly", "&&", "(", "minLength", "!=", "0", ")", "&&", "(", "minLength", "!=", "fileSize", ")", ")", "{", "file", ".", "setLength", "(", "minLength", ")", ";", "// System.out.println(\"TRUNCATE!!! minlength=\"+minLength);\r", "}", "// Close the underlying file object.\r", "file", ".", "close", "(", ")", ";", "file", "=", "null", ";", "// help the gc\r", "}"], "docstring": "Close the file, and release any associated system resources.\n\n@throws IOException if an I/O error occurrs.", "docstring_tokens": ["Close", "the", "file", "and", "release", "any", "associated", "system", "resources", "."]}
{"code": "seek(filePosition);", "comments": "read a new buffer", "lines": 9, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java", "func_name": "RandomAccessFile.searchForward", "original_string": "public boolean searchForward(KMPMatch match, int maxBytes) throws IOException {\r\n    long start = getFilePointer();\r\n    long last = (maxBytes < 0) ? length() : Math.min(length(), start + maxBytes);\r\n    long needToScan = last - start;\r\n\r\n    // check what ever is now in the buffer\r\n    int bytesAvailable = (int) (dataEnd - filePosition);\r\n    if (bytesAvailable < 1) {\r\n      seek(filePosition); // read a new buffer\r\n      bytesAvailable = (int) (dataEnd - filePosition);\r\n    }\r\n    int bufStart = (int) (filePosition - bufferStart);\r\n    int scanBytes = (int) Math.min(bytesAvailable, needToScan);\r\n    int pos = match.indexOf(buffer, bufStart, scanBytes);\r\n    if (pos >= 0) {\r\n      seek(bufferStart + pos);\r\n      return true;\r\n    }\r\n\r\n    int matchLen = match.getMatchLength();\r\n    needToScan -= scanBytes - matchLen;\r\n\r\n    while (needToScan > matchLen) {\r\n      readBuffer(dataEnd - matchLen); // force new buffer\r\n\r\n      scanBytes = (int) Math.min(buffer.length, needToScan);\r\n      pos = match.indexOf(buffer, 0, scanBytes);\r\n      if (pos > 0) {\r\n        seek(bufferStart + pos);\r\n        return true;\r\n      }\r\n\r\n      needToScan -= scanBytes - matchLen;\r\n    }\r\n\r\n    // failure\r\n    seek(last);\r\n    return false;\r\n  }", "language": "java", "Allcodes": "public boolean searchForward(KMPMatch match, int maxBytes) throws IOException {\r\n    long start = getFilePointer();\r\n    long last = (maxBytes < 0) ? length() : Math.min(length(), start + maxBytes);\r\n    long needToScan = last - start;\r\n\r\n    // check what ever is now in the buffer\r\n    int bytesAvailable = (int) (dataEnd - filePosition);\r\n    if (bytesAvailable < 1) {\r\n      seek(filePosition); // read a new buffer\r\n      bytesAvailable = (int) (dataEnd - filePosition);\r\n    }\r\n    int bufStart = (int) (filePosition - bufferStart);\r\n    int scanBytes = (int) Math.min(bytesAvailable, needToScan);\r\n    int pos = match.indexOf(buffer, bufStart, scanBytes);\r\n    if (pos >= 0) {\r\n      seek(bufferStart + pos);\r\n      return true;\r\n    }\r\n\r\n    int matchLen = match.getMatchLength();\r\n    needToScan -= scanBytes - matchLen;\r\n\r\n    while (needToScan > matchLen) {\r\n      readBuffer(dataEnd - matchLen); // force new buffer\r\n\r\n      scanBytes = (int) Math.min(buffer.length, needToScan);\r\n      pos = match.indexOf(buffer, 0, scanBytes);\r\n      if (pos > 0) {\r\n        seek(bufferStart + pos);\r\n        return true;\r\n      }\r\n\r\n      needToScan -= scanBytes - matchLen;\r\n    }\r\n\r\n    // failure\r\n    seek(last);\r\n    return false;\r\n  }", "code_tokens": ["public", "boolean", "searchForward", "(", "KMPMatch", "match", ",", "int", "maxBytes", ")", "throws", "IOException", "{", "long", "start", "=", "getFilePointer", "(", ")", ";", "long", "last", "=", "(", "maxBytes", "<", "0", ")", "?", "length", "(", ")", ":", "Math", ".", "min", "(", "length", "(", ")", ",", "start", "+", "maxBytes", ")", ";", "long", "needToScan", "=", "last", "-", "start", ";", "// check what ever is now in the buffer\r", "int", "bytesAvailable", "=", "(", "int", ")", "(", "dataEnd", "-", "filePosition", ")", ";", "if", "(", "bytesAvailable", "<", "1", ")", "{", "seek", "(", "filePosition", ")", ";", "// read a new buffer\r", "bytesAvailable", "=", "(", "int", ")", "(", "dataEnd", "-", "filePosition", ")", ";", "}", "int", "bufStart", "=", "(", "int", ")", "(", "filePosition", "-", "bufferStart", ")", ";", "int", "scanBytes", "=", "(", "int", ")", "Math", ".", "min", "(", "bytesAvailable", ",", "needToScan", ")", ";", "int", "pos", "=", "match", ".", "indexOf", "(", "buffer", ",", "bufStart", ",", "scanBytes", ")", ";", "if", "(", "pos", ">=", "0", ")", "{", "seek", "(", "bufferStart", "+", "pos", ")", ";", "return", "true", ";", "}", "int", "matchLen", "=", "match", ".", "getMatchLength", "(", ")", ";", "needToScan", "-=", "scanBytes", "-", "matchLen", ";", "while", "(", "needToScan", ">", "matchLen", ")", "{", "readBuffer", "(", "dataEnd", "-", "matchLen", ")", ";", "// force new buffer\r", "scanBytes", "=", "(", "int", ")", "Math", ".", "min", "(", "buffer", ".", "length", ",", "needToScan", ")", ";", "pos", "=", "match", ".", "indexOf", "(", "buffer", ",", "0", ",", "scanBytes", ")", ";", "if", "(", "pos", ">", "0", ")", "{", "seek", "(", "bufferStart", "+", "pos", ")", ";", "return", "true", ";", "}", "needToScan", "-=", "scanBytes", "-", "matchLen", ";", "}", "// failure\r", "seek", "(", "last", ")", ";", "return", "false", ";", "}"], "docstring": "Search forward from the current pos, looking for a match.\n\n@param match    the match to look for.\n@param maxBytes maximum number of bytes to search. use -1 for all\n@return true if found, file position will be at the start of the match.\n@throws IOException on read error", "docstring_tokens": ["Search", "forward", "from", "the", "current", "pos", "looking", "for", "a", "match", "."]}
{"code": "readBuffer(dataEnd - matchLen);", "comments": "force new buffer", "lines": 24, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java", "func_name": "RandomAccessFile.searchForward", "original_string": "public boolean searchForward(KMPMatch match, int maxBytes) throws IOException {\r\n    long start = getFilePointer();\r\n    long last = (maxBytes < 0) ? length() : Math.min(length(), start + maxBytes);\r\n    long needToScan = last - start;\r\n\r\n    // check what ever is now in the buffer\r\n    int bytesAvailable = (int) (dataEnd - filePosition);\r\n    if (bytesAvailable < 1) {\r\n      seek(filePosition); // read a new buffer\r\n      bytesAvailable = (int) (dataEnd - filePosition);\r\n    }\r\n    int bufStart = (int) (filePosition - bufferStart);\r\n    int scanBytes = (int) Math.min(bytesAvailable, needToScan);\r\n    int pos = match.indexOf(buffer, bufStart, scanBytes);\r\n    if (pos >= 0) {\r\n      seek(bufferStart + pos);\r\n      return true;\r\n    }\r\n\r\n    int matchLen = match.getMatchLength();\r\n    needToScan -= scanBytes - matchLen;\r\n\r\n    while (needToScan > matchLen) {\r\n      readBuffer(dataEnd - matchLen); // force new buffer\r\n\r\n      scanBytes = (int) Math.min(buffer.length, needToScan);\r\n      pos = match.indexOf(buffer, 0, scanBytes);\r\n      if (pos > 0) {\r\n        seek(bufferStart + pos);\r\n        return true;\r\n      }\r\n\r\n      needToScan -= scanBytes - matchLen;\r\n    }\r\n\r\n    // failure\r\n    seek(last);\r\n    return false;\r\n  }", "language": "java", "Allcodes": "public boolean searchForward(KMPMatch match, int maxBytes) throws IOException {\r\n    long start = getFilePointer();\r\n    long last = (maxBytes < 0) ? length() : Math.min(length(), start + maxBytes);\r\n    long needToScan = last - start;\r\n\r\n    // check what ever is now in the buffer\r\n    int bytesAvailable = (int) (dataEnd - filePosition);\r\n    if (bytesAvailable < 1) {\r\n      seek(filePosition); // read a new buffer\r\n      bytesAvailable = (int) (dataEnd - filePosition);\r\n    }\r\n    int bufStart = (int) (filePosition - bufferStart);\r\n    int scanBytes = (int) Math.min(bytesAvailable, needToScan);\r\n    int pos = match.indexOf(buffer, bufStart, scanBytes);\r\n    if (pos >= 0) {\r\n      seek(bufferStart + pos);\r\n      return true;\r\n    }\r\n\r\n    int matchLen = match.getMatchLength();\r\n    needToScan -= scanBytes - matchLen;\r\n\r\n    while (needToScan > matchLen) {\r\n      readBuffer(dataEnd - matchLen); // force new buffer\r\n\r\n      scanBytes = (int) Math.min(buffer.length, needToScan);\r\n      pos = match.indexOf(buffer, 0, scanBytes);\r\n      if (pos > 0) {\r\n        seek(bufferStart + pos);\r\n        return true;\r\n      }\r\n\r\n      needToScan -= scanBytes - matchLen;\r\n    }\r\n\r\n    // failure\r\n    seek(last);\r\n    return false;\r\n  }", "code_tokens": ["public", "boolean", "searchForward", "(", "KMPMatch", "match", ",", "int", "maxBytes", ")", "throws", "IOException", "{", "long", "start", "=", "getFilePointer", "(", ")", ";", "long", "last", "=", "(", "maxBytes", "<", "0", ")", "?", "length", "(", ")", ":", "Math", ".", "min", "(", "length", "(", ")", ",", "start", "+", "maxBytes", ")", ";", "long", "needToScan", "=", "last", "-", "start", ";", "// check what ever is now in the buffer\r", "int", "bytesAvailable", "=", "(", "int", ")", "(", "dataEnd", "-", "filePosition", ")", ";", "if", "(", "bytesAvailable", "<", "1", ")", "{", "seek", "(", "filePosition", ")", ";", "// read a new buffer\r", "bytesAvailable", "=", "(", "int", ")", "(", "dataEnd", "-", "filePosition", ")", ";", "}", "int", "bufStart", "=", "(", "int", ")", "(", "filePosition", "-", "bufferStart", ")", ";", "int", "scanBytes", "=", "(", "int", ")", "Math", ".", "min", "(", "bytesAvailable", ",", "needToScan", ")", ";", "int", "pos", "=", "match", ".", "indexOf", "(", "buffer", ",", "bufStart", ",", "scanBytes", ")", ";", "if", "(", "pos", ">=", "0", ")", "{", "seek", "(", "bufferStart", "+", "pos", ")", ";", "return", "true", ";", "}", "int", "matchLen", "=", "match", ".", "getMatchLength", "(", ")", ";", "needToScan", "-=", "scanBytes", "-", "matchLen", ";", "while", "(", "needToScan", ">", "matchLen", ")", "{", "readBuffer", "(", "dataEnd", "-", "matchLen", ")", ";", "// force new buffer\r", "scanBytes", "=", "(", "int", ")", "Math", ".", "min", "(", "buffer", ".", "length", ",", "needToScan", ")", ";", "pos", "=", "match", ".", "indexOf", "(", "buffer", ",", "0", ",", "scanBytes", ")", ";", "if", "(", "pos", ">", "0", ")", "{", "seek", "(", "bufferStart", "+", "pos", ")", ";", "return", "true", ";", "}", "needToScan", "-=", "scanBytes", "-", "matchLen", ";", "}", "// failure\r", "seek", "(", "last", ")", ";", "return", "false", ";", "}"], "docstring": "Search forward from the current pos, looking for a match.\n\n@param match    the match to look for.\n@param maxBytes maximum number of bytes to search. use -1 for all\n@return true if found, file position will be at the start of the match.\n@throws IOException on read error", "docstring_tokens": ["Search", "forward", "from", "the", "current", "pos", "looking", "for", "a", "match", "."]}
{"code": "DirectoryCollection result = new DirectoryCollection(config.collectionName, topDir, isTop, config.olderThan, logger);", "comments": "no index file", "lines": 14, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/inventory/partition/DirectoryBuilder.java", "func_name": "DirectoryBuilder.factory", "original_string": "static public MCollection factory(FeatureCollectionConfig config, Path topDir, boolean isTop, IndexReader indexReader, String suffix, org.slf4j.Logger logger) throws IOException {\n    DirectoryBuilder builder = new DirectoryBuilder(config.collectionName, topDir.toString(), suffix);\n\n    DirectoryPartition dpart = new DirectoryPartition(config, topDir, isTop, indexReader, suffix, logger);\n    if (!builder.isLeaf(indexReader))  { // its a partition\n      return dpart;\n    }\n\n    // its a collection\n    boolean hasIndex = builder.findIndex();\n    if (hasIndex) {\n      return dpart.makeChildCollection(builder);\n    } else {\n      DirectoryCollection result = new DirectoryCollection(config.collectionName, topDir, isTop, config.olderThan, logger); // no index file\n      return result;\n    }\n  }", "language": "java", "Allcodes": "static public MCollection factory(FeatureCollectionConfig config, Path topDir, boolean isTop, IndexReader indexReader, String suffix, org.slf4j.Logger logger) throws IOException {\n    DirectoryBuilder builder = new DirectoryBuilder(config.collectionName, topDir.toString(), suffix);\n\n    DirectoryPartition dpart = new DirectoryPartition(config, topDir, isTop, indexReader, suffix, logger);\n    if (!builder.isLeaf(indexReader))  { // its a partition\n      return dpart;\n    }\n\n    // its a collection\n    boolean hasIndex = builder.findIndex();\n    if (hasIndex) {\n      return dpart.makeChildCollection(builder);\n    } else {\n      DirectoryCollection result = new DirectoryCollection(config.collectionName, topDir, isTop, config.olderThan, logger); // no index file\n      return result;\n    }\n  }", "code_tokens": ["static", "public", "MCollection", "factory", "(", "FeatureCollectionConfig", "config", ",", "Path", "topDir", ",", "boolean", "isTop", ",", "IndexReader", "indexReader", ",", "String", "suffix", ",", "org", ".", "slf4j", ".", "Logger", "logger", ")", "throws", "IOException", "{", "DirectoryBuilder", "builder", "=", "new", "DirectoryBuilder", "(", "config", ".", "collectionName", ",", "topDir", ".", "toString", "(", ")", ",", "suffix", ")", ";", "DirectoryPartition", "dpart", "=", "new", "DirectoryPartition", "(", "config", ",", "topDir", ",", "isTop", ",", "indexReader", ",", "suffix", ",", "logger", ")", ";", "if", "(", "!", "builder", ".", "isLeaf", "(", "indexReader", ")", ")", "{", "// its a partition", "return", "dpart", ";", "}", "// its a collection", "boolean", "hasIndex", "=", "builder", ".", "findIndex", "(", ")", ";", "if", "(", "hasIndex", ")", "{", "return", "dpart", ".", "makeChildCollection", "(", "builder", ")", ";", "}", "else", "{", "DirectoryCollection", "result", "=", "new", "DirectoryCollection", "(", "config", ".", "collectionName", ",", "topDir", ",", "isTop", ",", "config", ".", "olderThan", ",", "logger", ")", ";", "// no index file", "return", "result", ";", "}", "}"], "docstring": "returns a DirectoryPartition or DirectoryCollection", "docstring_tokens": ["returns", "a", "DirectoryPartition", "or", "DirectoryCollection"]}
{"code": "childrenConstructed = true;", "comments": "otherwise we are good", "lines": 13, "repo": "Unidata/thredds", "path": "cdm/src/main/java/thredds/inventory/partition/DirectoryBuilder.java", "func_name": "DirectoryBuilder.constructChildren", "original_string": "public List<DirectoryBuilder> constructChildren(IndexReader indexReader, CollectionUpdateType forceCollection) throws IOException {\n    if (childrenConstructed) return children;\n\n    if (index != null && forceCollection == CollectionUpdateType.nocheck) { // use index if it exists\n      constructChildrenFromIndex(indexReader, false);\n\n    } else {\n      scanForChildren();\n    }\n\n    //once we have found children, we know that this is a time partition\n    partitionStatus = (children.size() > 0) ?  PartitionStatus.isDirectoryPartition : PartitionStatus.isLeaf;\n    childrenConstructed = true;  // otherwise we are good\n\n    return children;\n  }", "language": "java", "Allcodes": "public List<DirectoryBuilder> constructChildren(IndexReader indexReader, CollectionUpdateType forceCollection) throws IOException {\n    if (childrenConstructed) return children;\n\n    if (index != null && forceCollection == CollectionUpdateType.nocheck) { // use index if it exists\n      constructChildrenFromIndex(indexReader, false);\n\n    } else {\n      scanForChildren();\n    }\n\n    //once we have found children, we know that this is a time partition\n    partitionStatus = (children.size() > 0) ?  PartitionStatus.isDirectoryPartition : PartitionStatus.isLeaf;\n    childrenConstructed = true;  // otherwise we are good\n\n    return children;\n  }", "code_tokens": ["public", "List", "<", "DirectoryBuilder", ">", "constructChildren", "(", "IndexReader", "indexReader", ",", "CollectionUpdateType", "forceCollection", ")", "throws", "IOException", "{", "if", "(", "childrenConstructed", ")", "return", "children", ";", "if", "(", "index", "!=", "null", "&&", "forceCollection", "==", "CollectionUpdateType", ".", "nocheck", ")", "{", "// use index if it exists", "constructChildrenFromIndex", "(", "indexReader", ",", "false", ")", ";", "}", "else", "{", "scanForChildren", "(", ")", ";", "}", "//once we have found children, we know that this is a time partition", "partitionStatus", "=", "(", "children", ".", "size", "(", ")", ">", "0", ")", "?", "PartitionStatus", ".", "isDirectoryPartition", ":", "PartitionStatus", ".", "isLeaf", ";", "childrenConstructed", "=", "true", ";", "// otherwise we are good", "return", "children", ";", "}"], "docstring": "Find all children directories. Does not recurse.\nWe separate this from the constructor so it can be done on demand\nPublic for debugging.\n\nLook for children by:\n<ol>\n<li>If index exists , use the children inside there./li>\n<li>(or) scan the directory for children partitions</li>\n</ol>\n\n@param indexReader  this reads the index, and calls AddChild.addchild() for each child\n@return children, may be empty but not null\n@throws IOException", "docstring_tokens": ["Find", "all", "children", "directories", ".", "Does", "not", "recurse", ".", "We", "separate", "this", "from", "the", "constructor", "so", "it", "can", "be", "done", "on", "demand", "Public", "for", "debugging", "."]}
{"code": "want.ncfile.setFileCache(null);", "comments": "unhook the caching", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCache.java", "func_name": "FileCache.remove", "original_string": "private void remove(CacheElement.CacheFile want) {\r\n     want.remove();\r\n     files.remove(want.ncfile);\r\n     try {\r\n       want.ncfile.setFileCache(null); // unhook the caching\r\n       want.ncfile.close();\r\n     } catch (IOException e) {\r\n       log.error(\"close failed on \"+want.ncfile.getLocation(), e);\r\n     }\r\n     want.ncfile = null;\r\n  }", "language": "java", "Allcodes": "private void remove(CacheElement.CacheFile want) {\r\n     want.remove();\r\n     files.remove(want.ncfile);\r\n     try {\r\n       want.ncfile.setFileCache(null); // unhook the caching\r\n       want.ncfile.close();\r\n     } catch (IOException e) {\r\n       log.error(\"close failed on \"+want.ncfile.getLocation(), e);\r\n     }\r\n     want.ncfile = null;\r\n  }", "code_tokens": ["private", "void", "remove", "(", "CacheElement", ".", "CacheFile", "want", ")", "{", "want", ".", "remove", "(", ")", ";", "files", ".", "remove", "(", "want", ".", "ncfile", ")", ";", "try", "{", "want", ".", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "// unhook the caching\r", "want", ".", "ncfile", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"close failed on \"", "+", "want", ".", "ncfile", ".", "getLocation", "(", ")", ",", "e", ")", ";", "}", "want", ".", "ncfile", "=", "null", ";", "}"], "docstring": "LOOK should you remove the entire CacheElement ?", "docstring_tokens": ["LOOK", "should", "you", "remove", "the", "entire", "CacheElement", "?"]}
{"code": "want.ncfile.close();", "comments": "really close the file", "lines": 15, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCache.java", "func_name": "FileCache.eject", "original_string": "@Override\r\n  public void eject(Object hashKey) {\r\n     if (disabled.get()) return;\r\n\r\n     // see if its in the cache\r\n     CacheElement wantCacheElem = cache.get(hashKey);\r\n     if (wantCacheElem == null) return;\r\n\r\n     synchronized (wantCacheElem) { // synch in order to traverse the list\r\n       for (CacheElement.CacheFile want : wantCacheElem.list) {\r\n          // LOOK can we use remove(want);  ??\r\n          files.remove(want.ncfile);\r\n          try {\r\n            want.ncfile.setFileCache(null); // unhook the caching\r\n            want.ncfile.close();  // really close the file\r\n            log.debug(\"close \"+want.ncfile.getLocation());\r\n          } catch (IOException e) {\r\n            log.error(\"close failed on \"+want.ncfile.getLocation(), e);\r\n          }\r\n          want.ncfile = null;\r\n         if (debugPrint) System.out.println(\"  FileCache \" + name + \" eject \" + hashKey);\r\n       }\r\n       wantCacheElem.list.clear();\r\n     }\r\n    cache.remove(hashKey);\r\n   }", "language": "java", "Allcodes": "@Override\r\n  public void eject(Object hashKey) {\r\n     if (disabled.get()) return;\r\n\r\n     // see if its in the cache\r\n     CacheElement wantCacheElem = cache.get(hashKey);\r\n     if (wantCacheElem == null) return;\r\n\r\n     synchronized (wantCacheElem) { // synch in order to traverse the list\r\n       for (CacheElement.CacheFile want : wantCacheElem.list) {\r\n          // LOOK can we use remove(want);  ??\r\n          files.remove(want.ncfile);\r\n          try {\r\n            want.ncfile.setFileCache(null); // unhook the caching\r\n            want.ncfile.close();  // really close the file\r\n            log.debug(\"close \"+want.ncfile.getLocation());\r\n          } catch (IOException e) {\r\n            log.error(\"close failed on \"+want.ncfile.getLocation(), e);\r\n          }\r\n          want.ncfile = null;\r\n         if (debugPrint) System.out.println(\"  FileCache \" + name + \" eject \" + hashKey);\r\n       }\r\n       wantCacheElem.list.clear();\r\n     }\r\n    cache.remove(hashKey);\r\n   }", "code_tokens": ["@", "Override", "public", "void", "eject", "(", "Object", "hashKey", ")", "{", "if", "(", "disabled", ".", "get", "(", ")", ")", "return", ";", "// see if its in the cache\r", "CacheElement", "wantCacheElem", "=", "cache", ".", "get", "(", "hashKey", ")", ";", "if", "(", "wantCacheElem", "==", "null", ")", "return", ";", "synchronized", "(", "wantCacheElem", ")", "{", "// synch in order to traverse the list\r", "for", "(", "CacheElement", ".", "CacheFile", "want", ":", "wantCacheElem", ".", "list", ")", "{", "// LOOK can we use remove(want);  ??\r", "files", ".", "remove", "(", "want", ".", "ncfile", ")", ";", "try", "{", "want", ".", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "// unhook the caching\r", "want", ".", "ncfile", ".", "close", "(", ")", ";", "// really close the file\r", "log", ".", "debug", "(", "\"close \"", "+", "want", ".", "ncfile", ".", "getLocation", "(", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"close failed on \"", "+", "want", ".", "ncfile", ".", "getLocation", "(", ")", ",", "e", ")", ";", "}", "want", ".", "ncfile", "=", "null", ";", "if", "(", "debugPrint", ")", "System", ".", "out", ".", "println", "(", "\"  FileCache \"", "+", "name", "+", "\" eject \"", "+", "hashKey", ")", ";", "}", "wantCacheElem", ".", "list", ".", "clear", "(", ")", ";", "}", "cache", ".", "remove", "(", "hashKey", ")", ";", "}"], "docstring": "Remove all instances of object from the cache\n@param hashKey the object", "docstring_tokens": ["Remove", "all", "instances", "of", "object", "from", "the", "cache"]}
{"code": "ncfile.setFileCache(null);", "comments": "prevent infinite loops", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCache.java", "func_name": "FileCache.release", "original_string": "@Override\r\n  public boolean release(FileCacheable ncfile) throws IOException {\r\n    if (ncfile == null) return false;\r\n\r\n    if (disabled.get()) {\r\n      ncfile.setFileCache(null); // prevent infinite loops\r\n      ncfile.close();\r\n      return false;\r\n    }\r\n\r\n    // find it in the file cache\r\n    CacheElement.CacheFile file = files.get(ncfile); // using hashCode of the FileCacheable\r\n    if (file != null) {\r\n      if (!file.isLocked.get()) {\r\n        cacheLog.warn(\"FileCache \" + name + \" release \" + ncfile.getLocation() + \" not locked; hash= \"+ncfile.hashCode());\r\n      }\r\n      file.lastAccessed = System.currentTimeMillis();\r\n      file.countAccessed++;\r\n      file.isLocked.set(false);\r\n      file.ncfile.release();\r\n\r\n      if (cacheLog.isDebugEnabled()) cacheLog.debug(\"FileCache \" + name + \" release \" + ncfile.getLocation()+\"; hash= \"+ncfile.hashCode());\r\n      if (debugPrint) System.out.printf(\"  FileCache %s release %s lock=%s count=%d%n\", name, ncfile.getLocation(), file.isLocked.get(), countLocked());\r\n      return true;\r\n    }\r\n    return false;\r\n    // throw new IOException(\"FileCache \" + name + \" release does not have file in cache = \" + ncfile.getLocation());\r\n  }", "language": "java", "Allcodes": "@Override\r\n  public boolean release(FileCacheable ncfile) throws IOException {\r\n    if (ncfile == null) return false;\r\n\r\n    if (disabled.get()) {\r\n      ncfile.setFileCache(null); // prevent infinite loops\r\n      ncfile.close();\r\n      return false;\r\n    }\r\n\r\n    // find it in the file cache\r\n    CacheElement.CacheFile file = files.get(ncfile); // using hashCode of the FileCacheable\r\n    if (file != null) {\r\n      if (!file.isLocked.get()) {\r\n        cacheLog.warn(\"FileCache \" + name + \" release \" + ncfile.getLocation() + \" not locked; hash= \"+ncfile.hashCode());\r\n      }\r\n      file.lastAccessed = System.currentTimeMillis();\r\n      file.countAccessed++;\r\n      file.isLocked.set(false);\r\n      file.ncfile.release();\r\n\r\n      if (cacheLog.isDebugEnabled()) cacheLog.debug(\"FileCache \" + name + \" release \" + ncfile.getLocation()+\"; hash= \"+ncfile.hashCode());\r\n      if (debugPrint) System.out.printf(\"  FileCache %s release %s lock=%s count=%d%n\", name, ncfile.getLocation(), file.isLocked.get(), countLocked());\r\n      return true;\r\n    }\r\n    return false;\r\n    // throw new IOException(\"FileCache \" + name + \" release does not have file in cache = \" + ncfile.getLocation());\r\n  }", "code_tokens": ["@", "Override", "public", "boolean", "release", "(", "FileCacheable", "ncfile", ")", "throws", "IOException", "{", "if", "(", "ncfile", "==", "null", ")", "return", "false", ";", "if", "(", "disabled", ".", "get", "(", ")", ")", "{", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "// prevent infinite loops\r", "ncfile", ".", "close", "(", ")", ";", "return", "false", ";", "}", "// find it in the file cache\r", "CacheElement", ".", "CacheFile", "file", "=", "files", ".", "get", "(", "ncfile", ")", ";", "// using hashCode of the FileCacheable\r", "if", "(", "file", "!=", "null", ")", "{", "if", "(", "!", "file", ".", "isLocked", ".", "get", "(", ")", ")", "{", "cacheLog", ".", "warn", "(", "\"FileCache \"", "+", "name", "+", "\" release \"", "+", "ncfile", ".", "getLocation", "(", ")", "+", "\" not locked; hash= \"", "+", "ncfile", ".", "hashCode", "(", ")", ")", ";", "}", "file", ".", "lastAccessed", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "file", ".", "countAccessed", "++", ";", "file", ".", "isLocked", ".", "set", "(", "false", ")", ";", "file", ".", "ncfile", ".", "release", "(", ")", ";", "if", "(", "cacheLog", ".", "isDebugEnabled", "(", ")", ")", "cacheLog", ".", "debug", "(", "\"FileCache \"", "+", "name", "+", "\" release \"", "+", "ncfile", ".", "getLocation", "(", ")", "+", "\"; hash= \"", "+", "ncfile", ".", "hashCode", "(", ")", ")", ";", "if", "(", "debugPrint", ")", "System", ".", "out", ".", "printf", "(", "\"  FileCache %s release %s lock=%s count=%d%n\"", ",", "name", ",", "ncfile", ".", "getLocation", "(", ")", ",", "file", ".", "isLocked", ".", "get", "(", ")", ",", "countLocked", "(", ")", ")", ";", "return", "true", ";", "}", "return", "false", ";", "// throw new IOException(\"FileCache \" + name + \" release does not have file in cache = \" + ncfile.getLocation());\r", "}"], "docstring": "Release the file. This unlocks it, updates its lastAccessed date.\nNormally applications need not call this, just close the file as usual.\nThe FileCacheable has to do tricky stuff.\n\n@param ncfile release this file.\n@return true if file was in cache, false if it was not", "docstring_tokens": ["Release", "the", "file", ".", "This", "unlocks", "it", "updates", "its", "lastAccessed", "date", ".", "Normally", "applications", "need", "not", "call", "this", "just", "close", "the", "file", "as", "usual", ".", "The", "FileCacheable", "has", "to", "do", "tricky", "stuff", "."]}
{"code": "CacheElement.CacheFile file = files.get(ncfile);", "comments": "using hashCode of the FileCacheable", "lines": 12, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCache.java", "func_name": "FileCache.release", "original_string": "@Override\r\n  public boolean release(FileCacheable ncfile) throws IOException {\r\n    if (ncfile == null) return false;\r\n\r\n    if (disabled.get()) {\r\n      ncfile.setFileCache(null); // prevent infinite loops\r\n      ncfile.close();\r\n      return false;\r\n    }\r\n\r\n    // find it in the file cache\r\n    CacheElement.CacheFile file = files.get(ncfile); // using hashCode of the FileCacheable\r\n    if (file != null) {\r\n      if (!file.isLocked.get()) {\r\n        cacheLog.warn(\"FileCache \" + name + \" release \" + ncfile.getLocation() + \" not locked; hash= \"+ncfile.hashCode());\r\n      }\r\n      file.lastAccessed = System.currentTimeMillis();\r\n      file.countAccessed++;\r\n      file.isLocked.set(false);\r\n      file.ncfile.release();\r\n\r\n      if (cacheLog.isDebugEnabled()) cacheLog.debug(\"FileCache \" + name + \" release \" + ncfile.getLocation()+\"; hash= \"+ncfile.hashCode());\r\n      if (debugPrint) System.out.printf(\"  FileCache %s release %s lock=%s count=%d%n\", name, ncfile.getLocation(), file.isLocked.get(), countLocked());\r\n      return true;\r\n    }\r\n    return false;\r\n    // throw new IOException(\"FileCache \" + name + \" release does not have file in cache = \" + ncfile.getLocation());\r\n  }", "language": "java", "Allcodes": "@Override\r\n  public boolean release(FileCacheable ncfile) throws IOException {\r\n    if (ncfile == null) return false;\r\n\r\n    if (disabled.get()) {\r\n      ncfile.setFileCache(null); // prevent infinite loops\r\n      ncfile.close();\r\n      return false;\r\n    }\r\n\r\n    // find it in the file cache\r\n    CacheElement.CacheFile file = files.get(ncfile); // using hashCode of the FileCacheable\r\n    if (file != null) {\r\n      if (!file.isLocked.get()) {\r\n        cacheLog.warn(\"FileCache \" + name + \" release \" + ncfile.getLocation() + \" not locked; hash= \"+ncfile.hashCode());\r\n      }\r\n      file.lastAccessed = System.currentTimeMillis();\r\n      file.countAccessed++;\r\n      file.isLocked.set(false);\r\n      file.ncfile.release();\r\n\r\n      if (cacheLog.isDebugEnabled()) cacheLog.debug(\"FileCache \" + name + \" release \" + ncfile.getLocation()+\"; hash= \"+ncfile.hashCode());\r\n      if (debugPrint) System.out.printf(\"  FileCache %s release %s lock=%s count=%d%n\", name, ncfile.getLocation(), file.isLocked.get(), countLocked());\r\n      return true;\r\n    }\r\n    return false;\r\n    // throw new IOException(\"FileCache \" + name + \" release does not have file in cache = \" + ncfile.getLocation());\r\n  }", "code_tokens": ["@", "Override", "public", "boolean", "release", "(", "FileCacheable", "ncfile", ")", "throws", "IOException", "{", "if", "(", "ncfile", "==", "null", ")", "return", "false", ";", "if", "(", "disabled", ".", "get", "(", ")", ")", "{", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "// prevent infinite loops\r", "ncfile", ".", "close", "(", ")", ";", "return", "false", ";", "}", "// find it in the file cache\r", "CacheElement", ".", "CacheFile", "file", "=", "files", ".", "get", "(", "ncfile", ")", ";", "// using hashCode of the FileCacheable\r", "if", "(", "file", "!=", "null", ")", "{", "if", "(", "!", "file", ".", "isLocked", ".", "get", "(", ")", ")", "{", "cacheLog", ".", "warn", "(", "\"FileCache \"", "+", "name", "+", "\" release \"", "+", "ncfile", ".", "getLocation", "(", ")", "+", "\" not locked; hash= \"", "+", "ncfile", ".", "hashCode", "(", ")", ")", ";", "}", "file", ".", "lastAccessed", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "file", ".", "countAccessed", "++", ";", "file", ".", "isLocked", ".", "set", "(", "false", ")", ";", "file", ".", "ncfile", ".", "release", "(", ")", ";", "if", "(", "cacheLog", ".", "isDebugEnabled", "(", ")", ")", "cacheLog", ".", "debug", "(", "\"FileCache \"", "+", "name", "+", "\" release \"", "+", "ncfile", ".", "getLocation", "(", ")", "+", "\"; hash= \"", "+", "ncfile", ".", "hashCode", "(", ")", ")", ";", "if", "(", "debugPrint", ")", "System", ".", "out", ".", "printf", "(", "\"  FileCache %s release %s lock=%s count=%d%n\"", ",", "name", ",", "ncfile", ".", "getLocation", "(", ")", ",", "file", ".", "isLocked", ".", "get", "(", ")", ",", "countLocked", "(", ")", ")", ";", "return", "true", ";", "}", "return", "false", ";", "// throw new IOException(\"FileCache \" + name + \" release does not have file in cache = \" + ncfile.getLocation());\r", "}"], "docstring": "Release the file. This unlocks it, updates its lastAccessed date.\nNormally applications need not call this, just close the file as usual.\nThe FileCacheable has to do tricky stuff.\n\n@param ncfile release this file.\n@return true if file was in cache, false if it was not", "docstring_tokens": ["Release", "the", "file", ".", "This", "unlocks", "it", "updates", "its", "lastAccessed", "date", ".", "Normally", "applications", "need", "not", "call", "this", "just", "close", "the", "file", "as", "usual", ".", "The", "FileCacheable", "has", "to", "do", "tricky", "stuff", "."]}
{"code": "CacheElement prev = shadowCache.put(elem, elem);", "comments": "faster if we could just insert at the top of the list. maybe we need to use LinkedList ?", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCacheARC.java", "func_name": "FileCacheARC.updateInCache", "original_string": "private CacheElement updateInCache(CacheElement elem) {\n    if (shadowCache.firstKey() == elem) return elem;\n\n    elem.updateAccessed();\n    CacheElement prev = shadowCache.put(elem, elem); // faster if we could just insert at the top of the list. maybe we need to use LinkedList ?\n    if (prev != null && (elem != prev)) {\n      CacheElementComparator cc = new CacheElementComparator();\n      System.out.printf(\"elem != prev compare=%d%n\", cc.compare(elem, prev));\n      System.out.printf(\"hash elem =%d prev=%d%n\", elem.hashCode(), prev.hashCode());\n    }\n    return elem;\n  }", "language": "java", "Allcodes": "private CacheElement updateInCache(CacheElement elem) {\n    if (shadowCache.firstKey() == elem) return elem;\n\n    elem.updateAccessed();\n    CacheElement prev = shadowCache.put(elem, elem); // faster if we could just insert at the top of the list. maybe we need to use LinkedList ?\n    if (prev != null && (elem != prev)) {\n      CacheElementComparator cc = new CacheElementComparator();\n      System.out.printf(\"elem != prev compare=%d%n\", cc.compare(elem, prev));\n      System.out.printf(\"hash elem =%d prev=%d%n\", elem.hashCode(), prev.hashCode());\n    }\n    return elem;\n  }", "code_tokens": ["private", "CacheElement", "updateInCache", "(", "CacheElement", "elem", ")", "{", "if", "(", "shadowCache", ".", "firstKey", "(", ")", "==", "elem", ")", "return", "elem", ";", "elem", ".", "updateAccessed", "(", ")", ";", "CacheElement", "prev", "=", "shadowCache", ".", "put", "(", "elem", ",", "elem", ")", ";", "// faster if we could just insert at the top of the list. maybe we need to use LinkedList ?", "if", "(", "prev", "!=", "null", "&&", "(", "elem", "!=", "prev", ")", ")", "{", "CacheElementComparator", "cc", "=", "new", "CacheElementComparator", "(", ")", ";", "System", ".", "out", ".", "printf", "(", "\"elem != prev compare=%d%n\"", ",", "cc", ".", "compare", "(", "elem", ",", "prev", ")", ")", ";", "System", ".", "out", ".", "printf", "(", "\"hash elem =%d prev=%d%n\"", ",", "elem", ".", "hashCode", "(", ")", ",", "prev", ".", "hashCode", "(", ")", ")", ";", "}", "return", "elem", ";", "}"], "docstring": "get CacheElement specified by hashKey. If found, update lastUsed in shadowCache.", "docstring_tokens": ["get", "CacheElement", "specified", "by", "hashKey", ".", "If", "found", "update", "lastUsed", "in", "shadowCache", "."]}
{"code": "cache.clear();", "comments": "deletes everything from the cache", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCacheARC.java", "func_name": "FileCacheARC.clearCache", "original_string": "public synchronized void clearCache(boolean force) {\n    List<CacheElement.CacheFile> deleteList = new ArrayList<>(2 * cache.size());\n\n    if (force) {\n      cache.clear(); // deletes everything from the cache\n      deleteList.addAll(files.values());  // add everything to the delete list\n      files.clear();\n      // counter.set(0);\n\n    } else {\n\n      // add unlocked files to the delete list, remove from files hash\n      Iterator<CacheElement.CacheFile> iter = files.values().iterator();\n      while (iter.hasNext()) {\n        CacheElement.CacheFile file = iter.next();\n        if (file.isLocked.compareAndSet(false, true)) {\n          file.remove(); // remove from the containing CacheElement\n          deleteList.add(file);\n          iter.remove();\n        }\n      }\n\n      // remove empty cache elements\n      for (CacheElement elem : cache.values()) {\n        if (elem.list.size() == 0)\n          cache.remove(elem.hashKey);\n      }\n    }\n\n    // close all files in deleteList\n    for (CacheElement.CacheFile file : deleteList) {\n      if (force && file.isLocked.get())\n        cacheLog.warn(\"FileCacheARC \" + name + \" force close locked file= \" + file);\n      //counter.decrementAndGet();\n\n      if (file.ncfile == null) continue;\n\n      try {\n        file.ncfile.setFileCache(null);\n        file.ncfile.close();\n        file.ncfile = null; // help the gc\n      } catch (IOException e) {\n        log.error(\"FileCacheARC \" + name + \" close failed on \" + file);\n      }\n    }\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + files.size());\n    //System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());\n  }", "language": "java", "Allcodes": "public synchronized void clearCache(boolean force) {\n    List<CacheElement.CacheFile> deleteList = new ArrayList<>(2 * cache.size());\n\n    if (force) {\n      cache.clear(); // deletes everything from the cache\n      deleteList.addAll(files.values());  // add everything to the delete list\n      files.clear();\n      // counter.set(0);\n\n    } else {\n\n      // add unlocked files to the delete list, remove from files hash\n      Iterator<CacheElement.CacheFile> iter = files.values().iterator();\n      while (iter.hasNext()) {\n        CacheElement.CacheFile file = iter.next();\n        if (file.isLocked.compareAndSet(false, true)) {\n          file.remove(); // remove from the containing CacheElement\n          deleteList.add(file);\n          iter.remove();\n        }\n      }\n\n      // remove empty cache elements\n      for (CacheElement elem : cache.values()) {\n        if (elem.list.size() == 0)\n          cache.remove(elem.hashKey);\n      }\n    }\n\n    // close all files in deleteList\n    for (CacheElement.CacheFile file : deleteList) {\n      if (force && file.isLocked.get())\n        cacheLog.warn(\"FileCacheARC \" + name + \" force close locked file= \" + file);\n      //counter.decrementAndGet();\n\n      if (file.ncfile == null) continue;\n\n      try {\n        file.ncfile.setFileCache(null);\n        file.ncfile.close();\n        file.ncfile = null; // help the gc\n      } catch (IOException e) {\n        log.error(\"FileCacheARC \" + name + \" close failed on \" + file);\n      }\n    }\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + files.size());\n    //System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());\n  }", "code_tokens": ["public", "synchronized", "void", "clearCache", "(", "boolean", "force", ")", "{", "List", "<", "CacheElement", ".", "CacheFile", ">", "deleteList", "=", "new", "ArrayList", "<>", "(", "2", "*", "cache", ".", "size", "(", ")", ")", ";", "if", "(", "force", ")", "{", "cache", ".", "clear", "(", ")", ";", "// deletes everything from the cache", "deleteList", ".", "addAll", "(", "files", ".", "values", "(", ")", ")", ";", "// add everything to the delete list", "files", ".", "clear", "(", ")", ";", "// counter.set(0);", "}", "else", "{", "// add unlocked files to the delete list, remove from files hash", "Iterator", "<", "CacheElement", ".", "CacheFile", ">", "iter", "=", "files", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "CacheElement", ".", "CacheFile", "file", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "file", ".", "isLocked", ".", "compareAndSet", "(", "false", ",", "true", ")", ")", "{", "file", ".", "remove", "(", ")", ";", "// remove from the containing CacheElement", "deleteList", ".", "add", "(", "file", ")", ";", "iter", ".", "remove", "(", ")", ";", "}", "}", "// remove empty cache elements", "for", "(", "CacheElement", "elem", ":", "cache", ".", "values", "(", ")", ")", "{", "if", "(", "elem", ".", "list", ".", "size", "(", ")", "==", "0", ")", "cache", ".", "remove", "(", "elem", ".", "hashKey", ")", ";", "}", "}", "// close all files in deleteList", "for", "(", "CacheElement", ".", "CacheFile", "file", ":", "deleteList", ")", "{", "if", "(", "force", "&&", "file", ".", "isLocked", ".", "get", "(", ")", ")", "cacheLog", ".", "warn", "(", "\"FileCacheARC \"", "+", "name", "+", "\" force close locked file= \"", "+", "file", ")", ";", "//counter.decrementAndGet();", "if", "(", "file", ".", "ncfile", "==", "null", ")", "continue", ";", "try", "{", "file", ".", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "file", ".", "ncfile", ".", "close", "(", ")", ";", "file", ".", "ncfile", "=", "null", ";", "// help the gc", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"FileCacheARC \"", "+", "name", "+", "\" close failed on \"", "+", "file", ")", ";", "}", "}", "if", "(", "cacheLog", ".", "isDebugEnabled", "(", ")", ")", "cacheLog", ".", "debug", "(", "\"*FileCacheARC \"", "+", "name", "+", "\" clearCache force= \"", "+", "force", "+", "\" deleted= \"", "+", "deleteList", ".", "size", "(", ")", "+", "\" left=\"", "+", "files", ".", "size", "(", ")", ")", ";", "//System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());", "}"], "docstring": "Remove all cache entries.\n\n@param force if true, remove them even if they are currently locked.", "docstring_tokens": ["Remove", "all", "cache", "entries", "."]}
{"code": "deleteList.addAll(files.values());", "comments": "add everything to the delete list", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCacheARC.java", "func_name": "FileCacheARC.clearCache", "original_string": "public synchronized void clearCache(boolean force) {\n    List<CacheElement.CacheFile> deleteList = new ArrayList<>(2 * cache.size());\n\n    if (force) {\n      cache.clear(); // deletes everything from the cache\n      deleteList.addAll(files.values());  // add everything to the delete list\n      files.clear();\n      // counter.set(0);\n\n    } else {\n\n      // add unlocked files to the delete list, remove from files hash\n      Iterator<CacheElement.CacheFile> iter = files.values().iterator();\n      while (iter.hasNext()) {\n        CacheElement.CacheFile file = iter.next();\n        if (file.isLocked.compareAndSet(false, true)) {\n          file.remove(); // remove from the containing CacheElement\n          deleteList.add(file);\n          iter.remove();\n        }\n      }\n\n      // remove empty cache elements\n      for (CacheElement elem : cache.values()) {\n        if (elem.list.size() == 0)\n          cache.remove(elem.hashKey);\n      }\n    }\n\n    // close all files in deleteList\n    for (CacheElement.CacheFile file : deleteList) {\n      if (force && file.isLocked.get())\n        cacheLog.warn(\"FileCacheARC \" + name + \" force close locked file= \" + file);\n      //counter.decrementAndGet();\n\n      if (file.ncfile == null) continue;\n\n      try {\n        file.ncfile.setFileCache(null);\n        file.ncfile.close();\n        file.ncfile = null; // help the gc\n      } catch (IOException e) {\n        log.error(\"FileCacheARC \" + name + \" close failed on \" + file);\n      }\n    }\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + files.size());\n    //System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());\n  }", "language": "java", "Allcodes": "public synchronized void clearCache(boolean force) {\n    List<CacheElement.CacheFile> deleteList = new ArrayList<>(2 * cache.size());\n\n    if (force) {\n      cache.clear(); // deletes everything from the cache\n      deleteList.addAll(files.values());  // add everything to the delete list\n      files.clear();\n      // counter.set(0);\n\n    } else {\n\n      // add unlocked files to the delete list, remove from files hash\n      Iterator<CacheElement.CacheFile> iter = files.values().iterator();\n      while (iter.hasNext()) {\n        CacheElement.CacheFile file = iter.next();\n        if (file.isLocked.compareAndSet(false, true)) {\n          file.remove(); // remove from the containing CacheElement\n          deleteList.add(file);\n          iter.remove();\n        }\n      }\n\n      // remove empty cache elements\n      for (CacheElement elem : cache.values()) {\n        if (elem.list.size() == 0)\n          cache.remove(elem.hashKey);\n      }\n    }\n\n    // close all files in deleteList\n    for (CacheElement.CacheFile file : deleteList) {\n      if (force && file.isLocked.get())\n        cacheLog.warn(\"FileCacheARC \" + name + \" force close locked file= \" + file);\n      //counter.decrementAndGet();\n\n      if (file.ncfile == null) continue;\n\n      try {\n        file.ncfile.setFileCache(null);\n        file.ncfile.close();\n        file.ncfile = null; // help the gc\n      } catch (IOException e) {\n        log.error(\"FileCacheARC \" + name + \" close failed on \" + file);\n      }\n    }\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + files.size());\n    //System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());\n  }", "code_tokens": ["public", "synchronized", "void", "clearCache", "(", "boolean", "force", ")", "{", "List", "<", "CacheElement", ".", "CacheFile", ">", "deleteList", "=", "new", "ArrayList", "<>", "(", "2", "*", "cache", ".", "size", "(", ")", ")", ";", "if", "(", "force", ")", "{", "cache", ".", "clear", "(", ")", ";", "// deletes everything from the cache", "deleteList", ".", "addAll", "(", "files", ".", "values", "(", ")", ")", ";", "// add everything to the delete list", "files", ".", "clear", "(", ")", ";", "// counter.set(0);", "}", "else", "{", "// add unlocked files to the delete list, remove from files hash", "Iterator", "<", "CacheElement", ".", "CacheFile", ">", "iter", "=", "files", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "CacheElement", ".", "CacheFile", "file", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "file", ".", "isLocked", ".", "compareAndSet", "(", "false", ",", "true", ")", ")", "{", "file", ".", "remove", "(", ")", ";", "// remove from the containing CacheElement", "deleteList", ".", "add", "(", "file", ")", ";", "iter", ".", "remove", "(", ")", ";", "}", "}", "// remove empty cache elements", "for", "(", "CacheElement", "elem", ":", "cache", ".", "values", "(", ")", ")", "{", "if", "(", "elem", ".", "list", ".", "size", "(", ")", "==", "0", ")", "cache", ".", "remove", "(", "elem", ".", "hashKey", ")", ";", "}", "}", "// close all files in deleteList", "for", "(", "CacheElement", ".", "CacheFile", "file", ":", "deleteList", ")", "{", "if", "(", "force", "&&", "file", ".", "isLocked", ".", "get", "(", ")", ")", "cacheLog", ".", "warn", "(", "\"FileCacheARC \"", "+", "name", "+", "\" force close locked file= \"", "+", "file", ")", ";", "//counter.decrementAndGet();", "if", "(", "file", ".", "ncfile", "==", "null", ")", "continue", ";", "try", "{", "file", ".", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "file", ".", "ncfile", ".", "close", "(", ")", ";", "file", ".", "ncfile", "=", "null", ";", "// help the gc", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"FileCacheARC \"", "+", "name", "+", "\" close failed on \"", "+", "file", ")", ";", "}", "}", "if", "(", "cacheLog", ".", "isDebugEnabled", "(", ")", ")", "cacheLog", ".", "debug", "(", "\"*FileCacheARC \"", "+", "name", "+", "\" clearCache force= \"", "+", "force", "+", "\" deleted= \"", "+", "deleteList", ".", "size", "(", ")", "+", "\" left=\"", "+", "files", ".", "size", "(", ")", ")", ";", "//System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());", "}"], "docstring": "Remove all cache entries.\n\n@param force if true, remove them even if they are currently locked.", "docstring_tokens": ["Remove", "all", "cache", "entries", "."]}
{"code": "file.remove();", "comments": "remove from the containing CacheElement", "lines": 17, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCacheARC.java", "func_name": "FileCacheARC.clearCache", "original_string": "public synchronized void clearCache(boolean force) {\n    List<CacheElement.CacheFile> deleteList = new ArrayList<>(2 * cache.size());\n\n    if (force) {\n      cache.clear(); // deletes everything from the cache\n      deleteList.addAll(files.values());  // add everything to the delete list\n      files.clear();\n      // counter.set(0);\n\n    } else {\n\n      // add unlocked files to the delete list, remove from files hash\n      Iterator<CacheElement.CacheFile> iter = files.values().iterator();\n      while (iter.hasNext()) {\n        CacheElement.CacheFile file = iter.next();\n        if (file.isLocked.compareAndSet(false, true)) {\n          file.remove(); // remove from the containing CacheElement\n          deleteList.add(file);\n          iter.remove();\n        }\n      }\n\n      // remove empty cache elements\n      for (CacheElement elem : cache.values()) {\n        if (elem.list.size() == 0)\n          cache.remove(elem.hashKey);\n      }\n    }\n\n    // close all files in deleteList\n    for (CacheElement.CacheFile file : deleteList) {\n      if (force && file.isLocked.get())\n        cacheLog.warn(\"FileCacheARC \" + name + \" force close locked file= \" + file);\n      //counter.decrementAndGet();\n\n      if (file.ncfile == null) continue;\n\n      try {\n        file.ncfile.setFileCache(null);\n        file.ncfile.close();\n        file.ncfile = null; // help the gc\n      } catch (IOException e) {\n        log.error(\"FileCacheARC \" + name + \" close failed on \" + file);\n      }\n    }\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + files.size());\n    //System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());\n  }", "language": "java", "Allcodes": "public synchronized void clearCache(boolean force) {\n    List<CacheElement.CacheFile> deleteList = new ArrayList<>(2 * cache.size());\n\n    if (force) {\n      cache.clear(); // deletes everything from the cache\n      deleteList.addAll(files.values());  // add everything to the delete list\n      files.clear();\n      // counter.set(0);\n\n    } else {\n\n      // add unlocked files to the delete list, remove from files hash\n      Iterator<CacheElement.CacheFile> iter = files.values().iterator();\n      while (iter.hasNext()) {\n        CacheElement.CacheFile file = iter.next();\n        if (file.isLocked.compareAndSet(false, true)) {\n          file.remove(); // remove from the containing CacheElement\n          deleteList.add(file);\n          iter.remove();\n        }\n      }\n\n      // remove empty cache elements\n      for (CacheElement elem : cache.values()) {\n        if (elem.list.size() == 0)\n          cache.remove(elem.hashKey);\n      }\n    }\n\n    // close all files in deleteList\n    for (CacheElement.CacheFile file : deleteList) {\n      if (force && file.isLocked.get())\n        cacheLog.warn(\"FileCacheARC \" + name + \" force close locked file= \" + file);\n      //counter.decrementAndGet();\n\n      if (file.ncfile == null) continue;\n\n      try {\n        file.ncfile.setFileCache(null);\n        file.ncfile.close();\n        file.ncfile = null; // help the gc\n      } catch (IOException e) {\n        log.error(\"FileCacheARC \" + name + \" close failed on \" + file);\n      }\n    }\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + files.size());\n    //System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());\n  }", "code_tokens": ["public", "synchronized", "void", "clearCache", "(", "boolean", "force", ")", "{", "List", "<", "CacheElement", ".", "CacheFile", ">", "deleteList", "=", "new", "ArrayList", "<>", "(", "2", "*", "cache", ".", "size", "(", ")", ")", ";", "if", "(", "force", ")", "{", "cache", ".", "clear", "(", ")", ";", "// deletes everything from the cache", "deleteList", ".", "addAll", "(", "files", ".", "values", "(", ")", ")", ";", "// add everything to the delete list", "files", ".", "clear", "(", ")", ";", "// counter.set(0);", "}", "else", "{", "// add unlocked files to the delete list, remove from files hash", "Iterator", "<", "CacheElement", ".", "CacheFile", ">", "iter", "=", "files", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "CacheElement", ".", "CacheFile", "file", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "file", ".", "isLocked", ".", "compareAndSet", "(", "false", ",", "true", ")", ")", "{", "file", ".", "remove", "(", ")", ";", "// remove from the containing CacheElement", "deleteList", ".", "add", "(", "file", ")", ";", "iter", ".", "remove", "(", ")", ";", "}", "}", "// remove empty cache elements", "for", "(", "CacheElement", "elem", ":", "cache", ".", "values", "(", ")", ")", "{", "if", "(", "elem", ".", "list", ".", "size", "(", ")", "==", "0", ")", "cache", ".", "remove", "(", "elem", ".", "hashKey", ")", ";", "}", "}", "// close all files in deleteList", "for", "(", "CacheElement", ".", "CacheFile", "file", ":", "deleteList", ")", "{", "if", "(", "force", "&&", "file", ".", "isLocked", ".", "get", "(", ")", ")", "cacheLog", ".", "warn", "(", "\"FileCacheARC \"", "+", "name", "+", "\" force close locked file= \"", "+", "file", ")", ";", "//counter.decrementAndGet();", "if", "(", "file", ".", "ncfile", "==", "null", ")", "continue", ";", "try", "{", "file", ".", "ncfile", ".", "setFileCache", "(", "null", ")", ";", "file", ".", "ncfile", ".", "close", "(", ")", ";", "file", ".", "ncfile", "=", "null", ";", "// help the gc", "}", "catch", "(", "IOException", "e", ")", "{", "log", ".", "error", "(", "\"FileCacheARC \"", "+", "name", "+", "\" close failed on \"", "+", "file", ")", ";", "}", "}", "if", "(", "cacheLog", ".", "isDebugEnabled", "(", ")", ")", "cacheLog", ".", "debug", "(", "\"*FileCacheARC \"", "+", "name", "+", "\" clearCache force= \"", "+", "force", "+", "\" deleted= \"", "+", "deleteList", ".", "size", "(", ")", "+", "\" left=\"", "+", "files", ".", "size", "(", ")", ")", ";", "//System.out.println(\"\\n*NetcdfFileCache.clearCache force= \" + force + \" deleted= \" + deleteList.size() + \" left=\" + counter.get());", "}"], "docstring": "Remove all cache entries.\n\n@param force if true, remove them even if they are currently locked.", "docstring_tokens": ["Remove", "all", "cache", "entries", "."]}
{"code": "if (vt != null) return;", "comments": "already done", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dt/grid/GridCoordSys.java", "func_name": "GridCoordSys.makeVerticalTransform", "original_string": "void makeVerticalTransform(GridDataset gds, Formatter parseInfo) {\r\n    if (vt != null) return; // already done\r\n    if (vCT == null) return;  // no vt\r\n\r\n    vt = vCT.makeVerticalTransform(gds.getNetcdfDataset(), timeDim);\r\n\r\n    if (vt == null) {\r\n      if (parseInfo != null)\r\n        parseInfo.format(\"  - ERR can't make VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    } else {\r\n      if (parseInfo != null) parseInfo.format(\"  - VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    }\r\n  }", "language": "java", "Allcodes": "void makeVerticalTransform(GridDataset gds, Formatter parseInfo) {\r\n    if (vt != null) return; // already done\r\n    if (vCT == null) return;  // no vt\r\n\r\n    vt = vCT.makeVerticalTransform(gds.getNetcdfDataset(), timeDim);\r\n\r\n    if (vt == null) {\r\n      if (parseInfo != null)\r\n        parseInfo.format(\"  - ERR can't make VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    } else {\r\n      if (parseInfo != null) parseInfo.format(\"  - VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    }\r\n  }", "code_tokens": ["void", "makeVerticalTransform", "(", "GridDataset", "gds", ",", "Formatter", "parseInfo", ")", "{", "if", "(", "vt", "!=", "null", ")", "return", ";", "// already done\r", "if", "(", "vCT", "==", "null", ")", "return", ";", "// no vt\r", "vt", "=", "vCT", ".", "makeVerticalTransform", "(", "gds", ".", "getNetcdfDataset", "(", ")", ",", "timeDim", ")", ";", "if", "(", "vt", "==", "null", ")", "{", "if", "(", "parseInfo", "!=", "null", ")", "parseInfo", ".", "format", "(", "\"  - ERR can't make VerticalTransform = %s%n\"", ",", "vCT", ".", "getVerticalTransformType", "(", ")", ")", ";", "}", "else", "{", "if", "(", "parseInfo", "!=", "null", ")", "parseInfo", ".", "format", "(", "\"  - VerticalTransform = %s%n\"", ",", "vCT", ".", "getVerticalTransformType", "(", ")", ")", ";", "}", "}"], "docstring": "we have to delay making these, since we dont identify the dimensions specifically until now", "docstring_tokens": ["we", "have", "to", "delay", "making", "these", "since", "we", "dont", "identify", "the", "dimensions", "specifically", "until", "now"]}
{"code": "if (vCT == null) return;", "comments": "no vt", "lines": 3, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dt/grid/GridCoordSys.java", "func_name": "GridCoordSys.makeVerticalTransform", "original_string": "void makeVerticalTransform(GridDataset gds, Formatter parseInfo) {\r\n    if (vt != null) return; // already done\r\n    if (vCT == null) return;  // no vt\r\n\r\n    vt = vCT.makeVerticalTransform(gds.getNetcdfDataset(), timeDim);\r\n\r\n    if (vt == null) {\r\n      if (parseInfo != null)\r\n        parseInfo.format(\"  - ERR can't make VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    } else {\r\n      if (parseInfo != null) parseInfo.format(\"  - VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    }\r\n  }", "language": "java", "Allcodes": "void makeVerticalTransform(GridDataset gds, Formatter parseInfo) {\r\n    if (vt != null) return; // already done\r\n    if (vCT == null) return;  // no vt\r\n\r\n    vt = vCT.makeVerticalTransform(gds.getNetcdfDataset(), timeDim);\r\n\r\n    if (vt == null) {\r\n      if (parseInfo != null)\r\n        parseInfo.format(\"  - ERR can't make VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    } else {\r\n      if (parseInfo != null) parseInfo.format(\"  - VerticalTransform = %s%n\", vCT.getVerticalTransformType());\r\n    }\r\n  }", "code_tokens": ["void", "makeVerticalTransform", "(", "GridDataset", "gds", ",", "Formatter", "parseInfo", ")", "{", "if", "(", "vt", "!=", "null", ")", "return", ";", "// already done\r", "if", "(", "vCT", "==", "null", ")", "return", ";", "// no vt\r", "vt", "=", "vCT", ".", "makeVerticalTransform", "(", "gds", ".", "getNetcdfDataset", "(", ")", ",", "timeDim", ")", ";", "if", "(", "vt", "==", "null", ")", "{", "if", "(", "parseInfo", "!=", "null", ")", "parseInfo", ".", "format", "(", "\"  - ERR can't make VerticalTransform = %s%n\"", ",", "vCT", ".", "getVerticalTransformType", "(", ")", ")", ";", "}", "else", "{", "if", "(", "parseInfo", "!=", "null", ")", "parseInfo", ".", "format", "(", "\"  - VerticalTransform = %s%n\"", ",", "vCT", ".", "getVerticalTransformType", "(", ")", ")", ";", "}", "}"], "docstring": "we have to delay making these, since we dont identify the dimensions specifically until now", "docstring_tokens": ["we", "have", "to", "delay", "making", "these", "since", "we", "dont", "identify", "the", "dimensions", "specifically", "until", "now"]}
{"code": "g2d.findCoordElement(y_coord, x_coord, result2);", "comments": "returns best guess", "lines": 16, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dt/grid/GridCoordSys.java", "func_name": "GridCoordSys.findXYindexFromCoordBounded", "original_string": "@Override\r\n  public int[] findXYindexFromCoordBounded(double x_coord, double y_coord, int[] result) {\r\n    if (result == null)\r\n      result = new int[2];\r\n\r\n    if ((horizXaxis instanceof CoordinateAxis1D) && (horizYaxis instanceof CoordinateAxis1D)) {\r\n      result[0] = ((CoordinateAxis1D) horizXaxis).findCoordElementBounded(x_coord);\r\n      result[1] = ((CoordinateAxis1D) horizYaxis).findCoordElementBounded(y_coord);\r\n      return result;\r\n\r\n    } else if ((horizXaxis instanceof CoordinateAxis2D) && (horizYaxis instanceof CoordinateAxis2D)) {\r\n      if (g2d == null)\r\n        g2d = new GridCoordinate2D((CoordinateAxis2D) horizYaxis, (CoordinateAxis2D) horizXaxis);\r\n\r\n      int[] result2 = new int[2];\r\n      g2d.findCoordElement(y_coord, x_coord, result2); // returns best guess\r\n      result[0] = result2[1];\r\n      result[1] = result2[0];\r\n      return result;\r\n    }\r\n\r\n    // cant happen\r\n    throw new IllegalStateException(\"GridCoordSystem.findXYindexFromCoord\");\r\n  }", "language": "java", "Allcodes": "@Override\r\n  public int[] findXYindexFromCoordBounded(double x_coord, double y_coord, int[] result) {\r\n    if (result == null)\r\n      result = new int[2];\r\n\r\n    if ((horizXaxis instanceof CoordinateAxis1D) && (horizYaxis instanceof CoordinateAxis1D)) {\r\n      result[0] = ((CoordinateAxis1D) horizXaxis).findCoordElementBounded(x_coord);\r\n      result[1] = ((CoordinateAxis1D) horizYaxis).findCoordElementBounded(y_coord);\r\n      return result;\r\n\r\n    } else if ((horizXaxis instanceof CoordinateAxis2D) && (horizYaxis instanceof CoordinateAxis2D)) {\r\n      if (g2d == null)\r\n        g2d = new GridCoordinate2D((CoordinateAxis2D) horizYaxis, (CoordinateAxis2D) horizXaxis);\r\n\r\n      int[] result2 = new int[2];\r\n      g2d.findCoordElement(y_coord, x_coord, result2); // returns best guess\r\n      result[0] = result2[1];\r\n      result[1] = result2[0];\r\n      return result;\r\n    }\r\n\r\n    // cant happen\r\n    throw new IllegalStateException(\"GridCoordSystem.findXYindexFromCoord\");\r\n  }", "code_tokens": ["@", "Override", "public", "int", "[", "]", "findXYindexFromCoordBounded", "(", "double", "x_coord", ",", "double", "y_coord", ",", "int", "[", "]", "result", ")", "{", "if", "(", "result", "==", "null", ")", "result", "=", "new", "int", "[", "2", "]", ";", "if", "(", "(", "horizXaxis", "instanceof", "CoordinateAxis1D", ")", "&&", "(", "horizYaxis", "instanceof", "CoordinateAxis1D", ")", ")", "{", "result", "[", "0", "]", "=", "(", "(", "CoordinateAxis1D", ")", "horizXaxis", ")", ".", "findCoordElementBounded", "(", "x_coord", ")", ";", "result", "[", "1", "]", "=", "(", "(", "CoordinateAxis1D", ")", "horizYaxis", ")", ".", "findCoordElementBounded", "(", "y_coord", ")", ";", "return", "result", ";", "}", "else", "if", "(", "(", "horizXaxis", "instanceof", "CoordinateAxis2D", ")", "&&", "(", "horizYaxis", "instanceof", "CoordinateAxis2D", ")", ")", "{", "if", "(", "g2d", "==", "null", ")", "g2d", "=", "new", "GridCoordinate2D", "(", "(", "CoordinateAxis2D", ")", "horizYaxis", ",", "(", "CoordinateAxis2D", ")", "horizXaxis", ")", ";", "int", "[", "]", "result2", "=", "new", "int", "[", "2", "]", ";", "g2d", ".", "findCoordElement", "(", "y_coord", ",", "x_coord", ",", "result2", ")", ";", "// returns best guess\r", "result", "[", "0", "]", "=", "result2", "[", "1", "]", ";", "result", "[", "1", "]", "=", "result2", "[", "0", "]", ";", "return", "result", ";", "}", "// cant happen\r", "throw", "new", "IllegalStateException", "(", "\"GridCoordSystem.findXYindexFromCoord\"", ")", ";", "}"], "docstring": "Given a point in x,y coordinate space, find the x,y index in the coordinate system.\nIf outside the range, the closest point is returned, eg, 0 or n-1 depending on if the coordinate is too small or too large.\n\n@param x_coord position in x coordinate space.\n@param y_coord position in y coordinate space.\n@param result  put result in here, may be null\n@return int[2], 0=x,1=y indices in the coordinate system of the point.", "docstring_tokens": ["Given", "a", "point", "in", "x", "y", "coordinate", "space", "find", "the", "x", "y", "index", "in", "the", "coordinate", "system", ".", "If", "outside", "the", "range", "the", "closest", "point", "is", "returned", "eg", "0", "or", "n", "-", "1", "depending", "on", "if", "the", "coordinate", "is", "too", "small", "or", "too", "large", "."]}
{"code": "return -arrow_size;", "comments": "dont show indicator", "lines": 3, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/SuperComboBox.java", "func_name": "MyTextField.getItemPos", "original_string": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "language": "java", "Allcodes": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "code_tokens": ["protected", "int", "getItemPos", "(", ")", "{", "if", "(", "nitems", "<", "1", ")", "return", "-", "arrow_size", ";", "// dont show indicator\r", "else", "if", "(", "nitems", "==", "1", ")", "return", "b", ".", "width", "/", "2", ";", "// indicator in center\r", "int", "item", "=", "table", ".", "getSelectedRowIndex", "(", ")", ";", "// selected item\r", "int", "eff_width", "=", "b", ".", "width", "-", "2", "*", "arrow_size", ";", "// effective width\r", "int", "pixel", "=", "(", "item", "*", "eff_width", ")", "/", "(", "nitems", "-", "1", ")", ";", "// divided into n-1 intervals\r", "return", "pixel", "+", "arrow_size", ";", "}"], "docstring": "return slider indicator position for currently selected item", "docstring_tokens": ["return", "slider", "indicator", "position", "for", "currently", "selected", "item"]}
{"code": "return b.width/2;", "comments": "indicator in center", "lines": 5, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/SuperComboBox.java", "func_name": "MyTextField.getItemPos", "original_string": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "language": "java", "Allcodes": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "code_tokens": ["protected", "int", "getItemPos", "(", ")", "{", "if", "(", "nitems", "<", "1", ")", "return", "-", "arrow_size", ";", "// dont show indicator\r", "else", "if", "(", "nitems", "==", "1", ")", "return", "b", ".", "width", "/", "2", ";", "// indicator in center\r", "int", "item", "=", "table", ".", "getSelectedRowIndex", "(", ")", ";", "// selected item\r", "int", "eff_width", "=", "b", ".", "width", "-", "2", "*", "arrow_size", ";", "// effective width\r", "int", "pixel", "=", "(", "item", "*", "eff_width", ")", "/", "(", "nitems", "-", "1", ")", ";", "// divided into n-1 intervals\r", "return", "pixel", "+", "arrow_size", ";", "}"], "docstring": "return slider indicator position for currently selected item", "docstring_tokens": ["return", "slider", "indicator", "position", "for", "currently", "selected", "item"]}
{"code": "int item = table.getSelectedRowIndex();", "comments": "selected item", "lines": 7, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/SuperComboBox.java", "func_name": "MyTextField.getItemPos", "original_string": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "language": "java", "Allcodes": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "code_tokens": ["protected", "int", "getItemPos", "(", ")", "{", "if", "(", "nitems", "<", "1", ")", "return", "-", "arrow_size", ";", "// dont show indicator\r", "else", "if", "(", "nitems", "==", "1", ")", "return", "b", ".", "width", "/", "2", ";", "// indicator in center\r", "int", "item", "=", "table", ".", "getSelectedRowIndex", "(", ")", ";", "// selected item\r", "int", "eff_width", "=", "b", ".", "width", "-", "2", "*", "arrow_size", ";", "// effective width\r", "int", "pixel", "=", "(", "item", "*", "eff_width", ")", "/", "(", "nitems", "-", "1", ")", ";", "// divided into n-1 intervals\r", "return", "pixel", "+", "arrow_size", ";", "}"], "docstring": "return slider indicator position for currently selected item", "docstring_tokens": ["return", "slider", "indicator", "position", "for", "currently", "selected", "item"]}
{"code": "int eff_width = b.width - 2*arrow_size;", "comments": "effective width", "lines": 8, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/SuperComboBox.java", "func_name": "MyTextField.getItemPos", "original_string": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "language": "java", "Allcodes": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "code_tokens": ["protected", "int", "getItemPos", "(", ")", "{", "if", "(", "nitems", "<", "1", ")", "return", "-", "arrow_size", ";", "// dont show indicator\r", "else", "if", "(", "nitems", "==", "1", ")", "return", "b", ".", "width", "/", "2", ";", "// indicator in center\r", "int", "item", "=", "table", ".", "getSelectedRowIndex", "(", ")", ";", "// selected item\r", "int", "eff_width", "=", "b", ".", "width", "-", "2", "*", "arrow_size", ";", "// effective width\r", "int", "pixel", "=", "(", "item", "*", "eff_width", ")", "/", "(", "nitems", "-", "1", ")", ";", "// divided into n-1 intervals\r", "return", "pixel", "+", "arrow_size", ";", "}"], "docstring": "return slider indicator position for currently selected item", "docstring_tokens": ["return", "slider", "indicator", "position", "for", "currently", "selected", "item"]}
{"code": "int pixel =  (item * eff_width)/(nitems-1);", "comments": "divided into n-1 intervals", "lines": 9, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/widget/SuperComboBox.java", "func_name": "MyTextField.getItemPos", "original_string": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "language": "java", "Allcodes": "protected int getItemPos() {\r\n      if (nitems < 1)\r\n        return -arrow_size;   // dont show indicator\r\n      else if (nitems == 1)\r\n        return b.width/2;   // indicator in center\r\n\r\n      int item = table.getSelectedRowIndex();  // selected item\r\n      int eff_width = b.width - 2*arrow_size;   // effective width\r\n      int pixel =  (item * eff_width)/(nitems-1);  // divided into n-1 intervals\r\n      return pixel+arrow_size;\r\n    }", "code_tokens": ["protected", "int", "getItemPos", "(", ")", "{", "if", "(", "nitems", "<", "1", ")", "return", "-", "arrow_size", ";", "// dont show indicator\r", "else", "if", "(", "nitems", "==", "1", ")", "return", "b", ".", "width", "/", "2", ";", "// indicator in center\r", "int", "item", "=", "table", ".", "getSelectedRowIndex", "(", ")", ";", "// selected item\r", "int", "eff_width", "=", "b", ".", "width", "-", "2", "*", "arrow_size", ";", "// effective width\r", "int", "pixel", "=", "(", "item", "*", "eff_width", ")", "/", "(", "nitems", "-", "1", ")", ";", "// divided into n-1 intervals\r", "return", "pixel", "+", "arrow_size", ";", "}"], "docstring": "return slider indicator position for currently selected item", "docstring_tokens": ["return", "slider", "indicator", "position", "for", "currently", "selected", "item"]}
{"code": "Integer idx = indexMap.get(use);", "comments": "index into unionCoords", "lines": 6, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/coord/CoordinateSharerBest.java", "func_name": "CoordinateSharerBest.reindex", "original_string": "public List<Integer> reindex(List<Coordinate> coords) {\n     List<Integer> result = new ArrayList<>();\n     for (Coordinate coord : coords) {\n       Coordinate sub = swap.get(coord);\n       Coordinate use = (sub == null) ? coord : sub;\n       Integer idx = indexMap.get(use); // index into unionCoords\n       if (idx == null) {\n         throw new IllegalStateException();\n       }\n       result.add(idx);\n     }\n     return result;\n   }", "language": "java", "Allcodes": "public List<Integer> reindex(List<Coordinate> coords) {\n     List<Integer> result = new ArrayList<>();\n     for (Coordinate coord : coords) {\n       Coordinate sub = swap.get(coord);\n       Coordinate use = (sub == null) ? coord : sub;\n       Integer idx = indexMap.get(use); // index into unionCoords\n       if (idx == null) {\n         throw new IllegalStateException();\n       }\n       result.add(idx);\n     }\n     return result;\n   }", "code_tokens": ["public", "List", "<", "Integer", ">", "reindex", "(", "List", "<", "Coordinate", ">", "coords", ")", "{", "List", "<", "Integer", ">", "result", "=", "new", "ArrayList", "<>", "(", ")", ";", "for", "(", "Coordinate", "coord", ":", "coords", ")", "{", "Coordinate", "sub", "=", "swap", ".", "get", "(", "coord", ")", ";", "Coordinate", "use", "=", "(", "sub", "==", "null", ")", "?", "coord", ":", "sub", ";", "Integer", "idx", "=", "indexMap", ".", "get", "(", "use", ")", ";", "// index into unionCoords", "if", "(", "idx", "==", "null", ")", "{", "throw", "new", "IllegalStateException", "(", ")", ";", "}", "result", ".", "add", "(", "idx", ")", ";", "}", "return", "result", ";", "}"], "docstring": "redo the variables against the shared coordinates", "docstring_tokens": ["redo", "the", "variables", "against", "the", "shared", "coordinates"]}
{"code": "GridDataset gridDataset = (GridDataset) result.featureDataset;", "comments": "LOOK wrong", "lines": 12, "repo": "Unidata/thredds", "path": "tdcommon/src/main/java/thredds/server/catalog/writer/ThreddsMetadataExtractor.java", "func_name": "ThreddsMetadataExtractor.extract", "original_string": "public ThreddsMetadata extract(Dataset threddsDataset) throws IOException {\n    ThreddsMetadata metadata = new ThreddsMetadata();\n    Map<String, Object> flds = metadata.getFlds();\n\n    try ( DataFactory.Result result = new DataFactory().openFeatureDataset(threddsDataset, null)) {\n      if (result.fatalError) {\n        logger.warn(\" openFeatureDataset failed, errs=%s%n\", result.errLog);\n        return null;\n      }\n\n      if (result.featureType.isCoverageFeatureType()) {\n        GridDataset gridDataset = (GridDataset) result.featureDataset; // LOOK wrong\n        flds.put(Dataset.GeospatialCoverage, extractGeospatial(gridDataset));\n\n        CalendarDateRange tc = extractCalendarDateRange(gridDataset);\n        if (tc != null)\n          flds.put(Dataset.TimeCoverage, tc);\n\n        ThreddsMetadata.VariableGroup vars = extractVariables(threddsDataset.getDataFormatName(), gridDataset);\n        if (vars != null)\n          flds.put(Dataset.VariableGroups, vars);\n\n      } else if (result.featureType.isPointFeatureType()) {\n        PointDatasetImpl pobsDataset = (PointDatasetImpl) result.featureDataset;\n        LatLonRect llbb = pobsDataset.getBoundingBox();\n        if (null != llbb)\n          flds.put(Dataset.GeospatialCoverage, new ThreddsMetadata.GeospatialCoverage(llbb, null, 0.0, 0.0));\n\n        CalendarDateRange tc = extractCalendarDateRange(pobsDataset);\n        if (tc != null)\n          flds.put(Dataset.TimeCoverage, tc);\n\n        ThreddsMetadata.VariableGroup vars = extractVariables(pobsDataset);\n        if (vars != null)\n          flds.put(Dataset.VariableGroups, vars);\n      }\n\n    } catch (IOException ioe) {\n      logger.error(\"Error opening dataset \" + threddsDataset.getName(), ioe);\n    }\n\n    return metadata;\n  }", "language": "java", "Allcodes": "public ThreddsMetadata extract(Dataset threddsDataset) throws IOException {\n    ThreddsMetadata metadata = new ThreddsMetadata();\n    Map<String, Object> flds = metadata.getFlds();\n\n    try ( DataFactory.Result result = new DataFactory().openFeatureDataset(threddsDataset, null)) {\n      if (result.fatalError) {\n        logger.warn(\" openFeatureDataset failed, errs=%s%n\", result.errLog);\n        return null;\n      }\n\n      if (result.featureType.isCoverageFeatureType()) {\n        GridDataset gridDataset = (GridDataset) result.featureDataset; // LOOK wrong\n        flds.put(Dataset.GeospatialCoverage, extractGeospatial(gridDataset));\n\n        CalendarDateRange tc = extractCalendarDateRange(gridDataset);\n        if (tc != null)\n          flds.put(Dataset.TimeCoverage, tc);\n\n        ThreddsMetadata.VariableGroup vars = extractVariables(threddsDataset.getDataFormatName(), gridDataset);\n        if (vars != null)\n          flds.put(Dataset.VariableGroups, vars);\n\n      } else if (result.featureType.isPointFeatureType()) {\n        PointDatasetImpl pobsDataset = (PointDatasetImpl) result.featureDataset;\n        LatLonRect llbb = pobsDataset.getBoundingBox();\n        if (null != llbb)\n          flds.put(Dataset.GeospatialCoverage, new ThreddsMetadata.GeospatialCoverage(llbb, null, 0.0, 0.0));\n\n        CalendarDateRange tc = extractCalendarDateRange(pobsDataset);\n        if (tc != null)\n          flds.put(Dataset.TimeCoverage, tc);\n\n        ThreddsMetadata.VariableGroup vars = extractVariables(pobsDataset);\n        if (vars != null)\n          flds.put(Dataset.VariableGroups, vars);\n      }\n\n    } catch (IOException ioe) {\n      logger.error(\"Error opening dataset \" + threddsDataset.getName(), ioe);\n    }\n\n    return metadata;\n  }", "code_tokens": ["public", "ThreddsMetadata", "extract", "(", "Dataset", "threddsDataset", ")", "throws", "IOException", "{", "ThreddsMetadata", "metadata", "=", "new", "ThreddsMetadata", "(", ")", ";", "Map", "<", "String", ",", "Object", ">", "flds", "=", "metadata", ".", "getFlds", "(", ")", ";", "try", "(", "DataFactory", ".", "Result", "result", "=", "new", "DataFactory", "(", ")", ".", "openFeatureDataset", "(", "threddsDataset", ",", "null", ")", ")", "{", "if", "(", "result", ".", "fatalError", ")", "{", "logger", ".", "warn", "(", "\" openFeatureDataset failed, errs=%s%n\"", ",", "result", ".", "errLog", ")", ";", "return", "null", ";", "}", "if", "(", "result", ".", "featureType", ".", "isCoverageFeatureType", "(", ")", ")", "{", "GridDataset", "gridDataset", "=", "(", "GridDataset", ")", "result", ".", "featureDataset", ";", "// LOOK wrong", "flds", ".", "put", "(", "Dataset", ".", "GeospatialCoverage", ",", "extractGeospatial", "(", "gridDataset", ")", ")", ";", "CalendarDateRange", "tc", "=", "extractCalendarDateRange", "(", "gridDataset", ")", ";", "if", "(", "tc", "!=", "null", ")", "flds", ".", "put", "(", "Dataset", ".", "TimeCoverage", ",", "tc", ")", ";", "ThreddsMetadata", ".", "VariableGroup", "vars", "=", "extractVariables", "(", "threddsDataset", ".", "getDataFormatName", "(", ")", ",", "gridDataset", ")", ";", "if", "(", "vars", "!=", "null", ")", "flds", ".", "put", "(", "Dataset", ".", "VariableGroups", ",", "vars", ")", ";", "}", "else", "if", "(", "result", ".", "featureType", ".", "isPointFeatureType", "(", ")", ")", "{", "PointDatasetImpl", "pobsDataset", "=", "(", "PointDatasetImpl", ")", "result", ".", "featureDataset", ";", "LatLonRect", "llbb", "=", "pobsDataset", ".", "getBoundingBox", "(", ")", ";", "if", "(", "null", "!=", "llbb", ")", "flds", ".", "put", "(", "Dataset", ".", "GeospatialCoverage", ",", "new", "ThreddsMetadata", ".", "GeospatialCoverage", "(", "llbb", ",", "null", ",", "0.0", ",", "0.0", ")", ")", ";", "CalendarDateRange", "tc", "=", "extractCalendarDateRange", "(", "pobsDataset", ")", ";", "if", "(", "tc", "!=", "null", ")", "flds", ".", "put", "(", "Dataset", ".", "TimeCoverage", ",", "tc", ")", ";", "ThreddsMetadata", ".", "VariableGroup", "vars", "=", "extractVariables", "(", "pobsDataset", ")", ";", "if", "(", "vars", "!=", "null", ")", "flds", ".", "put", "(", "Dataset", ".", "VariableGroups", ",", "vars", ")", ";", "}", "}", "catch", "(", "IOException", "ioe", ")", "{", "logger", ".", "error", "(", "\"Error opening dataset \"", "+", "threddsDataset", ".", "getName", "(", ")", ",", "ioe", ")", ";", "}", "return", "metadata", ";", "}"], "docstring": "extract info from underlying feature dataset\n@param threddsDataset  call DataFactory().openFeatureDataset() to open it\n@return results in ThreddsMetadata object\n@throws IOException", "docstring_tokens": ["extract", "info", "from", "underlying", "feature", "dataset"]}
{"code": "openDatabases = new ArrayList<>();", "comments": "empty", "lines": 8, "repo": "Unidata/thredds", "path": "clcommon/src/main/java/thredds/inventory/bdb/MetadataManager.java", "func_name": "MetadataManager.closeAll", "original_string": "static synchronized public void closeAll() {\n\n    List<MetadataManager> closeDatabases = new ArrayList<>(openDatabases);\n    for (MetadataManager mm : closeDatabases) {\n      if (debug) System.out.println(\"  close database \" + mm.collectionName);\n      mm.close();\n    }\n    openDatabases = new ArrayList<>(); // empty\n\n    if (myEnv != null) {\n      try {\n        // Finally, close the store and environment.\n        myEnv.close();\n        myEnv = null;\n        logger.info(\"closed bdb caching\");\n\n      } catch (DatabaseException dbe) {\n        logger.error(\"Error closing bdb: \", dbe);\n      }\n    }\n  }", "language": "java", "Allcodes": "static synchronized public void closeAll() {\n\n    List<MetadataManager> closeDatabases = new ArrayList<>(openDatabases);\n    for (MetadataManager mm : closeDatabases) {\n      if (debug) System.out.println(\"  close database \" + mm.collectionName);\n      mm.close();\n    }\n    openDatabases = new ArrayList<>(); // empty\n\n    if (myEnv != null) {\n      try {\n        // Finally, close the store and environment.\n        myEnv.close();\n        myEnv = null;\n        logger.info(\"closed bdb caching\");\n\n      } catch (DatabaseException dbe) {\n        logger.error(\"Error closing bdb: \", dbe);\n      }\n    }\n  }", "code_tokens": ["static", "synchronized", "public", "void", "closeAll", "(", ")", "{", "List", "<", "MetadataManager", ">", "closeDatabases", "=", "new", "ArrayList", "<>", "(", "openDatabases", ")", ";", "for", "(", "MetadataManager", "mm", ":", "closeDatabases", ")", "{", "if", "(", "debug", ")", "System", ".", "out", ".", "println", "(", "\"  close database \"", "+", "mm", ".", "collectionName", ")", ";", "mm", ".", "close", "(", ")", ";", "}", "openDatabases", "=", "new", "ArrayList", "<>", "(", ")", ";", "// empty", "if", "(", "myEnv", "!=", "null", ")", "{", "try", "{", "// Finally, close the store and environment.", "myEnv", ".", "close", "(", ")", ";", "myEnv", "=", "null", ";", "logger", ".", "info", "(", "\"closed bdb caching\"", ")", ";", "}", "catch", "(", "DatabaseException", "dbe", ")", "{", "logger", ".", "error", "(", "\"Error closing bdb: \"", ",", "dbe", ")", ";", "}", "}", "}"], "docstring": "this is called on TDS shutdown and reinit", "docstring_tokens": ["this", "is", "called", "on", "TDS", "shutdown", "and", "reinit"]}
{"code": "newCapacity = (int)minCapacity;", "comments": "safe since checked above", "lines": 9, "repo": "Unidata/thredds", "path": "waterml/src/main/java/ucar/nc2/ogc/erddap/util/ErddapStringArray.java", "func_name": "ErddapStringArray.ensureCapacity", "original_string": "public void ensureCapacity(long minCapacity) {\n        if (array.length < minCapacity) {\n            //ensure minCapacity is < Integer.MAX_VALUE\n            ErddapMath2.ensureArraySizeOkay(minCapacity, \"StringArray\");\n\n            //caller may know exact number needed, so don't double above 2x current size\n            int newCapacity = (int)Math.min(Integer.MAX_VALUE - 1, array.length + (long)array.length); \n            if (newCapacity < minCapacity) \n                newCapacity = (int)minCapacity; //safe since checked above\n\n            String[] newArray = new String[newCapacity];\n            System.arraycopy(array, 0, newArray, 0, size);\n            array = newArray; //do last to minimize concurrency problems\n        }\n    }", "language": "java", "Allcodes": "public void ensureCapacity(long minCapacity) {\n        if (array.length < minCapacity) {\n            //ensure minCapacity is < Integer.MAX_VALUE\n            ErddapMath2.ensureArraySizeOkay(minCapacity, \"StringArray\");\n\n            //caller may know exact number needed, so don't double above 2x current size\n            int newCapacity = (int)Math.min(Integer.MAX_VALUE - 1, array.length + (long)array.length); \n            if (newCapacity < minCapacity) \n                newCapacity = (int)minCapacity; //safe since checked above\n\n            String[] newArray = new String[newCapacity];\n            System.arraycopy(array, 0, newArray, 0, size);\n            array = newArray; //do last to minimize concurrency problems\n        }\n    }", "code_tokens": ["public", "void", "ensureCapacity", "(", "long", "minCapacity", ")", "{", "if", "(", "array", ".", "length", "<", "minCapacity", ")", "{", "//ensure minCapacity is < Integer.MAX_VALUE", "ErddapMath2", ".", "ensureArraySizeOkay", "(", "minCapacity", ",", "\"StringArray\"", ")", ";", "//caller may know exact number needed, so don't double above 2x current size", "int", "newCapacity", "=", "(", "int", ")", "Math", ".", "min", "(", "Integer", ".", "MAX_VALUE", "-", "1", ",", "array", ".", "length", "+", "(", "long", ")", "array", ".", "length", ")", ";", "if", "(", "newCapacity", "<", "minCapacity", ")", "newCapacity", "=", "(", "int", ")", "minCapacity", ";", "//safe since checked above", "String", "[", "]", "newArray", "=", "new", "String", "[", "newCapacity", "]", ";", "System", ".", "arraycopy", "(", "array", ",", "0", ",", "newArray", ",", "0", ",", "size", ")", ";", "array", "=", "newArray", ";", "//do last to minimize concurrency problems", "}", "}"], "docstring": "This ensures that the capacity is at least 'minCapacity'.\n\n@param minCapacity the minimum acceptable capacity.\nminCapacity is type long, but &gt;= Integer.MAX_VALUE will throw exception.", "docstring_tokens": ["This", "ensures", "that", "the", "capacity", "is", "at", "least", "minCapacity", "."]}
{"code": "array = newArray;", "comments": "do last to minimize concurrency problems", "lines": 13, "repo": "Unidata/thredds", "path": "waterml/src/main/java/ucar/nc2/ogc/erddap/util/ErddapStringArray.java", "func_name": "ErddapStringArray.ensureCapacity", "original_string": "public void ensureCapacity(long minCapacity) {\n        if (array.length < minCapacity) {\n            //ensure minCapacity is < Integer.MAX_VALUE\n            ErddapMath2.ensureArraySizeOkay(minCapacity, \"StringArray\");\n\n            //caller may know exact number needed, so don't double above 2x current size\n            int newCapacity = (int)Math.min(Integer.MAX_VALUE - 1, array.length + (long)array.length); \n            if (newCapacity < minCapacity) \n                newCapacity = (int)minCapacity; //safe since checked above\n\n            String[] newArray = new String[newCapacity];\n            System.arraycopy(array, 0, newArray, 0, size);\n            array = newArray; //do last to minimize concurrency problems\n        }\n    }", "language": "java", "Allcodes": "public void ensureCapacity(long minCapacity) {\n        if (array.length < minCapacity) {\n            //ensure minCapacity is < Integer.MAX_VALUE\n            ErddapMath2.ensureArraySizeOkay(minCapacity, \"StringArray\");\n\n            //caller may know exact number needed, so don't double above 2x current size\n            int newCapacity = (int)Math.min(Integer.MAX_VALUE - 1, array.length + (long)array.length); \n            if (newCapacity < minCapacity) \n                newCapacity = (int)minCapacity; //safe since checked above\n\n            String[] newArray = new String[newCapacity];\n            System.arraycopy(array, 0, newArray, 0, size);\n            array = newArray; //do last to minimize concurrency problems\n        }\n    }", "code_tokens": ["public", "void", "ensureCapacity", "(", "long", "minCapacity", ")", "{", "if", "(", "array", ".", "length", "<", "minCapacity", ")", "{", "//ensure minCapacity is < Integer.MAX_VALUE", "ErddapMath2", ".", "ensureArraySizeOkay", "(", "minCapacity", ",", "\"StringArray\"", ")", ";", "//caller may know exact number needed, so don't double above 2x current size", "int", "newCapacity", "=", "(", "int", ")", "Math", ".", "min", "(", "Integer", ".", "MAX_VALUE", "-", "1", ",", "array", ".", "length", "+", "(", "long", ")", "array", ".", "length", ")", ";", "if", "(", "newCapacity", "<", "minCapacity", ")", "newCapacity", "=", "(", "int", ")", "minCapacity", ";", "//safe since checked above", "String", "[", "]", "newArray", "=", "new", "String", "[", "newCapacity", "]", ";", "System", ".", "arraycopy", "(", "array", ",", "0", ",", "newArray", ",", "0", ",", "size", ")", ";", "array", "=", "newArray", ";", "//do last to minimize concurrency problems", "}", "}"], "docstring": "This ensures that the capacity is at least 'minCapacity'.\n\n@param minCapacity the minimum acceptable capacity.\nminCapacity is type long, but &gt;= Integer.MAX_VALUE will throw exception.", "docstring_tokens": ["This", "ensures", "that", "the", "capacity", "is", "at", "least", "minCapacity", "."]}
{"code": "if (line == null) break;", "comments": "done with the file", "lines": 21, "repo": "Unidata/thredds", "path": "grib/src/main/java/ucar/nc2/grib/grib1/tables/EcmwfLocalConcepts.java", "func_name": "EcmwfLocalConcepts.addLocalConcept", "original_string": "private void addLocalConcept(InputStream is, String conceptName) throws IOException {\n        /*\n        example entry from name.def:\n\n        #Total precipitation of at least 5 mm\n        'Total precipitation of at least 5 mm' = {\n             table2Version = 131 ;\n             indicatorOfParameter = 61 ;\n            }\n         */\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, ENCODING))) {\n            String line = br.readLine();\n\n            while (!line.startsWith(\"#\"))\n                line = br.readLine(); // skip\n\n            while (true) {\n                HashMap<String, String> items = new HashMap<>();\n                line = br.readLine();\n                if (line == null) break; // done with the file\n                if ((line.length() == 0) || line.startsWith(\"#\")) continue;\n                line = cleanLine(line);\n                if (line.contains(\"{\")) {\n                    String paramName = line.split(\"=\")[0].trim();\n                    line = br.readLine();\n                    if (line == null) break; // done with the file\n                    line = cleanLine(line);\n                    while (line.contains(\"=\")) {\n                        String[] kvp = line.split(\"=\");\n                        items.put(kvp[0].trim(), kvp[1].trim());\n                        line = br.readLine();\n                        if (line == null) break; // done with the file\n                        line = cleanLine(line);                    }\n                    String tableVersion = items.get(TABLE_VERSION_ID);\n                    String parameterNumber = items.get(PARAM_NUM_ID);\n\n                    storeConcept(tableVersion, parameterNumber, conceptName, paramName);\n                }\n            }\n        }\n    }", "language": "java", "Allcodes": "private void addLocalConcept(InputStream is, String conceptName) throws IOException {\n        /*\n        example entry from name.def:\n\n        #Total precipitation of at least 5 mm\n        'Total precipitation of at least 5 mm' = {\n             table2Version = 131 ;\n             indicatorOfParameter = 61 ;\n            }\n         */\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, ENCODING))) {\n            String line = br.readLine();\n\n            while (!line.startsWith(\"#\"))\n                line = br.readLine(); // skip\n\n            while (true) {\n                HashMap<String, String> items = new HashMap<>();\n                line = br.readLine();\n                if (line == null) break; // done with the file\n                if ((line.length() == 0) || line.startsWith(\"#\")) continue;\n                line = cleanLine(line);\n                if (line.contains(\"{\")) {\n                    String paramName = line.split(\"=\")[0].trim();\n                    line = br.readLine();\n                    if (line == null) break; // done with the file\n                    line = cleanLine(line);\n                    while (line.contains(\"=\")) {\n                        String[] kvp = line.split(\"=\");\n                        items.put(kvp[0].trim(), kvp[1].trim());\n                        line = br.readLine();\n                        if (line == null) break; // done with the file\n                        line = cleanLine(line);                    }\n                    String tableVersion = items.get(TABLE_VERSION_ID);\n                    String parameterNumber = items.get(PARAM_NUM_ID);\n\n                    storeConcept(tableVersion, parameterNumber, conceptName, paramName);\n                }\n            }\n        }\n    }", "code_tokens": ["private", "void", "addLocalConcept", "(", "InputStream", "is", ",", "String", "conceptName", ")", "throws", "IOException", "{", "/*\n        example entry from name.def:\n\n        #Total precipitation of at least 5 mm\n        'Total precipitation of at least 5 mm' = {\n             table2Version = 131 ;\n             indicatorOfParameter = 61 ;\n            }\n         */", "try", "(", "BufferedReader", "br", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "is", ",", "ENCODING", ")", ")", ")", "{", "String", "line", "=", "br", ".", "readLine", "(", ")", ";", "while", "(", "!", "line", ".", "startsWith", "(", "\"#\"", ")", ")", "line", "=", "br", ".", "readLine", "(", ")", ";", "// skip", "while", "(", "true", ")", "{", "HashMap", "<", "String", ",", "String", ">", "items", "=", "new", "HashMap", "<>", "(", ")", ";", "line", "=", "br", ".", "readLine", "(", ")", ";", "if", "(", "line", "==", "null", ")", "break", ";", "// done with the file", "if", "(", "(", "line", ".", "length", "(", ")", "==", "0", ")", "||", "line", ".", "startsWith", "(", "\"#\"", ")", ")", "continue", ";", "line", "=", "cleanLine", "(", "line", ")", ";", "if", "(", "line", ".", "contains", "(", "\"{\"", ")", ")", "{", "String", "paramName", "=", "line", ".", "split", "(", "\"=\"", ")", "[", "0", "]", ".", "trim", "(", ")", ";", "line", "=", "br", ".", "readLine", "(", ")", ";", "if", "(", "line", "==", "null", ")", "break", ";", "// done with the file", "line", "=", "cleanLine", "(", "line", ")", ";", "while", "(", "line", ".", "contains", "(", "\"=\"", ")", ")", "{", "String", "[", "]", "kvp", "=", "line", ".", "split", "(", "\"=\"", ")", ";", "items", ".", "put", "(", "kvp", "[", "0", "]", ".", "trim", "(", ")", ",", "kvp", "[", "1", "]", ".", "trim", "(", ")", ")", ";", "line", "=", "br", ".", "readLine", "(", ")", ";", "if", "(", "line", "==", "null", ")", "break", ";", "// done with the file", "line", "=", "cleanLine", "(", "line", ")", ";", "}", "String", "tableVersion", "=", "items", ".", "get", "(", "TABLE_VERSION_ID", ")", ";", "String", "parameterNumber", "=", "items", ".", "get", "(", "PARAM_NUM_ID", ")", ";", "storeConcept", "(", "tableVersion", ",", "parameterNumber", ",", "conceptName", ",", "paramName", ")", ";", "}", "}", "}", "}"], "docstring": "Add the information from a localConcept file to super HashMap localConcepts\n\n@param is InputStream of the localConcept file\n@param conceptName \"type\" of localConcept being added", "docstring_tokens": ["Add", "the", "information", "from", "a", "localConcept", "file", "to", "super", "HashMap", "localConcepts"]}
{"code": "root = StringUtil2.replace(cacheDir, '\\\\', \"/\");", "comments": "no nasty backslash", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/DiskCache.java", "func_name": "DiskCache.setRootDirectory", "original_string": "static public void setRootDirectory(String cacheDir) {\r\n    if (!cacheDir.endsWith(\"/\"))\r\n      cacheDir = cacheDir + \"/\";\r\n    root = StringUtil2.replace(cacheDir, '\\\\', \"/\"); // no nasty backslash\r\n\r\n    makeRootDirectory();\r\n  }", "language": "java", "Allcodes": "static public void setRootDirectory(String cacheDir) {\r\n    if (!cacheDir.endsWith(\"/\"))\r\n      cacheDir = cacheDir + \"/\";\r\n    root = StringUtil2.replace(cacheDir, '\\\\', \"/\"); // no nasty backslash\r\n\r\n    makeRootDirectory();\r\n  }", "code_tokens": ["static", "public", "void", "setRootDirectory", "(", "String", "cacheDir", ")", "{", "if", "(", "!", "cacheDir", ".", "endsWith", "(", "\"/\"", ")", ")", "cacheDir", "=", "cacheDir", "+", "\"/\"", ";", "root", "=", "StringUtil2", ".", "replace", "(", "cacheDir", ",", "'", "'", ",", "\"/\"", ")", ";", "// no nasty backslash\r", "makeRootDirectory", "(", ")", ";", "}"], "docstring": "Set the cache root directory. Create it if it doesnt exist.\n\n@param cacheDir the cache directory", "docstring_tokens": ["Set", "the", "cache", "root", "directory", ".", "Create", "it", "if", "it", "doesnt", "exist", "."]}
{"code": "axis.cache = new Variable.Cache();", "comments": "decouple cache", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/dataset/CoordinateAxis.java", "func_name": "CoordinateAxis.copyNoCache", "original_string": "public CoordinateAxis copyNoCache() {\n    CoordinateAxis axis = new CoordinateAxis(ncd, getParentGroup(), getShortName(), getDataType(), getDimensionsString(),\n            getUnitsString(), getDescription());\n\n    // other state\n    axis.axisType = this.axisType;\n    axis.boundaryRef = this.boundaryRef;\n    axis.isContiguous = this.isContiguous;\n    axis.positive = this.positive;\n\n    axis.cache = new Variable.Cache(); // decouple cache\n    return axis;\n  }", "language": "java", "Allcodes": "public CoordinateAxis copyNoCache() {\n    CoordinateAxis axis = new CoordinateAxis(ncd, getParentGroup(), getShortName(), getDataType(), getDimensionsString(),\n            getUnitsString(), getDescription());\n\n    // other state\n    axis.axisType = this.axisType;\n    axis.boundaryRef = this.boundaryRef;\n    axis.isContiguous = this.isContiguous;\n    axis.positive = this.positive;\n\n    axis.cache = new Variable.Cache(); // decouple cache\n    return axis;\n  }", "code_tokens": ["public", "CoordinateAxis", "copyNoCache", "(", ")", "{", "CoordinateAxis", "axis", "=", "new", "CoordinateAxis", "(", "ncd", ",", "getParentGroup", "(", ")", ",", "getShortName", "(", ")", ",", "getDataType", "(", ")", ",", "getDimensionsString", "(", ")", ",", "getUnitsString", "(", ")", ",", "getDescription", "(", ")", ")", ";", "// other state", "axis", ".", "axisType", "=", "this", ".", "axisType", ";", "axis", ".", "boundaryRef", "=", "this", ".", "boundaryRef", ";", "axis", ".", "isContiguous", "=", "this", ".", "isContiguous", ";", "axis", ".", "positive", "=", "this", ".", "positive", ";", "axis", ".", "cache", "=", "new", "Variable", ".", "Cache", "(", ")", ";", "// decouple cache", "return", "axis", ";", "}"], "docstring": "Make a copy, with an independent cache.\n\n@return copy of this CoordinateAxis", "docstring_tokens": ["Make", "a", "copy", "with", "an", "independent", "cache", "."]}
{"code": "double e = DEG2RAD * (lonlat[0] - rot1);", "comments": "east", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/projection/RotatedLatLon.java", "func_name": "RotatedLatLon.rotate", "original_string": "private double[] rotate(double[] lonlat, double rot1, double rot2, double s) {\r\n\r\n    /* original code\r\n      double e = DEG2RAD * (lonlat[0] - rot1); //east\r\n      double n = DEG2RAD * lonlat[1]; //north\r\n      double cn = Math.cos(n);\r\n      double x = cn * Math.cos(e);\r\n      double y = cn * Math.sin(e);\r\n      double z = Math.sin(n);\r\n      double x2 = cosDlat * x + s * z;\r\n      double z2 = -s * x + cosDlat * z;\r\n      double R = Math.sqrt(x2 * x2 + y * y);\r\n      double e2 = Math.atan2(y, x2);\r\n      double n2 = Math.atan2(z2, R);\r\n      double rlon = RAD2DEG * e2 - rot2;\r\n      double rlat = RAD2DEG * n2;\r\n      return new double[]{rlon, rlat};\r\n     */\r\n\r\n    double e = Math.toRadians(lonlat[0] - rot1); //east\r\n    double n = Math.toRadians(lonlat[1]); //north\r\n    double cn = Math.cos(n);\r\n    double x = cn * Math.cos(e);\r\n    double y = cn * Math.sin(e);\r\n    double z = Math.sin(n);\r\n    double x2 = cosDlat * x + s * z;\r\n    double z2 = -s * x + cosDlat * z;\r\n    double R = Math.sqrt(x2 * x2 + y * y);\r\n    double e2 = Math.atan2(y, x2);\r\n    double n2 = Math.atan2(z2, R);\r\n    double rlon = Math.toDegrees(e2) - rot2;\r\n    double rlat =  Math.toDegrees(n2);\r\n    return new double[]{rlon, rlat};\r\n\r\n  }", "language": "java", "Allcodes": "private double[] rotate(double[] lonlat, double rot1, double rot2, double s) {\r\n\r\n    /* original code\r\n      double e = DEG2RAD * (lonlat[0] - rot1); //east\r\n      double n = DEG2RAD * lonlat[1]; //north\r\n      double cn = Math.cos(n);\r\n      double x = cn * Math.cos(e);\r\n      double y = cn * Math.sin(e);\r\n      double z = Math.sin(n);\r\n      double x2 = cosDlat * x + s * z;\r\n      double z2 = -s * x + cosDlat * z;\r\n      double R = Math.sqrt(x2 * x2 + y * y);\r\n      double e2 = Math.atan2(y, x2);\r\n      double n2 = Math.atan2(z2, R);\r\n      double rlon = RAD2DEG * e2 - rot2;\r\n      double rlat = RAD2DEG * n2;\r\n      return new double[]{rlon, rlat};\r\n     */\r\n\r\n    double e = Math.toRadians(lonlat[0] - rot1); //east\r\n    double n = Math.toRadians(lonlat[1]); //north\r\n    double cn = Math.cos(n);\r\n    double x = cn * Math.cos(e);\r\n    double y = cn * Math.sin(e);\r\n    double z = Math.sin(n);\r\n    double x2 = cosDlat * x + s * z;\r\n    double z2 = -s * x + cosDlat * z;\r\n    double R = Math.sqrt(x2 * x2 + y * y);\r\n    double e2 = Math.atan2(y, x2);\r\n    double n2 = Math.atan2(z2, R);\r\n    double rlon = Math.toDegrees(e2) - rot2;\r\n    double rlat =  Math.toDegrees(n2);\r\n    return new double[]{rlon, rlat};\r\n\r\n  }", "code_tokens": ["private", "double", "[", "]", "rotate", "(", "double", "[", "]", "lonlat", ",", "double", "rot1", ",", "double", "rot2", ",", "double", "s", ")", "{", "/* original code\r\n      double e = DEG2RAD * (lonlat[0] - rot1); //east\r\n      double n = DEG2RAD * lonlat[1]; //north\r\n      double cn = Math.cos(n);\r\n      double x = cn * Math.cos(e);\r\n      double y = cn * Math.sin(e);\r\n      double z = Math.sin(n);\r\n      double x2 = cosDlat * x + s * z;\r\n      double z2 = -s * x + cosDlat * z;\r\n      double R = Math.sqrt(x2 * x2 + y * y);\r\n      double e2 = Math.atan2(y, x2);\r\n      double n2 = Math.atan2(z2, R);\r\n      double rlon = RAD2DEG * e2 - rot2;\r\n      double rlat = RAD2DEG * n2;\r\n      return new double[]{rlon, rlat};\r\n     */", "double", "e", "=", "Math", ".", "toRadians", "(", "lonlat", "[", "0", "]", "-", "rot1", ")", ";", "//east\r", "double", "n", "=", "Math", ".", "toRadians", "(", "lonlat", "[", "1", "]", ")", ";", "//north\r", "double", "cn", "=", "Math", ".", "cos", "(", "n", ")", ";", "double", "x", "=", "cn", "*", "Math", ".", "cos", "(", "e", ")", ";", "double", "y", "=", "cn", "*", "Math", ".", "sin", "(", "e", ")", ";", "double", "z", "=", "Math", ".", "sin", "(", "n", ")", ";", "double", "x2", "=", "cosDlat", "*", "x", "+", "s", "*", "z", ";", "double", "z2", "=", "-", "s", "*", "x", "+", "cosDlat", "*", "z", ";", "double", "R", "=", "Math", ".", "sqrt", "(", "x2", "*", "x2", "+", "y", "*", "y", ")", ";", "double", "e2", "=", "Math", ".", "atan2", "(", "y", ",", "x2", ")", ";", "double", "n2", "=", "Math", ".", "atan2", "(", "z2", ",", "R", ")", ";", "double", "rlon", "=", "Math", ".", "toDegrees", "(", "e2", ")", "-", "rot2", ";", "double", "rlat", "=", "Math", ".", "toDegrees", "(", "n2", ")", ";", "return", "new", "double", "[", "]", "{", "rlon", ",", "rlat", "}", ";", "}"], "docstring": "Tor's transform algorithm renamed to rotate for clarity", "docstring_tokens": ["Tor", "s", "transform", "algorithm", "renamed", "to", "rotate", "for", "clarity"]}
{"code": "double n = DEG2RAD * lonlat[1];", "comments": "north", "lines": 5, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/unidata/geoloc/projection/RotatedLatLon.java", "func_name": "RotatedLatLon.rotate", "original_string": "private double[] rotate(double[] lonlat, double rot1, double rot2, double s) {\r\n\r\n    /* original code\r\n      double e = DEG2RAD * (lonlat[0] - rot1); //east\r\n      double n = DEG2RAD * lonlat[1]; //north\r\n      double cn = Math.cos(n);\r\n      double x = cn * Math.cos(e);\r\n      double y = cn * Math.sin(e);\r\n      double z = Math.sin(n);\r\n      double x2 = cosDlat * x + s * z;\r\n      double z2 = -s * x + cosDlat * z;\r\n      double R = Math.sqrt(x2 * x2 + y * y);\r\n      double e2 = Math.atan2(y, x2);\r\n      double n2 = Math.atan2(z2, R);\r\n      double rlon = RAD2DEG * e2 - rot2;\r\n      double rlat = RAD2DEG * n2;\r\n      return new double[]{rlon, rlat};\r\n     */\r\n\r\n    double e = Math.toRadians(lonlat[0] - rot1); //east\r\n    double n = Math.toRadians(lonlat[1]); //north\r\n    double cn = Math.cos(n);\r\n    double x = cn * Math.cos(e);\r\n    double y = cn * Math.sin(e);\r\n    double z = Math.sin(n);\r\n    double x2 = cosDlat * x + s * z;\r\n    double z2 = -s * x + cosDlat * z;\r\n    double R = Math.sqrt(x2 * x2 + y * y);\r\n    double e2 = Math.atan2(y, x2);\r\n    double n2 = Math.atan2(z2, R);\r\n    double rlon = Math.toDegrees(e2) - rot2;\r\n    double rlat =  Math.toDegrees(n2);\r\n    return new double[]{rlon, rlat};\r\n\r\n  }", "language": "java", "Allcodes": "private double[] rotate(double[] lonlat, double rot1, double rot2, double s) {\r\n\r\n    /* original code\r\n      double e = DEG2RAD * (lonlat[0] - rot1); //east\r\n      double n = DEG2RAD * lonlat[1]; //north\r\n      double cn = Math.cos(n);\r\n      double x = cn * Math.cos(e);\r\n      double y = cn * Math.sin(e);\r\n      double z = Math.sin(n);\r\n      double x2 = cosDlat * x + s * z;\r\n      double z2 = -s * x + cosDlat * z;\r\n      double R = Math.sqrt(x2 * x2 + y * y);\r\n      double e2 = Math.atan2(y, x2);\r\n      double n2 = Math.atan2(z2, R);\r\n      double rlon = RAD2DEG * e2 - rot2;\r\n      double rlat = RAD2DEG * n2;\r\n      return new double[]{rlon, rlat};\r\n     */\r\n\r\n    double e = Math.toRadians(lonlat[0] - rot1); //east\r\n    double n = Math.toRadians(lonlat[1]); //north\r\n    double cn = Math.cos(n);\r\n    double x = cn * Math.cos(e);\r\n    double y = cn * Math.sin(e);\r\n    double z = Math.sin(n);\r\n    double x2 = cosDlat * x + s * z;\r\n    double z2 = -s * x + cosDlat * z;\r\n    double R = Math.sqrt(x2 * x2 + y * y);\r\n    double e2 = Math.atan2(y, x2);\r\n    double n2 = Math.atan2(z2, R);\r\n    double rlon = Math.toDegrees(e2) - rot2;\r\n    double rlat =  Math.toDegrees(n2);\r\n    return new double[]{rlon, rlat};\r\n\r\n  }", "code_tokens": ["private", "double", "[", "]", "rotate", "(", "double", "[", "]", "lonlat", ",", "double", "rot1", ",", "double", "rot2", ",", "double", "s", ")", "{", "/* original code\r\n      double e = DEG2RAD * (lonlat[0] - rot1); //east\r\n      double n = DEG2RAD * lonlat[1]; //north\r\n      double cn = Math.cos(n);\r\n      double x = cn * Math.cos(e);\r\n      double y = cn * Math.sin(e);\r\n      double z = Math.sin(n);\r\n      double x2 = cosDlat * x + s * z;\r\n      double z2 = -s * x + cosDlat * z;\r\n      double R = Math.sqrt(x2 * x2 + y * y);\r\n      double e2 = Math.atan2(y, x2);\r\n      double n2 = Math.atan2(z2, R);\r\n      double rlon = RAD2DEG * e2 - rot2;\r\n      double rlat = RAD2DEG * n2;\r\n      return new double[]{rlon, rlat};\r\n     */", "double", "e", "=", "Math", ".", "toRadians", "(", "lonlat", "[", "0", "]", "-", "rot1", ")", ";", "//east\r", "double", "n", "=", "Math", ".", "toRadians", "(", "lonlat", "[", "1", "]", ")", ";", "//north\r", "double", "cn", "=", "Math", ".", "cos", "(", "n", ")", ";", "double", "x", "=", "cn", "*", "Math", ".", "cos", "(", "e", ")", ";", "double", "y", "=", "cn", "*", "Math", ".", "sin", "(", "e", ")", ";", "double", "z", "=", "Math", ".", "sin", "(", "n", ")", ";", "double", "x2", "=", "cosDlat", "*", "x", "+", "s", "*", "z", ";", "double", "z2", "=", "-", "s", "*", "x", "+", "cosDlat", "*", "z", ";", "double", "R", "=", "Math", ".", "sqrt", "(", "x2", "*", "x2", "+", "y", "*", "y", ")", ";", "double", "e2", "=", "Math", ".", "atan2", "(", "y", ",", "x2", ")", ";", "double", "n2", "=", "Math", ".", "atan2", "(", "z2", ",", "R", ")", ";", "double", "rlon", "=", "Math", ".", "toDegrees", "(", "e2", ")", "-", "rot2", ";", "double", "rlat", "=", "Math", ".", "toDegrees", "(", "n2", ")", ";", "return", "new", "double", "[", "]", "{", "rlon", ",", "rlat", "}", ";", "}"], "docstring": "Tor's transform algorithm renamed to rotate for clarity", "docstring_tokens": ["Tor", "s", "transform", "algorithm", "renamed", "to", "rotate", "for", "clarity"]}
{"code": "boolean ok = f.mkdirs();", "comments": "now ready for file creation in writeXML", "lines": 14, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/util/prefs/XMLStore.java", "func_name": "XMLStore.makeStandardFilename", "original_string": "static public String makeStandardFilename(String appName, String storeName) {\n      // the directory\n    String userHome = null;\n    try {\n      userHome = System.getProperty(\"user.home\");\n    } catch (Exception e) {\n      System.out.println( \"XMLStore.makeStandardFilename: error System.getProperty(user.home) \"+e);\n    }\n    if (null == userHome) userHome = \".\";\n\n    String dirFilename = userHome+\"/\"+appName;\n    File f = new File(dirFilename);\n    if (!f.exists()) {\n      boolean ok = f.mkdirs(); // now ready for file creation in writeXML\n      if (!ok)\n        System.out.println(\"Error creating directories: \" + f.getAbsolutePath());\n    }\n    return dirFilename +\"/\"+ storeName;\n  }", "language": "java", "Allcodes": "static public String makeStandardFilename(String appName, String storeName) {\n      // the directory\n    String userHome = null;\n    try {\n      userHome = System.getProperty(\"user.home\");\n    } catch (Exception e) {\n      System.out.println( \"XMLStore.makeStandardFilename: error System.getProperty(user.home) \"+e);\n    }\n    if (null == userHome) userHome = \".\";\n\n    String dirFilename = userHome+\"/\"+appName;\n    File f = new File(dirFilename);\n    if (!f.exists()) {\n      boolean ok = f.mkdirs(); // now ready for file creation in writeXML\n      if (!ok)\n        System.out.println(\"Error creating directories: \" + f.getAbsolutePath());\n    }\n    return dirFilename +\"/\"+ storeName;\n  }", "code_tokens": ["static", "public", "String", "makeStandardFilename", "(", "String", "appName", ",", "String", "storeName", ")", "{", "// the directory", "String", "userHome", "=", "null", ";", "try", "{", "userHome", "=", "System", ".", "getProperty", "(", "\"user.home\"", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "System", ".", "out", ".", "println", "(", "\"XMLStore.makeStandardFilename: error System.getProperty(user.home) \"", "+", "e", ")", ";", "}", "if", "(", "null", "==", "userHome", ")", "userHome", "=", "\".\"", ";", "String", "dirFilename", "=", "userHome", "+", "\"/\"", "+", "appName", ";", "File", "f", "=", "new", "File", "(", "dirFilename", ")", ";", "if", "(", "!", "f", ".", "exists", "(", ")", ")", "{", "boolean", "ok", "=", "f", ".", "mkdirs", "(", ")", ";", "// now ready for file creation in writeXML", "if", "(", "!", "ok", ")", "System", ".", "out", ".", "println", "(", "\"Error creating directories: \"", "+", "f", ".", "getAbsolutePath", "(", ")", ")", ";", "}", "return", "dirFilename", "+", "\"/\"", "+", "storeName", ";", "}"], "docstring": "Convenience routine for creating an XMLStore file in a standard place.\n\n<p> Initialize:\n<ol>\n<li> $user.home = System.getProperty(\"user.home\"), if not exist, use \".\"\n<li> create directory \"$(user_home)/appName/\" , if not exist, create it\n<li> return  \"$(user_home)/appName/storeName\" for use in createFromFile()\n</ol>\n@param appName application name\n@param storeName store name\n@return  standard file name", "docstring_tokens": ["Convenience", "routine", "for", "creating", "an", "XMLStore", "file", "in", "a", "standard", "place", "."]}
{"code": "if(!this.ce.references(field)) continue;", "comments": "not in the view", "lines": 13, "repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/DapSerializer.java", "func_name": "DapSerializer.writeStructure1", "original_string": "protected void\n    writeStructure1(DataCursor instance, SerialWriter dst)\n            throws IOException\n    {\n        assert instance.getScheme() == DataCursor.Scheme.STRUCTURE;\n        DapVariable template = (DapVariable) instance.getTemplate();\n        assert (this.ce.references(template));\n        DapStructure ds = (DapStructure) template.getBaseType();\n\n        List<DapVariable> fields = ds.getFields();\n        for(int i = 0; i < fields.size(); i++) {\n            DapVariable field = fields.get(i);\n            if(!this.ce.references(field)) continue; // not in the view\n            DataCursor df = (DataCursor) instance.readField(i);\n            writeVariable(df, dst);\n        }\n    }", "language": "java", "Allcodes": "protected void\n    writeStructure1(DataCursor instance, SerialWriter dst)\n            throws IOException\n    {\n        assert instance.getScheme() == DataCursor.Scheme.STRUCTURE;\n        DapVariable template = (DapVariable) instance.getTemplate();\n        assert (this.ce.references(template));\n        DapStructure ds = (DapStructure) template.getBaseType();\n\n        List<DapVariable> fields = ds.getFields();\n        for(int i = 0; i < fields.size(); i++) {\n            DapVariable field = fields.get(i);\n            if(!this.ce.references(field)) continue; // not in the view\n            DataCursor df = (DataCursor) instance.readField(i);\n            writeVariable(df, dst);\n        }\n    }", "code_tokens": ["protected", "void", "writeStructure1", "(", "DataCursor", "instance", ",", "SerialWriter", "dst", ")", "throws", "IOException", "{", "assert", "instance", ".", "getScheme", "(", ")", "==", "DataCursor", ".", "Scheme", ".", "STRUCTURE", ";", "DapVariable", "template", "=", "(", "DapVariable", ")", "instance", ".", "getTemplate", "(", ")", ";", "assert", "(", "this", ".", "ce", ".", "references", "(", "template", ")", ")", ";", "DapStructure", "ds", "=", "(", "DapStructure", ")", "template", ".", "getBaseType", "(", ")", ";", "List", "<", "DapVariable", ">", "fields", "=", "ds", ".", "getFields", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "fields", ".", "size", "(", ")", ";", "i", "++", ")", "{", "DapVariable", "field", "=", "fields", ".", "get", "(", "i", ")", ";", "if", "(", "!", "this", ".", "ce", ".", "references", "(", "field", ")", ")", "continue", ";", "// not in the view", "DataCursor", "df", "=", "(", "DataCursor", ")", "instance", ".", "readField", "(", "i", ")", ";", "writeVariable", "(", "df", ",", "dst", ")", ";", "}", "}"], "docstring": "Write out a single structure instance\n\n@param instance\n@param dst      - where to write\n@throws dap4.core.util.DapException", "docstring_tokens": ["Write", "out", "a", "single", "structure", "instance"]}
{"code": "if (!raf.searchForward(matcher, 40 * 1000)) return false;", "comments": "must find \"BUFR\" in first 40k", "lines": 3, "repo": "Unidata/thredds", "path": "bufr/src/main/java/ucar/nc2/iosp/bufr/MessageScanner.java", "func_name": "MessageScanner.isValidFile", "original_string": "static public boolean isValidFile(ucar.unidata.io.RandomAccessFile raf) throws IOException {\r\n    raf.seek(0);\r\n    if (!raf.searchForward(matcher, 40 * 1000)) return false; // must find \"BUFR\" in first 40k\r\n    raf.skipBytes(4);\r\n    BufrIndicatorSection is = new BufrIndicatorSection(raf);\r\n    if (is.getBufrEdition() > 4) return false;\r\n    // if(is.getBufrLength() > MAX_MESSAGE_SIZE) return false;\r\n    return !(is.getBufrLength() > raf.length());\r\n  }", "language": "java", "Allcodes": "static public boolean isValidFile(ucar.unidata.io.RandomAccessFile raf) throws IOException {\r\n    raf.seek(0);\r\n    if (!raf.searchForward(matcher, 40 * 1000)) return false; // must find \"BUFR\" in first 40k\r\n    raf.skipBytes(4);\r\n    BufrIndicatorSection is = new BufrIndicatorSection(raf);\r\n    if (is.getBufrEdition() > 4) return false;\r\n    // if(is.getBufrLength() > MAX_MESSAGE_SIZE) return false;\r\n    return !(is.getBufrLength() > raf.length());\r\n  }", "code_tokens": ["static", "public", "boolean", "isValidFile", "(", "ucar", ".", "unidata", ".", "io", ".", "RandomAccessFile", "raf", ")", "throws", "IOException", "{", "raf", ".", "seek", "(", "0", ")", ";", "if", "(", "!", "raf", ".", "searchForward", "(", "matcher", ",", "40", "*", "1000", ")", ")", "return", "false", ";", "// must find \"BUFR\" in first 40k\r", "raf", ".", "skipBytes", "(", "4", ")", ";", "BufrIndicatorSection", "is", "=", "new", "BufrIndicatorSection", "(", "raf", ")", ";", "if", "(", "is", ".", "getBufrEdition", "(", ")", ">", "4", ")", "return", "false", ";", "// if(is.getBufrLength() > MAX_MESSAGE_SIZE) return false;\r", "return", "!", "(", "is", ".", "getBufrLength", "(", ")", ">", "raf", ".", "length", "(", ")", ")", ";", "}"], "docstring": "is this a valid BUFR file.\n\n@param raf check this file\n@return true if its a BUFR file\n@throws IOException on read error", "docstring_tokens": ["is", "this", "a", "valid", "BUFR", "file", "."]}
{"code": "StationUI sui = new StationUI( s);", "comments": "wrap in a StationUI", "lines": 6, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/point/StationRenderer.java", "func_name": "StationRenderer.setStations", "original_string": "public void setStations(java.util.List<ucar.unidata.geoloc.Station> stns) {\n    stations = new ArrayList<StationUI>( stns.size());\n    stationHash.clear();\n    for (int i = 0; i < stns.size(); i++) {\n      ucar.unidata.geoloc.Station s = (ucar.unidata.geoloc.Station) stns.get(i);\n      StationUI sui = new StationUI( s); // wrap in a StationUI\n      stations.add(sui); // wrap in a StationUI\n      stationHash.put( s.getName(), sui);\n    }\n    posWasCalc = false;\n    calcWorldPos();\n  }", "language": "java", "Allcodes": "public void setStations(java.util.List<ucar.unidata.geoloc.Station> stns) {\n    stations = new ArrayList<StationUI>( stns.size());\n    stationHash.clear();\n    for (int i = 0; i < stns.size(); i++) {\n      ucar.unidata.geoloc.Station s = (ucar.unidata.geoloc.Station) stns.get(i);\n      StationUI sui = new StationUI( s); // wrap in a StationUI\n      stations.add(sui); // wrap in a StationUI\n      stationHash.put( s.getName(), sui);\n    }\n    posWasCalc = false;\n    calcWorldPos();\n  }", "code_tokens": ["public", "void", "setStations", "(", "java", ".", "util", ".", "List", "<", "ucar", ".", "unidata", ".", "geoloc", ".", "Station", ">", "stns", ")", "{", "stations", "=", "new", "ArrayList", "<", "StationUI", ">", "(", "stns", ".", "size", "(", ")", ")", ";", "stationHash", ".", "clear", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "stns", ".", "size", "(", ")", ";", "i", "++", ")", "{", "ucar", ".", "unidata", ".", "geoloc", ".", "Station", "s", "=", "(", "ucar", ".", "unidata", ".", "geoloc", ".", "Station", ")", "stns", ".", "get", "(", "i", ")", ";", "StationUI", "sui", "=", "new", "StationUI", "(", "s", ")", ";", "// wrap in a StationUI", "stations", ".", "add", "(", "sui", ")", ";", "// wrap in a StationUI", "stationHash", ".", "put", "(", "s", ".", "getName", "(", ")", ",", "sui", ")", ";", "}", "posWasCalc", "=", "false", ";", "calcWorldPos", "(", ")", ";", "}"], "docstring": "Set the list of stations.\n@param stns: list of DDStation objects", "docstring_tokens": ["Set", "the", "list", "of", "stations", "."]}
{"code": "world2Normal.transform(pickPt, ptN);", "comments": "work in normalized coordinate space", "lines": 4, "repo": "Unidata/thredds", "path": "ui/src/main/java/ucar/nc2/ui/point/StationRenderer.java", "func_name": "StationRenderer.pick", "original_string": "public ucar.unidata.geoloc.Station pick(Point2D pickPt) {\n    if (world2Normal == null || pickPt == null || stations.isEmpty()) return null;\n\n    world2Normal.transform(pickPt, ptN); // work in normalized coordinate space\n    StationUI closest = (StationUI) stationGrid.findIntersection(ptN);\n    setSelectedStation( closest);\n\n    return getSelectedStation();\n  }", "language": "java", "Allcodes": "public ucar.unidata.geoloc.Station pick(Point2D pickPt) {\n    if (world2Normal == null || pickPt == null || stations.isEmpty()) return null;\n\n    world2Normal.transform(pickPt, ptN); // work in normalized coordinate space\n    StationUI closest = (StationUI) stationGrid.findIntersection(ptN);\n    setSelectedStation( closest);\n\n    return getSelectedStation();\n  }", "code_tokens": ["public", "ucar", ".", "unidata", ".", "geoloc", ".", "Station", "pick", "(", "Point2D", "pickPt", ")", "{", "if", "(", "world2Normal", "==", "null", "||", "pickPt", "==", "null", "||", "stations", ".", "isEmpty", "(", ")", ")", "return", "null", ";", "world2Normal", ".", "transform", "(", "pickPt", ",", "ptN", ")", ";", "// work in normalized coordinate space", "StationUI", "closest", "=", "(", "StationUI", ")", "stationGrid", ".", "findIntersection", "(", "ptN", ")", ";", "setSelectedStation", "(", "closest", ")", ";", "return", "getSelectedStation", "(", ")", ";", "}"], "docstring": "Find station that contains this point. If it exists, make it the\n\"selected\" station.\n@param pickPt: world coordinates\n@return station that contains this point, or null if none.", "docstring_tokens": ["Find", "station", "that", "contains", "this", "point", ".", "If", "it", "exists", "make", "it", "the", "selected", "station", "."]}
{"code": "return email.indexOf('@') >= 0;", "comments": "should really do a regexp", "lines": 3, "repo": "Unidata/thredds", "path": "legacy/src/main/java/thredds/catalog/dl/ADNWriter.java", "func_name": "ADNWriter.emailOK", "original_string": "protected boolean emailOK(ThreddsMetadata.Source p) {\n    String email = p.getEmail();\n    return email.indexOf('@') >= 0; // should really do a regexp\n  }", "language": "java", "Allcodes": "protected boolean emailOK(ThreddsMetadata.Source p) {\n    String email = p.getEmail();\n    return email.indexOf('@') >= 0; // should really do a regexp\n  }", "code_tokens": ["protected", "boolean", "emailOK", "(", "ThreddsMetadata", ".", "Source", "p", ")", "{", "String", "email", "=", "p", ".", "getEmail", "(", ")", ";", "return", "email", ".", "indexOf", "(", "'", "'", ")", ">=", "0", ";", "// should really do a regexp", "}"], "docstring": "check its an acceptable form of email", "docstring_tokens": ["check", "its", "an", "acceptable", "form", "of", "email"]}
{"code": "spi = (IOServiceProvider) iospClass.newInstance();", "comments": "fail fast", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NetcdfFile.java", "func_name": "NetcdfFile.registerIOProvider", "original_string": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "language": "java", "Allcodes": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "code_tokens": ["static", "public", "void", "registerIOProvider", "(", "Class", "iospClass", ",", "boolean", "last", ")", "throws", "IllegalAccessException", ",", "InstantiationException", "{", "IOServiceProvider", "spi", ";", "spi", "=", "(", "IOServiceProvider", ")", "iospClass", ".", "newInstance", "(", ")", ";", "// fail fast", "if", "(", "userLoads", "&&", "!", "last", ")", "registeredProviders", ".", "add", "(", "0", ",", "spi", ")", ";", "// put user stuff first", "else", "registeredProviders", ".", "add", "(", "spi", ")", ";", "}"], "docstring": "Register an IOServiceProvider. A new instance will be created when one of its files is opened.\n\n@param iospClass Class that implements IOServiceProvider.\n@param last      true=>insert at the end of the list; otherwise front\n@throws IllegalAccessException if class is not accessible.\n@throws InstantiationException if class doesnt have a no-arg constructor.\n@throws ClassCastException     if class doesnt implement IOServiceProvider interface.", "docstring_tokens": ["Register", "an", "IOServiceProvider", ".", "A", "new", "instance", "will", "be", "created", "when", "one", "of", "its", "files", "is", "opened", "."]}
{"code": "registeredProviders.add(0, spi);", "comments": "put user stuff first", "lines": 6, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NetcdfFile.java", "func_name": "NetcdfFile.registerIOProvider", "original_string": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "language": "java", "Allcodes": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "code_tokens": ["static", "public", "void", "registerIOProvider", "(", "Class", "iospClass", ",", "boolean", "last", ")", "throws", "IllegalAccessException", ",", "InstantiationException", "{", "IOServiceProvider", "spi", ";", "spi", "=", "(", "IOServiceProvider", ")", "iospClass", ".", "newInstance", "(", ")", ";", "// fail fast", "if", "(", "userLoads", "&&", "!", "last", ")", "registeredProviders", ".", "add", "(", "0", ",", "spi", ")", ";", "// put user stuff first", "else", "registeredProviders", ".", "add", "(", "spi", ")", ";", "}"], "docstring": "Register an IOServiceProvider. A new instance will be created when one of its files is opened.\n\n@param iospClass Class that implements IOServiceProvider.\n@param last      true=>insert at the end of the list; otherwise front\n@throws IllegalAccessException if class is not accessible.\n@throws InstantiationException if class doesnt have a no-arg constructor.\n@throws ClassCastException     if class doesnt implement IOServiceProvider interface.", "docstring_tokens": ["Register", "an", "IOServiceProvider", ".", "A", "new", "instance", "will", "be", "created", "when", "one", "of", "its", "files", "is", "opened", "."]}
{"code": "iospDeRegister(iospClass);", "comments": "forcibly de-register", "lines": 4, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NetcdfFile.java", "func_name": "NetcdfFile.registerIOProviderPreferred", "original_string": "static public void registerIOProviderPreferred(Class iospClass, Class target)\n           throws IllegalAccessException, InstantiationException\n   {\n     iospDeRegister(iospClass); // forcibly de-register\n     int pos = -1;\n     for(int i = 0; i < registeredProviders.size(); i++) {\n       IOServiceProvider candidate = registeredProviders.get(i);\n       if(candidate.getClass() == target) {\n         if(pos < i)\n           pos = i;\n         break; // this is where is must be placed\n       }\n     }\n     if(pos < 0) pos = 0;\n     IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n     registeredProviders.add(pos, spi);  // insert before target\n   }", "language": "java", "Allcodes": "static public void registerIOProviderPreferred(Class iospClass, Class target)\n           throws IllegalAccessException, InstantiationException\n   {\n     iospDeRegister(iospClass); // forcibly de-register\n     int pos = -1;\n     for(int i = 0; i < registeredProviders.size(); i++) {\n       IOServiceProvider candidate = registeredProviders.get(i);\n       if(candidate.getClass() == target) {\n         if(pos < i)\n           pos = i;\n         break; // this is where is must be placed\n       }\n     }\n     if(pos < 0) pos = 0;\n     IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n     registeredProviders.add(pos, spi);  // insert before target\n   }", "code_tokens": ["static", "public", "void", "registerIOProviderPreferred", "(", "Class", "iospClass", ",", "Class", "target", ")", "throws", "IllegalAccessException", ",", "InstantiationException", "{", "iospDeRegister", "(", "iospClass", ")", ";", "// forcibly de-register", "int", "pos", "=", "-", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "registeredProviders", ".", "size", "(", ")", ";", "i", "++", ")", "{", "IOServiceProvider", "candidate", "=", "registeredProviders", ".", "get", "(", "i", ")", ";", "if", "(", "candidate", ".", "getClass", "(", ")", "==", "target", ")", "{", "if", "(", "pos", "<", "i", ")", "pos", "=", "i", ";", "break", ";", "// this is where is must be placed", "}", "}", "if", "(", "pos", "<", "0", ")", "pos", "=", "0", ";", "IOServiceProvider", "spi", "=", "(", "IOServiceProvider", ")", "iospClass", ".", "newInstance", "(", ")", ";", "// fail fast", "registeredProviders", ".", "add", "(", "pos", ",", "spi", ")", ";", "// insert before target", "}"], "docstring": "Register an IOServiceProvider. A new instance will be created when one of its files is opened.\nThis differs from the above in that it specifically locates the target iosp and inserts\nthe new one in front of it in order to override the target.\nIf the iospclass is already registered, remove it and reinsert.\nIf the target class is not present, then insert at front of the registry\n\n@param iospClass Class that implements IOServiceProvider.\n@param target Class to override\n@throws IllegalAccessException if class is not accessible.\n@throws InstantiationException if class doesnt have a no-arg constructor.\n@throws ClassCastException     if class doesnt implement IOServiceProvider interface.", "docstring_tokens": ["Register", "an", "IOServiceProvider", ".", "A", "new", "instance", "will", "be", "created", "when", "one", "of", "its", "files", "is", "opened", ".", "This", "differs", "from", "the", "above", "in", "that", "it", "specifically", "locates", "the", "target", "iosp", "and", "inserts", "the", "new", "one", "in", "front", "of", "it", "in", "order", "to", "override", "the", "target", ".", "If", "the", "iospclass", "is", "already", "registered", "remove", "it", "and", "reinsert", ".", "If", "the", "target", "class", "is", "not", "present", "then", "insert", "at", "front", "of", "the", "registry"]}
{"code": "break;", "comments": "this is where is must be placed", "lines": 11, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NetcdfFile.java", "func_name": "NetcdfFile.registerIOProviderPreferred", "original_string": "static public void registerIOProviderPreferred(Class iospClass, Class target)\n           throws IllegalAccessException, InstantiationException\n   {\n     iospDeRegister(iospClass); // forcibly de-register\n     int pos = -1;\n     for(int i = 0; i < registeredProviders.size(); i++) {\n       IOServiceProvider candidate = registeredProviders.get(i);\n       if(candidate.getClass() == target) {\n         if(pos < i)\n           pos = i;\n         break; // this is where is must be placed\n       }\n     }\n     if(pos < 0) pos = 0;\n     IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n     registeredProviders.add(pos, spi);  // insert before target\n   }", "language": "java", "Allcodes": "static public void registerIOProviderPreferred(Class iospClass, Class target)\n           throws IllegalAccessException, InstantiationException\n   {\n     iospDeRegister(iospClass); // forcibly de-register\n     int pos = -1;\n     for(int i = 0; i < registeredProviders.size(); i++) {\n       IOServiceProvider candidate = registeredProviders.get(i);\n       if(candidate.getClass() == target) {\n         if(pos < i)\n           pos = i;\n         break; // this is where is must be placed\n       }\n     }\n     if(pos < 0) pos = 0;\n     IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n     registeredProviders.add(pos, spi);  // insert before target\n   }", "code_tokens": ["static", "public", "void", "registerIOProviderPreferred", "(", "Class", "iospClass", ",", "Class", "target", ")", "throws", "IllegalAccessException", ",", "InstantiationException", "{", "iospDeRegister", "(", "iospClass", ")", ";", "// forcibly de-register", "int", "pos", "=", "-", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "registeredProviders", ".", "size", "(", ")", ";", "i", "++", ")", "{", "IOServiceProvider", "candidate", "=", "registeredProviders", ".", "get", "(", "i", ")", ";", "if", "(", "candidate", ".", "getClass", "(", ")", "==", "target", ")", "{", "if", "(", "pos", "<", "i", ")", "pos", "=", "i", ";", "break", ";", "// this is where is must be placed", "}", "}", "if", "(", "pos", "<", "0", ")", "pos", "=", "0", ";", "IOServiceProvider", "spi", "=", "(", "IOServiceProvider", ")", "iospClass", ".", "newInstance", "(", ")", ";", "// fail fast", "registeredProviders", ".", "add", "(", "pos", ",", "spi", ")", ";", "// insert before target", "}"], "docstring": "Register an IOServiceProvider. A new instance will be created when one of its files is opened.\nThis differs from the above in that it specifically locates the target iosp and inserts\nthe new one in front of it in order to override the target.\nIf the iospclass is already registered, remove it and reinsert.\nIf the target class is not present, then insert at front of the registry\n\n@param iospClass Class that implements IOServiceProvider.\n@param target Class to override\n@throws IllegalAccessException if class is not accessible.\n@throws InstantiationException if class doesnt have a no-arg constructor.\n@throws ClassCastException     if class doesnt implement IOServiceProvider interface.", "docstring_tokens": ["Register", "an", "IOServiceProvider", ".", "A", "new", "instance", "will", "be", "created", "when", "one", "of", "its", "files", "is", "opened", ".", "This", "differs", "from", "the", "above", "in", "that", "it", "specifically", "locates", "the", "target", "iosp", "and", "inserts", "the", "new", "one", "in", "front", "of", "it", "in", "order", "to", "override", "the", "target", ".", "If", "the", "iospclass", "is", "already", "registered", "remove", "it", "and", "reinsert", ".", "If", "the", "target", "class", "is", "not", "present", "then", "insert", "at", "front", "of", "the", "registry"]}
{"code": "registeredProviders.add(pos, spi);", "comments": "insert before target", "lines": 16, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NetcdfFile.java", "func_name": "NetcdfFile.registerIOProviderPreferred", "original_string": "static public void registerIOProviderPreferred(Class iospClass, Class target)\n           throws IllegalAccessException, InstantiationException\n   {\n     iospDeRegister(iospClass); // forcibly de-register\n     int pos = -1;\n     for(int i = 0; i < registeredProviders.size(); i++) {\n       IOServiceProvider candidate = registeredProviders.get(i);\n       if(candidate.getClass() == target) {\n         if(pos < i)\n           pos = i;\n         break; // this is where is must be placed\n       }\n     }\n     if(pos < 0) pos = 0;\n     IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n     registeredProviders.add(pos, spi);  // insert before target\n   }", "language": "java", "Allcodes": "static public void registerIOProviderPreferred(Class iospClass, Class target)\n           throws IllegalAccessException, InstantiationException\n   {\n     iospDeRegister(iospClass); // forcibly de-register\n     int pos = -1;\n     for(int i = 0; i < registeredProviders.size(); i++) {\n       IOServiceProvider candidate = registeredProviders.get(i);\n       if(candidate.getClass() == target) {\n         if(pos < i)\n           pos = i;\n         break; // this is where is must be placed\n       }\n     }\n     if(pos < 0) pos = 0;\n     IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n     registeredProviders.add(pos, spi);  // insert before target\n   }", "code_tokens": ["static", "public", "void", "registerIOProviderPreferred", "(", "Class", "iospClass", ",", "Class", "target", ")", "throws", "IllegalAccessException", ",", "InstantiationException", "{", "iospDeRegister", "(", "iospClass", ")", ";", "// forcibly de-register", "int", "pos", "=", "-", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "registeredProviders", ".", "size", "(", ")", ";", "i", "++", ")", "{", "IOServiceProvider", "candidate", "=", "registeredProviders", ".", "get", "(", "i", ")", ";", "if", "(", "candidate", ".", "getClass", "(", ")", "==", "target", ")", "{", "if", "(", "pos", "<", "i", ")", "pos", "=", "i", ";", "break", ";", "// this is where is must be placed", "}", "}", "if", "(", "pos", "<", "0", ")", "pos", "=", "0", ";", "IOServiceProvider", "spi", "=", "(", "IOServiceProvider", ")", "iospClass", ".", "newInstance", "(", ")", ";", "// fail fast", "registeredProviders", ".", "add", "(", "pos", ",", "spi", ")", ";", "// insert before target", "}"], "docstring": "Register an IOServiceProvider. A new instance will be created when one of its files is opened.\nThis differs from the above in that it specifically locates the target iosp and inserts\nthe new one in front of it in order to override the target.\nIf the iospclass is already registered, remove it and reinsert.\nIf the target class is not present, then insert at front of the registry\n\n@param iospClass Class that implements IOServiceProvider.\n@param target Class to override\n@throws IllegalAccessException if class is not accessible.\n@throws InstantiationException if class doesnt have a no-arg constructor.\n@throws ClassCastException     if class doesnt implement IOServiceProvider interface.", "docstring_tokens": ["Register", "an", "IOServiceProvider", ".", "A", "new", "instance", "will", "be", "created", "when", "one", "of", "its", "files", "is", "opened", ".", "This", "differs", "from", "the", "above", "in", "that", "it", "specifically", "locates", "the", "target", "iosp", "and", "inserts", "the", "new", "one", "in", "front", "of", "it", "in", "order", "to", "override", "the", "target", ".", "If", "the", "iospclass", "is", "already", "registered", "remove", "it", "and", "reinsert", ".", "If", "the", "target", "class", "is", "not", "present", "then", "insert", "at", "front", "of", "the", "registry"]}
{"code": "name = makeValidPathName(name);", "comments": "escape for use in full name", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NetcdfFile.java", "func_name": "NetcdfFile.makeFullNameWithString", "original_string": "protected String makeFullNameWithString(Group parent, String name) {\n    name = makeValidPathName(name); // escape for use in full name  \n    StringBuilder sbuff = new StringBuilder();\n    appendGroupName(sbuff, parent, null);\n    sbuff.append(name);\n    return sbuff.toString();\n  }", "language": "java", "Allcodes": "protected String makeFullNameWithString(Group parent, String name) {\n    name = makeValidPathName(name); // escape for use in full name  \n    StringBuilder sbuff = new StringBuilder();\n    appendGroupName(sbuff, parent, null);\n    sbuff.append(name);\n    return sbuff.toString();\n  }", "code_tokens": ["protected", "String", "makeFullNameWithString", "(", "Group", "parent", ",", "String", "name", ")", "{", "name", "=", "makeValidPathName", "(", "name", ")", ";", "// escape for use in full name  ", "StringBuilder", "sbuff", "=", "new", "StringBuilder", "(", ")", ";", "appendGroupName", "(", "sbuff", ",", "parent", ",", "null", ")", ";", "sbuff", ".", "append", "(", "name", ")", ";", "return", "sbuff", ".", "toString", "(", ")", ";", "}"], "docstring": "Create a synthetic full name from a group plus a string\n\n@param parent parent group\n@param name   synthetic name string\n@return synthetic name", "docstring_tokens": ["Create", "a", "synthetic", "full", "name", "from", "a", "group", "plus", "a", "string"]}
{"code": "return start;", "comments": "indicates part of the buffer thats not processed", "lines": 11, "repo": "Unidata/thredds", "path": "ldm/src/main/thredds/ldm/MessageBroker.java", "func_name": "MessageBroker.process", "original_string": "private int process(Buffer b, InputStream is) throws IOException {\n    int start = 0;\n    while (start < b.have) {\n      int matchPos = matcher.indexOf(b.buff, start, b.have - start);\n\n      // didnt find \"BUFR\" match\n      if (matchPos < 0) {\n        if (start == 0) // discard all but last 3 bytes\n          return b.have - 3;\n        else\n          return start; // indicates part of the buffer thats not processed\n      }\n\n      // do we have the length already read ??\n      if (matchPos + 6 >= b.have) {\n        return start; // this will save the end of the buffer and read more in.\n      }\n\n      // read BUFR message length\n      int b1 = (b.buff[matchPos + 4] & 0xff);\n      int b2 = (b.buff[matchPos + 5] & 0xff);\n      int b3 = (b.buff[matchPos + 6] & 0xff);\n      int messLen = b1 << 16 | b2 << 8 | b3;\n      // System.out.println(\"match at=\" + matchPos + \" len= \" + messLen);\n\n      // create a task for this message\n      //int headerLen = matchPos - start;\n      MessageTask task = new MessageTask(messLen);\n      task.header = extractHeader(start, matchPos, b);\n\n      // copy message bytes into it\n      int last = matchPos + messLen;\n      if (last > b.have) {\n        task.have = b.have - matchPos;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n\n        // read the rest of the message\n        if (!readBuffer(is, task.mess, task.have, task.len - task.have)) {\n          System.out.println(\"Failed to read remaining BUFR message\");\n          break;\n        }\n\n      } else {\n        task.have = task.len;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n      }\n\n      boolean ok = true;\n\n      // check on ending\n      for (int i = task.len - 4; i < task.len; i++) {\n        int bb = task.mess[i];\n        if (bb != 55) {\n          //System.out.println(\"Missing End of BUFR message at pos=\" + i + \" \" + bb);\n          ok = false;\n          bad_msgs++;\n        }\n      }\n\n      try {\n        if (ok) messQ.put(task);\n        total_msgs++;\n        //System.out.println(\" added message \" + task.id + \" start=\" + matchPos + \" end= \" + (matchPos + messLen));\n      } catch (InterruptedException e) {\n        System.out.println(\" interrupted queue put - assume process exit\");\n        break;\n      }\n\n      start = matchPos + messLen + 1;\n    }\n\n    return -1;\n  }", "language": "java", "Allcodes": "private int process(Buffer b, InputStream is) throws IOException {\n    int start = 0;\n    while (start < b.have) {\n      int matchPos = matcher.indexOf(b.buff, start, b.have - start);\n\n      // didnt find \"BUFR\" match\n      if (matchPos < 0) {\n        if (start == 0) // discard all but last 3 bytes\n          return b.have - 3;\n        else\n          return start; // indicates part of the buffer thats not processed\n      }\n\n      // do we have the length already read ??\n      if (matchPos + 6 >= b.have) {\n        return start; // this will save the end of the buffer and read more in.\n      }\n\n      // read BUFR message length\n      int b1 = (b.buff[matchPos + 4] & 0xff);\n      int b2 = (b.buff[matchPos + 5] & 0xff);\n      int b3 = (b.buff[matchPos + 6] & 0xff);\n      int messLen = b1 << 16 | b2 << 8 | b3;\n      // System.out.println(\"match at=\" + matchPos + \" len= \" + messLen);\n\n      // create a task for this message\n      //int headerLen = matchPos - start;\n      MessageTask task = new MessageTask(messLen);\n      task.header = extractHeader(start, matchPos, b);\n\n      // copy message bytes into it\n      int last = matchPos + messLen;\n      if (last > b.have) {\n        task.have = b.have - matchPos;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n\n        // read the rest of the message\n        if (!readBuffer(is, task.mess, task.have, task.len - task.have)) {\n          System.out.println(\"Failed to read remaining BUFR message\");\n          break;\n        }\n\n      } else {\n        task.have = task.len;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n      }\n\n      boolean ok = true;\n\n      // check on ending\n      for (int i = task.len - 4; i < task.len; i++) {\n        int bb = task.mess[i];\n        if (bb != 55) {\n          //System.out.println(\"Missing End of BUFR message at pos=\" + i + \" \" + bb);\n          ok = false;\n          bad_msgs++;\n        }\n      }\n\n      try {\n        if (ok) messQ.put(task);\n        total_msgs++;\n        //System.out.println(\" added message \" + task.id + \" start=\" + matchPos + \" end= \" + (matchPos + messLen));\n      } catch (InterruptedException e) {\n        System.out.println(\" interrupted queue put - assume process exit\");\n        break;\n      }\n\n      start = matchPos + messLen + 1;\n    }\n\n    return -1;\n  }", "code_tokens": ["private", "int", "process", "(", "Buffer", "b", ",", "InputStream", "is", ")", "throws", "IOException", "{", "int", "start", "=", "0", ";", "while", "(", "start", "<", "b", ".", "have", ")", "{", "int", "matchPos", "=", "matcher", ".", "indexOf", "(", "b", ".", "buff", ",", "start", ",", "b", ".", "have", "-", "start", ")", ";", "// didnt find \"BUFR\" match", "if", "(", "matchPos", "<", "0", ")", "{", "if", "(", "start", "==", "0", ")", "// discard all but last 3 bytes", "return", "b", ".", "have", "-", "3", ";", "else", "return", "start", ";", "// indicates part of the buffer thats not processed", "}", "// do we have the length already read ??", "if", "(", "matchPos", "+", "6", ">=", "b", ".", "have", ")", "{", "return", "start", ";", "// this will save the end of the buffer and read more in.", "}", "// read BUFR message length", "int", "b1", "=", "(", "b", ".", "buff", "[", "matchPos", "+", "4", "]", "&", "0xff", ")", ";", "int", "b2", "=", "(", "b", ".", "buff", "[", "matchPos", "+", "5", "]", "&", "0xff", ")", ";", "int", "b3", "=", "(", "b", ".", "buff", "[", "matchPos", "+", "6", "]", "&", "0xff", ")", ";", "int", "messLen", "=", "b1", "<<", "16", "|", "b2", "<<", "8", "|", "b3", ";", "// System.out.println(\"match at=\" + matchPos + \" len= \" + messLen);", "// create a task for this message", "//int headerLen = matchPos - start;", "MessageTask", "task", "=", "new", "MessageTask", "(", "messLen", ")", ";", "task", ".", "header", "=", "extractHeader", "(", "start", ",", "matchPos", ",", "b", ")", ";", "// copy message bytes into it", "int", "last", "=", "matchPos", "+", "messLen", ";", "if", "(", "last", ">", "b", ".", "have", ")", "{", "task", ".", "have", "=", "b", ".", "have", "-", "matchPos", ";", "System", ".", "arraycopy", "(", "b", ".", "buff", ",", "matchPos", ",", "task", ".", "mess", ",", "0", ",", "task", ".", "have", ")", ";", "// read the rest of the message", "if", "(", "!", "readBuffer", "(", "is", ",", "task", ".", "mess", ",", "task", ".", "have", ",", "task", ".", "len", "-", "task", ".", "have", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"Failed to read remaining BUFR message\"", ")", ";", "break", ";", "}", "}", "else", "{", "task", ".", "have", "=", "task", ".", "len", ";", "System", ".", "arraycopy", "(", "b", ".", "buff", ",", "matchPos", ",", "task", ".", "mess", ",", "0", ",", "task", ".", "have", ")", ";", "}", "boolean", "ok", "=", "true", ";", "// check on ending", "for", "(", "int", "i", "=", "task", ".", "len", "-", "4", ";", "i", "<", "task", ".", "len", ";", "i", "++", ")", "{", "int", "bb", "=", "task", ".", "mess", "[", "i", "]", ";", "if", "(", "bb", "!=", "55", ")", "{", "//System.out.println(\"Missing End of BUFR message at pos=\" + i + \" \" + bb);", "ok", "=", "false", ";", "bad_msgs", "++", ";", "}", "}", "try", "{", "if", "(", "ok", ")", "messQ", ".", "put", "(", "task", ")", ";", "total_msgs", "++", ";", "//System.out.println(\" added message \" + task.id + \" start=\" + matchPos + \" end= \" + (matchPos + messLen));", "}", "catch", "(", "InterruptedException", "e", ")", "{", "System", ".", "out", ".", "println", "(", "\" interrupted queue put - assume process exit\"", ")", ";", "break", ";", "}", "start", "=", "matchPos", "+", "messLen", "+", "1", ";", "}", "return", "-", "1", ";", "}"], "docstring": "return where in the buffer we got to.", "docstring_tokens": ["return", "where", "in", "the", "buffer", "we", "got", "to", "."]}
{"code": "return start;", "comments": "this will save the end of the buffer and read more in.", "lines": 16, "repo": "Unidata/thredds", "path": "ldm/src/main/thredds/ldm/MessageBroker.java", "func_name": "MessageBroker.process", "original_string": "private int process(Buffer b, InputStream is) throws IOException {\n    int start = 0;\n    while (start < b.have) {\n      int matchPos = matcher.indexOf(b.buff, start, b.have - start);\n\n      // didnt find \"BUFR\" match\n      if (matchPos < 0) {\n        if (start == 0) // discard all but last 3 bytes\n          return b.have - 3;\n        else\n          return start; // indicates part of the buffer thats not processed\n      }\n\n      // do we have the length already read ??\n      if (matchPos + 6 >= b.have) {\n        return start; // this will save the end of the buffer and read more in.\n      }\n\n      // read BUFR message length\n      int b1 = (b.buff[matchPos + 4] & 0xff);\n      int b2 = (b.buff[matchPos + 5] & 0xff);\n      int b3 = (b.buff[matchPos + 6] & 0xff);\n      int messLen = b1 << 16 | b2 << 8 | b3;\n      // System.out.println(\"match at=\" + matchPos + \" len= \" + messLen);\n\n      // create a task for this message\n      //int headerLen = matchPos - start;\n      MessageTask task = new MessageTask(messLen);\n      task.header = extractHeader(start, matchPos, b);\n\n      // copy message bytes into it\n      int last = matchPos + messLen;\n      if (last > b.have) {\n        task.have = b.have - matchPos;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n\n        // read the rest of the message\n        if (!readBuffer(is, task.mess, task.have, task.len - task.have)) {\n          System.out.println(\"Failed to read remaining BUFR message\");\n          break;\n        }\n\n      } else {\n        task.have = task.len;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n      }\n\n      boolean ok = true;\n\n      // check on ending\n      for (int i = task.len - 4; i < task.len; i++) {\n        int bb = task.mess[i];\n        if (bb != 55) {\n          //System.out.println(\"Missing End of BUFR message at pos=\" + i + \" \" + bb);\n          ok = false;\n          bad_msgs++;\n        }\n      }\n\n      try {\n        if (ok) messQ.put(task);\n        total_msgs++;\n        //System.out.println(\" added message \" + task.id + \" start=\" + matchPos + \" end= \" + (matchPos + messLen));\n      } catch (InterruptedException e) {\n        System.out.println(\" interrupted queue put - assume process exit\");\n        break;\n      }\n\n      start = matchPos + messLen + 1;\n    }\n\n    return -1;\n  }", "language": "java", "Allcodes": "private int process(Buffer b, InputStream is) throws IOException {\n    int start = 0;\n    while (start < b.have) {\n      int matchPos = matcher.indexOf(b.buff, start, b.have - start);\n\n      // didnt find \"BUFR\" match\n      if (matchPos < 0) {\n        if (start == 0) // discard all but last 3 bytes\n          return b.have - 3;\n        else\n          return start; // indicates part of the buffer thats not processed\n      }\n\n      // do we have the length already read ??\n      if (matchPos + 6 >= b.have) {\n        return start; // this will save the end of the buffer and read more in.\n      }\n\n      // read BUFR message length\n      int b1 = (b.buff[matchPos + 4] & 0xff);\n      int b2 = (b.buff[matchPos + 5] & 0xff);\n      int b3 = (b.buff[matchPos + 6] & 0xff);\n      int messLen = b1 << 16 | b2 << 8 | b3;\n      // System.out.println(\"match at=\" + matchPos + \" len= \" + messLen);\n\n      // create a task for this message\n      //int headerLen = matchPos - start;\n      MessageTask task = new MessageTask(messLen);\n      task.header = extractHeader(start, matchPos, b);\n\n      // copy message bytes into it\n      int last = matchPos + messLen;\n      if (last > b.have) {\n        task.have = b.have - matchPos;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n\n        // read the rest of the message\n        if (!readBuffer(is, task.mess, task.have, task.len - task.have)) {\n          System.out.println(\"Failed to read remaining BUFR message\");\n          break;\n        }\n\n      } else {\n        task.have = task.len;\n        System.arraycopy(b.buff, matchPos, task.mess, 0, task.have);\n      }\n\n      boolean ok = true;\n\n      // check on ending\n      for (int i = task.len - 4; i < task.len; i++) {\n        int bb = task.mess[i];\n        if (bb != 55) {\n          //System.out.println(\"Missing End of BUFR message at pos=\" + i + \" \" + bb);\n          ok = false;\n          bad_msgs++;\n        }\n      }\n\n      try {\n        if (ok) messQ.put(task);\n        total_msgs++;\n        //System.out.println(\" added message \" + task.id + \" start=\" + matchPos + \" end= \" + (matchPos + messLen));\n      } catch (InterruptedException e) {\n        System.out.println(\" interrupted queue put - assume process exit\");\n        break;\n      }\n\n      start = matchPos + messLen + 1;\n    }\n\n    return -1;\n  }", "code_tokens": ["private", "int", "process", "(", "Buffer", "b", ",", "InputStream", "is", ")", "throws", "IOException", "{", "int", "start", "=", "0", ";", "while", "(", "start", "<", "b", ".", "have", ")", "{", "int", "matchPos", "=", "matcher", ".", "indexOf", "(", "b", ".", "buff", ",", "start", ",", "b", ".", "have", "-", "start", ")", ";", "// didnt find \"BUFR\" match", "if", "(", "matchPos", "<", "0", ")", "{", "if", "(", "start", "==", "0", ")", "// discard all but last 3 bytes", "return", "b", ".", "have", "-", "3", ";", "else", "return", "start", ";", "// indicates part of the buffer thats not processed", "}", "// do we have the length already read ??", "if", "(", "matchPos", "+", "6", ">=", "b", ".", "have", ")", "{", "return", "start", ";", "// this will save the end of the buffer and read more in.", "}", "// read BUFR message length", "int", "b1", "=", "(", "b", ".", "buff", "[", "matchPos", "+", "4", "]", "&", "0xff", ")", ";", "int", "b2", "=", "(", "b", ".", "buff", "[", "matchPos", "+", "5", "]", "&", "0xff", ")", ";", "int", "b3", "=", "(", "b", ".", "buff", "[", "matchPos", "+", "6", "]", "&", "0xff", ")", ";", "int", "messLen", "=", "b1", "<<", "16", "|", "b2", "<<", "8", "|", "b3", ";", "// System.out.println(\"match at=\" + matchPos + \" len= \" + messLen);", "// create a task for this message", "//int headerLen = matchPos - start;", "MessageTask", "task", "=", "new", "MessageTask", "(", "messLen", ")", ";", "task", ".", "header", "=", "extractHeader", "(", "start", ",", "matchPos", ",", "b", ")", ";", "// copy message bytes into it", "int", "last", "=", "matchPos", "+", "messLen", ";", "if", "(", "last", ">", "b", ".", "have", ")", "{", "task", ".", "have", "=", "b", ".", "have", "-", "matchPos", ";", "System", ".", "arraycopy", "(", "b", ".", "buff", ",", "matchPos", ",", "task", ".", "mess", ",", "0", ",", "task", ".", "have", ")", ";", "// read the rest of the message", "if", "(", "!", "readBuffer", "(", "is", ",", "task", ".", "mess", ",", "task", ".", "have", ",", "task", ".", "len", "-", "task", ".", "have", ")", ")", "{", "System", ".", "out", ".", "println", "(", "\"Failed to read remaining BUFR message\"", ")", ";", "break", ";", "}", "}", "else", "{", "task", ".", "have", "=", "task", ".", "len", ";", "System", ".", "arraycopy", "(", "b", ".", "buff", ",", "matchPos", ",", "task", ".", "mess", ",", "0", ",", "task", ".", "have", ")", ";", "}", "boolean", "ok", "=", "true", ";", "// check on ending", "for", "(", "int", "i", "=", "task", ".", "len", "-", "4", ";", "i", "<", "task", ".", "len", ";", "i", "++", ")", "{", "int", "bb", "=", "task", ".", "mess", "[", "i", "]", ";", "if", "(", "bb", "!=", "55", ")", "{", "//System.out.println(\"Missing End of BUFR message at pos=\" + i + \" \" + bb);", "ok", "=", "false", ";", "bad_msgs", "++", ";", "}", "}", "try", "{", "if", "(", "ok", ")", "messQ", ".", "put", "(", "task", ")", ";", "total_msgs", "++", ";", "//System.out.println(\" added message \" + task.id + \" start=\" + matchPos + \" end= \" + (matchPos + messLen));", "}", "catch", "(", "InterruptedException", "e", ")", "{", "System", ".", "out", ".", "println", "(", "\" interrupted queue put - assume process exit\"", ")", ";", "break", ";", "}", "start", "=", "matchPos", "+", "messLen", "+", "1", ";", "}", "return", "-", "1", ";", "}"], "docstring": "return where in the buffer we got to.", "docstring_tokens": ["return", "where", "in", "the", "buffer", "we", "got", "to", "."]}
{"code": "stationHelper.addStation(new StationFeatureStream(null, null));", "comments": "LOOK WRONG", "lines": 18, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/ft/point/remote/StationCollectionStream.java", "func_name": "StationCollectionStream.createStationHelper", "original_string": "@Override\n  protected StationHelper createStationHelper() throws IOException {\n    // read in all the stations with the \"stations\" query\n    StationHelper stationHelper = new StationHelper();\n\n    try (InputStream in = CdmRemote.sendQuery(null, uri, \"req=stations\")) {\n      PointStream.MessageType mtype = PointStream.readMagic(in);\n      if (mtype != PointStream.MessageType.StationList) {\n        throw new RuntimeException(\"Station Request: bad response\");\n      }\n\n      int len = NcStream.readVInt(in);\n      byte[] b = new byte[len];\n      NcStream.readFully(in, b);\n      PointStreamProto.StationList stationsp = PointStreamProto.StationList.parseFrom(b);\n      for (ucar.nc2.ft.point.remote.PointStreamProto.Station sp : stationsp.getStationsList()) {\n//        Station s = new StationImpl(sp.getId(), sp.getDesc(), sp.getWmoId(), sp.getLat(), sp.getLon(), sp.getAlt());\n        stationHelper.addStation(new StationFeatureStream(null, null));    // LOOK WRONG\n      }\n      return stationHelper;\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected StationHelper createStationHelper() throws IOException {\n    // read in all the stations with the \"stations\" query\n    StationHelper stationHelper = new StationHelper();\n\n    try (InputStream in = CdmRemote.sendQuery(null, uri, \"req=stations\")) {\n      PointStream.MessageType mtype = PointStream.readMagic(in);\n      if (mtype != PointStream.MessageType.StationList) {\n        throw new RuntimeException(\"Station Request: bad response\");\n      }\n\n      int len = NcStream.readVInt(in);\n      byte[] b = new byte[len];\n      NcStream.readFully(in, b);\n      PointStreamProto.StationList stationsp = PointStreamProto.StationList.parseFrom(b);\n      for (ucar.nc2.ft.point.remote.PointStreamProto.Station sp : stationsp.getStationsList()) {\n//        Station s = new StationImpl(sp.getId(), sp.getDesc(), sp.getWmoId(), sp.getLat(), sp.getLon(), sp.getAlt());\n        stationHelper.addStation(new StationFeatureStream(null, null));    // LOOK WRONG\n      }\n      return stationHelper;\n    }\n  }", "code_tokens": ["@", "Override", "protected", "StationHelper", "createStationHelper", "(", ")", "throws", "IOException", "{", "// read in all the stations with the \"stations\" query", "StationHelper", "stationHelper", "=", "new", "StationHelper", "(", ")", ";", "try", "(", "InputStream", "in", "=", "CdmRemote", ".", "sendQuery", "(", "null", ",", "uri", ",", "\"req=stations\"", ")", ")", "{", "PointStream", ".", "MessageType", "mtype", "=", "PointStream", ".", "readMagic", "(", "in", ")", ";", "if", "(", "mtype", "!=", "PointStream", ".", "MessageType", ".", "StationList", ")", "{", "throw", "new", "RuntimeException", "(", "\"Station Request: bad response\"", ")", ";", "}", "int", "len", "=", "NcStream", ".", "readVInt", "(", "in", ")", ";", "byte", "[", "]", "b", "=", "new", "byte", "[", "len", "]", ";", "NcStream", ".", "readFully", "(", "in", ",", "b", ")", ";", "PointStreamProto", ".", "StationList", "stationsp", "=", "PointStreamProto", ".", "StationList", ".", "parseFrom", "(", "b", ")", ";", "for", "(", "ucar", ".", "nc2", ".", "ft", ".", "point", ".", "remote", ".", "PointStreamProto", ".", "Station", "sp", ":", "stationsp", ".", "getStationsList", "(", ")", ")", "{", "//        Station s = new StationImpl(sp.getId(), sp.getDesc(), sp.getWmoId(), sp.getLat(), sp.getLon(), sp.getAlt());", "stationHelper", ".", "addStation", "(", "new", "StationFeatureStream", "(", "null", ",", "null", ")", ")", ";", "// LOOK WRONG", "}", "return", "stationHelper", ";", "}", "}"], "docstring": "initialize the stationHelper.", "docstring_tokens": ["initialize", "the", "stationHelper", "."]}
{"code": "Section section = null;", "comments": "works for scalars i think", "lines": 2, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Structure.java", "func_name": "Structure.readStructure", "original_string": "public StructureData readStructure(int index) throws IOException, ucar.ma2.InvalidRangeException {\n    Section section = null; // works for scalars i think\n\n    if (getRank() == 1) {\n      section = new Section().appendRange(index,index);\n\n    } else if (getRank() > 1) {\n      Index ii = Index.factory(shape); // convert to nD index\n      ii.setCurrentCounter(index);\n      int[] origin = ii.getCurrentCounter();\n      section = new Section();\n      for (int anOrigin : origin)\n        section.appendRange(anOrigin, anOrigin);\n    }\n\n    Array dataArray = read(section);\n    ArrayStructure data = (ArrayStructure) dataArray;\n    return data.getStructureData(0);\n  }", "language": "java", "Allcodes": "public StructureData readStructure(int index) throws IOException, ucar.ma2.InvalidRangeException {\n    Section section = null; // works for scalars i think\n\n    if (getRank() == 1) {\n      section = new Section().appendRange(index,index);\n\n    } else if (getRank() > 1) {\n      Index ii = Index.factory(shape); // convert to nD index\n      ii.setCurrentCounter(index);\n      int[] origin = ii.getCurrentCounter();\n      section = new Section();\n      for (int anOrigin : origin)\n        section.appendRange(anOrigin, anOrigin);\n    }\n\n    Array dataArray = read(section);\n    ArrayStructure data = (ArrayStructure) dataArray;\n    return data.getStructureData(0);\n  }", "code_tokens": ["public", "StructureData", "readStructure", "(", "int", "index", ")", "throws", "IOException", ",", "ucar", ".", "ma2", ".", "InvalidRangeException", "{", "Section", "section", "=", "null", ";", "// works for scalars i think", "if", "(", "getRank", "(", ")", "==", "1", ")", "{", "section", "=", "new", "Section", "(", ")", ".", "appendRange", "(", "index", ",", "index", ")", ";", "}", "else", "if", "(", "getRank", "(", ")", ">", "1", ")", "{", "Index", "ii", "=", "Index", ".", "factory", "(", "shape", ")", ";", "// convert to nD index", "ii", ".", "setCurrentCounter", "(", "index", ")", ";", "int", "[", "]", "origin", "=", "ii", ".", "getCurrentCounter", "(", ")", ";", "section", "=", "new", "Section", "(", ")", ";", "for", "(", "int", "anOrigin", ":", "origin", ")", "section", ".", "appendRange", "(", "anOrigin", ",", "anOrigin", ")", ";", "}", "Array", "dataArray", "=", "read", "(", "section", ")", ";", "ArrayStructure", "data", "=", "(", "ArrayStructure", ")", "dataArray", ";", "return", "data", ".", "getStructureData", "(", "0", ")", ";", "}"], "docstring": "Use this when this is a one dimensional array of Structures, or you are doing the index calculation yourself for\na multidimension array. This will read only the ith structure, and return the data as a StructureData object.\n@param index index into 1D array\n@return ith StructureData\n@throws java.io.IOException on read error\n@throws ucar.ma2.InvalidRangeException if index out of range", "docstring_tokens": ["Use", "this", "when", "this", "is", "a", "one", "dimensional", "array", "of", "Structures", "or", "you", "are", "doing", "the", "index", "calculation", "yourself", "for", "a", "multidimension", "array", ".", "This", "will", "read", "only", "the", "ith", "structure", "and", "return", "the", "data", "as", "a", "StructureData", "object", "."]}
{"code": "Index ii = Index.factory(shape);", "comments": "convert to nD index", "lines": 8, "repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/Structure.java", "func_name": "Structure.readStructure", "original_string": "public StructureData readStructure(int index) throws IOException, ucar.ma2.InvalidRangeException {\n    Section section = null; // works for scalars i think\n\n    if (getRank() == 1) {\n      section = new Section().appendRange(index,index);\n\n    } else if (getRank() > 1) {\n      Index ii = Index.factory(shape); // convert to nD index\n      ii.setCurrentCounter(index);\n      int[] origin = ii.getCurrentCounter();\n      section = new Section();\n      for (int anOrigin : origin)\n        section.appendRange(anOrigin, anOrigin);\n    }\n\n    Array dataArray = read(section);\n    ArrayStructure data = (ArrayStructure) dataArray;\n    return data.getStructureData(0);\n  }", "language": "java", "Allcodes": "public StructureData readStructure(int index) throws IOException, ucar.ma2.InvalidRangeException {\n    Section section = null; // works for scalars i think\n\n    if (getRank() == 1) {\n      section = new Section().appendRange(index,index);\n\n    } else if (getRank() > 1) {\n      Index ii = Index.factory(shape); // convert to nD index\n      ii.setCurrentCounter(index);\n      int[] origin = ii.getCurrentCounter();\n      section = new Section();\n      for (int anOrigin : origin)\n        section.appendRange(anOrigin, anOrigin);\n    }\n\n    Array dataArray = read(section);\n    ArrayStructure data = (ArrayStructure) dataArray;\n    return data.getStructureData(0);\n  }", "code_tokens": ["public", "StructureData", "readStructure", "(", "int", "index", ")", "throws", "IOException", ",", "ucar", ".", "ma2", ".", "InvalidRangeException", "{", "Section", "section", "=", "null", ";", "// works for scalars i think", "if", "(", "getRank", "(", ")", "==", "1", ")", "{", "section", "=", "new", "Section", "(", ")", ".", "appendRange", "(", "index", ",", "index", ")", ";", "}", "else", "if", "(", "getRank", "(", ")", ">", "1", ")", "{", "Index", "ii", "=", "Index", ".", "factory", "(", "shape", ")", ";", "// convert to nD index", "ii", ".", "setCurrentCounter", "(", "index", ")", ";", "int", "[", "]", "origin", "=", "ii", ".", "getCurrentCounter", "(", ")", ";", "section", "=", "new", "Section", "(", ")", ";", "for", "(", "int", "anOrigin", ":", "origin", ")", "section", ".", "appendRange", "(", "anOrigin", ",", "anOrigin", ")", ";", "}", "Array", "dataArray", "=", "read", "(", "section", ")", ";", "ArrayStructure", "data", "=", "(", "ArrayStructure", ")", "dataArray", ";", "return", "data", ".", "getStructureData", "(", "0", ")", ";", "}"], "docstring": "Use this when this is a one dimensional array of Structures, or you are doing the index calculation yourself for\na multidimension array. This will read only the ith structure, and return the data as a StructureData object.\n@param index index into 1D array\n@return ith StructureData\n@throws java.io.IOException on read error\n@throws ucar.ma2.InvalidRangeException if index out of range", "docstring_tokens": ["Use", "this", "when", "this", "is", "a", "one", "dimensional", "array", "of", "Structures", "or", "you", "are", "doing", "the", "index", "calculation", "yourself", "for", "a", "multidimension", "array", ".", "This", "will", "read", "only", "the", "ith", "structure", "and", "return", "the", "data", "as", "a", "StructureData", "object", "."]}
{"code": "final FxmlPath pathAnnotation = viewType.getDeclaredAnnotation(FxmlPath.class);", "comments": "Get annotation from view", "lines": 4, "repo": "sialcasa/mvvmFX", "path": "mvvmfx/src/main/java/de/saxsys/mvvmfx/internal/viewloader/FxmlViewLoader.java", "func_name": "FxmlViewLoader.createFxmlPath", "original_string": "private String createFxmlPath(Class<?> viewType) {\n        final StringBuilder pathBuilder = new StringBuilder();\n\n        final FxmlPath pathAnnotation = viewType.getDeclaredAnnotation(FxmlPath.class); //Get annotation from view\n        final String fxmlPath = Optional.ofNullable(pathAnnotation)\n                .map(FxmlPath::value)\n                .map(String::trim)\n                .orElse(\"\");\n\n        if (fxmlPath.isEmpty()) {\n            pathBuilder.append(\"/\");\n\n            if (viewType.getPackage() != null) {\n                pathBuilder.append(viewType.getPackage().getName().replaceAll(\"\\\\.\", \"/\"));\n                pathBuilder.append(\"/\");\n            }\n\n            pathBuilder.append(viewType.getSimpleName());\n            pathBuilder.append(\".fxml\");\n        } else {\n            pathBuilder.append(fxmlPath);\n        }\n\n        return pathBuilder.toString();\n    }", "language": "java", "Allcodes": "private String createFxmlPath(Class<?> viewType) {\n        final StringBuilder pathBuilder = new StringBuilder();\n\n        final FxmlPath pathAnnotation = viewType.getDeclaredAnnotation(FxmlPath.class); //Get annotation from view\n        final String fxmlPath = Optional.ofNullable(pathAnnotation)\n                .map(FxmlPath::value)\n                .map(String::trim)\n                .orElse(\"\");\n\n        if (fxmlPath.isEmpty()) {\n            pathBuilder.append(\"/\");\n\n            if (viewType.getPackage() != null) {\n                pathBuilder.append(viewType.getPackage().getName().replaceAll(\"\\\\.\", \"/\"));\n                pathBuilder.append(\"/\");\n            }\n\n            pathBuilder.append(viewType.getSimpleName());\n            pathBuilder.append(\".fxml\");\n        } else {\n            pathBuilder.append(fxmlPath);\n        }\n\n        return pathBuilder.toString();\n    }", "code_tokens": ["private", "String", "createFxmlPath", "(", "Class", "<", "?", ">", "viewType", ")", "{", "final", "StringBuilder", "pathBuilder", "=", "new", "StringBuilder", "(", ")", ";", "final", "FxmlPath", "pathAnnotation", "=", "viewType", ".", "getDeclaredAnnotation", "(", "FxmlPath", ".", "class", ")", ";", "//Get annotation from view", "final", "String", "fxmlPath", "=", "Optional", ".", "ofNullable", "(", "pathAnnotation", ")", ".", "map", "(", "FxmlPath", "::", "value", ")", ".", "map", "(", "String", "::", "trim", ")", ".", "orElse", "(", "\"\"", ")", ";", "if", "(", "fxmlPath", ".", "isEmpty", "(", ")", ")", "{", "pathBuilder", ".", "append", "(", "\"/\"", ")", ";", "if", "(", "viewType", ".", "getPackage", "(", ")", "!=", "null", ")", "{", "pathBuilder", ".", "append", "(", "viewType", ".", "getPackage", "(", ")", ".", "getName", "(", ")", ".", "replaceAll", "(", "\"\\\\.\"", ",", "\"/\"", ")", ")", ";", "pathBuilder", ".", "append", "(", "\"/\"", ")", ";", "}", "pathBuilder", ".", "append", "(", "viewType", ".", "getSimpleName", "(", ")", ")", ";", "pathBuilder", ".", "append", "(", "\".fxml\"", ")", ";", "}", "else", "{", "pathBuilder", ".", "append", "(", "fxmlPath", ")", ";", "}", "return", "pathBuilder", ".", "toString", "(", ")", ";", "}"], "docstring": "This method is used to create a String with the path to the FXML file for\na given View class.\n\nThis is done by taking the package of the view class (if any) and replace\n\".\" with \"/\". After that the Name of the class and the file ending\n\".fxml\" is appended.\n\nIf the View class is annotated with @FxmlPath then the String path supplied\nin the annotation  value will be used.\n\nExample: de.saxsys.myapp.ui.MainView as view class will be transformed to\n\"/de/saxsys/myapp/ui/MainView.fxml\"\n\nExample 2: MainView (located in the default package) will be transformed\nto \"/MainView.fxml\"\n\n@param viewType\nthe view class type.\n@return the path to the fxml file as string.", "docstring_tokens": ["This", "method", "is", "used", "to", "create", "a", "String", "with", "the", "path", "to", "the", "FXML", "file", "for", "a", "given", "View", "class", "."]}
{"code": "return;", "comments": "idempotent naming", "lines": 3, "repo": "tony19/logback-android", "path": "logback-android/src/main/java/ch/qos/logback/core/ContextBase.java", "func_name": "ContextBase.setName", "original_string": "public void setName(String name) throws IllegalStateException {\n    if (name != null && name.equals(this.name)) {\n      return; // idempotent naming\n    }\n    if (this.name == null\n            || CoreConstants.DEFAULT_CONTEXT_NAME.equals(this.name)) {\n      this.name = name;\n    } else {\n      throw new IllegalStateException(\"Context has been already given a name\");\n    }\n  }", "language": "java", "Allcodes": "public void setName(String name) throws IllegalStateException {\n    if (name != null && name.equals(this.name)) {\n      return; // idempotent naming\n    }\n    if (this.name == null\n            || CoreConstants.DEFAULT_CONTEXT_NAME.equals(this.name)) {\n      this.name = name;\n    } else {\n      throw new IllegalStateException(\"Context has been already given a name\");\n    }\n  }", "code_tokens": ["public", "void", "setName", "(", "String", "name", ")", "throws", "IllegalStateException", "{", "if", "(", "name", "!=", "null", "&&", "name", ".", "equals", "(", "this", ".", "name", ")", ")", "{", "return", ";", "// idempotent naming", "}", "if", "(", "this", ".", "name", "==", "null", "||", "CoreConstants", ".", "DEFAULT_CONTEXT_NAME", ".", "equals", "(", "this", ".", "name", ")", ")", "{", "this", ".", "name", "=", "name", ";", "}", "else", "{", "throw", "new", "IllegalStateException", "(", "\"Context has been already given a name\"", ")", ";", "}", "}"], "docstring": "The context name can be set only if it is not already set, or if the\ncurrent name is the default context name, namely \"default\", or if the\ncurrent name and the old name are the same.\n\n@throws IllegalStateException if the context already has a name, other than \"default\".", "docstring_tokens": ["The", "context", "name", "can", "be", "set", "only", "if", "it", "is", "not", "already", "set", "or", "if", "the", "current", "name", "is", "the", "default", "context", "name", "namely", "default", "or", "if", "the", "current", "name", "and", "the", "old", "name", "are", "the", "same", "."]}
{"code": "throw new RuntimeException(e);", "comments": "should never happen", "lines": 27, "repo": "algolia/algoliasearch-client-android", "path": "algoliasearch/src/offline/java/com/algolia/search/saas/OfflineClient.java", "func_name": "OfflineClient.listIndexesOfflineSync", "original_string": "private JSONObject listIndexesOfflineSync() throws AlgoliaException {\n        try {\n            final String rootDataPath = getRootDataDir().getAbsolutePath();\n            final File appDir = getAppDir();\n            final File[] directories = appDir.listFiles(new FileFilter() {\n                @Override\n                public boolean accept(File pathname) {\n                    return pathname.isDirectory();\n                }\n            });\n            JSONObject response = new JSONObject();\n            JSONArray items = new JSONArray();\n            if (directories != null) {\n                for (File directory : directories) {\n                    final String name = directory.getName();\n                    if (hasOfflineData(name)) {\n                        items.put(new JSONObject()\n                            .put(\"name\", name)\n                        );\n                        // TODO: Do we need other data as in the online API?\n                    }\n                }\n            }\n            response.put(\"items\", items);\n            return response;\n        } catch (JSONException e) {\n            throw new RuntimeException(e); // should never happen\n        }\n    }", "language": "java", "Allcodes": "private JSONObject listIndexesOfflineSync() throws AlgoliaException {\n        try {\n            final String rootDataPath = getRootDataDir().getAbsolutePath();\n            final File appDir = getAppDir();\n            final File[] directories = appDir.listFiles(new FileFilter() {\n                @Override\n                public boolean accept(File pathname) {\n                    return pathname.isDirectory();\n                }\n            });\n            JSONObject response = new JSONObject();\n            JSONArray items = new JSONArray();\n            if (directories != null) {\n                for (File directory : directories) {\n                    final String name = directory.getName();\n                    if (hasOfflineData(name)) {\n                        items.put(new JSONObject()\n                            .put(\"name\", name)\n                        );\n                        // TODO: Do we need other data as in the online API?\n                    }\n                }\n            }\n            response.put(\"items\", items);\n            return response;\n        } catch (JSONException e) {\n            throw new RuntimeException(e); // should never happen\n        }\n    }", "code_tokens": ["private", "JSONObject", "listIndexesOfflineSync", "(", ")", "throws", "AlgoliaException", "{", "try", "{", "final", "String", "rootDataPath", "=", "getRootDataDir", "(", ")", ".", "getAbsolutePath", "(", ")", ";", "final", "File", "appDir", "=", "getAppDir", "(", ")", ";", "final", "File", "[", "]", "directories", "=", "appDir", ".", "listFiles", "(", "new", "FileFilter", "(", ")", "{", "@", "Override", "public", "boolean", "accept", "(", "File", "pathname", ")", "{", "return", "pathname", ".", "isDirectory", "(", ")", ";", "}", "}", ")", ";", "JSONObject", "response", "=", "new", "JSONObject", "(", ")", ";", "JSONArray", "items", "=", "new", "JSONArray", "(", ")", ";", "if", "(", "directories", "!=", "null", ")", "{", "for", "(", "File", "directory", ":", "directories", ")", "{", "final", "String", "name", "=", "directory", ".", "getName", "(", ")", ";", "if", "(", "hasOfflineData", "(", "name", ")", ")", "{", "items", ".", "put", "(", "new", "JSONObject", "(", ")", ".", "put", "(", "\"name\"", ",", "name", ")", ")", ";", "// TODO: Do we need other data as in the online API?", "}", "}", "}", "response", ".", "put", "(", "\"items\"", ",", "items", ")", ";", "return", "response", ";", "}", "catch", "(", "JSONException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "// should never happen", "}", "}"], "docstring": "List existing offline indices.\n\n**Note:** This applies both to {@link MirroredIndex} and {@link OfflineIndex} instances. Only indices that\n*actually exist* on disk are listed. If an instance was created but never synced or written to, it will not\nappear in the list.\n\n@return A JSON object with an `items` attribute containing the indices details as JSON objects.", "docstring_tokens": ["List", "existing", "offline", "indices", "."]}
{"code": "String editorId = desc != null?desc.getId():\"org.eclipse.ui.DefaultTextEditor\";", "comments": "$NON-NLS-1$", "lines": 10, "repo": "kiegroup/droolsjbpm-tools", "path": "drools-eclipse/org.guvnor.tools/src/org/guvnor/tools/utils/PlatformUtils.java", "func_name": "PlatformUtils.openEditor", "original_string": "public static void openEditor(String contents, String name) {\n        IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();\n        IStorage storage = new StringStorage(contents, name);\n        IStorageEditorInput input = new StringInput(storage);\n        IWorkbenchPage page = window.getActivePage();\n        IEditorDescriptor desc = PlatformUI.getWorkbench().\n                                    getEditorRegistry().getDefaultEditor(name);\n        // If there is no editor associated with the given file name, we'll just\n        // use the eclipse text editor as a default\n        String editorId = desc != null?desc.getId():\"org.eclipse.ui.DefaultTextEditor\"; //$NON-NLS-1$\n        try {\n        if (page != null) {\n            page.openEditor(input, editorId);\n        }\n        } catch (Exception e) {\n            Activator.getDefault().displayError(IStatus.ERROR, e.getMessage(), e, true);\n        }\n    }", "language": "java", "Allcodes": "public static void openEditor(String contents, String name) {\n        IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();\n        IStorage storage = new StringStorage(contents, name);\n        IStorageEditorInput input = new StringInput(storage);\n        IWorkbenchPage page = window.getActivePage();\n        IEditorDescriptor desc = PlatformUI.getWorkbench().\n                                    getEditorRegistry().getDefaultEditor(name);\n        // If there is no editor associated with the given file name, we'll just\n        // use the eclipse text editor as a default\n        String editorId = desc != null?desc.getId():\"org.eclipse.ui.DefaultTextEditor\"; //$NON-NLS-1$\n        try {\n        if (page != null) {\n            page.openEditor(input, editorId);\n        }\n        } catch (Exception e) {\n            Activator.getDefault().displayError(IStatus.ERROR, e.getMessage(), e, true);\n        }\n    }", "code_tokens": ["public", "static", "void", "openEditor", "(", "String", "contents", ",", "String", "name", ")", "{", "IWorkbenchWindow", "window", "=", "PlatformUI", ".", "getWorkbench", "(", ")", ".", "getActiveWorkbenchWindow", "(", ")", ";", "IStorage", "storage", "=", "new", "StringStorage", "(", "contents", ",", "name", ")", ";", "IStorageEditorInput", "input", "=", "new", "StringInput", "(", "storage", ")", ";", "IWorkbenchPage", "page", "=", "window", ".", "getActivePage", "(", ")", ";", "IEditorDescriptor", "desc", "=", "PlatformUI", ".", "getWorkbench", "(", ")", ".", "getEditorRegistry", "(", ")", ".", "getDefaultEditor", "(", "name", ")", ";", "// If there is no editor associated with the given file name, we'll just", "// use the eclipse text editor as a default", "String", "editorId", "=", "desc", "!=", "null", "?", "desc", ".", "getId", "(", ")", ":", "\"org.eclipse.ui.DefaultTextEditor\"", ";", "//$NON-NLS-1$", "try", "{", "if", "(", "page", "!=", "null", ")", "{", "page", ".", "openEditor", "(", "input", ",", "editorId", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "Activator", ".", "getDefault", "(", ")", ".", "displayError", "(", "IStatus", ".", "ERROR", ",", "e", ".", "getMessage", "(", ")", ",", "e", ",", "true", ")", ";", "}", "}"], "docstring": "Opens a read-only, in-memory editor.\n@param contents The contents for the editor\n@param name The name of the file. Will be used to determine\neclipse editor association, defaulting to text editor\nif no association is found", "docstring_tokens": ["Opens", "a", "read", "-", "only", "in", "-", "memory", "editor", "."]}
{"code": "appendChild(root, \"keepalive\", \"*\");", "comments": "$NON-NLS-1$ //$NON-NLS-2$", "lines": 10, "repo": "kiegroup/droolsjbpm-tools", "path": "drools-eclipse/org.guvnor.eclipse.webdav/src/interface/org/eclipse/webdav/dom/PropertyBehavior.java", "func_name": "PropertyBehavior.setIsKeepAllAlive", "original_string": "public void setIsKeepAllAlive(boolean isKeepAllAlive) {\n        Element child = getFirstChild(root, childNames);\n        boolean isAlreadyKeepAllAlive = false;\n        if (isDAVElement(child, \"keepalive\")) //$NON-NLS-1$\n            isAlreadyKeepAllAlive = \"*\".equals(getFirstText(child)); //$NON-NLS-1$\n        if (isKeepAllAlive) {\n            if (!isAlreadyKeepAllAlive) {\n                if (child != null)\n                    root.removeChild(child);\n                appendChild(root, \"keepalive\", \"*\"); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n        } else if (isAlreadyKeepAllAlive)\n            root.removeChild(child);\n    }", "language": "java", "Allcodes": "public void setIsKeepAllAlive(boolean isKeepAllAlive) {\n        Element child = getFirstChild(root, childNames);\n        boolean isAlreadyKeepAllAlive = false;\n        if (isDAVElement(child, \"keepalive\")) //$NON-NLS-1$\n            isAlreadyKeepAllAlive = \"*\".equals(getFirstText(child)); //$NON-NLS-1$\n        if (isKeepAllAlive) {\n            if (!isAlreadyKeepAllAlive) {\n                if (child != null)\n                    root.removeChild(child);\n                appendChild(root, \"keepalive\", \"*\"); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n        } else if (isAlreadyKeepAllAlive)\n            root.removeChild(child);\n    }", "code_tokens": ["public", "void", "setIsKeepAllAlive", "(", "boolean", "isKeepAllAlive", ")", "{", "Element", "child", "=", "getFirstChild", "(", "root", ",", "childNames", ")", ";", "boolean", "isAlreadyKeepAllAlive", "=", "false", ";", "if", "(", "isDAVElement", "(", "child", ",", "\"keepalive\"", ")", ")", "//$NON-NLS-1$", "isAlreadyKeepAllAlive", "=", "\"*\"", ".", "equals", "(", "getFirstText", "(", "child", ")", ")", ";", "//$NON-NLS-1$", "if", "(", "isKeepAllAlive", ")", "{", "if", "(", "!", "isAlreadyKeepAllAlive", ")", "{", "if", "(", "child", "!=", "null", ")", "root", ".", "removeChild", "(", "child", ")", ";", "appendChild", "(", "root", ",", "\"keepalive\"", ",", "\"*\"", ")", ";", "//$NON-NLS-1$ //$NON-NLS-2$", "}", "}", "else", "if", "(", "isAlreadyKeepAllAlive", ")", "root", ".", "removeChild", "(", "child", ")", ";", "}"], "docstring": "Sets whether this propertybehavior is in the \"keep all alive\" form or\nnot.\n\n@param isKeepAllAlive a boolean indicating whether this\npropertybehavior will be in the \"keep all\nalive\" form", "docstring_tokens": ["Sets", "whether", "this", "propertybehavior", "is", "in", "the", "keep", "all", "alive", "form", "or", "not", "."]}
{"code": "return null;", "comments": "Never reached.", "lines": 7, "repo": "kiegroup/droolsjbpm-tools", "path": "drools-eclipse/org.guvnor.eclipse.webdav/src/interface/org/eclipse/webdav/dom/MultiStatus.java", "func_name": "MultiStatus.addResponse", "original_string": "public ResponseBody addResponse() {\n        Element response = addChild(root, \"response\", childNames, true); //$NON-NLS-1$\n        try {\n            return new ResponseBody(response);\n        } catch (MalformedElementException e) {\n            Assert.isTrue(false, Policy.bind(\"assert.internalError\")); //$NON-NLS-1$\n            return null; // Never reached.\n        }\n    }", "language": "java", "Allcodes": "public ResponseBody addResponse() {\n        Element response = addChild(root, \"response\", childNames, true); //$NON-NLS-1$\n        try {\n            return new ResponseBody(response);\n        } catch (MalformedElementException e) {\n            Assert.isTrue(false, Policy.bind(\"assert.internalError\")); //$NON-NLS-1$\n            return null; // Never reached.\n        }\n    }", "code_tokens": ["public", "ResponseBody", "addResponse", "(", ")", "{", "Element", "response", "=", "addChild", "(", "root", ",", "\"response\"", ",", "childNames", ",", "true", ")", ";", "//$NON-NLS-1$", "try", "{", "return", "new", "ResponseBody", "(", "response", ")", ";", "}", "catch", "(", "MalformedElementException", "e", ")", "{", "Assert", ".", "isTrue", "(", "false", ",", "Policy", ".", "bind", "(", "\"assert.internalError\"", ")", ")", ";", "//$NON-NLS-1$", "return", "null", ";", "// Never reached.", "}", "}"], "docstring": "Creates and adds a response element to this multistatus and returns\nan editor on it.\n\n@return an editor on a response element", "docstring_tokens": ["Creates", "and", "adds", "a", "response", "element", "to", "this", "multistatus", "and", "returns", "an", "editor", "on", "it", "."]}
{"code": "if (t1 == NONNUMERIC) t1 = DOUBLE;", "comments": "Try to interpret strings as doubles...", "lines": 7, "repo": "jkuhnert/ognl", "path": "src/main/java/ognl/OgnlOps.java", "func_name": "OgnlOps.getNumericType", "original_string": "public static int getNumericType(int t1, int t2, boolean canBeNonNumeric)\n    {\n        if (t1 == t2) return t1;\n\n        if (canBeNonNumeric && (t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR)) return NONNUMERIC;\n\n        if (t1 == NONNUMERIC) t1 = DOUBLE; // Try to interpret strings as doubles...\n        if (t2 == NONNUMERIC) t2 = DOUBLE; // Try to interpret strings as doubles...\n\n        if (t1 >= MIN_REAL_TYPE) {\n            if (t2 >= MIN_REAL_TYPE) return Math.max(t1, t2);\n            if (t2 < INT) return t1;\n            if (t2 == BIGINT) return BIGDEC;\n            return Math.max(DOUBLE, t1);\n        } else if (t2 >= MIN_REAL_TYPE) {\n            if (t1 < INT) return t2;\n            if (t1 == BIGINT) return BIGDEC;\n            return Math.max(DOUBLE, t2);\n        } else return Math.max(t1, t2);\n    }", "language": "java", "Allcodes": "public static int getNumericType(int t1, int t2, boolean canBeNonNumeric)\n    {\n        if (t1 == t2) return t1;\n\n        if (canBeNonNumeric && (t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR)) return NONNUMERIC;\n\n        if (t1 == NONNUMERIC) t1 = DOUBLE; // Try to interpret strings as doubles...\n        if (t2 == NONNUMERIC) t2 = DOUBLE; // Try to interpret strings as doubles...\n\n        if (t1 >= MIN_REAL_TYPE) {\n            if (t2 >= MIN_REAL_TYPE) return Math.max(t1, t2);\n            if (t2 < INT) return t1;\n            if (t2 == BIGINT) return BIGDEC;\n            return Math.max(DOUBLE, t1);\n        } else if (t2 >= MIN_REAL_TYPE) {\n            if (t1 < INT) return t2;\n            if (t1 == BIGINT) return BIGDEC;\n            return Math.max(DOUBLE, t2);\n        } else return Math.max(t1, t2);\n    }", "code_tokens": ["public", "static", "int", "getNumericType", "(", "int", "t1", ",", "int", "t2", ",", "boolean", "canBeNonNumeric", ")", "{", "if", "(", "t1", "==", "t2", ")", "return", "t1", ";", "if", "(", "canBeNonNumeric", "&&", "(", "t1", "==", "NONNUMERIC", "||", "t2", "==", "NONNUMERIC", "||", "t1", "==", "CHAR", "||", "t2", "==", "CHAR", ")", ")", "return", "NONNUMERIC", ";", "if", "(", "t1", "==", "NONNUMERIC", ")", "t1", "=", "DOUBLE", ";", "// Try to interpret strings as doubles...", "if", "(", "t2", "==", "NONNUMERIC", ")", "t2", "=", "DOUBLE", ";", "// Try to interpret strings as doubles...", "if", "(", "t1", ">=", "MIN_REAL_TYPE", ")", "{", "if", "(", "t2", ">=", "MIN_REAL_TYPE", ")", "return", "Math", ".", "max", "(", "t1", ",", "t2", ")", ";", "if", "(", "t2", "<", "INT", ")", "return", "t1", ";", "if", "(", "t2", "==", "BIGINT", ")", "return", "BIGDEC", ";", "return", "Math", ".", "max", "(", "DOUBLE", ",", "t1", ")", ";", "}", "else", "if", "(", "t2", ">=", "MIN_REAL_TYPE", ")", "{", "if", "(", "t1", "<", "INT", ")", "return", "t2", ";", "if", "(", "t1", "==", "BIGINT", ")", "return", "BIGDEC", ";", "return", "Math", ".", "max", "(", "DOUBLE", ",", "t2", ")", ";", "}", "else", "return", "Math", ".", "max", "(", "t1", ",", "t2", ")", ";", "}"], "docstring": "Returns the constant from the NumericTypes interface that best expresses the type of an\noperation, which can be either numeric or not, on the two given types.\n\n@param t1\ntype of one argument to an operator\n@param t2\ntype of the other argument\n@param canBeNonNumeric\nwhether the operator can be interpreted as non-numeric\n@return the appropriate constant from the NumericTypes interface", "docstring_tokens": ["Returns", "the", "constant", "from", "the", "NumericTypes", "interface", "that", "best", "expresses", "the", "type", "of", "an", "operation", "which", "can", "be", "either", "numeric", "or", "not", "on", "the", "two", "given", "types", "."]}
{"code": "result.setDuplicateBehavior( Archiver.DUPLICATES_FAIL );", "comments": "Just in case", "lines": 5, "repo": "play2-maven-plugin/play2-maven-plugin", "path": "play2-maven-plugin/src/main/java/com/google/code/play2/plugin/AbstractArchivingMojo.java", "func_name": "AbstractArchivingMojo.getArchiver", "original_string": "protected Archiver getArchiver( String archiverName )\n        throws NoSuchArchiverException\n    {\n        Archiver result = archiverManager.getArchiver( archiverName );\n        result.setDuplicateBehavior( Archiver.DUPLICATES_FAIL ); // Just in case\n        return result;\n    }", "language": "java", "Allcodes": "protected Archiver getArchiver( String archiverName )\n        throws NoSuchArchiverException\n    {\n        Archiver result = archiverManager.getArchiver( archiverName );\n        result.setDuplicateBehavior( Archiver.DUPLICATES_FAIL ); // Just in case\n        return result;\n    }", "code_tokens": ["protected", "Archiver", "getArchiver", "(", "String", "archiverName", ")", "throws", "NoSuchArchiverException", "{", "Archiver", "result", "=", "archiverManager", ".", "getArchiver", "(", "archiverName", ")", ";", "result", ".", "setDuplicateBehavior", "(", "Archiver", ".", "DUPLICATES_FAIL", ")", ";", "// Just in case", "return", "result", ";", "}"], "docstring": "Returns preconfigured archiver\n\n@param archiverName archiver name\n@return archiver\n@throws NoSuchArchiverException for unsupported archiver name", "docstring_tokens": ["Returns", "preconfigured", "archiver"]}
{"code": "helper.getImportStack().addElement( \"AntBuilder\" );", "comments": "import checks that stack is not empty", "lines": 7, "repo": "play2-maven-plugin/play2-maven-plugin", "path": "play2-maven-plugin/src/main/java/com/google/code/play2/plugin/AbstractAntJavaBasedPlay2Mojo.java", "func_name": "AbstractAntJavaBasedPlay2Mojo.createProject", "original_string": "protected Project createProject()\n    {\n        final Project antProject = new Project();\n\n        final ProjectHelper helper = ProjectHelper.getProjectHelper();\n        antProject.addReference( ProjectHelper.PROJECTHELPER_REFERENCE, helper );\n        helper.getImportStack().addElement( \"AntBuilder\" ); // import checks that stack is not empty\n\n        final BuildLogger logger = new NoBannerLogger();\n\n        logger.setMessageOutputLevel( Project.MSG_INFO );\n        logger.setOutputPrintStream( System.out );\n        logger.setErrorPrintStream( System.err );\n\n        antProject.addBuildListener( logger );\n\n        antProject.init();\n        antProject.getBaseDir();\n        return antProject;\n    }", "language": "java", "Allcodes": "protected Project createProject()\n    {\n        final Project antProject = new Project();\n\n        final ProjectHelper helper = ProjectHelper.getProjectHelper();\n        antProject.addReference( ProjectHelper.PROJECTHELPER_REFERENCE, helper );\n        helper.getImportStack().addElement( \"AntBuilder\" ); // import checks that stack is not empty\n\n        final BuildLogger logger = new NoBannerLogger();\n\n        logger.setMessageOutputLevel( Project.MSG_INFO );\n        logger.setOutputPrintStream( System.out );\n        logger.setErrorPrintStream( System.err );\n\n        antProject.addBuildListener( logger );\n\n        antProject.init();\n        antProject.getBaseDir();\n        return antProject;\n    }", "code_tokens": ["protected", "Project", "createProject", "(", ")", "{", "final", "Project", "antProject", "=", "new", "Project", "(", ")", ";", "final", "ProjectHelper", "helper", "=", "ProjectHelper", ".", "getProjectHelper", "(", ")", ";", "antProject", ".", "addReference", "(", "ProjectHelper", ".", "PROJECTHELPER_REFERENCE", ",", "helper", ")", ";", "helper", ".", "getImportStack", "(", ")", ".", "addElement", "(", "\"AntBuilder\"", ")", ";", "// import checks that stack is not empty", "final", "BuildLogger", "logger", "=", "new", "NoBannerLogger", "(", ")", ";", "logger", ".", "setMessageOutputLevel", "(", "Project", ".", "MSG_INFO", ")", ";", "logger", ".", "setOutputPrintStream", "(", "System", ".", "out", ")", ";", "logger", ".", "setErrorPrintStream", "(", "System", ".", "err", ")", ";", "antProject", ".", "addBuildListener", "(", "logger", ")", ";", "antProject", ".", "init", "(", ")", ";", "antProject", ".", "getBaseDir", "(", ")", ";", "return", "antProject", ";", "}"], "docstring": "Creates and configures Ant project for Java task.\n\n@return Ant project for Java task", "docstring_tokens": ["Creates", "and", "configures", "Ant", "project", "for", "Java", "task", "."]}
{"code": "endList(orderedList);", "comments": "find the next matching style", "lines": 22, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/ConverterHtmlToSpanned.java", "func_name": "ConverterHtmlToSpanned.endList", "original_string": "private void endList(boolean orderedList) {\n        if (!mParagraphStyles.isEmpty()) {\n            AccumulatedParagraphStyle style = mParagraphStyles.peek();\n            ParagraphType type = style.getType();\n\n            if ((orderedList && (type.isNumbering() || type == ParagraphType.INDENTATION_OL)) ||\n                    (!orderedList && (type.isBullet() || type == ParagraphType.INDENTATION_UL))) {\n\n                // the end tag matches the current style\n                int indent = style.getRelativeIndent();\n                if (indent > 1) {\n                    style.setRelativeIndent(indent - 1);\n                    style.setAbsoluteIndent(style.getAbsoluteIndent() - 1);\n                } else {\n                    mParagraphStyles.pop();\n                }\n\n            } else {\n\n                // the end tag doesn't match the current style\n                mParagraphStyles.pop();\n                endList(orderedList);    // find the next matching style\n\n            }\n        }\n    }", "language": "java", "Allcodes": "private void endList(boolean orderedList) {\n        if (!mParagraphStyles.isEmpty()) {\n            AccumulatedParagraphStyle style = mParagraphStyles.peek();\n            ParagraphType type = style.getType();\n\n            if ((orderedList && (type.isNumbering() || type == ParagraphType.INDENTATION_OL)) ||\n                    (!orderedList && (type.isBullet() || type == ParagraphType.INDENTATION_UL))) {\n\n                // the end tag matches the current style\n                int indent = style.getRelativeIndent();\n                if (indent > 1) {\n                    style.setRelativeIndent(indent - 1);\n                    style.setAbsoluteIndent(style.getAbsoluteIndent() - 1);\n                } else {\n                    mParagraphStyles.pop();\n                }\n\n            } else {\n\n                // the end tag doesn't match the current style\n                mParagraphStyles.pop();\n                endList(orderedList);    // find the next matching style\n\n            }\n        }\n    }", "code_tokens": ["private", "void", "endList", "(", "boolean", "orderedList", ")", "{", "if", "(", "!", "mParagraphStyles", ".", "isEmpty", "(", ")", ")", "{", "AccumulatedParagraphStyle", "style", "=", "mParagraphStyles", ".", "peek", "(", ")", ";", "ParagraphType", "type", "=", "style", ".", "getType", "(", ")", ";", "if", "(", "(", "orderedList", "&&", "(", "type", ".", "isNumbering", "(", ")", "||", "type", "==", "ParagraphType", ".", "INDENTATION_OL", ")", ")", "||", "(", "!", "orderedList", "&&", "(", "type", ".", "isBullet", "(", ")", "||", "type", "==", "ParagraphType", ".", "INDENTATION_UL", ")", ")", ")", "{", "// the end tag matches the current style", "int", "indent", "=", "style", ".", "getRelativeIndent", "(", ")", ";", "if", "(", "indent", ">", "1", ")", "{", "style", ".", "setRelativeIndent", "(", "indent", "-", "1", ")", ";", "style", ".", "setAbsoluteIndent", "(", "style", ".", "getAbsoluteIndent", "(", ")", "-", "1", ")", ";", "}", "else", "{", "mParagraphStyles", ".", "pop", "(", ")", ";", "}", "}", "else", "{", "// the end tag doesn't match the current style", "mParagraphStyles", ".", "pop", "(", ")", ";", "endList", "(", "orderedList", ")", ";", "// find the next matching style", "}", "}", "}"], "docstring": "Handles OL and UL end tags", "docstring_tokens": ["Handles", "OL", "and", "UL", "end", "tags"]}
{"code": "return start1 - start2;", "comments": "span which starts first comes first", "lines": 7, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/ConverterSpannedToHtml.java", "func_name": "ConverterSpannedToHtml.withinParagraph", "original_string": "private void withinParagraph(final Spanned text, int start, int end) {\n        // create sorted set of CharacterStyles\n        SortedSet<CharacterStyle> sortedSpans = new TreeSet<>((s1, s2) -> {\n            int start1 = text.getSpanStart(s1);\n            int start2 = text.getSpanStart(s2);\n            if (start1 != start2)\n                return start1 - start2;        // span which starts first comes first\n\n            int end1 = text.getSpanEnd(s1);\n            int end2 = text.getSpanEnd(s2);\n            if (end1 != end2) return end2 - end1;                // longer span comes first\n\n            // if the paragraphs have the same span [start, end] we compare their name\n            // compare the name only because local + anonymous classes have no canonical name\n            return s1.getClass().getName().compareTo(s2.getClass().getName());\n        });\n        List<CharacterStyle> spanList = Arrays.asList(text.getSpans(start, end, CharacterStyle.class));\n        sortedSpans.addAll(spanList);\n\n        // process paragraphs/divs\n        convertText(text, start, end, sortedSpans);\n    }", "language": "java", "Allcodes": "private void withinParagraph(final Spanned text, int start, int end) {\n        // create sorted set of CharacterStyles\n        SortedSet<CharacterStyle> sortedSpans = new TreeSet<>((s1, s2) -> {\n            int start1 = text.getSpanStart(s1);\n            int start2 = text.getSpanStart(s2);\n            if (start1 != start2)\n                return start1 - start2;        // span which starts first comes first\n\n            int end1 = text.getSpanEnd(s1);\n            int end2 = text.getSpanEnd(s2);\n            if (end1 != end2) return end2 - end1;                // longer span comes first\n\n            // if the paragraphs have the same span [start, end] we compare their name\n            // compare the name only because local + anonymous classes have no canonical name\n            return s1.getClass().getName().compareTo(s2.getClass().getName());\n        });\n        List<CharacterStyle> spanList = Arrays.asList(text.getSpans(start, end, CharacterStyle.class));\n        sortedSpans.addAll(spanList);\n\n        // process paragraphs/divs\n        convertText(text, start, end, sortedSpans);\n    }", "code_tokens": ["private", "void", "withinParagraph", "(", "final", "Spanned", "text", ",", "int", "start", ",", "int", "end", ")", "{", "// create sorted set of CharacterStyles", "SortedSet", "<", "CharacterStyle", ">", "sortedSpans", "=", "new", "TreeSet", "<>", "(", "(", "s1", ",", "s2", ")", "->", "{", "int", "start1", "=", "text", ".", "getSpanStart", "(", "s1", ")", ";", "int", "start2", "=", "text", ".", "getSpanStart", "(", "s2", ")", ";", "if", "(", "start1", "!=", "start2", ")", "return", "start1", "-", "start2", ";", "// span which starts first comes first", "int", "end1", "=", "text", ".", "getSpanEnd", "(", "s1", ")", ";", "int", "end2", "=", "text", ".", "getSpanEnd", "(", "s2", ")", ";", "if", "(", "end1", "!=", "end2", ")", "return", "end2", "-", "end1", ";", "// longer span comes first", "// if the paragraphs have the same span [start, end] we compare their name", "// compare the name only because local + anonymous classes have no canonical name", "return", "s1", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "compareTo", "(", "s2", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "}", ")", ";", "List", "<", "CharacterStyle", ">", "spanList", "=", "Arrays", ".", "asList", "(", "text", ".", "getSpans", "(", "start", ",", "end", ",", "CharacterStyle", ".", "class", ")", ")", ";", "sortedSpans", ".", "addAll", "(", "spanList", ")", ";", "// process paragraphs/divs", "convertText", "(", "text", ",", "start", ",", "end", ",", "sortedSpans", ")", ";", "}"], "docstring": "Convert a spanned text within a paragraph", "docstring_tokens": ["Convert", "a", "spanned", "text", "within", "a", "paragraph"]}
{"code": "if (end1 != end2) return end2 - end1;", "comments": "longer span comes first", "lines": 11, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/ConverterSpannedToHtml.java", "func_name": "ConverterSpannedToHtml.withinParagraph", "original_string": "private void withinParagraph(final Spanned text, int start, int end) {\n        // create sorted set of CharacterStyles\n        SortedSet<CharacterStyle> sortedSpans = new TreeSet<>((s1, s2) -> {\n            int start1 = text.getSpanStart(s1);\n            int start2 = text.getSpanStart(s2);\n            if (start1 != start2)\n                return start1 - start2;        // span which starts first comes first\n\n            int end1 = text.getSpanEnd(s1);\n            int end2 = text.getSpanEnd(s2);\n            if (end1 != end2) return end2 - end1;                // longer span comes first\n\n            // if the paragraphs have the same span [start, end] we compare their name\n            // compare the name only because local + anonymous classes have no canonical name\n            return s1.getClass().getName().compareTo(s2.getClass().getName());\n        });\n        List<CharacterStyle> spanList = Arrays.asList(text.getSpans(start, end, CharacterStyle.class));\n        sortedSpans.addAll(spanList);\n\n        // process paragraphs/divs\n        convertText(text, start, end, sortedSpans);\n    }", "language": "java", "Allcodes": "private void withinParagraph(final Spanned text, int start, int end) {\n        // create sorted set of CharacterStyles\n        SortedSet<CharacterStyle> sortedSpans = new TreeSet<>((s1, s2) -> {\n            int start1 = text.getSpanStart(s1);\n            int start2 = text.getSpanStart(s2);\n            if (start1 != start2)\n                return start1 - start2;        // span which starts first comes first\n\n            int end1 = text.getSpanEnd(s1);\n            int end2 = text.getSpanEnd(s2);\n            if (end1 != end2) return end2 - end1;                // longer span comes first\n\n            // if the paragraphs have the same span [start, end] we compare their name\n            // compare the name only because local + anonymous classes have no canonical name\n            return s1.getClass().getName().compareTo(s2.getClass().getName());\n        });\n        List<CharacterStyle> spanList = Arrays.asList(text.getSpans(start, end, CharacterStyle.class));\n        sortedSpans.addAll(spanList);\n\n        // process paragraphs/divs\n        convertText(text, start, end, sortedSpans);\n    }", "code_tokens": ["private", "void", "withinParagraph", "(", "final", "Spanned", "text", ",", "int", "start", ",", "int", "end", ")", "{", "// create sorted set of CharacterStyles", "SortedSet", "<", "CharacterStyle", ">", "sortedSpans", "=", "new", "TreeSet", "<>", "(", "(", "s1", ",", "s2", ")", "->", "{", "int", "start1", "=", "text", ".", "getSpanStart", "(", "s1", ")", ";", "int", "start2", "=", "text", ".", "getSpanStart", "(", "s2", ")", ";", "if", "(", "start1", "!=", "start2", ")", "return", "start1", "-", "start2", ";", "// span which starts first comes first", "int", "end1", "=", "text", ".", "getSpanEnd", "(", "s1", ")", ";", "int", "end2", "=", "text", ".", "getSpanEnd", "(", "s2", ")", ";", "if", "(", "end1", "!=", "end2", ")", "return", "end2", "-", "end1", ";", "// longer span comes first", "// if the paragraphs have the same span [start, end] we compare their name", "// compare the name only because local + anonymous classes have no canonical name", "return", "s1", ".", "getClass", "(", ")", ".", "getName", "(", ")", ".", "compareTo", "(", "s2", ".", "getClass", "(", ")", ".", "getName", "(", ")", ")", ";", "}", ")", ";", "List", "<", "CharacterStyle", ">", "spanList", "=", "Arrays", ".", "asList", "(", "text", ".", "getSpans", "(", "start", ",", "end", ",", "CharacterStyle", ".", "class", ")", ")", ";", "sortedSpans", ".", "addAll", "(", "spanList", ")", ";", "// process paragraphs/divs", "convertText", "(", "text", ",", "start", ",", "end", ",", "sortedSpans", ")", ";", "}"], "docstring": "Convert a spanned text within a paragraph", "docstring_tokens": ["Convert", "a", "spanned", "text", "within", "a", "paragraph"]}
{"code": "return null;", "comments": "Missing permissions or corrupted font file?", "lines": 8, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/fonts/TTFAnalyzer.java", "func_name": "TTFAnalyzer.getFontName", "original_string": "static String getFontName(String filePath) {\n        TTFRandomAccessFile in = null;\n        try {\n            RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n            in = new TTFRandomAccessFile(file);\n            return getTTFFontName(in, filePath);\n        } catch (IOException e) {\n            return null;    // Missing permissions or corrupted font file?\n        }\n        finally {\n            IOUtils.closeQuietly(in);\n        }\n    }", "language": "java", "Allcodes": "static String getFontName(String filePath) {\n        TTFRandomAccessFile in = null;\n        try {\n            RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n            in = new TTFRandomAccessFile(file);\n            return getTTFFontName(in, filePath);\n        } catch (IOException e) {\n            return null;    // Missing permissions or corrupted font file?\n        }\n        finally {\n            IOUtils.closeQuietly(in);\n        }\n    }", "code_tokens": ["static", "String", "getFontName", "(", "String", "filePath", ")", "{", "TTFRandomAccessFile", "in", "=", "null", ";", "try", "{", "RandomAccessFile", "file", "=", "new", "RandomAccessFile", "(", "filePath", ",", "\"r\"", ")", ";", "in", "=", "new", "TTFRandomAccessFile", "(", "file", ")", ";", "return", "getTTFFontName", "(", "in", ",", "filePath", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "return", "null", ";", "// Missing permissions or corrupted font file?", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "in", ")", ";", "}", "}"], "docstring": "Retrieve the file name for a system font.\n\n@param filePath the full path for the font to retrieve.\n\n@return The file name or null of none could be retrieved.", "docstring_tokens": ["Retrieve", "the", "file", "name", "for", "a", "system", "font", "."]}
{"code": "return null;", "comments": "Missing permissions?", "lines": 8, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/fonts/TTFAnalyzer.java", "func_name": "TTFAnalyzer.getFontName", "original_string": "static String getFontName(AssetManager assets, String filePath) {\n        TTFAssetInputStream in = null;\n        try {\n            InputStream file = assets.open(filePath, AssetManager.ACCESS_RANDOM);\n            in = new TTFAssetInputStream(file);\n            return getTTFFontName(in, filePath);\n        } catch (FileNotFoundException e) {\n            return null;    // Missing permissions?\n        } catch (IOException e) {\n            return null;    // Corrupted font file?\n        }\n        finally {\n            IOUtils.closeQuietly(in);\n        }\n    }", "language": "java", "Allcodes": "static String getFontName(AssetManager assets, String filePath) {\n        TTFAssetInputStream in = null;\n        try {\n            InputStream file = assets.open(filePath, AssetManager.ACCESS_RANDOM);\n            in = new TTFAssetInputStream(file);\n            return getTTFFontName(in, filePath);\n        } catch (FileNotFoundException e) {\n            return null;    // Missing permissions?\n        } catch (IOException e) {\n            return null;    // Corrupted font file?\n        }\n        finally {\n            IOUtils.closeQuietly(in);\n        }\n    }", "code_tokens": ["static", "String", "getFontName", "(", "AssetManager", "assets", ",", "String", "filePath", ")", "{", "TTFAssetInputStream", "in", "=", "null", ";", "try", "{", "InputStream", "file", "=", "assets", ".", "open", "(", "filePath", ",", "AssetManager", ".", "ACCESS_RANDOM", ")", ";", "in", "=", "new", "TTFAssetInputStream", "(", "file", ")", ";", "return", "getTTFFontName", "(", "in", ",", "filePath", ")", ";", "}", "catch", "(", "FileNotFoundException", "e", ")", "{", "return", "null", ";", "// Missing permissions?", "}", "catch", "(", "IOException", "e", ")", "{", "return", "null", ";", "// Corrupted font file?", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "in", ")", ";", "}", "}"], "docstring": "Retrieve the file name for a font in the asset folder.\n\n@param filePath the full path for the font in the asset folder to retrieve.\n\n@return The file name or null of none could be retrieved.", "docstring_tokens": ["Retrieve", "the", "file", "name", "for", "a", "font", "in", "the", "asset", "folder", "."]}
{"code": "return null;", "comments": "Corrupted font file?", "lines": 10, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/fonts/TTFAnalyzer.java", "func_name": "TTFAnalyzer.getFontName", "original_string": "static String getFontName(AssetManager assets, String filePath) {\n        TTFAssetInputStream in = null;\n        try {\n            InputStream file = assets.open(filePath, AssetManager.ACCESS_RANDOM);\n            in = new TTFAssetInputStream(file);\n            return getTTFFontName(in, filePath);\n        } catch (FileNotFoundException e) {\n            return null;    // Missing permissions?\n        } catch (IOException e) {\n            return null;    // Corrupted font file?\n        }\n        finally {\n            IOUtils.closeQuietly(in);\n        }\n    }", "language": "java", "Allcodes": "static String getFontName(AssetManager assets, String filePath) {\n        TTFAssetInputStream in = null;\n        try {\n            InputStream file = assets.open(filePath, AssetManager.ACCESS_RANDOM);\n            in = new TTFAssetInputStream(file);\n            return getTTFFontName(in, filePath);\n        } catch (FileNotFoundException e) {\n            return null;    // Missing permissions?\n        } catch (IOException e) {\n            return null;    // Corrupted font file?\n        }\n        finally {\n            IOUtils.closeQuietly(in);\n        }\n    }", "code_tokens": ["static", "String", "getFontName", "(", "AssetManager", "assets", ",", "String", "filePath", ")", "{", "TTFAssetInputStream", "in", "=", "null", ";", "try", "{", "InputStream", "file", "=", "assets", ".", "open", "(", "filePath", ",", "AssetManager", ".", "ACCESS_RANDOM", ")", ";", "in", "=", "new", "TTFAssetInputStream", "(", "file", ")", ";", "return", "getTTFFontName", "(", "in", ",", "filePath", ")", ";", "}", "catch", "(", "FileNotFoundException", "e", ")", "{", "return", "null", ";", "// Missing permissions?", "}", "catch", "(", "IOException", "e", ")", "{", "return", "null", ";", "// Corrupted font file?", "}", "finally", "{", "IOUtils", ".", "closeQuietly", "(", "in", ")", ";", "}", "}"], "docstring": "Retrieve the file name for a font in the asset folder.\n\n@param filePath the full path for the font in the asset folder to retrieve.\n\n@return The file name or null of none could be retrieved.", "docstring_tokens": ["Retrieve", "the", "file", "name", "for", "a", "font", "in", "the", "asset", "folder", "."]}
{"code": "return;", "comments": "empty stack", "lines": 3, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/tagsoup/Parser.java", "func_name": "Parser.pop", "original_string": "private void pop() throws SAXException {\n        if (theStack == null)\n            return; // empty stack\n        String name = theStack.name();\n        String localName = theStack.localName();\n        String namespace = theStack.namespace();\n        String prefix = prefixOf(name);\n\n        if (!namespaces)\n            namespace = localName = \"\";\n        theContentHandler.endElement(namespace, localName, name);\n        if (foreign(prefix, namespace)) {\n            theContentHandler.endPrefixMapping(prefix);\n            // \"] for elements to \" + namespace);\n        }\n        Attributes atts = theStack.atts();\n        for (int i = atts.getLength() - 1; i >= 0; i--) {\n            String attNamespace = atts.getURI(i);\n            String attPrefix = prefixOf(atts.getQName(i));\n            if (foreign(attPrefix, attNamespace)) {\n                theContentHandler.endPrefixMapping(attPrefix);\n                // \"] for attributes to \" + attNamespace);\n            }\n        }\n        theStack = theStack.next();\n    }", "language": "java", "Allcodes": "private void pop() throws SAXException {\n        if (theStack == null)\n            return; // empty stack\n        String name = theStack.name();\n        String localName = theStack.localName();\n        String namespace = theStack.namespace();\n        String prefix = prefixOf(name);\n\n        if (!namespaces)\n            namespace = localName = \"\";\n        theContentHandler.endElement(namespace, localName, name);\n        if (foreign(prefix, namespace)) {\n            theContentHandler.endPrefixMapping(prefix);\n            // \"] for elements to \" + namespace);\n        }\n        Attributes atts = theStack.atts();\n        for (int i = atts.getLength() - 1; i >= 0; i--) {\n            String attNamespace = atts.getURI(i);\n            String attPrefix = prefixOf(atts.getQName(i));\n            if (foreign(attPrefix, attNamespace)) {\n                theContentHandler.endPrefixMapping(attPrefix);\n                // \"] for attributes to \" + attNamespace);\n            }\n        }\n        theStack = theStack.next();\n    }", "code_tokens": ["private", "void", "pop", "(", ")", "throws", "SAXException", "{", "if", "(", "theStack", "==", "null", ")", "return", ";", "// empty stack", "String", "name", "=", "theStack", ".", "name", "(", ")", ";", "String", "localName", "=", "theStack", ".", "localName", "(", ")", ";", "String", "namespace", "=", "theStack", ".", "namespace", "(", ")", ";", "String", "prefix", "=", "prefixOf", "(", "name", ")", ";", "if", "(", "!", "namespaces", ")", "namespace", "=", "localName", "=", "\"\"", ";", "theContentHandler", ".", "endElement", "(", "namespace", ",", "localName", ",", "name", ")", ";", "if", "(", "foreign", "(", "prefix", ",", "namespace", ")", ")", "{", "theContentHandler", ".", "endPrefixMapping", "(", "prefix", ")", ";", "// \"] for elements to \" + namespace);", "}", "Attributes", "atts", "=", "theStack", ".", "atts", "(", ")", ";", "for", "(", "int", "i", "=", "atts", ".", "getLength", "(", ")", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "String", "attNamespace", "=", "atts", ".", "getURI", "(", "i", ")", ";", "String", "attPrefix", "=", "prefixOf", "(", "atts", ".", "getQName", "(", "i", ")", ")", ";", "if", "(", "foreign", "(", "attPrefix", ",", "attNamespace", ")", ")", "{", "theContentHandler", ".", "endPrefixMapping", "(", "attPrefix", ")", ";", "// \"] for attributes to \" + attNamespace);", "}", "}", "theStack", "=", "theStack", ".", "next", "(", ")", ";", "}"], "docstring": "Pop the stack irrevocably", "docstring_tokens": ["Pop", "the", "stack", "irrevocably"]}
{"code": "boolean sq = false;", "comments": "single quote", "lines": 9, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/tagsoup/Parser.java", "func_name": "Parser.split", "original_string": "private static String[] split(String val) throws IllegalArgumentException {\n        val = val.trim();\n        if (val.length() == 0) {\n            return new String[0];\n        } else {\n            ArrayList<String> l = new ArrayList<String>();\n            int s = 0;\n            int e = 0;\n            boolean sq = false; // single quote\n            boolean dq = false; // double quote\n            char lastc = 0;\n            int len = val.length();\n            for (e = 0; e < len; e++) {\n                char c = val.charAt(e);\n                if (!dq && c == '\\'' && lastc != '\\\\') {\n                    sq = !sq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && c == '\\\"' && lastc != '\\\\') {\n                    dq = !dq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && !dq) {\n                    if (Character.isWhitespace(c)) {\n                        if (s >= 0)\n                            l.add(val.substring(s, e));\n                        s = -1;\n                    } else if (s < 0 && c != ' ') {\n                        s = e;\n                    }\n                }\n                lastc = c;\n            }\n            l.add(val.substring(s, e));\n            return (String[]) l.toArray(new String[0]);\n        }\n    }", "language": "java", "Allcodes": "private static String[] split(String val) throws IllegalArgumentException {\n        val = val.trim();\n        if (val.length() == 0) {\n            return new String[0];\n        } else {\n            ArrayList<String> l = new ArrayList<String>();\n            int s = 0;\n            int e = 0;\n            boolean sq = false; // single quote\n            boolean dq = false; // double quote\n            char lastc = 0;\n            int len = val.length();\n            for (e = 0; e < len; e++) {\n                char c = val.charAt(e);\n                if (!dq && c == '\\'' && lastc != '\\\\') {\n                    sq = !sq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && c == '\\\"' && lastc != '\\\\') {\n                    dq = !dq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && !dq) {\n                    if (Character.isWhitespace(c)) {\n                        if (s >= 0)\n                            l.add(val.substring(s, e));\n                        s = -1;\n                    } else if (s < 0 && c != ' ') {\n                        s = e;\n                    }\n                }\n                lastc = c;\n            }\n            l.add(val.substring(s, e));\n            return (String[]) l.toArray(new String[0]);\n        }\n    }", "code_tokens": ["private", "static", "String", "[", "]", "split", "(", "String", "val", ")", "throws", "IllegalArgumentException", "{", "val", "=", "val", ".", "trim", "(", ")", ";", "if", "(", "val", ".", "length", "(", ")", "==", "0", ")", "{", "return", "new", "String", "[", "0", "]", ";", "}", "else", "{", "ArrayList", "<", "String", ">", "l", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "int", "s", "=", "0", ";", "int", "e", "=", "0", ";", "boolean", "sq", "=", "false", ";", "// single quote", "boolean", "dq", "=", "false", ";", "// double quote", "char", "lastc", "=", "0", ";", "int", "len", "=", "val", ".", "length", "(", ")", ";", "for", "(", "e", "=", "0", ";", "e", "<", "len", ";", "e", "++", ")", "{", "char", "c", "=", "val", ".", "charAt", "(", "e", ")", ";", "if", "(", "!", "dq", "&&", "c", "==", "'", "'", "&&", "lastc", "!=", "'", "'", ")", "{", "sq", "=", "!", "sq", ";", "if", "(", "s", "<", "0", ")", "s", "=", "e", ";", "}", "else", "if", "(", "!", "sq", "&&", "c", "==", "'", "'", "&&", "lastc", "!=", "'", "'", ")", "{", "dq", "=", "!", "dq", ";", "if", "(", "s", "<", "0", ")", "s", "=", "e", ";", "}", "else", "if", "(", "!", "sq", "&&", "!", "dq", ")", "{", "if", "(", "Character", ".", "isWhitespace", "(", "c", ")", ")", "{", "if", "(", "s", ">=", "0", ")", "l", ".", "add", "(", "val", ".", "substring", "(", "s", ",", "e", ")", ")", ";", "s", "=", "-", "1", ";", "}", "else", "if", "(", "s", "<", "0", "&&", "c", "!=", "'", "'", ")", "{", "s", "=", "e", ";", "}", "}", "lastc", "=", "c", ";", "}", "l", ".", "add", "(", "val", ".", "substring", "(", "s", ",", "e", ")", ")", ";", "return", "(", "String", "[", "]", ")", "l", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ";", "}", "}"], "docstring": "Recognises quotes around a phrase and doesn't split it.", "docstring_tokens": ["Recognises", "quotes", "around", "a", "phrase", "and", "doesn", "t", "split", "it", "."]}
{"code": "boolean dq = false;", "comments": "double quote", "lines": 10, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/tagsoup/Parser.java", "func_name": "Parser.split", "original_string": "private static String[] split(String val) throws IllegalArgumentException {\n        val = val.trim();\n        if (val.length() == 0) {\n            return new String[0];\n        } else {\n            ArrayList<String> l = new ArrayList<String>();\n            int s = 0;\n            int e = 0;\n            boolean sq = false; // single quote\n            boolean dq = false; // double quote\n            char lastc = 0;\n            int len = val.length();\n            for (e = 0; e < len; e++) {\n                char c = val.charAt(e);\n                if (!dq && c == '\\'' && lastc != '\\\\') {\n                    sq = !sq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && c == '\\\"' && lastc != '\\\\') {\n                    dq = !dq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && !dq) {\n                    if (Character.isWhitespace(c)) {\n                        if (s >= 0)\n                            l.add(val.substring(s, e));\n                        s = -1;\n                    } else if (s < 0 && c != ' ') {\n                        s = e;\n                    }\n                }\n                lastc = c;\n            }\n            l.add(val.substring(s, e));\n            return (String[]) l.toArray(new String[0]);\n        }\n    }", "language": "java", "Allcodes": "private static String[] split(String val) throws IllegalArgumentException {\n        val = val.trim();\n        if (val.length() == 0) {\n            return new String[0];\n        } else {\n            ArrayList<String> l = new ArrayList<String>();\n            int s = 0;\n            int e = 0;\n            boolean sq = false; // single quote\n            boolean dq = false; // double quote\n            char lastc = 0;\n            int len = val.length();\n            for (e = 0; e < len; e++) {\n                char c = val.charAt(e);\n                if (!dq && c == '\\'' && lastc != '\\\\') {\n                    sq = !sq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && c == '\\\"' && lastc != '\\\\') {\n                    dq = !dq;\n                    if (s < 0)\n                        s = e;\n                } else if (!sq && !dq) {\n                    if (Character.isWhitespace(c)) {\n                        if (s >= 0)\n                            l.add(val.substring(s, e));\n                        s = -1;\n                    } else if (s < 0 && c != ' ') {\n                        s = e;\n                    }\n                }\n                lastc = c;\n            }\n            l.add(val.substring(s, e));\n            return (String[]) l.toArray(new String[0]);\n        }\n    }", "code_tokens": ["private", "static", "String", "[", "]", "split", "(", "String", "val", ")", "throws", "IllegalArgumentException", "{", "val", "=", "val", ".", "trim", "(", ")", ";", "if", "(", "val", ".", "length", "(", ")", "==", "0", ")", "{", "return", "new", "String", "[", "0", "]", ";", "}", "else", "{", "ArrayList", "<", "String", ">", "l", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "int", "s", "=", "0", ";", "int", "e", "=", "0", ";", "boolean", "sq", "=", "false", ";", "// single quote", "boolean", "dq", "=", "false", ";", "// double quote", "char", "lastc", "=", "0", ";", "int", "len", "=", "val", ".", "length", "(", ")", ";", "for", "(", "e", "=", "0", ";", "e", "<", "len", ";", "e", "++", ")", "{", "char", "c", "=", "val", ".", "charAt", "(", "e", ")", ";", "if", "(", "!", "dq", "&&", "c", "==", "'", "'", "&&", "lastc", "!=", "'", "'", ")", "{", "sq", "=", "!", "sq", ";", "if", "(", "s", "<", "0", ")", "s", "=", "e", ";", "}", "else", "if", "(", "!", "sq", "&&", "c", "==", "'", "'", "&&", "lastc", "!=", "'", "'", ")", "{", "dq", "=", "!", "dq", ";", "if", "(", "s", "<", "0", ")", "s", "=", "e", ";", "}", "else", "if", "(", "!", "sq", "&&", "!", "dq", ")", "{", "if", "(", "Character", ".", "isWhitespace", "(", "c", ")", ")", "{", "if", "(", "s", ">=", "0", ")", "l", ".", "add", "(", "val", ".", "substring", "(", "s", ",", "e", ")", ")", ";", "s", "=", "-", "1", ";", "}", "else", "if", "(", "s", "<", "0", "&&", "c", "!=", "'", "'", ")", "{", "s", "=", "e", ";", "}", "}", "lastc", "=", "c", ";", "}", "l", ".", "add", "(", "val", ".", "substring", "(", "s", ",", "e", ")", ")", ";", "return", "(", "String", "[", "]", ")", "l", ".", "toArray", "(", "new", "String", "[", "0", "]", ")", ";", "}", "}"], "docstring": "Recognises quotes around a phrase and doesn't split it.", "docstring_tokens": ["Recognises", "quotes", "around", "a", "phrase", "and", "doesn", "t", "split", "it", "."]}
{"code": "return;", "comments": "don't know what to do", "lines": 19, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/converter/tagsoup/Parser.java", "func_name": "Parser.rectify", "original_string": "private void rectify(Element e) throws SAXException {\n        Element sp;\n        while (true) {\n            for (sp = theStack; sp != null; sp = sp.next()) {\n                if (sp.canContain(e))\n                    break;\n            }\n            if (sp != null)\n                break;\n            ElementType parentType = e.parent();\n            if (parentType == null)\n                break;\n            Element parent = new Element(parentType, defaultAttributes);\n            // parent.name());\n            parent.setNext(e);\n            e = parent;\n        }\n        if (sp == null)\n            return; // don't know what to do\n        while (theStack != sp) {\n            if (theStack == null || theStack.next() == null\n                    || theStack.next().next() == null)\n                break;\n            restartablyPop();\n        }\n        while (e != null) {\n            Element nexte = e.next();\n            if (!e.name().equals(\"<pcdata>\"))\n                push(e);\n            e = nexte;\n            restart(e);\n        }\n        theNewElement = null;\n    }", "language": "java", "Allcodes": "private void rectify(Element e) throws SAXException {\n        Element sp;\n        while (true) {\n            for (sp = theStack; sp != null; sp = sp.next()) {\n                if (sp.canContain(e))\n                    break;\n            }\n            if (sp != null)\n                break;\n            ElementType parentType = e.parent();\n            if (parentType == null)\n                break;\n            Element parent = new Element(parentType, defaultAttributes);\n            // parent.name());\n            parent.setNext(e);\n            e = parent;\n        }\n        if (sp == null)\n            return; // don't know what to do\n        while (theStack != sp) {\n            if (theStack == null || theStack.next() == null\n                    || theStack.next().next() == null)\n                break;\n            restartablyPop();\n        }\n        while (e != null) {\n            Element nexte = e.next();\n            if (!e.name().equals(\"<pcdata>\"))\n                push(e);\n            e = nexte;\n            restart(e);\n        }\n        theNewElement = null;\n    }", "code_tokens": ["private", "void", "rectify", "(", "Element", "e", ")", "throws", "SAXException", "{", "Element", "sp", ";", "while", "(", "true", ")", "{", "for", "(", "sp", "=", "theStack", ";", "sp", "!=", "null", ";", "sp", "=", "sp", ".", "next", "(", ")", ")", "{", "if", "(", "sp", ".", "canContain", "(", "e", ")", ")", "break", ";", "}", "if", "(", "sp", "!=", "null", ")", "break", ";", "ElementType", "parentType", "=", "e", ".", "parent", "(", ")", ";", "if", "(", "parentType", "==", "null", ")", "break", ";", "Element", "parent", "=", "new", "Element", "(", "parentType", ",", "defaultAttributes", ")", ";", "// parent.name());", "parent", ".", "setNext", "(", "e", ")", ";", "e", "=", "parent", ";", "}", "if", "(", "sp", "==", "null", ")", "return", ";", "// don't know what to do", "while", "(", "theStack", "!=", "sp", ")", "{", "if", "(", "theStack", "==", "null", "||", "theStack", ".", "next", "(", ")", "==", "null", "||", "theStack", ".", "next", "(", ")", ".", "next", "(", ")", "==", "null", ")", "break", ";", "restartablyPop", "(", ")", ";", "}", "while", "(", "e", "!=", "null", ")", "{", "Element", "nexte", "=", "e", ".", "next", "(", ")", ";", "if", "(", "!", "e", ".", "name", "(", ")", ".", "equals", "(", "\"<pcdata>\"", ")", ")", "push", "(", "e", ")", ";", "e", "=", "nexte", ";", "restart", "(", "e", ")", ";", "}", "theNewElement", "=", "null", ";", "}"], "docstring": "so that the argument can be safely pushed", "docstring_tokens": ["so", "that", "the", "argument", "can", "be", "safely", "pushed"]}
{"code": "editor.applyEffect(Effects.LINK, url);", "comments": "if url == null -> remove the link", "lines": 30, "repo": "1gravity/Android-RTEditor", "path": "RTEditor/src/main/java/com/onegravity/rteditor/RTManager.java", "func_name": "RTManager.onEventMainThread", "original_string": "@Subscribe(threadMode = ThreadMode.MAIN)\n    public void onEventMainThread(LinkEvent event) {\n        final String fragmentTag = event.getFragmentTag();\n        mRTApi.removeFragment(fragmentTag);\n\n        if (!event.wasCancelled() && ID_01_LINK_FRAGMENT.equals(fragmentTag)) {\n\n            RTEditText editor = getActiveEditor();\n            if (editor != null) {\n\n                Link link = event.getLink();\n                String url = null;\n                if (link != null && link.isValid()) {\n\n                    // the mLinkSelection.end() <= editor.length() check is necessary since\n                    // the editor text can change when the link fragment is open\n                    Selection selection = mLinkSelection != null && mLinkSelection.end() <= editor.length() ? mLinkSelection : new Selection(editor);\n\n                    String linkText = link.getLinkText();\n\n                    // if no text is selected this inserts the entered link text\n                    // if text is selected we replace it by the link text\n                    Editable str = editor.getText();\n                    str.replace(selection.start(), selection.end(), linkText);\n                    editor.setSelection(selection.start(), selection.start() + linkText.length());\n\n                    url = link.getUrl();\n\n                }\n                editor.applyEffect(Effects.LINK, url);    // if url == null -> remove the link\n\n            }\n\n        }\n    }", "language": "java", "Allcodes": "@Subscribe(threadMode = ThreadMode.MAIN)\n    public void onEventMainThread(LinkEvent event) {\n        final String fragmentTag = event.getFragmentTag();\n        mRTApi.removeFragment(fragmentTag);\n\n        if (!event.wasCancelled() && ID_01_LINK_FRAGMENT.equals(fragmentTag)) {\n\n            RTEditText editor = getActiveEditor();\n            if (editor != null) {\n\n                Link link = event.getLink();\n                String url = null;\n                if (link != null && link.isValid()) {\n\n                    // the mLinkSelection.end() <= editor.length() check is necessary since\n                    // the editor text can change when the link fragment is open\n                    Selection selection = mLinkSelection != null && mLinkSelection.end() <= editor.length() ? mLinkSelection : new Selection(editor);\n\n                    String linkText = link.getLinkText();\n\n                    // if no text is selected this inserts the entered link text\n                    // if text is selected we replace it by the link text\n                    Editable str = editor.getText();\n                    str.replace(selection.start(), selection.end(), linkText);\n                    editor.setSelection(selection.start(), selection.start() + linkText.length());\n\n                    url = link.getUrl();\n\n                }\n                editor.applyEffect(Effects.LINK, url);    // if url == null -> remove the link\n\n            }\n\n        }\n    }", "code_tokens": ["@", "Subscribe", "(", "threadMode", "=", "ThreadMode", ".", "MAIN", ")", "public", "void", "onEventMainThread", "(", "LinkEvent", "event", ")", "{", "final", "String", "fragmentTag", "=", "event", ".", "getFragmentTag", "(", ")", ";", "mRTApi", ".", "removeFragment", "(", "fragmentTag", ")", ";", "if", "(", "!", "event", ".", "wasCancelled", "(", ")", "&&", "ID_01_LINK_FRAGMENT", ".", "equals", "(", "fragmentTag", ")", ")", "{", "RTEditText", "editor", "=", "getActiveEditor", "(", ")", ";", "if", "(", "editor", "!=", "null", ")", "{", "Link", "link", "=", "event", ".", "getLink", "(", ")", ";", "String", "url", "=", "null", ";", "if", "(", "link", "!=", "null", "&&", "link", ".", "isValid", "(", ")", ")", "{", "// the mLinkSelection.end() <= editor.length() check is necessary since", "// the editor text can change when the link fragment is open", "Selection", "selection", "=", "mLinkSelection", "!=", "null", "&&", "mLinkSelection", ".", "end", "(", ")", "<=", "editor", ".", "length", "(", ")", "?", "mLinkSelection", ":", "new", "Selection", "(", "editor", ")", ";", "String", "linkText", "=", "link", ".", "getLinkText", "(", ")", ";", "// if no text is selected this inserts the entered link text", "// if text is selected we replace it by the link text", "Editable", "str", "=", "editor", ".", "getText", "(", ")", ";", "str", ".", "replace", "(", "selection", ".", "start", "(", ")", ",", "selection", ".", "end", "(", ")", ",", "linkText", ")", ";", "editor", ".", "setSelection", "(", "selection", ".", "start", "(", ")", ",", "selection", ".", "start", "(", ")", "+", "linkText", ".", "length", "(", ")", ")", ";", "url", "=", "link", ".", "getUrl", "(", ")", ";", "}", "editor", ".", "applyEffect", "(", "Effects", ".", "LINK", ",", "url", ")", ";", "// if url == null -> remove the link", "}", "}", "}"], "docstring": "LinkFragment has closed -> process the result.", "docstring_tokens": ["LinkFragment", "has", "closed", "-", ">", "process", "the", "result", "."]}
{"code": "int durationRandomModifier = 1 + RANDOM.nextInt(64);", "comments": "random duration to make readers out of sync, avoiding simultaneous readings", "lines": 5, "repo": "Axway/iron", "path": "iron-spi-aws/src/main/java/io/axway/iron/spi/aws/AwsUtils.java", "func_name": "AwsUtils.tryAmazonAction", "original_string": "public static <T> Optional<T> tryAmazonAction(String actionLabel, Supplier<T> action, AtomicLong durationBetweenRequests) {\n        try {\n            return of(action.get());\n        } catch (LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e) {\n            int durationRandomModifier = 1 + RANDOM.nextInt(64);// random duration to make readers out of sync, avoiding simultaneous readings\n            long updatedDuration = durationBetweenRequests.updateAndGet(duration -> duration * 2 // twice the duration\n                    + duration * 2 / durationRandomModifier);// add random duration to avoid simultaneous reads\n            LOG.debug(\"Update of minimal duration between two get shard iterator requests\",\n                      args -> args.add(\"actionLabel\", actionLabel).add(\"new minimalDurationBetweenTwoGetShardIteratorRequests\", updatedDuration));\n        }\n        return empty();\n    }", "language": "java", "Allcodes": "public static <T> Optional<T> tryAmazonAction(String actionLabel, Supplier<T> action, AtomicLong durationBetweenRequests) {\n        try {\n            return of(action.get());\n        } catch (LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e) {\n            int durationRandomModifier = 1 + RANDOM.nextInt(64);// random duration to make readers out of sync, avoiding simultaneous readings\n            long updatedDuration = durationBetweenRequests.updateAndGet(duration -> duration * 2 // twice the duration\n                    + duration * 2 / durationRandomModifier);// add random duration to avoid simultaneous reads\n            LOG.debug(\"Update of minimal duration between two get shard iterator requests\",\n                      args -> args.add(\"actionLabel\", actionLabel).add(\"new minimalDurationBetweenTwoGetShardIteratorRequests\", updatedDuration));\n        }\n        return empty();\n    }", "code_tokens": ["public", "static", "<", "T", ">", "Optional", "<", "T", ">", "tryAmazonAction", "(", "String", "actionLabel", ",", "Supplier", "<", "T", ">", "action", ",", "AtomicLong", "durationBetweenRequests", ")", "{", "try", "{", "return", "of", "(", "action", ".", "get", "(", ")", ")", ";", "}", "catch", "(", "LimitExceededException", "|", "ProvisionedThroughputExceededException", "|", "KMSThrottlingException", "e", ")", "{", "int", "durationRandomModifier", "=", "1", "+", "RANDOM", ".", "nextInt", "(", "64", ")", ";", "// random duration to make readers out of sync, avoiding simultaneous readings", "long", "updatedDuration", "=", "durationBetweenRequests", ".", "updateAndGet", "(", "duration", "->", "duration", "*", "2", "// twice the duration", "+", "duration", "*", "2", "/", "durationRandomModifier", ")", ";", "// add random duration to avoid simultaneous reads", "LOG", ".", "debug", "(", "\"Update of minimal duration between two get shard iterator requests\"", ",", "args", "->", "args", ".", "add", "(", "\"actionLabel\"", ",", "actionLabel", ")", ".", "add", "(", "\"new minimalDurationBetweenTwoGetShardIteratorRequests\"", ",", "updatedDuration", ")", ")", ";", "}", "return", "empty", "(", ")", ";", "}"], "docstring": "Try to perform an Amazon action and increase the duration between requests if some exception is exceeding resource usage exception is thrown.\n\n@param <T> the action return type\n@param actionLabel action label used for logging purpose only\n@param action the action to retry\n@param durationBetweenRequests duration between each retry\n@return the action result", "docstring_tokens": ["Try", "to", "perform", "an", "Amazon", "action", "and", "increase", "the", "duration", "between", "requests", "if", "some", "exception", "is", "exceeding", "resource", "usage", "exception", "is", "thrown", "."]}
{"code": "+ duration * 2 / durationRandomModifier);", "comments": "add random duration to avoid simultaneous reads", "lines": 7, "repo": "Axway/iron", "path": "iron-spi-aws/src/main/java/io/axway/iron/spi/aws/AwsUtils.java", "func_name": "AwsUtils.tryAmazonAction", "original_string": "public static <T> Optional<T> tryAmazonAction(String actionLabel, Supplier<T> action, AtomicLong durationBetweenRequests) {\n        try {\n            return of(action.get());\n        } catch (LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e) {\n            int durationRandomModifier = 1 + RANDOM.nextInt(64);// random duration to make readers out of sync, avoiding simultaneous readings\n            long updatedDuration = durationBetweenRequests.updateAndGet(duration -> duration * 2 // twice the duration\n                    + duration * 2 / durationRandomModifier);// add random duration to avoid simultaneous reads\n            LOG.debug(\"Update of minimal duration between two get shard iterator requests\",\n                      args -> args.add(\"actionLabel\", actionLabel).add(\"new minimalDurationBetweenTwoGetShardIteratorRequests\", updatedDuration));\n        }\n        return empty();\n    }", "language": "java", "Allcodes": "public static <T> Optional<T> tryAmazonAction(String actionLabel, Supplier<T> action, AtomicLong durationBetweenRequests) {\n        try {\n            return of(action.get());\n        } catch (LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e) {\n            int durationRandomModifier = 1 + RANDOM.nextInt(64);// random duration to make readers out of sync, avoiding simultaneous readings\n            long updatedDuration = durationBetweenRequests.updateAndGet(duration -> duration * 2 // twice the duration\n                    + duration * 2 / durationRandomModifier);// add random duration to avoid simultaneous reads\n            LOG.debug(\"Update of minimal duration between two get shard iterator requests\",\n                      args -> args.add(\"actionLabel\", actionLabel).add(\"new minimalDurationBetweenTwoGetShardIteratorRequests\", updatedDuration));\n        }\n        return empty();\n    }", "code_tokens": ["public", "static", "<", "T", ">", "Optional", "<", "T", ">", "tryAmazonAction", "(", "String", "actionLabel", ",", "Supplier", "<", "T", ">", "action", ",", "AtomicLong", "durationBetweenRequests", ")", "{", "try", "{", "return", "of", "(", "action", ".", "get", "(", ")", ")", ";", "}", "catch", "(", "LimitExceededException", "|", "ProvisionedThroughputExceededException", "|", "KMSThrottlingException", "e", ")", "{", "int", "durationRandomModifier", "=", "1", "+", "RANDOM", ".", "nextInt", "(", "64", ")", ";", "// random duration to make readers out of sync, avoiding simultaneous readings", "long", "updatedDuration", "=", "durationBetweenRequests", ".", "updateAndGet", "(", "duration", "->", "duration", "*", "2", "// twice the duration", "+", "duration", "*", "2", "/", "durationRandomModifier", ")", ";", "// add random duration to avoid simultaneous reads", "LOG", ".", "debug", "(", "\"Update of minimal duration between two get shard iterator requests\"", ",", "args", "->", "args", ".", "add", "(", "\"actionLabel\"", ",", "actionLabel", ")", ".", "add", "(", "\"new minimalDurationBetweenTwoGetShardIteratorRequests\"", ",", "updatedDuration", ")", ")", ";", "}", "return", "empty", "(", ")", ";", "}"], "docstring": "Try to perform an Amazon action and increase the duration between requests if some exception is exceeding resource usage exception is thrown.\n\n@param <T> the action return type\n@param actionLabel action label used for logging purpose only\n@param action the action to retry\n@param durationBetweenRequests duration between each retry\n@return the action result", "docstring_tokens": ["Try", "to", "perform", "an", "Amazon", "action", "and", "increase", "the", "duration", "between", "requests", "if", "some", "exception", "is", "exceeding", "resource", "usage", "exception", "is", "thrown", "."]}
{"code": "int pos = 0;", "comments": "our position in the old string", "lines": 8, "repo": "wro4j/wro4j", "path": "wro4j-core/src/main/java/ro/isdc/wro/util/StringUtils.java", "func_name": "StringUtils.replace", "original_string": "private static String replace(final String inString, final String oldPattern,\n      final String newPattern) {\n    if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n      return inString;\n    }\n    final StringBuffer sbuf = new StringBuffer();\n    // output StringBuffer we'll build up\n    int pos = 0; // our position in the old string\n    int index = inString.indexOf(oldPattern);\n    // the index of an occurrence we've found, or -1\n    final int patLen = oldPattern.length();\n    while (index >= 0) {\n      sbuf.append(inString.substring(pos, index));\n      sbuf.append(newPattern);\n      pos = index + patLen;\n      index = inString.indexOf(oldPattern, pos);\n    }\n    sbuf.append(inString.substring(pos));\n    // remember to append any characters to the right of a match\n    return sbuf.toString();\n  }", "language": "java", "Allcodes": "private static String replace(final String inString, final String oldPattern,\n      final String newPattern) {\n    if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\n      return inString;\n    }\n    final StringBuffer sbuf = new StringBuffer();\n    // output StringBuffer we'll build up\n    int pos = 0; // our position in the old string\n    int index = inString.indexOf(oldPattern);\n    // the index of an occurrence we've found, or -1\n    final int patLen = oldPattern.length();\n    while (index >= 0) {\n      sbuf.append(inString.substring(pos, index));\n      sbuf.append(newPattern);\n      pos = index + patLen;\n      index = inString.indexOf(oldPattern, pos);\n    }\n    sbuf.append(inString.substring(pos));\n    // remember to append any characters to the right of a match\n    return sbuf.toString();\n  }", "code_tokens": ["private", "static", "String", "replace", "(", "final", "String", "inString", ",", "final", "String", "oldPattern", ",", "final", "String", "newPattern", ")", "{", "if", "(", "!", "hasLength", "(", "inString", ")", "||", "!", "hasLength", "(", "oldPattern", ")", "||", "newPattern", "==", "null", ")", "{", "return", "inString", ";", "}", "final", "StringBuffer", "sbuf", "=", "new", "StringBuffer", "(", ")", ";", "// output StringBuffer we'll build up", "int", "pos", "=", "0", ";", "// our position in the old string", "int", "index", "=", "inString", ".", "indexOf", "(", "oldPattern", ")", ";", "// the index of an occurrence we've found, or -1", "final", "int", "patLen", "=", "oldPattern", ".", "length", "(", ")", ";", "while", "(", "index", ">=", "0", ")", "{", "sbuf", ".", "append", "(", "inString", ".", "substring", "(", "pos", ",", "index", ")", ")", ";", "sbuf", ".", "append", "(", "newPattern", ")", ";", "pos", "=", "index", "+", "patLen", ";", "index", "=", "inString", ".", "indexOf", "(", "oldPattern", ",", "pos", ")", ";", "}", "sbuf", ".", "append", "(", "inString", ".", "substring", "(", "pos", ")", ")", ";", "// remember to append any characters to the right of a match", "return", "sbuf", ".", "toString", "(", ")", ";", "}"], "docstring": "Replace all occurrences of a substring within a string with another string.\n\n@param inString\nString to examine\n@param oldPattern\nString to replace\n@param newPattern\nString to insert\n@return a String with the replacements", "docstring_tokens": ["Replace", "all", "occurrences", "of", "a", "substring", "within", "a", "string", "with", "another", "string", "."]}
{"code": "listener_.notifyFinished(nextJob);", "comments": "can be interrupted", "lines": 62, "repo": "liveontologies/elk-reasoner", "path": "elk-reasoner/src/main/java/org/semanticweb/elk/reasoner/saturation/ClassExpressionSaturationFactory.java", "func_name": "ClassExpressionSaturationFactory.updateFinishedCounters", "original_string": "private void updateFinishedCounters(ThisStatistics localStatistics)\n\t\t\tthrows InterruptedException {\n\t\tint snapshotJobsProcessed = countJobsProcessedLower_.get();\n\t\t/*\n\t\t * ensure that all contexts for processed jobs are marked as saturated\n\t\t */\n\t\tfor (;;) {\n\t\t\tint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_\n\t\t\t\t\t.get();\n\t\t\tsaturationState_\n\t\t\t\t\t.setContextsSaturated(snapshotCountContextsSaturatedLower);\n\t\t\tif (saturationState_\n\t\t\t\t\t.getContextSetSaturatedCount() < snapshotCountContextsSaturatedLower) {\n\t\t\t\t/*\n\t\t\t\t * this means that some other worker also sets contexts as\n\t\t\t\t * saturated, then it will mark the finished jobs instead\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ensure that the counter for processed jobs is still up to date\n\t\t\t */\n\t\t\tint updatedSnapshotJobsProcessed = countJobsProcessedLower_.get();\n\t\t\tif (updatedSnapshotJobsProcessed == snapshotJobsProcessed) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* else refresh counters */\n\t\t\tsnapshotJobsProcessed = updatedSnapshotJobsProcessed;\n\t\t}\n\t\t/*\n\t\t * ensure that all processed jobs are finished\n\t\t */\n\t\tfor (;;) {\n\t\t\tint snapshotJobsFinished = countJobsFinishedUpper_.get();\n\t\t\tif (snapshotJobsFinished >= snapshotJobsProcessed) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * update the finished context counter at least to the taken\n\t\t\t * snapshot value and mark the corresponding number of jobs as\n\t\t\t * processed\n\t\t\t */\n\t\t\tif (!countJobsFinishedUpper_.compareAndSet(snapshotJobsFinished,\n\t\t\t\t\tsnapshotJobsFinished + 1)) {\n\t\t\t\t/* retry */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// else\n\t\t\tJ nextJob = jobsInProgress_.poll();\n\t\t\tIndexedContextRoot root = nextJob.getInput();\n\t\t\tContext rootSaturation = saturationState_.getContext(root);\n\t\t\tif (rootSaturation.isInitialized()\n\t\t\t\t\t&& !rootSaturation.isSaturated()) {\n\t\t\t\tLOGGER_.error(\"{}: context for a finished job not saturated!\",\n\t\t\t\t\t\trootSaturation);\n\t\t\t}\n\t\t\tnextJob.setOutput(rootSaturation);\n\n\t\t\tLOGGER_.trace(\"{}: saturation finished\", root);\n\n\t\t\tlocalStatistics.jobsProcessedNo++;\n\t\t\tlistener_.notifyFinished(nextJob);// can be interrupted\n\t\t}\n\n\t}", "language": "java", "Allcodes": "private void updateFinishedCounters(ThisStatistics localStatistics)\n\t\t\tthrows InterruptedException {\n\t\tint snapshotJobsProcessed = countJobsProcessedLower_.get();\n\t\t/*\n\t\t * ensure that all contexts for processed jobs are marked as saturated\n\t\t */\n\t\tfor (;;) {\n\t\t\tint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_\n\t\t\t\t\t.get();\n\t\t\tsaturationState_\n\t\t\t\t\t.setContextsSaturated(snapshotCountContextsSaturatedLower);\n\t\t\tif (saturationState_\n\t\t\t\t\t.getContextSetSaturatedCount() < snapshotCountContextsSaturatedLower) {\n\t\t\t\t/*\n\t\t\t\t * this means that some other worker also sets contexts as\n\t\t\t\t * saturated, then it will mark the finished jobs instead\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ensure that the counter for processed jobs is still up to date\n\t\t\t */\n\t\t\tint updatedSnapshotJobsProcessed = countJobsProcessedLower_.get();\n\t\t\tif (updatedSnapshotJobsProcessed == snapshotJobsProcessed) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* else refresh counters */\n\t\t\tsnapshotJobsProcessed = updatedSnapshotJobsProcessed;\n\t\t}\n\t\t/*\n\t\t * ensure that all processed jobs are finished\n\t\t */\n\t\tfor (;;) {\n\t\t\tint snapshotJobsFinished = countJobsFinishedUpper_.get();\n\t\t\tif (snapshotJobsFinished >= snapshotJobsProcessed) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * update the finished context counter at least to the taken\n\t\t\t * snapshot value and mark the corresponding number of jobs as\n\t\t\t * processed\n\t\t\t */\n\t\t\tif (!countJobsFinishedUpper_.compareAndSet(snapshotJobsFinished,\n\t\t\t\t\tsnapshotJobsFinished + 1)) {\n\t\t\t\t/* retry */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// else\n\t\t\tJ nextJob = jobsInProgress_.poll();\n\t\t\tIndexedContextRoot root = nextJob.getInput();\n\t\t\tContext rootSaturation = saturationState_.getContext(root);\n\t\t\tif (rootSaturation.isInitialized()\n\t\t\t\t\t&& !rootSaturation.isSaturated()) {\n\t\t\t\tLOGGER_.error(\"{}: context for a finished job not saturated!\",\n\t\t\t\t\t\trootSaturation);\n\t\t\t}\n\t\t\tnextJob.setOutput(rootSaturation);\n\n\t\t\tLOGGER_.trace(\"{}: saturation finished\", root);\n\n\t\t\tlocalStatistics.jobsProcessedNo++;\n\t\t\tlistener_.notifyFinished(nextJob);// can be interrupted\n\t\t}\n\n\t}", "code_tokens": ["private", "void", "updateFinishedCounters", "(", "ThisStatistics", "localStatistics", ")", "throws", "InterruptedException", "{", "int", "snapshotJobsProcessed", "=", "countJobsProcessedLower_", ".", "get", "(", ")", ";", "/*\n\t\t * ensure that all contexts for processed jobs are marked as saturated\n\t\t */", "for", "(", ";", ";", ")", "{", "int", "snapshotCountContextsSaturatedLower", "=", "countContextsSaturatedLower_", ".", "get", "(", ")", ";", "saturationState_", ".", "setContextsSaturated", "(", "snapshotCountContextsSaturatedLower", ")", ";", "if", "(", "saturationState_", ".", "getContextSetSaturatedCount", "(", ")", "<", "snapshotCountContextsSaturatedLower", ")", "{", "/*\n\t\t\t\t * this means that some other worker also sets contexts as\n\t\t\t\t * saturated, then it will mark the finished jobs instead\n\t\t\t\t */", "return", ";", "}", "/*\n\t\t\t * ensure that the counter for processed jobs is still up to date\n\t\t\t */", "int", "updatedSnapshotJobsProcessed", "=", "countJobsProcessedLower_", ".", "get", "(", ")", ";", "if", "(", "updatedSnapshotJobsProcessed", "==", "snapshotJobsProcessed", ")", "{", "break", ";", "}", "/* else refresh counters */", "snapshotJobsProcessed", "=", "updatedSnapshotJobsProcessed", ";", "}", "/*\n\t\t * ensure that all processed jobs are finished\n\t\t */", "for", "(", ";", ";", ")", "{", "int", "snapshotJobsFinished", "=", "countJobsFinishedUpper_", ".", "get", "(", ")", ";", "if", "(", "snapshotJobsFinished", ">=", "snapshotJobsProcessed", ")", "{", "break", ";", "}", "/*\n\t\t\t * update the finished context counter at least to the taken\n\t\t\t * snapshot value and mark the corresponding number of jobs as\n\t\t\t * processed\n\t\t\t */", "if", "(", "!", "countJobsFinishedUpper_", ".", "compareAndSet", "(", "snapshotJobsFinished", ",", "snapshotJobsFinished", "+", "1", ")", ")", "{", "/* retry */", "continue", ";", "}", "// else", "J", "nextJob", "=", "jobsInProgress_", ".", "poll", "(", ")", ";", "IndexedContextRoot", "root", "=", "nextJob", ".", "getInput", "(", ")", ";", "Context", "rootSaturation", "=", "saturationState_", ".", "getContext", "(", "root", ")", ";", "if", "(", "rootSaturation", ".", "isInitialized", "(", ")", "&&", "!", "rootSaturation", ".", "isSaturated", "(", ")", ")", "{", "LOGGER_", ".", "error", "(", "\"{}: context for a finished job not saturated!\"", ",", "rootSaturation", ")", ";", "}", "nextJob", ".", "setOutput", "(", "rootSaturation", ")", ";", "LOGGER_", ".", "trace", "(", "\"{}: saturation finished\"", ",", "root", ")", ";", "localStatistics", ".", "jobsProcessedNo", "++", ";", "listener_", ".", "notifyFinished", "(", "nextJob", ")", ";", "// can be interrupted", "}", "}"], "docstring": "Check if the counter for saturated contexts and processed jobs can be\nincreased and post-process the finished jobs\n\n@throws InterruptedException", "docstring_tokens": ["Check", "if", "the", "counter", "for", "saturated", "contexts", "and", "processed", "jobs", "can", "be", "increased", "and", "post", "-", "process", "the", "finished", "jobs"]}
{"code": "vocab = mixinVocab.value();", "comments": "wins over class", "lines": 19, "repo": "dschulten/hydra-java", "path": "hydra-jsonld/src/main/java/de/escalon/hypermedia/hydra/serialize/LdContextFactory.java", "func_name": "LdContextFactory.getVocab", "original_string": "public String getVocab(MixinSource mixinSource, Object bean, Class<?> mixInClass) {\n        if (proxyUnwrapper != null) {\n            bean = proxyUnwrapper.unwrapProxy(bean);\n        }\n\n        // determine vocab in context\n        String classVocab = bean == null ? null : vocabFromClassOrPackage(bean.getClass());\n\n        final Vocab mixinVocab = findAnnotation(mixInClass, Vocab.class);\n\n        Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin(mixinSource, bean, mixInClass);\n        String contextProviderVocab = null;\n        if (nestedContextProviderFromMixin != null) {\n            contextProviderVocab = getVocab(mixinSource, nestedContextProviderFromMixin, null);\n        }\n\n        String vocab;\n        if (mixinVocab != null) {\n            vocab = mixinVocab.value(); // wins over class\n        } else if (classVocab != null) {\n            vocab = classVocab; // wins over context provider\n        } else if (contextProviderVocab != null) {\n            vocab = contextProviderVocab; // wins over last resort\n        } else {\n            vocab = HTTP_SCHEMA_ORG;\n        }\n        return vocab;\n    }", "language": "java", "Allcodes": "public String getVocab(MixinSource mixinSource, Object bean, Class<?> mixInClass) {\n        if (proxyUnwrapper != null) {\n            bean = proxyUnwrapper.unwrapProxy(bean);\n        }\n\n        // determine vocab in context\n        String classVocab = bean == null ? null : vocabFromClassOrPackage(bean.getClass());\n\n        final Vocab mixinVocab = findAnnotation(mixInClass, Vocab.class);\n\n        Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin(mixinSource, bean, mixInClass);\n        String contextProviderVocab = null;\n        if (nestedContextProviderFromMixin != null) {\n            contextProviderVocab = getVocab(mixinSource, nestedContextProviderFromMixin, null);\n        }\n\n        String vocab;\n        if (mixinVocab != null) {\n            vocab = mixinVocab.value(); // wins over class\n        } else if (classVocab != null) {\n            vocab = classVocab; // wins over context provider\n        } else if (contextProviderVocab != null) {\n            vocab = contextProviderVocab; // wins over last resort\n        } else {\n            vocab = HTTP_SCHEMA_ORG;\n        }\n        return vocab;\n    }", "code_tokens": ["public", "String", "getVocab", "(", "MixinSource", "mixinSource", ",", "Object", "bean", ",", "Class", "<", "?", ">", "mixInClass", ")", "{", "if", "(", "proxyUnwrapper", "!=", "null", ")", "{", "bean", "=", "proxyUnwrapper", ".", "unwrapProxy", "(", "bean", ")", ";", "}", "// determine vocab in context", "String", "classVocab", "=", "bean", "==", "null", "?", "null", ":", "vocabFromClassOrPackage", "(", "bean", ".", "getClass", "(", ")", ")", ";", "final", "Vocab", "mixinVocab", "=", "findAnnotation", "(", "mixInClass", ",", "Vocab", ".", "class", ")", ";", "Object", "nestedContextProviderFromMixin", "=", "getNestedContextProviderFromMixin", "(", "mixinSource", ",", "bean", ",", "mixInClass", ")", ";", "String", "contextProviderVocab", "=", "null", ";", "if", "(", "nestedContextProviderFromMixin", "!=", "null", ")", "{", "contextProviderVocab", "=", "getVocab", "(", "mixinSource", ",", "nestedContextProviderFromMixin", ",", "null", ")", ";", "}", "String", "vocab", ";", "if", "(", "mixinVocab", "!=", "null", ")", "{", "vocab", "=", "mixinVocab", ".", "value", "(", ")", ";", "// wins over class", "}", "else", "if", "(", "classVocab", "!=", "null", ")", "{", "vocab", "=", "classVocab", ";", "// wins over context provider", "}", "else", "if", "(", "contextProviderVocab", "!=", "null", ")", "{", "vocab", "=", "contextProviderVocab", ";", "// wins over last resort", "}", "else", "{", "vocab", "=", "HTTP_SCHEMA_ORG", ";", "}", "return", "vocab", ";", "}"], "docstring": "Gets vocab for given bean.\n\n@param bean\nto inspect for vocab\n@param mixInClass\nfor bean which might define a vocab or has a context provider\n@return explicitly defined vocab or http://schema.org", "docstring_tokens": ["Gets", "vocab", "for", "given", "bean", "."]}
{"code": "vocab = classVocab;", "comments": "wins over context provider", "lines": 21, "repo": "dschulten/hydra-java", "path": "hydra-jsonld/src/main/java/de/escalon/hypermedia/hydra/serialize/LdContextFactory.java", "func_name": "LdContextFactory.getVocab", "original_string": "public String getVocab(MixinSource mixinSource, Object bean, Class<?> mixInClass) {\n        if (proxyUnwrapper != null) {\n            bean = proxyUnwrapper.unwrapProxy(bean);\n        }\n\n        // determine vocab in context\n        String classVocab = bean == null ? null : vocabFromClassOrPackage(bean.getClass());\n\n        final Vocab mixinVocab = findAnnotation(mixInClass, Vocab.class);\n\n        Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin(mixinSource, bean, mixInClass);\n        String contextProviderVocab = null;\n        if (nestedContextProviderFromMixin != null) {\n            contextProviderVocab = getVocab(mixinSource, nestedContextProviderFromMixin, null);\n        }\n\n        String vocab;\n        if (mixinVocab != null) {\n            vocab = mixinVocab.value(); // wins over class\n        } else if (classVocab != null) {\n            vocab = classVocab; // wins over context provider\n        } else if (contextProviderVocab != null) {\n            vocab = contextProviderVocab; // wins over last resort\n        } else {\n            vocab = HTTP_SCHEMA_ORG;\n        }\n        return vocab;\n    }", "language": "java", "Allcodes": "public String getVocab(MixinSource mixinSource, Object bean, Class<?> mixInClass) {\n        if (proxyUnwrapper != null) {\n            bean = proxyUnwrapper.unwrapProxy(bean);\n        }\n\n        // determine vocab in context\n        String classVocab = bean == null ? null : vocabFromClassOrPackage(bean.getClass());\n\n        final Vocab mixinVocab = findAnnotation(mixInClass, Vocab.class);\n\n        Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin(mixinSource, bean, mixInClass);\n        String contextProviderVocab = null;\n        if (nestedContextProviderFromMixin != null) {\n            contextProviderVocab = getVocab(mixinSource, nestedContextProviderFromMixin, null);\n        }\n\n        String vocab;\n        if (mixinVocab != null) {\n            vocab = mixinVocab.value(); // wins over class\n        } else if (classVocab != null) {\n            vocab = classVocab; // wins over context provider\n        } else if (contextProviderVocab != null) {\n            vocab = contextProviderVocab; // wins over last resort\n        } else {\n            vocab = HTTP_SCHEMA_ORG;\n        }\n        return vocab;\n    }", "code_tokens": ["public", "String", "getVocab", "(", "MixinSource", "mixinSource", ",", "Object", "bean", ",", "Class", "<", "?", ">", "mixInClass", ")", "{", "if", "(", "proxyUnwrapper", "!=", "null", ")", "{", "bean", "=", "proxyUnwrapper", ".", "unwrapProxy", "(", "bean", ")", ";", "}", "// determine vocab in context", "String", "classVocab", "=", "bean", "==", "null", "?", "null", ":", "vocabFromClassOrPackage", "(", "bean", ".", "getClass", "(", ")", ")", ";", "final", "Vocab", "mixinVocab", "=", "findAnnotation", "(", "mixInClass", ",", "Vocab", ".", "class", ")", ";", "Object", "nestedContextProviderFromMixin", "=", "getNestedContextProviderFromMixin", "(", "mixinSource", ",", "bean", ",", "mixInClass", ")", ";", "String", "contextProviderVocab", "=", "null", ";", "if", "(", "nestedContextProviderFromMixin", "!=", "null", ")", "{", "contextProviderVocab", "=", "getVocab", "(", "mixinSource", ",", "nestedContextProviderFromMixin", ",", "null", ")", ";", "}", "String", "vocab", ";", "if", "(", "mixinVocab", "!=", "null", ")", "{", "vocab", "=", "mixinVocab", ".", "value", "(", ")", ";", "// wins over class", "}", "else", "if", "(", "classVocab", "!=", "null", ")", "{", "vocab", "=", "classVocab", ";", "// wins over context provider", "}", "else", "if", "(", "contextProviderVocab", "!=", "null", ")", "{", "vocab", "=", "contextProviderVocab", ";", "// wins over last resort", "}", "else", "{", "vocab", "=", "HTTP_SCHEMA_ORG", ";", "}", "return", "vocab", ";", "}"], "docstring": "Gets vocab for given bean.\n\n@param bean\nto inspect for vocab\n@param mixInClass\nfor bean which might define a vocab or has a context provider\n@return explicitly defined vocab or http://schema.org", "docstring_tokens": ["Gets", "vocab", "for", "given", "bean", "."]}
{"code": "vocab = contextProviderVocab;", "comments": "wins over last resort", "lines": 23, "repo": "dschulten/hydra-java", "path": "hydra-jsonld/src/main/java/de/escalon/hypermedia/hydra/serialize/LdContextFactory.java", "func_name": "LdContextFactory.getVocab", "original_string": "public String getVocab(MixinSource mixinSource, Object bean, Class<?> mixInClass) {\n        if (proxyUnwrapper != null) {\n            bean = proxyUnwrapper.unwrapProxy(bean);\n        }\n\n        // determine vocab in context\n        String classVocab = bean == null ? null : vocabFromClassOrPackage(bean.getClass());\n\n        final Vocab mixinVocab = findAnnotation(mixInClass, Vocab.class);\n\n        Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin(mixinSource, bean, mixInClass);\n        String contextProviderVocab = null;\n        if (nestedContextProviderFromMixin != null) {\n            contextProviderVocab = getVocab(mixinSource, nestedContextProviderFromMixin, null);\n        }\n\n        String vocab;\n        if (mixinVocab != null) {\n            vocab = mixinVocab.value(); // wins over class\n        } else if (classVocab != null) {\n            vocab = classVocab; // wins over context provider\n        } else if (contextProviderVocab != null) {\n            vocab = contextProviderVocab; // wins over last resort\n        } else {\n            vocab = HTTP_SCHEMA_ORG;\n        }\n        return vocab;\n    }", "language": "java", "Allcodes": "public String getVocab(MixinSource mixinSource, Object bean, Class<?> mixInClass) {\n        if (proxyUnwrapper != null) {\n            bean = proxyUnwrapper.unwrapProxy(bean);\n        }\n\n        // determine vocab in context\n        String classVocab = bean == null ? null : vocabFromClassOrPackage(bean.getClass());\n\n        final Vocab mixinVocab = findAnnotation(mixInClass, Vocab.class);\n\n        Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin(mixinSource, bean, mixInClass);\n        String contextProviderVocab = null;\n        if (nestedContextProviderFromMixin != null) {\n            contextProviderVocab = getVocab(mixinSource, nestedContextProviderFromMixin, null);\n        }\n\n        String vocab;\n        if (mixinVocab != null) {\n            vocab = mixinVocab.value(); // wins over class\n        } else if (classVocab != null) {\n            vocab = classVocab; // wins over context provider\n        } else if (contextProviderVocab != null) {\n            vocab = contextProviderVocab; // wins over last resort\n        } else {\n            vocab = HTTP_SCHEMA_ORG;\n        }\n        return vocab;\n    }", "code_tokens": ["public", "String", "getVocab", "(", "MixinSource", "mixinSource", ",", "Object", "bean", ",", "Class", "<", "?", ">", "mixInClass", ")", "{", "if", "(", "proxyUnwrapper", "!=", "null", ")", "{", "bean", "=", "proxyUnwrapper", ".", "unwrapProxy", "(", "bean", ")", ";", "}", "// determine vocab in context", "String", "classVocab", "=", "bean", "==", "null", "?", "null", ":", "vocabFromClassOrPackage", "(", "bean", ".", "getClass", "(", ")", ")", ";", "final", "Vocab", "mixinVocab", "=", "findAnnotation", "(", "mixInClass", ",", "Vocab", ".", "class", ")", ";", "Object", "nestedContextProviderFromMixin", "=", "getNestedContextProviderFromMixin", "(", "mixinSource", ",", "bean", ",", "mixInClass", ")", ";", "String", "contextProviderVocab", "=", "null", ";", "if", "(", "nestedContextProviderFromMixin", "!=", "null", ")", "{", "contextProviderVocab", "=", "getVocab", "(", "mixinSource", ",", "nestedContextProviderFromMixin", ",", "null", ")", ";", "}", "String", "vocab", ";", "if", "(", "mixinVocab", "!=", "null", ")", "{", "vocab", "=", "mixinVocab", ".", "value", "(", ")", ";", "// wins over class", "}", "else", "if", "(", "classVocab", "!=", "null", ")", "{", "vocab", "=", "classVocab", ";", "// wins over context provider", "}", "else", "if", "(", "contextProviderVocab", "!=", "null", ")", "{", "vocab", "=", "contextProviderVocab", ";", "// wins over last resort", "}", "else", "{", "vocab", "=", "HTTP_SCHEMA_ORG", ";", "}", "return", "vocab", ";", "}"], "docstring": "Gets vocab for given bean.\n\n@param bean\nto inspect for vocab\n@param mixInClass\nfor bean which might define a vocab or has a context provider\n@return explicitly defined vocab or http://schema.org", "docstring_tokens": ["Gets", "vocab", "for", "given", "bean", "."]}
{"code": ".isReadOnly(requestParamName));", "comments": "not readonly", "lines": 48, "repo": "dschulten/hydra-java", "path": "spring-hateoas-ext/src/main/java/de/escalon/hypermedia/spring/xhtml/XhtmlWriter.java", "func_name": "XhtmlWriter.appendForm", "original_string": "private void appendForm(Affordance affordance, ActionDescriptor actionDescriptor) throws IOException {\n        String formName = actionDescriptor.getActionName();\n        RequestMethod httpMethod = RequestMethod.valueOf(actionDescriptor.getHttpMethod());\n\n        // Link's expand method removes non-required variables from URL\n        String actionUrl = affordance.expand()\n                .getHref();\n        beginForm(OptionalAttributes.attr(\"action\", actionUrl)\n                .and(\"method\", getHtmlConformingHttpMethod(httpMethod))\n                .and(\"name\", formName));\n        write(\"<h4>\");\n        write(\"Form \" + formName);\n        write(\"</h4>\");\n\n        writeHiddenHttpMethodField(httpMethod);\n        // build the form\n        if (actionDescriptor.hasRequestBody()) { // parameter bean\n            ActionInputParameter requestBody = actionDescriptor.getRequestBody();\n            Class<?> parameterType = requestBody.getParameterType();\n            recurseBeanProperties(parameterType, actionDescriptor, requestBody, requestBody.getValue(), \"\");\n        } else { // plain parameter list\n            Collection<String> requestParams = actionDescriptor.getRequestParamNames();\n            for (String requestParamName : requestParams) {\n                ActionInputParameter actionInputParameter = actionDescriptor.getActionInputParameter(requestParamName);\n\n                Object[] possibleValues = actionInputParameter.getPossibleValues(actionDescriptor);\n                // TODO duplication with appendInputOrSelect\n                if (possibleValues.length > 0) {\n                    if (actionInputParameter.isArrayOrCollection()) {\n                        appendSelectMulti(requestParamName, possibleValues, actionInputParameter);\n                    } else {\n                        appendSelectOne(requestParamName, possibleValues, actionInputParameter);\n                    }\n                } else {\n                    if (actionInputParameter.isArrayOrCollection()) {\n                        // have as many inputs as there are call values, list of 5 nulls gives you five input fields\n                        // TODO support for free list input instead, code on demand?\n                        Object[] callValues = actionInputParameter.getValues();\n                        int items = callValues.length;\n                        for (int i = 0; i < items; i++) {\n                            Object value;\n                            if (i < callValues.length) {\n                                value = callValues[i];\n                            } else {\n                                value = null;\n                            }\n                            appendInput(requestParamName, actionInputParameter, value, actionInputParameter\n\t\t\t\t\t\t\t\t\t.isReadOnly(requestParamName)); // not readonly\n                        }\n                    } else {\n                        String callValueFormatted = actionInputParameter.getValueFormatted();\n                        appendInput(requestParamName, actionInputParameter, callValueFormatted, actionInputParameter\n\t\t\t\t\t\t\t\t.isReadOnly(requestParamName)); // not readonly\n                    }\n                }\n            }\n        }\n        inputButton(Type.SUBMIT, capitalize(httpMethod.name()\n                .toLowerCase()));\n        endForm();\n    }", "language": "java", "Allcodes": "private void appendForm(Affordance affordance, ActionDescriptor actionDescriptor) throws IOException {\n        String formName = actionDescriptor.getActionName();\n        RequestMethod httpMethod = RequestMethod.valueOf(actionDescriptor.getHttpMethod());\n\n        // Link's expand method removes non-required variables from URL\n        String actionUrl = affordance.expand()\n                .getHref();\n        beginForm(OptionalAttributes.attr(\"action\", actionUrl)\n                .and(\"method\", getHtmlConformingHttpMethod(httpMethod))\n                .and(\"name\", formName));\n        write(\"<h4>\");\n        write(\"Form \" + formName);\n        write(\"</h4>\");\n\n        writeHiddenHttpMethodField(httpMethod);\n        // build the form\n        if (actionDescriptor.hasRequestBody()) { // parameter bean\n            ActionInputParameter requestBody = actionDescriptor.getRequestBody();\n            Class<?> parameterType = requestBody.getParameterType();\n            recurseBeanProperties(parameterType, actionDescriptor, requestBody, requestBody.getValue(), \"\");\n        } else { // plain parameter list\n            Collection<String> requestParams = actionDescriptor.getRequestParamNames();\n            for (String requestParamName : requestParams) {\n                ActionInputParameter actionInputParameter = actionDescriptor.getActionInputParameter(requestParamName);\n\n                Object[] possibleValues = actionInputParameter.getPossibleValues(actionDescriptor);\n                // TODO duplication with appendInputOrSelect\n                if (possibleValues.length > 0) {\n                    if (actionInputParameter.isArrayOrCollection()) {\n                        appendSelectMulti(requestParamName, possibleValues, actionInputParameter);\n                    } else {\n                        appendSelectOne(requestParamName, possibleValues, actionInputParameter);\n                    }\n                } else {\n                    if (actionInputParameter.isArrayOrCollection()) {\n                        // have as many inputs as there are call values, list of 5 nulls gives you five input fields\n                        // TODO support for free list input instead, code on demand?\n                        Object[] callValues = actionInputParameter.getValues();\n                        int items = callValues.length;\n                        for (int i = 0; i < items; i++) {\n                            Object value;\n                            if (i < callValues.length) {\n                                value = callValues[i];\n                            } else {\n                                value = null;\n                            }\n                            appendInput(requestParamName, actionInputParameter, value, actionInputParameter\n\t\t\t\t\t\t\t\t\t.isReadOnly(requestParamName)); // not readonly\n                        }\n                    } else {\n                        String callValueFormatted = actionInputParameter.getValueFormatted();\n                        appendInput(requestParamName, actionInputParameter, callValueFormatted, actionInputParameter\n\t\t\t\t\t\t\t\t.isReadOnly(requestParamName)); // not readonly\n                    }\n                }\n            }\n        }\n        inputButton(Type.SUBMIT, capitalize(httpMethod.name()\n                .toLowerCase()));\n        endForm();\n    }", "code_tokens": ["private", "void", "appendForm", "(", "Affordance", "affordance", ",", "ActionDescriptor", "actionDescriptor", ")", "throws", "IOException", "{", "String", "formName", "=", "actionDescriptor", ".", "getActionName", "(", ")", ";", "RequestMethod", "httpMethod", "=", "RequestMethod", ".", "valueOf", "(", "actionDescriptor", ".", "getHttpMethod", "(", ")", ")", ";", "// Link's expand method removes non-required variables from URL", "String", "actionUrl", "=", "affordance", ".", "expand", "(", ")", ".", "getHref", "(", ")", ";", "beginForm", "(", "OptionalAttributes", ".", "attr", "(", "\"action\"", ",", "actionUrl", ")", ".", "and", "(", "\"method\"", ",", "getHtmlConformingHttpMethod", "(", "httpMethod", ")", ")", ".", "and", "(", "\"name\"", ",", "formName", ")", ")", ";", "write", "(", "\"<h4>\"", ")", ";", "write", "(", "\"Form \"", "+", "formName", ")", ";", "write", "(", "\"</h4>\"", ")", ";", "writeHiddenHttpMethodField", "(", "httpMethod", ")", ";", "// build the form", "if", "(", "actionDescriptor", ".", "hasRequestBody", "(", ")", ")", "{", "// parameter bean", "ActionInputParameter", "requestBody", "=", "actionDescriptor", ".", "getRequestBody", "(", ")", ";", "Class", "<", "?", ">", "parameterType", "=", "requestBody", ".", "getParameterType", "(", ")", ";", "recurseBeanProperties", "(", "parameterType", ",", "actionDescriptor", ",", "requestBody", ",", "requestBody", ".", "getValue", "(", ")", ",", "\"\"", ")", ";", "}", "else", "{", "// plain parameter list", "Collection", "<", "String", ">", "requestParams", "=", "actionDescriptor", ".", "getRequestParamNames", "(", ")", ";", "for", "(", "String", "requestParamName", ":", "requestParams", ")", "{", "ActionInputParameter", "actionInputParameter", "=", "actionDescriptor", ".", "getActionInputParameter", "(", "requestParamName", ")", ";", "Object", "[", "]", "possibleValues", "=", "actionInputParameter", ".", "getPossibleValues", "(", "actionDescriptor", ")", ";", "// TODO duplication with appendInputOrSelect", "if", "(", "possibleValues", ".", "length", ">", "0", ")", "{", "if", "(", "actionInputParameter", ".", "isArrayOrCollection", "(", ")", ")", "{", "appendSelectMulti", "(", "requestParamName", ",", "possibleValues", ",", "actionInputParameter", ")", ";", "}", "else", "{", "appendSelectOne", "(", "requestParamName", ",", "possibleValues", ",", "actionInputParameter", ")", ";", "}", "}", "else", "{", "if", "(", "actionInputParameter", ".", "isArrayOrCollection", "(", ")", ")", "{", "// have as many inputs as there are call values, list of 5 nulls gives you five input fields", "// TODO support for free list input instead, code on demand?", "Object", "[", "]", "callValues", "=", "actionInputParameter", ".", "getValues", "(", ")", ";", "int", "items", "=", "callValues", ".", "length", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "items", ";", "i", "++", ")", "{", "Object", "value", ";", "if", "(", "i", "<", "callValues", ".", "length", ")", "{", "value", "=", "callValues", "[", "i", "]", ";", "}", "else", "{", "value", "=", "null", ";", "}", "appendInput", "(", "requestParamName", ",", "actionInputParameter", ",", "value", ",", "actionInputParameter", ".", "isReadOnly", "(", "requestParamName", ")", ")", ";", "// not readonly", "}", "}", "else", "{", "String", "callValueFormatted", "=", "actionInputParameter", ".", "getValueFormatted", "(", ")", ";", "appendInput", "(", "requestParamName", ",", "actionInputParameter", ",", "callValueFormatted", ",", "actionInputParameter", ".", "isReadOnly", "(", "requestParamName", ")", ")", ";", "// not readonly", "}", "}", "}", "}", "inputButton", "(", "Type", ".", "SUBMIT", ",", "capitalize", "(", "httpMethod", ".", "name", "(", ")", ".", "toLowerCase", "(", ")", ")", ")", ";", "endForm", "(", ")", ";", "}"], "docstring": "Appends form and squashes non-GET or POST to POST. If required, adds _method field for handling by an\nappropriate\nfilter such as Spring's HiddenHttpMethodFilter.\n\n@param affordance\nto make into a form\n@param actionDescriptor\ndescribing the form action\n@throws IOException\n@see\n\n<a href=\"http://docs.spring.io/spring/docs/3.0 .x/javadoc-api/org/springframework/web/filter/HiddenHttpMethodFilter.html\">Spring\nMVC HiddenHttpMethodFilter</a>", "docstring_tokens": ["Appends", "form", "and", "squashes", "non", "-", "GET", "or", "POST", "to", "POST", ".", "If", "required", "adds", "_method", "field", "for", "handling", "by", "an", "appropriate", "filter", "such", "as", "Spring", "s", "HiddenHttpMethodFilter", "."]}
{"code": "continue;", "comments": "@todo: need to check args also", "lines": 13, "repo": "RestComm/jain-slee", "path": "container/services/src/main/java/org/mobicents/slee/container/deployment/ConcreteActivityContextInterfaceGenerator.java", "func_name": "ConcreteActivityContextInterfaceGenerator.generateConcreteMethods", "original_string": "private void generateConcreteMethods(Map interfaceMethods) {\r\n\t\tif (interfaceMethods == null)\r\n\t\t\treturn;\r\n\r\n\t\tIterator it = interfaceMethods.values().iterator();\r\n\t\twhile (it.hasNext()) {\r\n\t\t\tCtMethod interfaceMethod = (CtMethod) it.next();\r\n\t\t\tif (interfaceMethod != null\r\n\t\t\t\t\t//&& isBaseInterfaceMethod(interfaceMethod.getName()))\r\n\t\t\t\t\t&& (interfaceMethod.getDeclaringClass().getName().equals(\r\n\t\t\t\t\t\t\tjavax.slee.ActivityContextInterface.class.getName()) || interfaceMethod.getDeclaringClass().getName().equals(\r\n\t\t\t\t\t\t\t\t\tActivityContextInterfaceExt.class.getName())))\r\n\t\t\t\tcontinue; // @todo: need to check args also\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// copy method from abstract to concrete class\r\n\t\t\t\tCtMethod concreteMethod = CtNewMethod.copy(interfaceMethod,\r\n\t\t\t\t\t\tconcreteActivityContextInterface, null);\r\n\t\t\t\t// create the method body\r\n\t\t\t\tString fieldName = interfaceMethod.getName().substring(3);\r\n\t\t\t\tfieldName = fieldName.substring(0, 1).toLowerCase()\r\n\t\t\t\t\t\t+ fieldName.substring(1);\r\n\t\t\t\tString concreteMethodBody = null;\r\n\t\t\t\tif (interfaceMethod.getName().startsWith(\"get\")) {\r\n\t\t\t\t\tconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\"\r\n\t\t\t\t\t\t\t+ fieldName + \"\\\",\"+concreteMethod.getReturnType().getName()+\".class); }\";\r\n\t\t\t\t} else if (interfaceMethod.getName().startsWith(\"set\")) {\r\n\t\t\t\t\tconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName\r\n\t\t\t\t\t\t\t+ \"\\\",$1); }\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new SLEEException(\"unexpected method name <\"\r\n\t\t\t\t\t\t\t+ interfaceMethod.getName()\r\n\t\t\t\t\t\t\t+ \"> to implement in sbb aci interface\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (logger.isTraceEnabled()) {\r\n\t\t            logger.trace(\"Generated method \"\r\n\t\t\t\t\t\t\t+ interfaceMethod.getName() + \" , body = \"\r\n\t\t\t\t\t\t\t+ concreteMethodBody);\r\n\t\t\t\t}\r\n\t\t\t\tconcreteMethod.setBody(concreteMethodBody);\r\n\t\t\t\tconcreteActivityContextInterface.addMethod(concreteMethod);\r\n\t\t\t} catch (Exception cce) {\r\n\t\t\t\tthrow new SLEEException(\"Cannot compile method \"\r\n\t\t\t\t\t\t+ interfaceMethod.getName(), cce);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}", "language": "java", "Allcodes": "private void generateConcreteMethods(Map interfaceMethods) {\r\n\t\tif (interfaceMethods == null)\r\n\t\t\treturn;\r\n\r\n\t\tIterator it = interfaceMethods.values().iterator();\r\n\t\twhile (it.hasNext()) {\r\n\t\t\tCtMethod interfaceMethod = (CtMethod) it.next();\r\n\t\t\tif (interfaceMethod != null\r\n\t\t\t\t\t//&& isBaseInterfaceMethod(interfaceMethod.getName()))\r\n\t\t\t\t\t&& (interfaceMethod.getDeclaringClass().getName().equals(\r\n\t\t\t\t\t\t\tjavax.slee.ActivityContextInterface.class.getName()) || interfaceMethod.getDeclaringClass().getName().equals(\r\n\t\t\t\t\t\t\t\t\tActivityContextInterfaceExt.class.getName())))\r\n\t\t\t\tcontinue; // @todo: need to check args also\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// copy method from abstract to concrete class\r\n\t\t\t\tCtMethod concreteMethod = CtNewMethod.copy(interfaceMethod,\r\n\t\t\t\t\t\tconcreteActivityContextInterface, null);\r\n\t\t\t\t// create the method body\r\n\t\t\t\tString fieldName = interfaceMethod.getName().substring(3);\r\n\t\t\t\tfieldName = fieldName.substring(0, 1).toLowerCase()\r\n\t\t\t\t\t\t+ fieldName.substring(1);\r\n\t\t\t\tString concreteMethodBody = null;\r\n\t\t\t\tif (interfaceMethod.getName().startsWith(\"get\")) {\r\n\t\t\t\t\tconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\"\r\n\t\t\t\t\t\t\t+ fieldName + \"\\\",\"+concreteMethod.getReturnType().getName()+\".class); }\";\r\n\t\t\t\t} else if (interfaceMethod.getName().startsWith(\"set\")) {\r\n\t\t\t\t\tconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName\r\n\t\t\t\t\t\t\t+ \"\\\",$1); }\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new SLEEException(\"unexpected method name <\"\r\n\t\t\t\t\t\t\t+ interfaceMethod.getName()\r\n\t\t\t\t\t\t\t+ \"> to implement in sbb aci interface\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (logger.isTraceEnabled()) {\r\n\t\t            logger.trace(\"Generated method \"\r\n\t\t\t\t\t\t\t+ interfaceMethod.getName() + \" , body = \"\r\n\t\t\t\t\t\t\t+ concreteMethodBody);\r\n\t\t\t\t}\r\n\t\t\t\tconcreteMethod.setBody(concreteMethodBody);\r\n\t\t\t\tconcreteActivityContextInterface.addMethod(concreteMethod);\r\n\t\t\t} catch (Exception cce) {\r\n\t\t\t\tthrow new SLEEException(\"Cannot compile method \"\r\n\t\t\t\t\t\t+ interfaceMethod.getName(), cce);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}", "code_tokens": ["private", "void", "generateConcreteMethods", "(", "Map", "interfaceMethods", ")", "{", "if", "(", "interfaceMethods", "==", "null", ")", "return", ";", "Iterator", "it", "=", "interfaceMethods", ".", "values", "(", ")", ".", "iterator", "(", ")", ";", "while", "(", "it", ".", "hasNext", "(", ")", ")", "{", "CtMethod", "interfaceMethod", "=", "(", "CtMethod", ")", "it", ".", "next", "(", ")", ";", "if", "(", "interfaceMethod", "!=", "null", "//&& isBaseInterfaceMethod(interfaceMethod.getName()))\r", "&&", "(", "interfaceMethod", ".", "getDeclaringClass", "(", ")", ".", "getName", "(", ")", ".", "equals", "(", "javax", ".", "slee", ".", "ActivityContextInterface", ".", "class", ".", "getName", "(", ")", ")", "||", "interfaceMethod", ".", "getDeclaringClass", "(", ")", ".", "getName", "(", ")", ".", "equals", "(", "ActivityContextInterfaceExt", ".", "class", ".", "getName", "(", ")", ")", ")", ")", "continue", ";", "// @todo: need to check args also\r", "try", "{", "// copy method from abstract to concrete class\r", "CtMethod", "concreteMethod", "=", "CtNewMethod", ".", "copy", "(", "interfaceMethod", ",", "concreteActivityContextInterface", ",", "null", ")", ";", "// create the method body\r", "String", "fieldName", "=", "interfaceMethod", ".", "getName", "(", ")", ".", "substring", "(", "3", ")", ";", "fieldName", "=", "fieldName", ".", "substring", "(", "0", ",", "1", ")", ".", "toLowerCase", "(", ")", "+", "fieldName", ".", "substring", "(", "1", ")", ";", "String", "concreteMethodBody", "=", "null", ";", "if", "(", "interfaceMethod", ".", "getName", "(", ")", ".", "startsWith", "(", "\"get\"", ")", ")", "{", "concreteMethodBody", "=", "\"{ return ($r)getFieldValue(\\\"\"", "+", "fieldName", "+", "\"\\\",\"", "+", "concreteMethod", ".", "getReturnType", "(", ")", ".", "getName", "(", ")", "+", "\".class); }\"", ";", "}", "else", "if", "(", "interfaceMethod", ".", "getName", "(", ")", ".", "startsWith", "(", "\"set\"", ")", ")", "{", "concreteMethodBody", "=", "\"{ setFieldValue(\\\"\"", "+", "fieldName", "+", "\"\\\",$1); }\"", ";", "}", "else", "{", "throw", "new", "SLEEException", "(", "\"unexpected method name <\"", "+", "interfaceMethod", ".", "getName", "(", ")", "+", "\"> to implement in sbb aci interface\"", ")", ";", "}", "if", "(", "logger", ".", "isTraceEnabled", "(", ")", ")", "{", "logger", ".", "trace", "(", "\"Generated method \"", "+", "interfaceMethod", ".", "getName", "(", ")", "+", "\" , body = \"", "+", "concreteMethodBody", ")", ";", "}", "concreteMethod", ".", "setBody", "(", "concreteMethodBody", ")", ";", "concreteActivityContextInterface", ".", "addMethod", "(", "concreteMethod", ")", ";", "}", "catch", "(", "Exception", "cce", ")", "{", "throw", "new", "SLEEException", "(", "\"Cannot compile method \"", "+", "interfaceMethod", ".", "getName", "(", ")", ",", "cce", ")", ";", "}", "}", "}"], "docstring": "Generates the concrete methods of the class It generates a specific\nmethod implementation for the javax.slee.ActivityContextInterface methods\nfor the methods coming from the ActivityContextInterface developer the\ncall is routed to the base asbtract class\n\n@param interfaceMethods\nthe methods to implement coming from the\nActivityContextInterface developer", "docstring_tokens": ["Generates", "the", "concrete", "methods", "of", "the", "class", "It", "generates", "a", "specific", "method", "implementation", "for", "the", "javax", ".", "slee", ".", "ActivityContextInterface", "methods", "for", "the", "methods", "coming", "from", "the", "ActivityContextInterface", "developer", "the", "call", "is", "routed", "to", "the", "base", "asbtract", "class"]}
{"code": "text.replaceAll(\"\\\\r\\\\n\", \"\\n\");", "comments": "DOS to Unix", "lines": 8, "repo": "myabc/markdownj", "path": "core/src/main/java/org/markdownj/MarkdownProcessor.java", "func_name": "MarkdownProcessor.markdown", "original_string": "public String markdown(String txt) {\n        if (txt == null) {\n            txt = \"\";\n        }\n        TextEditor text = new TextEditor(txt);\n\n        // Standardize line endings:\n        text.replaceAll(\"\\\\r\\\\n\", \"\\n\"); \t// DOS to Unix\n        text.replaceAll(\"\\\\r\", \"\\n\");    \t// Mac to Unix\n        text.replaceAll(\"^[ \\\\t]+$\", \"\");\n\n        // Make sure $text ends with a couple of newlines:\n        text.append(\"\\n\\n\");\n\n        text.detabify();\n        text.deleteAll(\"^[ ]+$\");\n        hashHTMLBlocks(text);\n        stripLinkDefinitions(text);\n        text = runBlockGamut(text);\n        unEscapeSpecialChars(text);\n\n        text.append(\"\\n\");\n        return text.toString();\n    }", "language": "java", "Allcodes": "public String markdown(String txt) {\n        if (txt == null) {\n            txt = \"\";\n        }\n        TextEditor text = new TextEditor(txt);\n\n        // Standardize line endings:\n        text.replaceAll(\"\\\\r\\\\n\", \"\\n\"); \t// DOS to Unix\n        text.replaceAll(\"\\\\r\", \"\\n\");    \t// Mac to Unix\n        text.replaceAll(\"^[ \\\\t]+$\", \"\");\n\n        // Make sure $text ends with a couple of newlines:\n        text.append(\"\\n\\n\");\n\n        text.detabify();\n        text.deleteAll(\"^[ ]+$\");\n        hashHTMLBlocks(text);\n        stripLinkDefinitions(text);\n        text = runBlockGamut(text);\n        unEscapeSpecialChars(text);\n\n        text.append(\"\\n\");\n        return text.toString();\n    }", "code_tokens": ["public", "String", "markdown", "(", "String", "txt", ")", "{", "if", "(", "txt", "==", "null", ")", "{", "txt", "=", "\"\"", ";", "}", "TextEditor", "text", "=", "new", "TextEditor", "(", "txt", ")", ";", "// Standardize line endings:", "text", ".", "replaceAll", "(", "\"\\\\r\\\\n\"", ",", "\"\\n\"", ")", ";", "// DOS to Unix", "text", ".", "replaceAll", "(", "\"\\\\r\"", ",", "\"\\n\"", ")", ";", "// Mac to Unix", "text", ".", "replaceAll", "(", "\"^[ \\\\t]+$\"", ",", "\"\"", ")", ";", "// Make sure $text ends with a couple of newlines:", "text", ".", "append", "(", "\"\\n\\n\"", ")", ";", "text", ".", "detabify", "(", ")", ";", "text", ".", "deleteAll", "(", "\"^[ ]+$\"", ")", ";", "hashHTMLBlocks", "(", "text", ")", ";", "stripLinkDefinitions", "(", "text", ")", ";", "text", "=", "runBlockGamut", "(", "text", ")", ";", "unEscapeSpecialChars", "(", "text", ")", ";", "text", ".", "append", "(", "\"\\n\"", ")", ";", "return", "text", ".", "toString", "(", ")", ";", "}"], "docstring": "Perform the conversion from Markdown to HTML.\n\n@param txt - input in markdown format\n@return HTML block corresponding to txt passed in.", "docstring_tokens": ["Perform", "the", "conversion", "from", "Markdown", "to", "HTML", "."]}
{"code": "text.replaceAll(\"\\\\r\", \"\\n\");", "comments": "Mac to Unix", "lines": 9, "repo": "myabc/markdownj", "path": "core/src/main/java/org/markdownj/MarkdownProcessor.java", "func_name": "MarkdownProcessor.markdown", "original_string": "public String markdown(String txt) {\n        if (txt == null) {\n            txt = \"\";\n        }\n        TextEditor text = new TextEditor(txt);\n\n        // Standardize line endings:\n        text.replaceAll(\"\\\\r\\\\n\", \"\\n\"); \t// DOS to Unix\n        text.replaceAll(\"\\\\r\", \"\\n\");    \t// Mac to Unix\n        text.replaceAll(\"^[ \\\\t]+$\", \"\");\n\n        // Make sure $text ends with a couple of newlines:\n        text.append(\"\\n\\n\");\n\n        text.detabify();\n        text.deleteAll(\"^[ ]+$\");\n        hashHTMLBlocks(text);\n        stripLinkDefinitions(text);\n        text = runBlockGamut(text);\n        unEscapeSpecialChars(text);\n\n        text.append(\"\\n\");\n        return text.toString();\n    }", "language": "java", "Allcodes": "public String markdown(String txt) {\n        if (txt == null) {\n            txt = \"\";\n        }\n        TextEditor text = new TextEditor(txt);\n\n        // Standardize line endings:\n        text.replaceAll(\"\\\\r\\\\n\", \"\\n\"); \t// DOS to Unix\n        text.replaceAll(\"\\\\r\", \"\\n\");    \t// Mac to Unix\n        text.replaceAll(\"^[ \\\\t]+$\", \"\");\n\n        // Make sure $text ends with a couple of newlines:\n        text.append(\"\\n\\n\");\n\n        text.detabify();\n        text.deleteAll(\"^[ ]+$\");\n        hashHTMLBlocks(text);\n        stripLinkDefinitions(text);\n        text = runBlockGamut(text);\n        unEscapeSpecialChars(text);\n\n        text.append(\"\\n\");\n        return text.toString();\n    }", "code_tokens": ["public", "String", "markdown", "(", "String", "txt", ")", "{", "if", "(", "txt", "==", "null", ")", "{", "txt", "=", "\"\"", ";", "}", "TextEditor", "text", "=", "new", "TextEditor", "(", "txt", ")", ";", "// Standardize line endings:", "text", ".", "replaceAll", "(", "\"\\\\r\\\\n\"", ",", "\"\\n\"", ")", ";", "// DOS to Unix", "text", ".", "replaceAll", "(", "\"\\\\r\"", ",", "\"\\n\"", ")", ";", "// Mac to Unix", "text", ".", "replaceAll", "(", "\"^[ \\\\t]+$\"", ",", "\"\"", ")", ";", "// Make sure $text ends with a couple of newlines:", "text", ".", "append", "(", "\"\\n\\n\"", ")", ";", "text", ".", "detabify", "(", ")", ";", "text", ".", "deleteAll", "(", "\"^[ ]+$\"", ")", ";", "hashHTMLBlocks", "(", "text", ")", ";", "stripLinkDefinitions", "(", "text", ")", ";", "text", "=", "runBlockGamut", "(", "text", ")", ";", "unEscapeSpecialChars", "(", "text", ")", ";", "text", ".", "append", "(", "\"\\n\"", ")", ";", "return", "text", ".", "toString", "(", ")", ";", "}"], "docstring": "Perform the conversion from Markdown to HTML.\n\n@param txt - input in markdown format\n@return HTML block corresponding to txt passed in.", "docstring_tokens": ["Perform", "the", "conversion", "from", "Markdown", "to", "HTML", "."]}
{"code": "getOrInit().offer(exception);", "comments": "SQLExceptions from the above two sub-types are not stored", "lines": 3, "repo": "vibur/vibur-dbcp", "path": "src/main/java/org/vibur/dbcp/proxy/ExceptionCollector.java", "func_name": "ExceptionCollector.addException", "original_string": "final void addException(SQLException exception) {\n        if (!(exception instanceof SQLTimeoutException) && !(exception instanceof SQLTransactionRollbackException)) {\n            getOrInit().offer(exception); // SQLExceptions from the above two sub-types are not stored\n        }\n    }", "language": "java", "Allcodes": "final void addException(SQLException exception) {\n        if (!(exception instanceof SQLTimeoutException) && !(exception instanceof SQLTransactionRollbackException)) {\n            getOrInit().offer(exception); // SQLExceptions from the above two sub-types are not stored\n        }\n    }", "code_tokens": ["final", "void", "addException", "(", "SQLException", "exception", ")", "{", "if", "(", "!", "(", "exception", "instanceof", "SQLTimeoutException", ")", "&&", "!", "(", "exception", "instanceof", "SQLTransactionRollbackException", ")", ")", "{", "getOrInit", "(", ")", ".", "offer", "(", "exception", ")", ";", "// SQLExceptions from the above two sub-types are not stored", "}", "}"], "docstring": "This method will be called when an operation invoked on a JDBC object throws an SQLException.\nIt will accumulate a list of all non-transient SQL exceptions.\n\n@param exception the exception thrown", "docstring_tokens": ["This", "method", "will", "be", "called", "when", "an", "operation", "invoked", "on", "a", "JDBC", "object", "throws", "an", "SQLException", ".", "It", "will", "accumulate", "a", "list", "of", "all", "non", "-", "transient", "SQL", "exceptions", "."]}
{"code": "CompositeValidator compositeValidator = new CompositeValidator();", "comments": "hold", "lines": 9, "repo": "boonproject/boon", "path": "boon/src/main/java/org/boon/validation/RecursiveDescentPropertyValidator.java", "func_name": "RecursiveDescentPropertyValidator.createValidator", "original_string": "protected CompositeValidator createValidator(\n            List<ValidatorMetaData> validationMetaDataList ) {\n\n        /*\n         * A field (property) can be associated with many validators so we use a\n         * CompositeValidator to hold all of the validators associated with this\n         * validator.\n         */\n        CompositeValidator compositeValidator = new CompositeValidator(); // hold\n        // all\n        // of\n        // the\n        // validators\n        // associated\n        // with\n        // the\n        // field.\n\n        /*\n         * Lookup the list of validators for the current field and initialize\n         * them with validation meta-data properties.\n         */\n        List<FieldValidator> validatorsList =\n                lookupTheListOfValidatorsAndInitializeThemWithMetaDataProperties( validationMetaDataList );\n\n        compositeValidator.setValidatorList( validatorsList );\n\n        return compositeValidator;\n    }", "language": "java", "Allcodes": "protected CompositeValidator createValidator(\n            List<ValidatorMetaData> validationMetaDataList ) {\n\n        /*\n         * A field (property) can be associated with many validators so we use a\n         * CompositeValidator to hold all of the validators associated with this\n         * validator.\n         */\n        CompositeValidator compositeValidator = new CompositeValidator(); // hold\n        // all\n        // of\n        // the\n        // validators\n        // associated\n        // with\n        // the\n        // field.\n\n        /*\n         * Lookup the list of validators for the current field and initialize\n         * them with validation meta-data properties.\n         */\n        List<FieldValidator> validatorsList =\n                lookupTheListOfValidatorsAndInitializeThemWithMetaDataProperties( validationMetaDataList );\n\n        compositeValidator.setValidatorList( validatorsList );\n\n        return compositeValidator;\n    }", "code_tokens": ["protected", "CompositeValidator", "createValidator", "(", "List", "<", "ValidatorMetaData", ">", "validationMetaDataList", ")", "{", "/*\n         * A field (property) can be associated with many validators so we use a\n         * CompositeValidator to hold all of the validators associated with this\n         * validator.\n         */", "CompositeValidator", "compositeValidator", "=", "new", "CompositeValidator", "(", ")", ";", "// hold", "// all", "// of", "// the", "// validators", "// associated", "// with", "// the", "// field.", "/*\n         * Lookup the list of validators for the current field and initialize\n         * them with validation meta-data properties.\n         */", "List", "<", "FieldValidator", ">", "validatorsList", "=", "lookupTheListOfValidatorsAndInitializeThemWithMetaDataProperties", "(", "validationMetaDataList", ")", ";", "compositeValidator", ".", "setValidatorList", "(", "validatorsList", ")", ";", "return", "compositeValidator", ";", "}"], "docstring": "Create the validator by looking it up in the ObjectRegistry and then\npopulating it with values from the meta-data list.\n\n@param validationMetaDataList Holds metadataInformation about validation.\n@return composite validator with all of the validators for this property present.", "docstring_tokens": ["Create", "the", "validator", "by", "looking", "it", "up", "in", "the", "ObjectRegistry", "and", "then", "populating", "it", "with", "values", "from", "the", "meta", "-", "data", "list", "."]}
{"code": "options.blockSize(32_768);", "comments": "32K", "lines": 5, "repo": "boonproject/boon", "path": "slumberdb/slumberdb-leveldb/src/main/java/org/boon/slumberdb/leveldb/LevelDBKeyValueStore.java", "func_name": "LevelDBKeyValueStore.defaultOptions", "original_string": "private Options defaultOptions() {\n\n        Options options = new Options();\n        options.createIfMissing(true);\n        options.blockSize(32_768); //32K\n        options.cacheSize(67_108_864);//64MB\n        return options;\n    }", "language": "java", "Allcodes": "private Options defaultOptions() {\n\n        Options options = new Options();\n        options.createIfMissing(true);\n        options.blockSize(32_768); //32K\n        options.cacheSize(67_108_864);//64MB\n        return options;\n    }", "code_tokens": ["private", "Options", "defaultOptions", "(", ")", "{", "Options", "options", "=", "new", "Options", "(", ")", ";", "options", ".", "createIfMissing", "(", "true", ")", ";", "options", ".", "blockSize", "(", "32_768", ")", ";", "//32K", "options", ".", "cacheSize", "(", "67_108_864", ")", ";", "//64MB", "return", "options", ";", "}"], "docstring": "Configures default options.\n\n@return", "docstring_tokens": ["Configures", "default", "options", "."]}
{"code": "options.cacheSize(67_108_864);", "comments": "64MB", "lines": 6, "repo": "boonproject/boon", "path": "slumberdb/slumberdb-leveldb/src/main/java/org/boon/slumberdb/leveldb/LevelDBKeyValueStore.java", "func_name": "LevelDBKeyValueStore.defaultOptions", "original_string": "private Options defaultOptions() {\n\n        Options options = new Options();\n        options.createIfMissing(true);\n        options.blockSize(32_768); //32K\n        options.cacheSize(67_108_864);//64MB\n        return options;\n    }", "language": "java", "Allcodes": "private Options defaultOptions() {\n\n        Options options = new Options();\n        options.createIfMissing(true);\n        options.blockSize(32_768); //32K\n        options.cacheSize(67_108_864);//64MB\n        return options;\n    }", "code_tokens": ["private", "Options", "defaultOptions", "(", ")", "{", "Options", "options", "=", "new", "Options", "(", ")", ";", "options", ".", "createIfMissing", "(", "true", ")", ";", "options", ".", "blockSize", "(", "32_768", ")", ";", "//32K", "options", ".", "cacheSize", "(", "67_108_864", ")", ";", "//64MB", "return", "options", ";", "}"], "docstring": "Configures default options.\n\n@return", "docstring_tokens": ["Configures", "default", "options", "."]}
{"code": "dataToWriteToFile = inputChannel.poll();", "comments": "no wait", "lines": 7, "repo": "boonproject/boon", "path": "slumberdb/slumberdb-service-model/src/main/java/org/boon/slumberdb/stores/log/CollectorManager.java", "func_name": "CollectorManager.manageInputWriterChannel", "original_string": "private void manageInputWriterChannel() throws InterruptedException {\n\n\n        try {\n\n            ByteBuffer dataToWriteToFile;\n            dataToWriteToFile = inputChannel.poll();  //no wait\n\n            //If it is null, it means the inputChannel is empty and we need to flush.\n            if (dataToWriteToFile == null) {\n                queueEmptyMaybeFlush();\n                dataToWriteToFile = inputChannel.poll();\n            }\n\n\n            //If it is still null, this means that we need to wait\n            //for more items to show up in the inputChannel.\n            if (dataToWriteToFile == null) {\n                dataToWriteToFile = waitForNextDataToWrite();\n            }\n\n            //We have to check for null again because we could have been interrupted.\n            if (dataToWriteToFile != null) {\n                //Write it\n                writer.nextBufferToWrite(dataToWriteToFile);\n                //Then give it back\n                if (RECYCLE_BUFFER) {\n                    recycleChannel.offer(dataToWriteToFile);\n                }\n\n            }\n\n        } catch (InterruptedException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            ex.printStackTrace(System.err);\n        }\n\n    }", "language": "java", "Allcodes": "private void manageInputWriterChannel() throws InterruptedException {\n\n\n        try {\n\n            ByteBuffer dataToWriteToFile;\n            dataToWriteToFile = inputChannel.poll();  //no wait\n\n            //If it is null, it means the inputChannel is empty and we need to flush.\n            if (dataToWriteToFile == null) {\n                queueEmptyMaybeFlush();\n                dataToWriteToFile = inputChannel.poll();\n            }\n\n\n            //If it is still null, this means that we need to wait\n            //for more items to show up in the inputChannel.\n            if (dataToWriteToFile == null) {\n                dataToWriteToFile = waitForNextDataToWrite();\n            }\n\n            //We have to check for null again because we could have been interrupted.\n            if (dataToWriteToFile != null) {\n                //Write it\n                writer.nextBufferToWrite(dataToWriteToFile);\n                //Then give it back\n                if (RECYCLE_BUFFER) {\n                    recycleChannel.offer(dataToWriteToFile);\n                }\n\n            }\n\n        } catch (InterruptedException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            ex.printStackTrace(System.err);\n        }\n\n    }", "code_tokens": ["private", "void", "manageInputWriterChannel", "(", ")", "throws", "InterruptedException", "{", "try", "{", "ByteBuffer", "dataToWriteToFile", ";", "dataToWriteToFile", "=", "inputChannel", ".", "poll", "(", ")", ";", "//no wait", "//If it is null, it means the inputChannel is empty and we need to flush.", "if", "(", "dataToWriteToFile", "==", "null", ")", "{", "queueEmptyMaybeFlush", "(", ")", ";", "dataToWriteToFile", "=", "inputChannel", ".", "poll", "(", ")", ";", "}", "//If it is still null, this means that we need to wait", "//for more items to show up in the inputChannel.", "if", "(", "dataToWriteToFile", "==", "null", ")", "{", "dataToWriteToFile", "=", "waitForNextDataToWrite", "(", ")", ";", "}", "//We have to check for null again because we could have been interrupted.", "if", "(", "dataToWriteToFile", "!=", "null", ")", "{", "//Write it", "writer", ".", "nextBufferToWrite", "(", "dataToWriteToFile", ")", ";", "//Then give it back", "if", "(", "RECYCLE_BUFFER", ")", "{", "recycleChannel", ".", "offer", "(", "dataToWriteToFile", ")", ";", "}", "}", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "throw", "ex", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "ex", ".", "printStackTrace", "(", "System", ".", "err", ")", ";", "}", "}"], "docstring": "Queue and batch writer main logic.\nThis is where the magic happens.\n\n@throws InterruptedException", "docstring_tokens": ["Queue", "and", "batch", "writer", "main", "logic", ".", "This", "is", "where", "the", "magic", "happens", "."]}
{"code": "String idStr = entryId.replaceAll(ID_PREFIX, \"\");", "comments": "remove the prefix", "lines": 6, "repo": "Jasig/NotificationPortlet", "path": "notification-portlet-webapp/src/main/java/org/jasig/portlet/notice/service/jpa/JpaNotificationService.java", "func_name": "JpaNotificationService.addEntryState", "original_string": "public void addEntryState(PortletRequest req, String entryId, NotificationState state) {\n        if (usernameFinder.isAuthenticated(req)) {\n\n            final String username = usernameFinder.findUsername(req);\n\n            String idStr = entryId.replaceAll(ID_PREFIX, \"\"); // remove the prefix\n\n            JpaEntry jpaEntry = notificationDao.getEntry(Long.parseLong(idStr));\n            if (jpaEntry != null) {\n                JpaEvent event = new JpaEvent();\n                event.setEntry(jpaEntry);\n                event.setState(state);\n                event.setTimestamp(new Timestamp(new Date().getTime()));\n                event.setUsername(username);\n\n                notificationDao.createOrUpdateEvent(event);\n            }\n            else {\n                throw new IllegalArgumentException(\"JpaEntry not found\");\n            }\n        }\n    }", "language": "java", "Allcodes": "public void addEntryState(PortletRequest req, String entryId, NotificationState state) {\n        if (usernameFinder.isAuthenticated(req)) {\n\n            final String username = usernameFinder.findUsername(req);\n\n            String idStr = entryId.replaceAll(ID_PREFIX, \"\"); // remove the prefix\n\n            JpaEntry jpaEntry = notificationDao.getEntry(Long.parseLong(idStr));\n            if (jpaEntry != null) {\n                JpaEvent event = new JpaEvent();\n                event.setEntry(jpaEntry);\n                event.setState(state);\n                event.setTimestamp(new Timestamp(new Date().getTime()));\n                event.setUsername(username);\n\n                notificationDao.createOrUpdateEvent(event);\n            }\n            else {\n                throw new IllegalArgumentException(\"JpaEntry not found\");\n            }\n        }\n    }", "code_tokens": ["public", "void", "addEntryState", "(", "PortletRequest", "req", ",", "String", "entryId", ",", "NotificationState", "state", ")", "{", "if", "(", "usernameFinder", ".", "isAuthenticated", "(", "req", ")", ")", "{", "final", "String", "username", "=", "usernameFinder", ".", "findUsername", "(", "req", ")", ";", "String", "idStr", "=", "entryId", ".", "replaceAll", "(", "ID_PREFIX", ",", "\"\"", ")", ";", "// remove the prefix", "JpaEntry", "jpaEntry", "=", "notificationDao", ".", "getEntry", "(", "Long", ".", "parseLong", "(", "idStr", ")", ")", ";", "if", "(", "jpaEntry", "!=", "null", ")", "{", "JpaEvent", "event", "=", "new", "JpaEvent", "(", ")", ";", "event", ".", "setEntry", "(", "jpaEntry", ")", ";", "event", ".", "setState", "(", "state", ")", ";", "event", ".", "setTimestamp", "(", "new", "Timestamp", "(", "new", "Date", "(", ")", ".", "getTime", "(", ")", ")", ")", ";", "event", ".", "setUsername", "(", "username", ")", ";", "notificationDao", ".", "createOrUpdateEvent", "(", "event", ")", ";", "}", "else", "{", "throw", "new", "IllegalArgumentException", "(", "\"JpaEntry not found\"", ")", ";", "}", "}", "}"], "docstring": "Caller must insure that the state being set has not already been added to the entry\nto avoid multiple events with the same state.", "docstring_tokens": ["Caller", "must", "insure", "that", "the", "state", "being", "set", "has", "not", "already", "been", "added", "to", "the", "entry", "to", "avoid", "multiple", "events", "with", "the", "same", "state", "."]}
{"code": "double S = Math.sqrt(trace+1.0) * 2;", "comments": "S=4*qw", "lines": 24, "repo": "lessthanoptimal/GeoRegression", "path": "main/src/georegression/geometry/ConvertRotation3D_F64.java", "func_name": "ConvertRotation3D_F64.matrixToQuaternion", "original_string": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "language": "java", "Allcodes": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "code_tokens": ["public", "static", "Quaternion_F64", "matrixToQuaternion", "(", "DMatrixRMaj", "R", ",", "Quaternion_F64", "quat", ")", "{", "if", "(", "quat", "==", "null", ")", "quat", "=", "new", "Quaternion_F64", "(", ")", ";", "// algorithm from:", "// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/", "//", "// Designed to minimize numerical error by not dividing by very small numbers", "double", "m00", "=", "R", ".", "unsafe_get", "(", "0", ",", "0", ")", ";", "double", "m01", "=", "R", ".", "unsafe_get", "(", "0", ",", "1", ")", ";", "double", "m02", "=", "R", ".", "unsafe_get", "(", "0", ",", "2", ")", ";", "double", "m10", "=", "R", ".", "unsafe_get", "(", "1", ",", "0", ")", ";", "double", "m11", "=", "R", ".", "unsafe_get", "(", "1", ",", "1", ")", ";", "double", "m12", "=", "R", ".", "unsafe_get", "(", "1", ",", "2", ")", ";", "double", "m20", "=", "R", ".", "unsafe_get", "(", "2", ",", "0", ")", ";", "double", "m21", "=", "R", ".", "unsafe_get", "(", "2", ",", "1", ")", ";", "double", "m22", "=", "R", ".", "unsafe_get", "(", "2", ",", "2", ")", ";", "double", "trace", "=", "m00", "+", "m11", "+", "m22", ";", "if", "(", "trace", ">", "0", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "trace", "+", "1.0", ")", "*", "2", ";", "// S=4*qw", "quat", ".", "w", "=", "0.25", "*", "S", ";", "quat", ".", "x", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "}", "else", "if", "(", "(", "m00", ">", "m11", ")", "&", "(", "m00", ">", "m22", ")", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m00", "-", "m11", "-", "m22", ")", "*", "2", ";", "// S=4*qx", "quat", ".", "w", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "x", "=", "0.25", "*", "S", ";", "quat", ".", "y", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "}", "else", "if", "(", "m11", ">", "m22", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m11", "-", "m00", "-", "m22", ")", "*", "2", ";", "// S=4*qy", "quat", ".", "w", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "y", "=", "0.25", "*", "S", ";", "quat", ".", "z", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "}", "else", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m22", "-", "m00", "-", "m11", ")", "*", "2", ";", "// S=4*qz", "quat", ".", "w", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "quat", ".", "z", "=", "0.25", "*", "S", ";", "}", "return", "quat", ";", "}"], "docstring": "Extracts quaternions from the provided rotation matrix.\n\n@param R (Input) rotation matrix\n@param quat (Output) Optional storage for quaternion.  If null a new class will be used.\n@return unit quaternion representation of the rotation matrix.", "docstring_tokens": ["Extracts", "quaternions", "from", "the", "provided", "rotation", "matrix", "."]}
{"code": "double S = Math.sqrt(1.0 + m00 - m11 - m22) * 2;", "comments": "S=4*qx", "lines": 30, "repo": "lessthanoptimal/GeoRegression", "path": "main/src/georegression/geometry/ConvertRotation3D_F64.java", "func_name": "ConvertRotation3D_F64.matrixToQuaternion", "original_string": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "language": "java", "Allcodes": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "code_tokens": ["public", "static", "Quaternion_F64", "matrixToQuaternion", "(", "DMatrixRMaj", "R", ",", "Quaternion_F64", "quat", ")", "{", "if", "(", "quat", "==", "null", ")", "quat", "=", "new", "Quaternion_F64", "(", ")", ";", "// algorithm from:", "// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/", "//", "// Designed to minimize numerical error by not dividing by very small numbers", "double", "m00", "=", "R", ".", "unsafe_get", "(", "0", ",", "0", ")", ";", "double", "m01", "=", "R", ".", "unsafe_get", "(", "0", ",", "1", ")", ";", "double", "m02", "=", "R", ".", "unsafe_get", "(", "0", ",", "2", ")", ";", "double", "m10", "=", "R", ".", "unsafe_get", "(", "1", ",", "0", ")", ";", "double", "m11", "=", "R", ".", "unsafe_get", "(", "1", ",", "1", ")", ";", "double", "m12", "=", "R", ".", "unsafe_get", "(", "1", ",", "2", ")", ";", "double", "m20", "=", "R", ".", "unsafe_get", "(", "2", ",", "0", ")", ";", "double", "m21", "=", "R", ".", "unsafe_get", "(", "2", ",", "1", ")", ";", "double", "m22", "=", "R", ".", "unsafe_get", "(", "2", ",", "2", ")", ";", "double", "trace", "=", "m00", "+", "m11", "+", "m22", ";", "if", "(", "trace", ">", "0", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "trace", "+", "1.0", ")", "*", "2", ";", "// S=4*qw", "quat", ".", "w", "=", "0.25", "*", "S", ";", "quat", ".", "x", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "}", "else", "if", "(", "(", "m00", ">", "m11", ")", "&", "(", "m00", ">", "m22", ")", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m00", "-", "m11", "-", "m22", ")", "*", "2", ";", "// S=4*qx", "quat", ".", "w", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "x", "=", "0.25", "*", "S", ";", "quat", ".", "y", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "}", "else", "if", "(", "m11", ">", "m22", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m11", "-", "m00", "-", "m22", ")", "*", "2", ";", "// S=4*qy", "quat", ".", "w", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "y", "=", "0.25", "*", "S", ";", "quat", ".", "z", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "}", "else", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m22", "-", "m00", "-", "m11", ")", "*", "2", ";", "// S=4*qz", "quat", ".", "w", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "quat", ".", "z", "=", "0.25", "*", "S", ";", "}", "return", "quat", ";", "}"], "docstring": "Extracts quaternions from the provided rotation matrix.\n\n@param R (Input) rotation matrix\n@param quat (Output) Optional storage for quaternion.  If null a new class will be used.\n@return unit quaternion representation of the rotation matrix.", "docstring_tokens": ["Extracts", "quaternions", "from", "the", "provided", "rotation", "matrix", "."]}
{"code": "double S = Math.sqrt(1.0 + m11 - m00 - m22) * 2;", "comments": "S=4*qy", "lines": 36, "repo": "lessthanoptimal/GeoRegression", "path": "main/src/georegression/geometry/ConvertRotation3D_F64.java", "func_name": "ConvertRotation3D_F64.matrixToQuaternion", "original_string": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "language": "java", "Allcodes": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "code_tokens": ["public", "static", "Quaternion_F64", "matrixToQuaternion", "(", "DMatrixRMaj", "R", ",", "Quaternion_F64", "quat", ")", "{", "if", "(", "quat", "==", "null", ")", "quat", "=", "new", "Quaternion_F64", "(", ")", ";", "// algorithm from:", "// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/", "//", "// Designed to minimize numerical error by not dividing by very small numbers", "double", "m00", "=", "R", ".", "unsafe_get", "(", "0", ",", "0", ")", ";", "double", "m01", "=", "R", ".", "unsafe_get", "(", "0", ",", "1", ")", ";", "double", "m02", "=", "R", ".", "unsafe_get", "(", "0", ",", "2", ")", ";", "double", "m10", "=", "R", ".", "unsafe_get", "(", "1", ",", "0", ")", ";", "double", "m11", "=", "R", ".", "unsafe_get", "(", "1", ",", "1", ")", ";", "double", "m12", "=", "R", ".", "unsafe_get", "(", "1", ",", "2", ")", ";", "double", "m20", "=", "R", ".", "unsafe_get", "(", "2", ",", "0", ")", ";", "double", "m21", "=", "R", ".", "unsafe_get", "(", "2", ",", "1", ")", ";", "double", "m22", "=", "R", ".", "unsafe_get", "(", "2", ",", "2", ")", ";", "double", "trace", "=", "m00", "+", "m11", "+", "m22", ";", "if", "(", "trace", ">", "0", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "trace", "+", "1.0", ")", "*", "2", ";", "// S=4*qw", "quat", ".", "w", "=", "0.25", "*", "S", ";", "quat", ".", "x", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "}", "else", "if", "(", "(", "m00", ">", "m11", ")", "&", "(", "m00", ">", "m22", ")", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m00", "-", "m11", "-", "m22", ")", "*", "2", ";", "// S=4*qx", "quat", ".", "w", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "x", "=", "0.25", "*", "S", ";", "quat", ".", "y", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "}", "else", "if", "(", "m11", ">", "m22", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m11", "-", "m00", "-", "m22", ")", "*", "2", ";", "// S=4*qy", "quat", ".", "w", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "y", "=", "0.25", "*", "S", ";", "quat", ".", "z", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "}", "else", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m22", "-", "m00", "-", "m11", ")", "*", "2", ";", "// S=4*qz", "quat", ".", "w", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "quat", ".", "z", "=", "0.25", "*", "S", ";", "}", "return", "quat", ";", "}"], "docstring": "Extracts quaternions from the provided rotation matrix.\n\n@param R (Input) rotation matrix\n@param quat (Output) Optional storage for quaternion.  If null a new class will be used.\n@return unit quaternion representation of the rotation matrix.", "docstring_tokens": ["Extracts", "quaternions", "from", "the", "provided", "rotation", "matrix", "."]}
{"code": "double S = Math.sqrt(1.0 + m22 - m00 - m11) * 2;", "comments": "S=4*qz", "lines": 42, "repo": "lessthanoptimal/GeoRegression", "path": "main/src/georegression/geometry/ConvertRotation3D_F64.java", "func_name": "ConvertRotation3D_F64.matrixToQuaternion", "original_string": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "language": "java", "Allcodes": "public static Quaternion_F64 matrixToQuaternion( DMatrixRMaj R, Quaternion_F64 quat ) {\n\n\t\tif( quat == null )\n\t\t\tquat = new Quaternion_F64();\n\n\t\t// algorithm from:\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\t\t//\n\t\t// Designed to minimize numerical error by not dividing by very small numbers\n\n\t\tdouble m00 = R.unsafe_get(0,0);\n\t\tdouble m01 = R.unsafe_get(0,1);\n\t\tdouble m02 = R.unsafe_get(0,2);\n\t\tdouble m10 = R.unsafe_get(1,0);\n\t\tdouble m11 = R.unsafe_get(1,1);\n\t\tdouble m12 = R.unsafe_get(1,2);\n\t\tdouble m20 = R.unsafe_get(2,0);\n\t\tdouble m21 = R.unsafe_get(2,1);\n\t\tdouble m22 = R.unsafe_get(2,2);\n\n\t\tdouble trace = m00 + m11 + m22;\n\n\t\tif (trace > 0) {\n\t\t\tdouble S = Math.sqrt(trace+1.0) * 2; // S=4*qw\n\t\t\tquat.w = 0.25 * S;\n\t\t\tquat.x = (m21 - m12) / S;\n\t\t\tquat.y = (m02 - m20) / S;\n\t\t\tquat.z = (m10 - m01) / S;\n\t\t} else if ((m00 > m11)&(m00 > m22)) {\n\t\t\tdouble S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx\n\t\t\tquat.w = (m21 - m12) / S;\n\t\t\tquat.x = 0.25 * S;\n\t\t\tquat.y = (m01 + m10) / S;\n\t\t\tquat.z = (m02 + m20) / S;\n\t\t} else if (m11 > m22) {\n\t\t\tdouble S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy\n\t\t\tquat.w = (m02 - m20) / S;\n\t\t\tquat.x = (m01 + m10) / S;\n\t\t\tquat.y = 0.25 * S;\n\t\t\tquat.z = (m12 + m21) / S;\n\t\t} else {\n\t\t\tdouble S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz\n\t\t\tquat.w = (m10 - m01) / S;\n\t\t\tquat.x = (m02 + m20) / S;\n\t\t\tquat.y = (m12 + m21) / S;\n\t\t\tquat.z = 0.25 * S;\n\t\t}\n\n\t\treturn quat;\n\t}", "code_tokens": ["public", "static", "Quaternion_F64", "matrixToQuaternion", "(", "DMatrixRMaj", "R", ",", "Quaternion_F64", "quat", ")", "{", "if", "(", "quat", "==", "null", ")", "quat", "=", "new", "Quaternion_F64", "(", ")", ";", "// algorithm from:", "// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/", "//", "// Designed to minimize numerical error by not dividing by very small numbers", "double", "m00", "=", "R", ".", "unsafe_get", "(", "0", ",", "0", ")", ";", "double", "m01", "=", "R", ".", "unsafe_get", "(", "0", ",", "1", ")", ";", "double", "m02", "=", "R", ".", "unsafe_get", "(", "0", ",", "2", ")", ";", "double", "m10", "=", "R", ".", "unsafe_get", "(", "1", ",", "0", ")", ";", "double", "m11", "=", "R", ".", "unsafe_get", "(", "1", ",", "1", ")", ";", "double", "m12", "=", "R", ".", "unsafe_get", "(", "1", ",", "2", ")", ";", "double", "m20", "=", "R", ".", "unsafe_get", "(", "2", ",", "0", ")", ";", "double", "m21", "=", "R", ".", "unsafe_get", "(", "2", ",", "1", ")", ";", "double", "m22", "=", "R", ".", "unsafe_get", "(", "2", ",", "2", ")", ";", "double", "trace", "=", "m00", "+", "m11", "+", "m22", ";", "if", "(", "trace", ">", "0", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "trace", "+", "1.0", ")", "*", "2", ";", "// S=4*qw", "quat", ".", "w", "=", "0.25", "*", "S", ";", "quat", ".", "x", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "}", "else", "if", "(", "(", "m00", ">", "m11", ")", "&", "(", "m00", ">", "m22", ")", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m00", "-", "m11", "-", "m22", ")", "*", "2", ";", "// S=4*qx", "quat", ".", "w", "=", "(", "m21", "-", "m12", ")", "/", "S", ";", "quat", ".", "x", "=", "0.25", "*", "S", ";", "quat", ".", "y", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "z", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "}", "else", "if", "(", "m11", ">", "m22", ")", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m11", "-", "m00", "-", "m22", ")", "*", "2", ";", "// S=4*qy", "quat", ".", "w", "=", "(", "m02", "-", "m20", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m01", "+", "m10", ")", "/", "S", ";", "quat", ".", "y", "=", "0.25", "*", "S", ";", "quat", ".", "z", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "}", "else", "{", "double", "S", "=", "Math", ".", "sqrt", "(", "1.0", "+", "m22", "-", "m00", "-", "m11", ")", "*", "2", ";", "// S=4*qz", "quat", ".", "w", "=", "(", "m10", "-", "m01", ")", "/", "S", ";", "quat", ".", "x", "=", "(", "m02", "+", "m20", ")", "/", "S", ";", "quat", ".", "y", "=", "(", "m12", "+", "m21", ")", "/", "S", ";", "quat", ".", "z", "=", "0.25", "*", "S", ";", "}", "return", "quat", ";", "}"], "docstring": "Extracts quaternions from the provided rotation matrix.\n\n@param R (Input) rotation matrix\n@param quat (Output) Optional storage for quaternion.  If null a new class will be used.\n@return unit quaternion representation of the rotation matrix.", "docstring_tokens": ["Extracts", "quaternions", "from", "the", "provided", "rotation", "matrix", "."]}
{"code": "return !(t < 0.0) && !((s + t) > 1.0);", "comments": "I is outside T", "lines": 20, "repo": "lessthanoptimal/GeoRegression", "path": "main/src/georegression/metric/Intersection3D_F64.java", "func_name": "Intersection3D_F64.containedPlane", "original_string": "private static boolean containedPlane( Point3D_F64 T_v0,\n\t\t\t\t\t\t\t\t\t\t   Point3D_F64 output,\n\t\t\t\t\t\t\t\t\t\t   Vector3D_F64 u , Vector3D_F64 v ,\n\t\t\t\t\t\t\t\t\t\t   Vector3D_F64 w0 ) {\n\t\tdouble uu, uv, vv, wu, wv, D;\n\t\tuu = u.dot(u);\n\t\tuv = u.dot(v);\n\t\tvv = v.dot(v);\n\t\tw0.minus(output,T_v0);\n\t\twu = w0.dot(u);\n\t\twv = w0.dot(v);\n\t\tD = uv * uv - uu * vv;\n\n\t\t// get and test parametric coords\n\t\tdouble s, t;\n\t\ts = (uv * wv - vv * wu) / D;\n\t\tif (s < 0.0 || s > 1.0)        // I is outside T\n\t\t\treturn false;\n\t\tt = (uv * wu - uu * wv) / D;\n\t\treturn !(t < 0.0) && !((s + t) > 1.0);  // I is outside T\n\t}", "language": "java", "Allcodes": "private static boolean containedPlane( Point3D_F64 T_v0,\n\t\t\t\t\t\t\t\t\t\t   Point3D_F64 output,\n\t\t\t\t\t\t\t\t\t\t   Vector3D_F64 u , Vector3D_F64 v ,\n\t\t\t\t\t\t\t\t\t\t   Vector3D_F64 w0 ) {\n\t\tdouble uu, uv, vv, wu, wv, D;\n\t\tuu = u.dot(u);\n\t\tuv = u.dot(v);\n\t\tvv = v.dot(v);\n\t\tw0.minus(output,T_v0);\n\t\twu = w0.dot(u);\n\t\twv = w0.dot(v);\n\t\tD = uv * uv - uu * vv;\n\n\t\t// get and test parametric coords\n\t\tdouble s, t;\n\t\ts = (uv * wv - vv * wu) / D;\n\t\tif (s < 0.0 || s > 1.0)        // I is outside T\n\t\t\treturn false;\n\t\tt = (uv * wu - uu * wv) / D;\n\t\treturn !(t < 0.0) && !((s + t) > 1.0);  // I is outside T\n\t}", "code_tokens": ["private", "static", "boolean", "containedPlane", "(", "Point3D_F64", "T_v0", ",", "Point3D_F64", "output", ",", "Vector3D_F64", "u", ",", "Vector3D_F64", "v", ",", "Vector3D_F64", "w0", ")", "{", "double", "uu", ",", "uv", ",", "vv", ",", "wu", ",", "wv", ",", "D", ";", "uu", "=", "u", ".", "dot", "(", "u", ")", ";", "uv", "=", "u", ".", "dot", "(", "v", ")", ";", "vv", "=", "v", ".", "dot", "(", "v", ")", ";", "w0", ".", "minus", "(", "output", ",", "T_v0", ")", ";", "wu", "=", "w0", ".", "dot", "(", "u", ")", ";", "wv", "=", "w0", ".", "dot", "(", "v", ")", ";", "D", "=", "uv", "*", "uv", "-", "uu", "*", "vv", ";", "// get and test parametric coords", "double", "s", ",", "t", ";", "s", "=", "(", "uv", "*", "wv", "-", "vv", "*", "wu", ")", "/", "D", ";", "if", "(", "s", "<", "0.0", "||", "s", ">", "1.0", ")", "// I is outside T", "return", "false", ";", "t", "=", "(", "uv", "*", "wu", "-", "uu", "*", "wv", ")", "/", "D", ";", "return", "!", "(", "t", "<", "0.0", ")", "&&", "!", "(", "(", "s", "+", "t", ")", ">", "1.0", ")", ";", "// I is outside T", "}"], "docstring": "Determines if the point on the same plane as T is contained inside of T.", "docstring_tokens": ["Determines", "if", "the", "point", "on", "the", "same", "plane", "as", "T", "is", "contained", "inside", "of", "T", "."]}
{"code": "int startIndex = INSTALL_MAP_PREFIX.length() + 1;", "comments": "skip the underscore after the prefix", "lines": 2, "repo": "WASdev/ci.common", "path": "src/main/java/net/wasdev/wlp/common/plugins/util/InstallFeatureUtil.java", "func_name": "InstallFeatureUtil.extractVersion", "original_string": "private static String extractVersion(String fileName) {\n        int startIndex = INSTALL_MAP_PREFIX.length() + 1; // skip the underscore after the prefix\n        int endIndex = fileName.lastIndexOf(INSTALL_MAP_SUFFIX);\n        if (startIndex < endIndex) {\n            return fileName.substring(startIndex, endIndex);\n        } else {\n            return null;\n        }\n    }", "language": "java", "Allcodes": "private static String extractVersion(String fileName) {\n        int startIndex = INSTALL_MAP_PREFIX.length() + 1; // skip the underscore after the prefix\n        int endIndex = fileName.lastIndexOf(INSTALL_MAP_SUFFIX);\n        if (startIndex < endIndex) {\n            return fileName.substring(startIndex, endIndex);\n        } else {\n            return null;\n        }\n    }", "code_tokens": ["private", "static", "String", "extractVersion", "(", "String", "fileName", ")", "{", "int", "startIndex", "=", "INSTALL_MAP_PREFIX", ".", "length", "(", ")", "+", "1", ";", "// skip the underscore after the prefix", "int", "endIndex", "=", "fileName", ".", "lastIndexOf", "(", "INSTALL_MAP_SUFFIX", ")", ";", "if", "(", "startIndex", "<", "endIndex", ")", "{", "return", "fileName", ".", "substring", "(", "startIndex", ",", "endIndex", ")", ";", "}", "else", "{", "return", "null", ";", "}", "}"], "docstring": "Returns the extracted version from fileName\n\n@param fileName\n@return the version extracted from fileName", "docstring_tokens": ["Returns", "the", "extracted", "version", "from", "fileName"]}
{"code": "encryptor.setPoolSize(configuration.getPoolSize());", "comments": "This would be a good value for a 4-core system", "lines": 2, "repo": "robeio/robe", "path": "robe-auth/src/main/java/io/robe/auth/token/BasicToken.java", "func_name": "BasicToken.configure", "original_string": "public static void configure(TokenBasedAuthConfiguration configuration) {\n        encryptor.setPoolSize(configuration.getPoolSize());          // This would be a good value for a 4-core system\n        if (configuration.getServerPassword().equals(\"auto\")) {\n            encryptor.setPassword(UUID.randomUUID().toString());\n        } else {\n            encryptor.setPassword(configuration.getServerPassword());\n        }\n        encryptor.setAlgorithm(configuration.getAlgorithm());\n        encryptor.initialize();\n        BasicToken.defaultMaxAge = configuration.getMaxage();\n\n        //Create cache for permissions.\n        cache = CacheBuilder.newBuilder()\n                .expireAfterAccess(defaultMaxAge, TimeUnit.SECONDS)\n                .expireAfterWrite(defaultMaxAge, TimeUnit.SECONDS)\n                .build();\n\n    }", "language": "java", "Allcodes": "public static void configure(TokenBasedAuthConfiguration configuration) {\n        encryptor.setPoolSize(configuration.getPoolSize());          // This would be a good value for a 4-core system\n        if (configuration.getServerPassword().equals(\"auto\")) {\n            encryptor.setPassword(UUID.randomUUID().toString());\n        } else {\n            encryptor.setPassword(configuration.getServerPassword());\n        }\n        encryptor.setAlgorithm(configuration.getAlgorithm());\n        encryptor.initialize();\n        BasicToken.defaultMaxAge = configuration.getMaxage();\n\n        //Create cache for permissions.\n        cache = CacheBuilder.newBuilder()\n                .expireAfterAccess(defaultMaxAge, TimeUnit.SECONDS)\n                .expireAfterWrite(defaultMaxAge, TimeUnit.SECONDS)\n                .build();\n\n    }", "code_tokens": ["public", "static", "void", "configure", "(", "TokenBasedAuthConfiguration", "configuration", ")", "{", "encryptor", ".", "setPoolSize", "(", "configuration", ".", "getPoolSize", "(", ")", ")", ";", "// This would be a good value for a 4-core system", "if", "(", "configuration", ".", "getServerPassword", "(", ")", ".", "equals", "(", "\"auto\"", ")", ")", "{", "encryptor", ".", "setPassword", "(", "UUID", ".", "randomUUID", "(", ")", ".", "toString", "(", ")", ")", ";", "}", "else", "{", "encryptor", ".", "setPassword", "(", "configuration", ".", "getServerPassword", "(", ")", ")", ";", "}", "encryptor", ".", "setAlgorithm", "(", "configuration", ".", "getAlgorithm", "(", ")", ")", ";", "encryptor", ".", "initialize", "(", ")", ";", "BasicToken", ".", "defaultMaxAge", "=", "configuration", ".", "getMaxage", "(", ")", ";", "//Create cache for permissions.", "cache", "=", "CacheBuilder", ".", "newBuilder", "(", ")", ".", "expireAfterAccess", "(", "defaultMaxAge", ",", "TimeUnit", ".", "SECONDS", ")", ".", "expireAfterWrite", "(", "defaultMaxAge", ",", "TimeUnit", ".", "SECONDS", ")", ".", "build", "(", ")", ";", "}"], "docstring": "Configure method for Token generation configurations and encryptor configure\n\n@param configuration confiuration for auth bundle", "docstring_tokens": ["Configure", "method", "for", "Token", "generation", "configurations", "and", "encryptor", "configure"]}
{"code": "continue;", "comments": "this period is outside the requested period or this is a point forecast.", "lines": 31, "repo": "amedia/meteo", "path": "meteo-core/src/main/java/no/api/meteo/service/locationforecast/extras/MeteoForecastIndexer.java", "func_name": "MeteoForecastIndexer.getBestFitPeriodForecast", "original_string": "Optional<PeriodForecast> getBestFitPeriodForecast(ZonedDateTime from, ZonedDateTime to) {\n        if (from == null || to == null) {\n            return Optional.empty();\n        }\n\n        // Making sure that we remove minutes, seconds and milliseconds from the request timestamps\n        ZonedDateTime requestFrom = toZeroMSN(from);\n        ZonedDateTime requestTo = toZeroMSN(to);\n\n        //  Get list of period forecasts for the requested day. Return empty if date isn't present\n        List<PeriodForecast> forecastsList = dayIndex.get(new DayIndexKey(requestFrom));\n        if (forecastsList == null) {\n            return Optional.empty();\n        }\n\n        PeriodForecast chosenForecast = null;\n        long score = 0;\n        long tmpScore = 0;\n\n        for (PeriodForecast forecast : forecastsList) {\n            ZonedDateTime actualFrom = cloneZonedDateTime(forecast.getFrom());\n\n            ZonedDateTime actualTo = cloneZonedDateTime(forecast.getTo());\n\n            if (requestFrom.equals(actualFrom) && requestTo.equals(actualTo)) {\n                return Optional.of(forecast);\n            } else if (\n                    (requestFrom.isBefore(actualFrom) && requestTo.isBefore(actualFrom)) ||\n                            (requestFrom.isAfter(actualTo) && requestTo.isAfter(actualTo)) ||\n                            actualTo.isEqual(actualFrom)) {\n                continue; // this period is outside the requested period or this is a point forecast.\n            } else if (requestFrom.isBefore(actualFrom) && requestTo.isBefore(actualTo)) {\n                tmpScore = hoursBetween(requestTo, actualFrom);\n            } else if ((actualFrom.isBefore(requestFrom) || actualFrom.isEqual(requestFrom)) &&\n                    actualTo.isBefore(requestTo)) {\n                tmpScore = hoursBetween(actualTo, requestFrom);\n            } else if (actualFrom.isAfter(requestFrom) &&\n                    (actualTo.isBefore(requestTo) || actualTo.isEqual(requestTo))) {\n                tmpScore = hoursBetween(actualTo, actualFrom);\n            } else if (actualFrom.isBefore(requestFrom) && actualTo.isAfter(requestTo)) {\n                tmpScore = hoursBetween(requestTo, requestFrom);\n            } else {\n                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd:HH:mm\");\n                log.warn(\"Unhandled forecast Requested period:\" + requestFrom.format(formatter) + \"--\" +\n                                 requestTo.format(formatter) + \", Actual period: \" +\n                                 actualFrom.format(formatter) + \"--\" + actualTo.format(formatter));\n            }\n\n            tmpScore = Math.abs(tmpScore);\n\n            if ((score == 0 && tmpScore > 0) || tmpScore > score) {\n                score = tmpScore;\n                chosenForecast = forecast;\n            }\n        }\n\n        return Optional.ofNullable(chosenForecast);\n    }", "language": "java", "Allcodes": "Optional<PeriodForecast> getBestFitPeriodForecast(ZonedDateTime from, ZonedDateTime to) {\n        if (from == null || to == null) {\n            return Optional.empty();\n        }\n\n        // Making sure that we remove minutes, seconds and milliseconds from the request timestamps\n        ZonedDateTime requestFrom = toZeroMSN(from);\n        ZonedDateTime requestTo = toZeroMSN(to);\n\n        //  Get list of period forecasts for the requested day. Return empty if date isn't present\n        List<PeriodForecast> forecastsList = dayIndex.get(new DayIndexKey(requestFrom));\n        if (forecastsList == null) {\n            return Optional.empty();\n        }\n\n        PeriodForecast chosenForecast = null;\n        long score = 0;\n        long tmpScore = 0;\n\n        for (PeriodForecast forecast : forecastsList) {\n            ZonedDateTime actualFrom = cloneZonedDateTime(forecast.getFrom());\n\n            ZonedDateTime actualTo = cloneZonedDateTime(forecast.getTo());\n\n            if (requestFrom.equals(actualFrom) && requestTo.equals(actualTo)) {\n                return Optional.of(forecast);\n            } else if (\n                    (requestFrom.isBefore(actualFrom) && requestTo.isBefore(actualFrom)) ||\n                            (requestFrom.isAfter(actualTo) && requestTo.isAfter(actualTo)) ||\n                            actualTo.isEqual(actualFrom)) {\n                continue; // this period is outside the requested period or this is a point forecast.\n            } else if (requestFrom.isBefore(actualFrom) && requestTo.isBefore(actualTo)) {\n                tmpScore = hoursBetween(requestTo, actualFrom);\n            } else if ((actualFrom.isBefore(requestFrom) || actualFrom.isEqual(requestFrom)) &&\n                    actualTo.isBefore(requestTo)) {\n                tmpScore = hoursBetween(actualTo, requestFrom);\n            } else if (actualFrom.isAfter(requestFrom) &&\n                    (actualTo.isBefore(requestTo) || actualTo.isEqual(requestTo))) {\n                tmpScore = hoursBetween(actualTo, actualFrom);\n            } else if (actualFrom.isBefore(requestFrom) && actualTo.isAfter(requestTo)) {\n                tmpScore = hoursBetween(requestTo, requestFrom);\n            } else {\n                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd:HH:mm\");\n                log.warn(\"Unhandled forecast Requested period:\" + requestFrom.format(formatter) + \"--\" +\n                                 requestTo.format(formatter) + \", Actual period: \" +\n                                 actualFrom.format(formatter) + \"--\" + actualTo.format(formatter));\n            }\n\n            tmpScore = Math.abs(tmpScore);\n\n            if ((score == 0 && tmpScore > 0) || tmpScore > score) {\n                score = tmpScore;\n                chosenForecast = forecast;\n            }\n        }\n\n        return Optional.ofNullable(chosenForecast);\n    }", "code_tokens": ["Optional", "<", "PeriodForecast", ">", "getBestFitPeriodForecast", "(", "ZonedDateTime", "from", ",", "ZonedDateTime", "to", ")", "{", "if", "(", "from", "==", "null", "||", "to", "==", "null", ")", "{", "return", "Optional", ".", "empty", "(", ")", ";", "}", "// Making sure that we remove minutes, seconds and milliseconds from the request timestamps", "ZonedDateTime", "requestFrom", "=", "toZeroMSN", "(", "from", ")", ";", "ZonedDateTime", "requestTo", "=", "toZeroMSN", "(", "to", ")", ";", "//  Get list of period forecasts for the requested day. Return empty if date isn't present", "List", "<", "PeriodForecast", ">", "forecastsList", "=", "dayIndex", ".", "get", "(", "new", "DayIndexKey", "(", "requestFrom", ")", ")", ";", "if", "(", "forecastsList", "==", "null", ")", "{", "return", "Optional", ".", "empty", "(", ")", ";", "}", "PeriodForecast", "chosenForecast", "=", "null", ";", "long", "score", "=", "0", ";", "long", "tmpScore", "=", "0", ";", "for", "(", "PeriodForecast", "forecast", ":", "forecastsList", ")", "{", "ZonedDateTime", "actualFrom", "=", "cloneZonedDateTime", "(", "forecast", ".", "getFrom", "(", ")", ")", ";", "ZonedDateTime", "actualTo", "=", "cloneZonedDateTime", "(", "forecast", ".", "getTo", "(", ")", ")", ";", "if", "(", "requestFrom", ".", "equals", "(", "actualFrom", ")", "&&", "requestTo", ".", "equals", "(", "actualTo", ")", ")", "{", "return", "Optional", ".", "of", "(", "forecast", ")", ";", "}", "else", "if", "(", "(", "requestFrom", ".", "isBefore", "(", "actualFrom", ")", "&&", "requestTo", ".", "isBefore", "(", "actualFrom", ")", ")", "||", "(", "requestFrom", ".", "isAfter", "(", "actualTo", ")", "&&", "requestTo", ".", "isAfter", "(", "actualTo", ")", ")", "||", "actualTo", ".", "isEqual", "(", "actualFrom", ")", ")", "{", "continue", ";", "// this period is outside the requested period or this is a point forecast.", "}", "else", "if", "(", "requestFrom", ".", "isBefore", "(", "actualFrom", ")", "&&", "requestTo", ".", "isBefore", "(", "actualTo", ")", ")", "{", "tmpScore", "=", "hoursBetween", "(", "requestTo", ",", "actualFrom", ")", ";", "}", "else", "if", "(", "(", "actualFrom", ".", "isBefore", "(", "requestFrom", ")", "||", "actualFrom", ".", "isEqual", "(", "requestFrom", ")", ")", "&&", "actualTo", ".", "isBefore", "(", "requestTo", ")", ")", "{", "tmpScore", "=", "hoursBetween", "(", "actualTo", ",", "requestFrom", ")", ";", "}", "else", "if", "(", "actualFrom", ".", "isAfter", "(", "requestFrom", ")", "&&", "(", "actualTo", ".", "isBefore", "(", "requestTo", ")", "||", "actualTo", ".", "isEqual", "(", "requestTo", ")", ")", ")", "{", "tmpScore", "=", "hoursBetween", "(", "actualTo", ",", "actualFrom", ")", ";", "}", "else", "if", "(", "actualFrom", ".", "isBefore", "(", "requestFrom", ")", "&&", "actualTo", ".", "isAfter", "(", "requestTo", ")", ")", "{", "tmpScore", "=", "hoursBetween", "(", "requestTo", ",", "requestFrom", ")", ";", "}", "else", "{", "DateTimeFormatter", "formatter", "=", "DateTimeFormatter", ".", "ofPattern", "(", "\"yyyy-MM-dd:HH:mm\"", ")", ";", "log", ".", "warn", "(", "\"Unhandled forecast Requested period:\"", "+", "requestFrom", ".", "format", "(", "formatter", ")", "+", "\"--\"", "+", "requestTo", ".", "format", "(", "formatter", ")", "+", "\", Actual period: \"", "+", "actualFrom", ".", "format", "(", "formatter", ")", "+", "\"--\"", "+", "actualTo", ".", "format", "(", "formatter", ")", ")", ";", "}", "tmpScore", "=", "Math", ".", "abs", "(", "tmpScore", ")", ";", "if", "(", "(", "score", "==", "0", "&&", "tmpScore", ">", "0", ")", "||", "tmpScore", ">", "score", ")", "{", "score", "=", "tmpScore", ";", "chosenForecast", "=", "forecast", ";", "}", "}", "return", "Optional", ".", "ofNullable", "(", "chosenForecast", ")", ";", "}"], "docstring": "Find the period forecast that has the best fitted forecast for a given period.\n\nThis means a forecast covering the requested period, with to and from time closest possible to that period. If\nthis function only can find a period forecast that covers parts of the requested period, then the forecast\ncovering the most will be used.", "docstring_tokens": ["Find", "the", "period", "forecast", "that", "has", "the", "best", "fitted", "forecast", "for", "a", "given", "period", "."]}
{"code": "match.add(null);", "comments": "make room for 1.", "lines": 36, "repo": "basis-technology-corp/tcl-regex-java", "path": "src/main/java/com/basistech/tclre/Runtime.java", "func_name": "Runtime.exec", "original_string": "boolean exec(HsrePattern re, CharSequence data, EnumSet<ExecFlags> execFlags) throws RegexException {\n    /* sanity checks */\n    /* setup */\n\n\n        if (0 != (re.guts.info & Flags.REG_UIMPOSSIBLE)) {\n            throw new RegexException(\"Regex marked impossible\");\n        }\n\n        eflags = 0;\n        for (ExecFlags ef : execFlags) {\n            switch (ef) {\n            case NOTBOL:\n                eflags |= Flags.REG_NOTBOL;\n                break;\n            case NOTEOL:\n                eflags |= Flags.REG_NOTEOL;\n                break;\n            case LOOKING_AT:\n                eflags |= Flags.REG_LOOKING_AT;\n                break;\n            default:\n                throw new RuntimeException(\"impossible exec flag\");\n            }\n        }\n\n        this.re = re;\n        this.g = re.guts;\n        this.data = data;\n        this.dataLength = this.data.length();\n        if (this.match != null) {\n            this.match.clear();\n        } else {\n            this.match = Lists.newArrayList();\n        }\n        match.add(null); // make room for 1.\n        if (0 != (g.info & Flags.REG_UBACKREF)) {\n            while (match.size() < g.nsub + 1) {\n                match.add(null);\n            }\n        }\n        if (mem != null && mem.length >= g.ntree) {\n            Arrays.fill(mem, 0);\n        } else {\n            mem = new int[g.ntree];\n        }\n       \n    /* do it */\n        assert g.tree != null;\n\n        if (0 != (g.info & Flags.REG_UBACKREF)) {\n            return cfind(g.tree.machine);\n        } else {\n            return find(g.tree.machine);\n        }\n    }", "language": "java", "Allcodes": "boolean exec(HsrePattern re, CharSequence data, EnumSet<ExecFlags> execFlags) throws RegexException {\n    /* sanity checks */\n    /* setup */\n\n\n        if (0 != (re.guts.info & Flags.REG_UIMPOSSIBLE)) {\n            throw new RegexException(\"Regex marked impossible\");\n        }\n\n        eflags = 0;\n        for (ExecFlags ef : execFlags) {\n            switch (ef) {\n            case NOTBOL:\n                eflags |= Flags.REG_NOTBOL;\n                break;\n            case NOTEOL:\n                eflags |= Flags.REG_NOTEOL;\n                break;\n            case LOOKING_AT:\n                eflags |= Flags.REG_LOOKING_AT;\n                break;\n            default:\n                throw new RuntimeException(\"impossible exec flag\");\n            }\n        }\n\n        this.re = re;\n        this.g = re.guts;\n        this.data = data;\n        this.dataLength = this.data.length();\n        if (this.match != null) {\n            this.match.clear();\n        } else {\n            this.match = Lists.newArrayList();\n        }\n        match.add(null); // make room for 1.\n        if (0 != (g.info & Flags.REG_UBACKREF)) {\n            while (match.size() < g.nsub + 1) {\n                match.add(null);\n            }\n        }\n        if (mem != null && mem.length >= g.ntree) {\n            Arrays.fill(mem, 0);\n        } else {\n            mem = new int[g.ntree];\n        }\n       \n    /* do it */\n        assert g.tree != null;\n\n        if (0 != (g.info & Flags.REG_UBACKREF)) {\n            return cfind(g.tree.machine);\n        } else {\n            return find(g.tree.machine);\n        }\n    }", "code_tokens": ["boolean", "exec", "(", "HsrePattern", "re", ",", "CharSequence", "data", ",", "EnumSet", "<", "ExecFlags", ">", "execFlags", ")", "throws", "RegexException", "{", "/* sanity checks */", "/* setup */", "if", "(", "0", "!=", "(", "re", ".", "guts", ".", "info", "&", "Flags", ".", "REG_UIMPOSSIBLE", ")", ")", "{", "throw", "new", "RegexException", "(", "\"Regex marked impossible\"", ")", ";", "}", "eflags", "=", "0", ";", "for", "(", "ExecFlags", "ef", ":", "execFlags", ")", "{", "switch", "(", "ef", ")", "{", "case", "NOTBOL", ":", "eflags", "|=", "Flags", ".", "REG_NOTBOL", ";", "break", ";", "case", "NOTEOL", ":", "eflags", "|=", "Flags", ".", "REG_NOTEOL", ";", "break", ";", "case", "LOOKING_AT", ":", "eflags", "|=", "Flags", ".", "REG_LOOKING_AT", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"impossible exec flag\"", ")", ";", "}", "}", "this", ".", "re", "=", "re", ";", "this", ".", "g", "=", "re", ".", "guts", ";", "this", ".", "data", "=", "data", ";", "this", ".", "dataLength", "=", "this", ".", "data", ".", "length", "(", ")", ";", "if", "(", "this", ".", "match", "!=", "null", ")", "{", "this", ".", "match", ".", "clear", "(", ")", ";", "}", "else", "{", "this", ".", "match", "=", "Lists", ".", "newArrayList", "(", ")", ";", "}", "match", ".", "add", "(", "null", ")", ";", "// make room for 1.", "if", "(", "0", "!=", "(", "g", ".", "info", "&", "Flags", ".", "REG_UBACKREF", ")", ")", "{", "while", "(", "match", ".", "size", "(", ")", "<", "g", ".", "nsub", "+", "1", ")", "{", "match", ".", "add", "(", "null", ")", ";", "}", "}", "if", "(", "mem", "!=", "null", "&&", "mem", ".", "length", ">=", "g", ".", "ntree", ")", "{", "Arrays", ".", "fill", "(", "mem", ",", "0", ")", ";", "}", "else", "{", "mem", "=", "new", "int", "[", "g", ".", "ntree", "]", ";", "}", "/* do it */", "assert", "g", ".", "tree", "!=", "null", ";", "if", "(", "0", "!=", "(", "g", ".", "info", "&", "Flags", ".", "REG_UBACKREF", ")", ")", "{", "return", "cfind", "(", "g", ".", "tree", ".", "machine", ")", ";", "}", "else", "{", "return", "find", "(", "g", ".", "tree", ".", "machine", ")", ";", "}", "}"], "docstring": "exec - match regular expression", "docstring_tokens": ["exec", "-", "match", "regular", "expression"]}
{"code": "return lacons.size() - 1;", "comments": "it's the index into the array, -1.", "lines": 9, "repo": "basis-technology-corp/tcl-regex-java", "path": "src/main/java/com/basistech/tclre/Compiler.java", "func_name": "Compiler.newlacon", "original_string": "private int newlacon(State begin, State end, int pos) {\n        if (lacons.size() == 0) {\n            // skip 0\n            lacons.add(null);\n        }\n        Subre sub = new Subre((char)0, 0, begin, end);\n        sub.subno = pos;\n        lacons.add(sub);\n        return lacons.size() - 1; // it's the index into the array, -1.\n    }", "language": "java", "Allcodes": "private int newlacon(State begin, State end, int pos) {\n        if (lacons.size() == 0) {\n            // skip 0\n            lacons.add(null);\n        }\n        Subre sub = new Subre((char)0, 0, begin, end);\n        sub.subno = pos;\n        lacons.add(sub);\n        return lacons.size() - 1; // it's the index into the array, -1.\n    }", "code_tokens": ["private", "int", "newlacon", "(", "State", "begin", ",", "State", "end", ",", "int", "pos", ")", "{", "if", "(", "lacons", ".", "size", "(", ")", "==", "0", ")", "{", "// skip 0", "lacons", ".", "add", "(", "null", ")", ";", "}", "Subre", "sub", "=", "new", "Subre", "(", "(", "char", ")", "0", ",", "0", ",", "begin", ",", "end", ")", ";", "sub", ".", "subno", "=", "pos", ";", "lacons", ".", "add", "(", "sub", ")", ";", "return", "lacons", ".", "size", "(", ")", "-", "1", ";", "// it's the index into the array, -1.", "}"], "docstring": "newlacon - allocate a lookahead-constraint subRE\n\n@return lacon number", "docstring_tokens": ["newlacon", "-", "allocate", "a", "lookahead", "-", "constraint", "subRE"]}
{"code": "continue;", "comments": "not in use at all, so can't have a subcolor.", "lines": 10, "repo": "basis-technology-corp/tcl-regex-java", "path": "src/main/java/com/basistech/tclre/ColorMap.java", "func_name": "ColorMap.okcolors", "original_string": "void okcolors(Nfa nfa) {\n        ColorDesc cd;\n        ColorDesc scd;\n        Arc a;\n        short sco;\n\n        for (short co = 0; co < colorDescs.size(); co++) {\n            cd = colorDescs.get(co);\n            if (cd == null) {\n                continue; // not in use at all, so can't have a subcolor.\n            }\n\n            sco = cd.sub;\n\n            if (sco == Constants.NOSUB) {\n            /* has no subcolor, no further action */\n            } else if (sco == co) {\n            /* is subcolor, let parent deal with it */\n            } else if (cd.getNChars() == 0) {\n            /* parent empty, its arcs change color to subcolor */\n                cd.sub = Constants.NOSUB;\n                scd = colorDescs.get(sco);\n\n                assert scd.getNChars() > 0;\n                assert scd.sub == sco;\n\n                scd.sub = Constants.NOSUB;\n                while ((a = cd.arcs) != null) {\n                    assert a.co == co;\n                    cd.arcs = a.colorchain;\n                    a.setColor(sco);\n                    a.colorchain = scd.arcs;\n                    scd.arcs = a;\n                }\n                freecolor(co);\n            } else {\n                /* parent's arcs must gain parallel subcolor arcs */\n                cd.sub = Constants.NOSUB;\n                scd = colorDescs.get(sco);\n\n                assert scd.getNChars() > 0;\n                assert scd.sub == sco;\n\n                scd.sub = Constants.NOSUB;\n\n                for (a = cd.arcs; a != null; a = a.colorchain) {\n                    assert a.co == co;\n                    nfa.newarc(a.type, sco, a.from, a.to);\n                }\n            }\n        }\n    }", "language": "java", "Allcodes": "void okcolors(Nfa nfa) {\n        ColorDesc cd;\n        ColorDesc scd;\n        Arc a;\n        short sco;\n\n        for (short co = 0; co < colorDescs.size(); co++) {\n            cd = colorDescs.get(co);\n            if (cd == null) {\n                continue; // not in use at all, so can't have a subcolor.\n            }\n\n            sco = cd.sub;\n\n            if (sco == Constants.NOSUB) {\n            /* has no subcolor, no further action */\n            } else if (sco == co) {\n            /* is subcolor, let parent deal with it */\n            } else if (cd.getNChars() == 0) {\n            /* parent empty, its arcs change color to subcolor */\n                cd.sub = Constants.NOSUB;\n                scd = colorDescs.get(sco);\n\n                assert scd.getNChars() > 0;\n                assert scd.sub == sco;\n\n                scd.sub = Constants.NOSUB;\n                while ((a = cd.arcs) != null) {\n                    assert a.co == co;\n                    cd.arcs = a.colorchain;\n                    a.setColor(sco);\n                    a.colorchain = scd.arcs;\n                    scd.arcs = a;\n                }\n                freecolor(co);\n            } else {\n                /* parent's arcs must gain parallel subcolor arcs */\n                cd.sub = Constants.NOSUB;\n                scd = colorDescs.get(sco);\n\n                assert scd.getNChars() > 0;\n                assert scd.sub == sco;\n\n                scd.sub = Constants.NOSUB;\n\n                for (a = cd.arcs; a != null; a = a.colorchain) {\n                    assert a.co == co;\n                    nfa.newarc(a.type, sco, a.from, a.to);\n                }\n            }\n        }\n    }", "code_tokens": ["void", "okcolors", "(", "Nfa", "nfa", ")", "{", "ColorDesc", "cd", ";", "ColorDesc", "scd", ";", "Arc", "a", ";", "short", "sco", ";", "for", "(", "short", "co", "=", "0", ";", "co", "<", "colorDescs", ".", "size", "(", ")", ";", "co", "++", ")", "{", "cd", "=", "colorDescs", ".", "get", "(", "co", ")", ";", "if", "(", "cd", "==", "null", ")", "{", "continue", ";", "// not in use at all, so can't have a subcolor.", "}", "sco", "=", "cd", ".", "sub", ";", "if", "(", "sco", "==", "Constants", ".", "NOSUB", ")", "{", "/* has no subcolor, no further action */", "}", "else", "if", "(", "sco", "==", "co", ")", "{", "/* is subcolor, let parent deal with it */", "}", "else", "if", "(", "cd", ".", "getNChars", "(", ")", "==", "0", ")", "{", "/* parent empty, its arcs change color to subcolor */", "cd", ".", "sub", "=", "Constants", ".", "NOSUB", ";", "scd", "=", "colorDescs", ".", "get", "(", "sco", ")", ";", "assert", "scd", ".", "getNChars", "(", ")", ">", "0", ";", "assert", "scd", ".", "sub", "==", "sco", ";", "scd", ".", "sub", "=", "Constants", ".", "NOSUB", ";", "while", "(", "(", "a", "=", "cd", ".", "arcs", ")", "!=", "null", ")", "{", "assert", "a", ".", "co", "==", "co", ";", "cd", ".", "arcs", "=", "a", ".", "colorchain", ";", "a", ".", "setColor", "(", "sco", ")", ";", "a", ".", "colorchain", "=", "scd", ".", "arcs", ";", "scd", ".", "arcs", "=", "a", ";", "}", "freecolor", "(", "co", ")", ";", "}", "else", "{", "/* parent's arcs must gain parallel subcolor arcs */", "cd", ".", "sub", "=", "Constants", ".", "NOSUB", ";", "scd", "=", "colorDescs", ".", "get", "(", "sco", ")", ";", "assert", "scd", ".", "getNChars", "(", ")", ">", "0", ";", "assert", "scd", ".", "sub", "==", "sco", ";", "scd", ".", "sub", "=", "Constants", ".", "NOSUB", ";", "for", "(", "a", "=", "cd", ".", "arcs", ";", "a", "!=", "null", ";", "a", "=", "a", ".", "colorchain", ")", "{", "assert", "a", ".", "co", "==", "co", ";", "nfa", ".", "newarc", "(", "a", ".", "type", ",", "sco", ",", "a", ".", "from", ",", "a", ".", "to", ")", ";", "}", "}", "}", "}"], "docstring": "okcolors - promote subcolors to full colors", "docstring_tokens": ["okcolors", "-", "promote", "subcolors", "to", "full", "colors"]}
{"code": "newState.no = nstates++;", "comments": "a unique number.", "lines": 3, "repo": "basis-technology-corp/tcl-regex-java", "path": "src/main/java/com/basistech/tclre/Nfa.java", "func_name": "Nfa.newstate", "original_string": "State newstate(int flag) {\n        State newState = new State();\n        newState.no = nstates++; // a unique number.\n        if (states == null) {\n            states = newState;\n        }\n        if (slast != null) {\n            assert slast.next == null;\n            slast.next = newState;\n        }\n        newState.prev = slast;\n        slast = newState;\n        newState.flag = flag;\n        return newState;\n    }", "language": "java", "Allcodes": "State newstate(int flag) {\n        State newState = new State();\n        newState.no = nstates++; // a unique number.\n        if (states == null) {\n            states = newState;\n        }\n        if (slast != null) {\n            assert slast.next == null;\n            slast.next = newState;\n        }\n        newState.prev = slast;\n        slast = newState;\n        newState.flag = flag;\n        return newState;\n    }", "code_tokens": ["State", "newstate", "(", "int", "flag", ")", "{", "State", "newState", "=", "new", "State", "(", ")", ";", "newState", ".", "no", "=", "nstates", "++", ";", "// a unique number.", "if", "(", "states", "==", "null", ")", "{", "states", "=", "newState", ";", "}", "if", "(", "slast", "!=", "null", ")", "{", "assert", "slast", ".", "next", "==", "null", ";", "slast", ".", "next", "=", "newState", ";", "}", "newState", ".", "prev", "=", "slast", ";", "slast", "=", "newState", ";", "newState", ".", "flag", "=", "flag", ";", "return", "newState", ";", "}"], "docstring": "Factory method for new states.\n\n@return a new state wired into this Nfa.", "docstring_tokens": ["Factory", "method", "for", "new", "states", "."]}
{"code": "int matchByte = lz.getByte(0);", "comments": "lz.getByte(len, len)", "lines": 40, "repo": "eclipse/packagedrone", "path": "bundles/org.tukani.xz/src/org/tukaani/xz/lzma/LZMAEncoderNormal.java", "func_name": "LZMAEncoderNormal.calcLongRepPrices", "original_string": "private int calcLongRepPrices(int pos, int posState,\n                                  int avail, int anyRepPrice) {\n        int startLen = MATCH_LEN_MIN;\n        int lenLimit = Math.min(avail, niceLen);\n\n        for (int rep = 0; rep < REPS; ++rep) {\n            int len = lz.getMatchLen(opts[optCur].reps[rep], lenLimit);\n            if (len < MATCH_LEN_MIN)\n                continue;\n\n            while (optEnd < optCur + len)\n                opts[++optEnd].reset();\n\n            int longRepPrice = getLongRepPrice(anyRepPrice, rep,\n                                               opts[optCur].state, posState);\n\n            for (int i = len; i >= MATCH_LEN_MIN; --i) {\n                int price = longRepPrice\n                            + repLenEncoder.getPrice(i, posState);\n                if (price < opts[optCur + i].price)\n                    opts[optCur + i].set1(price, optCur, rep);\n            }\n\n            if (rep == 0)\n                startLen = len + 1;\n\n            int len2Limit = Math.min(niceLen, avail - len - 1);\n            int len2 = lz.getMatchLen(len + 1, opts[optCur].reps[rep],\n                                      len2Limit);\n\n            if (len2 >= MATCH_LEN_MIN) {\n                // Rep\n                int price = longRepPrice\n                            + repLenEncoder.getPrice(len, posState);\n                nextState.set(opts[optCur].state);\n                nextState.updateLongRep();\n\n                // Literal\n                int curByte = lz.getByte(len, 0);\n                int matchByte = lz.getByte(0); // lz.getByte(len, len)\n                int prevByte = lz.getByte(len, 1);\n                price += literalEncoder.getPrice(curByte, matchByte, prevByte,\n                                                 pos + len, nextState);\n                nextState.updateLiteral();\n\n                // Rep0\n                int nextPosState = (pos + len + 1) & posMask;\n                price += getLongRepAndLenPrice(0, len2,\n                                               nextState, nextPosState);\n\n                int i = optCur + len + 1 + len2;\n                while (optEnd < i)\n                    opts[++optEnd].reset();\n\n                if (price < opts[i].price)\n                    opts[i].set3(price, optCur, rep, len, 0);\n            }\n        }\n\n        return startLen;\n    }", "language": "java", "Allcodes": "private int calcLongRepPrices(int pos, int posState,\n                                  int avail, int anyRepPrice) {\n        int startLen = MATCH_LEN_MIN;\n        int lenLimit = Math.min(avail, niceLen);\n\n        for (int rep = 0; rep < REPS; ++rep) {\n            int len = lz.getMatchLen(opts[optCur].reps[rep], lenLimit);\n            if (len < MATCH_LEN_MIN)\n                continue;\n\n            while (optEnd < optCur + len)\n                opts[++optEnd].reset();\n\n            int longRepPrice = getLongRepPrice(anyRepPrice, rep,\n                                               opts[optCur].state, posState);\n\n            for (int i = len; i >= MATCH_LEN_MIN; --i) {\n                int price = longRepPrice\n                            + repLenEncoder.getPrice(i, posState);\n                if (price < opts[optCur + i].price)\n                    opts[optCur + i].set1(price, optCur, rep);\n            }\n\n            if (rep == 0)\n                startLen = len + 1;\n\n            int len2Limit = Math.min(niceLen, avail - len - 1);\n            int len2 = lz.getMatchLen(len + 1, opts[optCur].reps[rep],\n                                      len2Limit);\n\n            if (len2 >= MATCH_LEN_MIN) {\n                // Rep\n                int price = longRepPrice\n                            + repLenEncoder.getPrice(len, posState);\n                nextState.set(opts[optCur].state);\n                nextState.updateLongRep();\n\n                // Literal\n                int curByte = lz.getByte(len, 0);\n                int matchByte = lz.getByte(0); // lz.getByte(len, len)\n                int prevByte = lz.getByte(len, 1);\n                price += literalEncoder.getPrice(curByte, matchByte, prevByte,\n                                                 pos + len, nextState);\n                nextState.updateLiteral();\n\n                // Rep0\n                int nextPosState = (pos + len + 1) & posMask;\n                price += getLongRepAndLenPrice(0, len2,\n                                               nextState, nextPosState);\n\n                int i = optCur + len + 1 + len2;\n                while (optEnd < i)\n                    opts[++optEnd].reset();\n\n                if (price < opts[i].price)\n                    opts[i].set3(price, optCur, rep, len, 0);\n            }\n        }\n\n        return startLen;\n    }", "code_tokens": ["private", "int", "calcLongRepPrices", "(", "int", "pos", ",", "int", "posState", ",", "int", "avail", ",", "int", "anyRepPrice", ")", "{", "int", "startLen", "=", "MATCH_LEN_MIN", ";", "int", "lenLimit", "=", "Math", ".", "min", "(", "avail", ",", "niceLen", ")", ";", "for", "(", "int", "rep", "=", "0", ";", "rep", "<", "REPS", ";", "++", "rep", ")", "{", "int", "len", "=", "lz", ".", "getMatchLen", "(", "opts", "[", "optCur", "]", ".", "reps", "[", "rep", "]", ",", "lenLimit", ")", ";", "if", "(", "len", "<", "MATCH_LEN_MIN", ")", "continue", ";", "while", "(", "optEnd", "<", "optCur", "+", "len", ")", "opts", "[", "++", "optEnd", "]", ".", "reset", "(", ")", ";", "int", "longRepPrice", "=", "getLongRepPrice", "(", "anyRepPrice", ",", "rep", ",", "opts", "[", "optCur", "]", ".", "state", ",", "posState", ")", ";", "for", "(", "int", "i", "=", "len", ";", "i", ">=", "MATCH_LEN_MIN", ";", "--", "i", ")", "{", "int", "price", "=", "longRepPrice", "+", "repLenEncoder", ".", "getPrice", "(", "i", ",", "posState", ")", ";", "if", "(", "price", "<", "opts", "[", "optCur", "+", "i", "]", ".", "price", ")", "opts", "[", "optCur", "+", "i", "]", ".", "set1", "(", "price", ",", "optCur", ",", "rep", ")", ";", "}", "if", "(", "rep", "==", "0", ")", "startLen", "=", "len", "+", "1", ";", "int", "len2Limit", "=", "Math", ".", "min", "(", "niceLen", ",", "avail", "-", "len", "-", "1", ")", ";", "int", "len2", "=", "lz", ".", "getMatchLen", "(", "len", "+", "1", ",", "opts", "[", "optCur", "]", ".", "reps", "[", "rep", "]", ",", "len2Limit", ")", ";", "if", "(", "len2", ">=", "MATCH_LEN_MIN", ")", "{", "// Rep", "int", "price", "=", "longRepPrice", "+", "repLenEncoder", ".", "getPrice", "(", "len", ",", "posState", ")", ";", "nextState", ".", "set", "(", "opts", "[", "optCur", "]", ".", "state", ")", ";", "nextState", ".", "updateLongRep", "(", ")", ";", "// Literal", "int", "curByte", "=", "lz", ".", "getByte", "(", "len", ",", "0", ")", ";", "int", "matchByte", "=", "lz", ".", "getByte", "(", "0", ")", ";", "// lz.getByte(len, len)", "int", "prevByte", "=", "lz", ".", "getByte", "(", "len", ",", "1", ")", ";", "price", "+=", "literalEncoder", ".", "getPrice", "(", "curByte", ",", "matchByte", ",", "prevByte", ",", "pos", "+", "len", ",", "nextState", ")", ";", "nextState", ".", "updateLiteral", "(", ")", ";", "// Rep0", "int", "nextPosState", "=", "(", "pos", "+", "len", "+", "1", ")", "&", "posMask", ";", "price", "+=", "getLongRepAndLenPrice", "(", "0", ",", "len2", ",", "nextState", ",", "nextPosState", ")", ";", "int", "i", "=", "optCur", "+", "len", "+", "1", "+", "len2", ";", "while", "(", "optEnd", "<", "i", ")", "opts", "[", "++", "optEnd", "]", ".", "reset", "(", ")", ";", "if", "(", "price", "<", "opts", "[", "i", "]", ".", "price", ")", "opts", "[", "i", "]", ".", "set3", "(", "price", ",", "optCur", ",", "rep", ",", "len", ",", "0", ")", ";", "}", "}", "return", "startLen", ";", "}"], "docstring": "Calculates prices of long rep and long rep + literal + rep0.", "docstring_tokens": ["Calculates", "prices", "of", "long", "rep", "and", "long", "rep", "+", "literal", "+", "rep0", "."]}
{"code": "int prev = 'x';", "comments": "Doesn't matter", "lines": 5, "repo": "eclipse/packagedrone", "path": "bundles/org.apache.jasper.glassfish/src/org/apache/jasper/compiler/JspReader.java", "func_name": "JspReader.skipUntilIgnoreEsc", "original_string": "Mark skipUntilIgnoreEsc(String limit) throws JasperException {\n\tMark ret = null;\n\tint limlen = limit.length();\n\tint ch;\n\tint prev = 'x';\t// Doesn't matter\n\t\n    skip:\n\tfor (ret = mark(), ch = nextChar() ; ch != -1 ;\n\t         ret = mark(), prev = ch, ch = nextChar()) {\t    \n\t    if (ch == '\\\\' && prev == '\\\\') {\n\t\tch = 0;\t\t// Double \\ is not an escape char anymore\n\t    }\n\t    else if (ch == limit.charAt(0) && prev != '\\\\') {\n\t\tfor (int i = 1 ; i < limlen ; i++) {\n\t\t    if (peekChar() == limit.charAt(i))\n\t\t\tnextChar();\n\t\t    else\n\t\t\tcontinue skip;\n\t\t}\n\t\treturn ret;\n\t    }\n\t}\n\treturn null;\n    }", "language": "java", "Allcodes": "Mark skipUntilIgnoreEsc(String limit) throws JasperException {\n\tMark ret = null;\n\tint limlen = limit.length();\n\tint ch;\n\tint prev = 'x';\t// Doesn't matter\n\t\n    skip:\n\tfor (ret = mark(), ch = nextChar() ; ch != -1 ;\n\t         ret = mark(), prev = ch, ch = nextChar()) {\t    \n\t    if (ch == '\\\\' && prev == '\\\\') {\n\t\tch = 0;\t\t// Double \\ is not an escape char anymore\n\t    }\n\t    else if (ch == limit.charAt(0) && prev != '\\\\') {\n\t\tfor (int i = 1 ; i < limlen ; i++) {\n\t\t    if (peekChar() == limit.charAt(i))\n\t\t\tnextChar();\n\t\t    else\n\t\t\tcontinue skip;\n\t\t}\n\t\treturn ret;\n\t    }\n\t}\n\treturn null;\n    }", "code_tokens": ["Mark", "skipUntilIgnoreEsc", "(", "String", "limit", ")", "throws", "JasperException", "{", "Mark", "ret", "=", "null", ";", "int", "limlen", "=", "limit", ".", "length", "(", ")", ";", "int", "ch", ";", "int", "prev", "=", "'", "'", ";", "// Doesn't matter", "skip", ":", "for", "(", "ret", "=", "mark", "(", ")", ",", "ch", "=", "nextChar", "(", ")", ";", "ch", "!=", "-", "1", ";", "ret", "=", "mark", "(", ")", ",", "prev", "=", "ch", ",", "ch", "=", "nextChar", "(", ")", ")", "{", "if", "(", "ch", "==", "'", "'", "&&", "prev", "==", "'", "'", ")", "{", "ch", "=", "0", ";", "// Double \\ is not an escape char anymore", "}", "else", "if", "(", "ch", "==", "limit", ".", "charAt", "(", "0", ")", "&&", "prev", "!=", "'", "'", ")", "{", "for", "(", "int", "i", "=", "1", ";", "i", "<", "limlen", ";", "i", "++", ")", "{", "if", "(", "peekChar", "(", ")", "==", "limit", ".", "charAt", "(", "i", ")", ")", "nextChar", "(", ")", ";", "else", "continue", "skip", ";", "}", "return", "ret", ";", "}", "}", "return", "null", ";", "}"], "docstring": "Skip until the given string is matched in the stream, but ignoring\nchars initially escaped by a '\\'.\nWhen returned, the context is positioned past the end of the match.\n\n@param s The String to match.\n@return A non-null <code>Mark</code> instance (positioned immediately\nbefore the search string) if found, <strong>null</strong>\notherwise.", "docstring_tokens": ["Skip", "until", "the", "given", "string", "is", "matched", "in", "the", "stream", "but", "ignoring", "chars", "initially", "escaped", "by", "a", "\\", ".", "When", "returned", "the", "context", "is", "positioned", "past", "the", "end", "of", "the", "match", "."]}
{"code": "ch = 0;", "comments": "Double \\ is not an escape char anymore", "lines": 11, "repo": "eclipse/packagedrone", "path": "bundles/org.apache.jasper.glassfish/src/org/apache/jasper/compiler/JspReader.java", "func_name": "JspReader.skipUntilIgnoreEsc", "original_string": "Mark skipUntilIgnoreEsc(String limit) throws JasperException {\n\tMark ret = null;\n\tint limlen = limit.length();\n\tint ch;\n\tint prev = 'x';\t// Doesn't matter\n\t\n    skip:\n\tfor (ret = mark(), ch = nextChar() ; ch != -1 ;\n\t         ret = mark(), prev = ch, ch = nextChar()) {\t    \n\t    if (ch == '\\\\' && prev == '\\\\') {\n\t\tch = 0;\t\t// Double \\ is not an escape char anymore\n\t    }\n\t    else if (ch == limit.charAt(0) && prev != '\\\\') {\n\t\tfor (int i = 1 ; i < limlen ; i++) {\n\t\t    if (peekChar() == limit.charAt(i))\n\t\t\tnextChar();\n\t\t    else\n\t\t\tcontinue skip;\n\t\t}\n\t\treturn ret;\n\t    }\n\t}\n\treturn null;\n    }", "language": "java", "Allcodes": "Mark skipUntilIgnoreEsc(String limit) throws JasperException {\n\tMark ret = null;\n\tint limlen = limit.length();\n\tint ch;\n\tint prev = 'x';\t// Doesn't matter\n\t\n    skip:\n\tfor (ret = mark(), ch = nextChar() ; ch != -1 ;\n\t         ret = mark(), prev = ch, ch = nextChar()) {\t    \n\t    if (ch == '\\\\' && prev == '\\\\') {\n\t\tch = 0;\t\t// Double \\ is not an escape char anymore\n\t    }\n\t    else if (ch == limit.charAt(0) && prev != '\\\\') {\n\t\tfor (int i = 1 ; i < limlen ; i++) {\n\t\t    if (peekChar() == limit.charAt(i))\n\t\t\tnextChar();\n\t\t    else\n\t\t\tcontinue skip;\n\t\t}\n\t\treturn ret;\n\t    }\n\t}\n\treturn null;\n    }", "code_tokens": ["Mark", "skipUntilIgnoreEsc", "(", "String", "limit", ")", "throws", "JasperException", "{", "Mark", "ret", "=", "null", ";", "int", "limlen", "=", "limit", ".", "length", "(", ")", ";", "int", "ch", ";", "int", "prev", "=", "'", "'", ";", "// Doesn't matter", "skip", ":", "for", "(", "ret", "=", "mark", "(", ")", ",", "ch", "=", "nextChar", "(", ")", ";", "ch", "!=", "-", "1", ";", "ret", "=", "mark", "(", ")", ",", "prev", "=", "ch", ",", "ch", "=", "nextChar", "(", ")", ")", "{", "if", "(", "ch", "==", "'", "'", "&&", "prev", "==", "'", "'", ")", "{", "ch", "=", "0", ";", "// Double \\ is not an escape char anymore", "}", "else", "if", "(", "ch", "==", "limit", ".", "charAt", "(", "0", ")", "&&", "prev", "!=", "'", "'", ")", "{", "for", "(", "int", "i", "=", "1", ";", "i", "<", "limlen", ";", "i", "++", ")", "{", "if", "(", "peekChar", "(", ")", "==", "limit", ".", "charAt", "(", "i", ")", ")", "nextChar", "(", ")", ";", "else", "continue", "skip", ";", "}", "return", "ret", ";", "}", "}", "return", "null", ";", "}"], "docstring": "Skip until the given string is matched in the stream, but ignoring\nchars initially escaped by a '\\'.\nWhen returned, the context is positioned past the end of the match.\n\n@param s The String to match.\n@return A non-null <code>Mark</code> instance (positioned immediately\nbefore the search string) if found, <strong>null</strong>\notherwise.", "docstring_tokens": ["Skip", "until", "the", "given", "string", "is", "matched", "in", "the", "stream", "but", "ignoring", "chars", "initially", "escaped", "by", "a", "\\", ".", "When", "returned", "the", "context", "is", "positioned", "past", "the", "end", "of", "the", "match", "."]}
{"code": "zos.finish ();", "comments": "don't close stream, since there might be other channels following", "lines": 24, "repo": "eclipse/packagedrone", "path": "bundles/org.eclipse.packagedrone.repo.channel.impl/src/org/eclipse/packagedrone/repo/channel/impl/transfer/TransferServiceImpl.java", "func_name": "TransferServiceImpl.exportChannel", "original_string": "private void exportChannel ( final By by, final OutputStream stream ) throws IOException\n    {\n        final ZipOutputStream zos = new ZipOutputStream ( stream );\n\n        initExportFile ( zos );\n\n        this.channelService.accessRun ( by, ReadableChannel.class, channel -> {\n\n            putDataEntry ( zos, \"names\", makeNames ( channel.getId () ) );\n            putDataEntry ( zos, \"description\", channel.getId ().getDescription () );\n            putDirEntry ( zos, \"artifacts\" );\n            putProperties ( zos, \"properties.xml\", channel.getContext ().getProvidedMetaData () );\n            putAspects ( zos, channel.getContext ().getAspectStates ().keySet () );\n\n            // the first run receives all artifacts and filters for the root elements\n\n            putArtifacts ( zos, \"artifacts/\", channel, channel.getArtifacts (), true );\n        } );\n\n        this.channelService.accessRun ( by, TriggeredChannel.class, channel -> {\n            putTriggers ( zos, channel );\n        } );\n\n        zos.finish (); // don't close stream, since there might be other channels following\n    }", "language": "java", "Allcodes": "private void exportChannel ( final By by, final OutputStream stream ) throws IOException\n    {\n        final ZipOutputStream zos = new ZipOutputStream ( stream );\n\n        initExportFile ( zos );\n\n        this.channelService.accessRun ( by, ReadableChannel.class, channel -> {\n\n            putDataEntry ( zos, \"names\", makeNames ( channel.getId () ) );\n            putDataEntry ( zos, \"description\", channel.getId ().getDescription () );\n            putDirEntry ( zos, \"artifacts\" );\n            putProperties ( zos, \"properties.xml\", channel.getContext ().getProvidedMetaData () );\n            putAspects ( zos, channel.getContext ().getAspectStates ().keySet () );\n\n            // the first run receives all artifacts and filters for the root elements\n\n            putArtifacts ( zos, \"artifacts/\", channel, channel.getArtifacts (), true );\n        } );\n\n        this.channelService.accessRun ( by, TriggeredChannel.class, channel -> {\n            putTriggers ( zos, channel );\n        } );\n\n        zos.finish (); // don't close stream, since there might be other channels following\n    }", "code_tokens": ["private", "void", "exportChannel", "(", "final", "By", "by", ",", "final", "OutputStream", "stream", ")", "throws", "IOException", "{", "final", "ZipOutputStream", "zos", "=", "new", "ZipOutputStream", "(", "stream", ")", ";", "initExportFile", "(", "zos", ")", ";", "this", ".", "channelService", ".", "accessRun", "(", "by", ",", "ReadableChannel", ".", "class", ",", "channel", "->", "{", "putDataEntry", "(", "zos", ",", "\"names\"", ",", "makeNames", "(", "channel", ".", "getId", "(", ")", ")", ")", ";", "putDataEntry", "(", "zos", ",", "\"description\"", ",", "channel", ".", "getId", "(", ")", ".", "getDescription", "(", ")", ")", ";", "putDirEntry", "(", "zos", ",", "\"artifacts\"", ")", ";", "putProperties", "(", "zos", ",", "\"properties.xml\"", ",", "channel", ".", "getContext", "(", ")", ".", "getProvidedMetaData", "(", ")", ")", ";", "putAspects", "(", "zos", ",", "channel", ".", "getContext", "(", ")", ".", "getAspectStates", "(", ")", ".", "keySet", "(", ")", ")", ";", "// the first run receives all artifacts and filters for the root elements", "putArtifacts", "(", "zos", ",", "\"artifacts/\"", ",", "channel", ",", "channel", ".", "getArtifacts", "(", ")", ",", "true", ")", ";", "}", ")", ";", "this", ".", "channelService", ".", "accessRun", "(", "by", ",", "TriggeredChannel", ".", "class", ",", "channel", "->", "{", "putTriggers", "(", "zos", ",", "channel", ")", ";", "}", ")", ";", "zos", ".", "finish", "(", ")", ";", "// don't close stream, since there might be other channels following", "}"], "docstring": "Export the content of a channel\n\n@param by\nthe channel to export\n@param stream\nthe stream to write the export file to\n@throws IOException\nif the export cannot be performed", "docstring_tokens": ["Export", "the", "content", "of", "a", "channel"]}
{"code": "cir.setSeriesStroke(seriesIndex, stroke);", "comments": "series line", "lines": 11, "repo": "tiefaces/TieFaces", "path": "src/org/tiefaces/components/websheet/chart/ChartHelper.java", "func_name": "ChartHelper.setSeriesStyle", "original_string": "public final void setSeriesStyle(final JFreeChart chart,\r\n\t\t\tfinal int seriesIndex, final String style) {\r\n\t\tif (chart != null && style != null) {\r\n\t\t\tBasicStroke stroke = ChartUtility.toStroke(style);\r\n\r\n\t\t\tPlot plot = chart.getPlot();\r\n\t\t\tif (plot instanceof CategoryPlot) {\r\n\t\t\t\tCategoryPlot categoryPlot = chart.getCategoryPlot();\r\n\t\t\t\tCategoryItemRenderer cir = categoryPlot.getRenderer();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcir.setSeriesStroke(seriesIndex, stroke); // series line\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// style\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tLOG.log(Level.SEVERE,\r\n\t\t\t\t\t\t\t\"Error setting style '\" + style\r\n\t\t\t\t\t\t\t\t\t+ \"' for series '\"\r\n\t\t\t\t\t\t\t\t\t+ Integer.toString(seriesIndex)\r\n\t\t\t\t\t\t\t\t\t+ \"' of chart '\" + chart.toString()\r\n\t\t\t\t\t\t\t\t\t+ \"': \" + e.getLocalizedMessage(),\r\n\t\t\t\t\t\t\te);\r\n\t\t\t\t}\r\n\t\t\t} else if (plot instanceof XYPlot) {\r\n\t\t\t\tXYPlot xyPlot = chart.getXYPlot();\r\n\t\t\t\tXYItemRenderer xyir = xyPlot.getRenderer();\r\n\t\t\t\ttry {\r\n\t\t\t\t\txyir.setSeriesStroke(seriesIndex, stroke); // series line\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// style\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tLOG.log(Level.SEVERE,\r\n\t\t\t\t\t\t\t\"Error setting style '\" + style\r\n\t\t\t\t\t\t\t\t\t+ \"' for series '\"\r\n\t\t\t\t\t\t\t\t\t+ Integer.toString(seriesIndex)\r\n\t\t\t\t\t\t\t\t\t+ \"' of chart '\" + chart.toString()\r\n\t\t\t\t\t\t\t\t\t+ \"': \" + e.getLocalizedMessage(),\r\n\t\t\t\t\t\t\te);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tLOG.log(Level.FINE, \"setSeriesColor() unsupported plot: {}\",\r\n\t\t\t\t\t\tplot.toString());\r\n\t\t\t}\r\n\t\t}\r\n\t}", "language": "java", "Allcodes": "public final void setSeriesStyle(final JFreeChart chart,\r\n\t\t\tfinal int seriesIndex, final String style) {\r\n\t\tif (chart != null && style != null) {\r\n\t\t\tBasicStroke stroke = ChartUtility.toStroke(style);\r\n\r\n\t\t\tPlot plot = chart.getPlot();\r\n\t\t\tif (plot instanceof CategoryPlot) {\r\n\t\t\t\tCategoryPlot categoryPlot = chart.getCategoryPlot();\r\n\t\t\t\tCategoryItemRenderer cir = categoryPlot.getRenderer();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcir.setSeriesStroke(seriesIndex, stroke); // series line\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// style\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tLOG.log(Level.SEVERE,\r\n\t\t\t\t\t\t\t\"Error setting style '\" + style\r\n\t\t\t\t\t\t\t\t\t+ \"' for series '\"\r\n\t\t\t\t\t\t\t\t\t+ Integer.toString(seriesIndex)\r\n\t\t\t\t\t\t\t\t\t+ \"' of chart '\" + chart.toString()\r\n\t\t\t\t\t\t\t\t\t+ \"': \" + e.getLocalizedMessage(),\r\n\t\t\t\t\t\t\te);\r\n\t\t\t\t}\r\n\t\t\t} else if (plot instanceof XYPlot) {\r\n\t\t\t\tXYPlot xyPlot = chart.getXYPlot();\r\n\t\t\t\tXYItemRenderer xyir = xyPlot.getRenderer();\r\n\t\t\t\ttry {\r\n\t\t\t\t\txyir.setSeriesStroke(seriesIndex, stroke); // series line\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// style\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tLOG.log(Level.SEVERE,\r\n\t\t\t\t\t\t\t\"Error setting style '\" + style\r\n\t\t\t\t\t\t\t\t\t+ \"' for series '\"\r\n\t\t\t\t\t\t\t\t\t+ Integer.toString(seriesIndex)\r\n\t\t\t\t\t\t\t\t\t+ \"' of chart '\" + chart.toString()\r\n\t\t\t\t\t\t\t\t\t+ \"': \" + e.getLocalizedMessage(),\r\n\t\t\t\t\t\t\te);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tLOG.log(Level.FINE, \"setSeriesColor() unsupported plot: {}\",\r\n\t\t\t\t\t\tplot.toString());\r\n\t\t\t}\r\n\t\t}\r\n\t}", "code_tokens": ["public", "final", "void", "setSeriesStyle", "(", "final", "JFreeChart", "chart", ",", "final", "int", "seriesIndex", ",", "final", "String", "style", ")", "{", "if", "(", "chart", "!=", "null", "&&", "style", "!=", "null", ")", "{", "BasicStroke", "stroke", "=", "ChartUtility", ".", "toStroke", "(", "style", ")", ";", "Plot", "plot", "=", "chart", ".", "getPlot", "(", ")", ";", "if", "(", "plot", "instanceof", "CategoryPlot", ")", "{", "CategoryPlot", "categoryPlot", "=", "chart", ".", "getCategoryPlot", "(", ")", ";", "CategoryItemRenderer", "cir", "=", "categoryPlot", ".", "getRenderer", "(", ")", ";", "try", "{", "cir", ".", "setSeriesStroke", "(", "seriesIndex", ",", "stroke", ")", ";", "// series line\r", "// style\r", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "\"Error setting style '\"", "+", "style", "+", "\"' for series '\"", "+", "Integer", ".", "toString", "(", "seriesIndex", ")", "+", "\"' of chart '\"", "+", "chart", ".", "toString", "(", ")", "+", "\"': \"", "+", "e", ".", "getLocalizedMessage", "(", ")", ",", "e", ")", ";", "}", "}", "else", "if", "(", "plot", "instanceof", "XYPlot", ")", "{", "XYPlot", "xyPlot", "=", "chart", ".", "getXYPlot", "(", ")", ";", "XYItemRenderer", "xyir", "=", "xyPlot", ".", "getRenderer", "(", ")", ";", "try", "{", "xyir", ".", "setSeriesStroke", "(", "seriesIndex", ",", "stroke", ")", ";", "// series line\r", "// style\r", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "\"Error setting style '\"", "+", "style", "+", "\"' for series '\"", "+", "Integer", ".", "toString", "(", "seriesIndex", ")", "+", "\"' of chart '\"", "+", "chart", ".", "toString", "(", ")", "+", "\"': \"", "+", "e", ".", "getLocalizedMessage", "(", ")", ",", "e", ")", ";", "}", "}", "else", "{", "LOG", ".", "log", "(", "Level", ".", "FINE", ",", "\"setSeriesColor() unsupported plot: {}\"", ",", "plot", ".", "toString", "(", ")", ")", ";", "}", "}", "}"], "docstring": "Set color of series.\n\n@param chart\nJFreeChart.\n@param seriesIndex\nIndex of series to set color of (0 = first series)\n@param style\nOne of STYLE_xxx.", "docstring_tokens": ["Set", "color", "of", "series", "."]}
{"code": "return -1;", "comments": "not found", "lines": 9, "repo": "tiefaces/TieFaces", "path": "src/org/tiefaces/components/websheet/utility/ParserUtility.java", "func_name": "ParserUtility.findFirstNonCellNamePosition", "original_string": "public static int findFirstNonCellNamePosition(String input, int startPosition) {\r\n\t\tchar c;\r\n\t    for (int i = startPosition; i < input.length(); i++) {\r\n\t    \tc = input.charAt(i);\r\n\t        if ( c!='$' && !Character.isLetterOrDigit(c)) {\r\n\t            return i;\r\n\t        }\r\n\t    }\r\n\t    return -1; // not found\r\n\t}", "language": "java", "Allcodes": "public static int findFirstNonCellNamePosition(String input, int startPosition) {\r\n\t\tchar c;\r\n\t    for (int i = startPosition; i < input.length(); i++) {\r\n\t    \tc = input.charAt(i);\r\n\t        if ( c!='$' && !Character.isLetterOrDigit(c)) {\r\n\t            return i;\r\n\t        }\r\n\t    }\r\n\t    return -1; // not found\r\n\t}", "code_tokens": ["public", "static", "int", "findFirstNonCellNamePosition", "(", "String", "input", ",", "int", "startPosition", ")", "{", "char", "c", ";", "for", "(", "int", "i", "=", "startPosition", ";", "i", "<", "input", ".", "length", "(", ")", ";", "i", "++", ")", "{", "c", "=", "input", ".", "charAt", "(", "i", ")", ";", "if", "(", "c", "!=", "'", "'", "&&", "!", "Character", ".", "isLetterOrDigit", "(", "c", ")", ")", "{", "return", "i", ";", "}", "}", "return", "-", "1", ";", "// not found\r", "}"], "docstring": "find first non letterordigit position from string.\n\n@param input input string\n@param startPosition startposition\n@return first position", "docstring_tokens": ["find", "first", "non", "letterordigit", "position", "from", "string", "."]}
{"code": "columnstyle += CellStyleUtility.getCellStyle(wb, cell, \"\") + CellStyleUtility.getCellFontStyle(wb, cell);", "comments": "+", "lines": 6, "repo": "tiefaces/TieFaces", "path": "src/org/tiefaces/components/websheet/service/WebSheetLoader.java", "func_name": "WebSheetLoader.getHeaderColumnStyle", "original_string": "private String getHeaderColumnStyle(final Workbook wb, final Cell cell, final double colWidth,\r\n\t\t\tfinal double totalWidth) {\r\n\r\n\t\tString columnstyle = \"\";\r\n\t\tif (cell != null) {\r\n\t\t\tcolumnstyle += CellStyleUtility.getCellStyle(wb, cell, \"\") + CellStyleUtility.getCellFontStyle(wb, cell); // +\r\n\t\t}\r\n\r\n\t\tcolumnstyle = columnstyle + getWidthStyle(colWidth, totalWidth);\r\n\t\treturn columnstyle;\r\n\t}", "language": "java", "Allcodes": "private String getHeaderColumnStyle(final Workbook wb, final Cell cell, final double colWidth,\r\n\t\t\tfinal double totalWidth) {\r\n\r\n\t\tString columnstyle = \"\";\r\n\t\tif (cell != null) {\r\n\t\t\tcolumnstyle += CellStyleUtility.getCellStyle(wb, cell, \"\") + CellStyleUtility.getCellFontStyle(wb, cell); // +\r\n\t\t}\r\n\r\n\t\tcolumnstyle = columnstyle + getWidthStyle(colWidth, totalWidth);\r\n\t\treturn columnstyle;\r\n\t}", "code_tokens": ["private", "String", "getHeaderColumnStyle", "(", "final", "Workbook", "wb", ",", "final", "Cell", "cell", ",", "final", "double", "colWidth", ",", "final", "double", "totalWidth", ")", "{", "String", "columnstyle", "=", "\"\"", ";", "if", "(", "cell", "!=", "null", ")", "{", "columnstyle", "+=", "CellStyleUtility", ".", "getCellStyle", "(", "wb", ",", "cell", ",", "\"\"", ")", "+", "CellStyleUtility", ".", "getCellFontStyle", "(", "wb", ",", "cell", ")", ";", "// +\r", "}", "columnstyle", "=", "columnstyle", "+", "getWidthStyle", "(", "colWidth", ",", "totalWidth", ")", ";", "return", "columnstyle", ";", "}"], "docstring": "Gets the header column style.\n\n@param wb\nthe wb\n@param cell\nthe cell\n@param colWidth\nthe col width\n@param totalWidth\nthe total width\n@return the header column style", "docstring_tokens": ["Gets", "the", "header", "column", "style", "."]}
{"code": "final InputStream localIn = in;", "comments": "'in' could be invalidated by close()", "lines": 3, "repo": "stanfy/enroscar", "path": "io/src/main/java/com/stanfy/enroscar/io/PoolableBufferedInputStream.java", "func_name": "PoolableBufferedInputStream.available", "original_string": "@Override\r\n  public synchronized int available() throws IOException {\r\n    final InputStream localIn = in; // 'in' could be invalidated by close()\r\n    if (buf == null || localIn == null) { throw new IOException(\"Stream is closed\"); }\r\n    return count - pos + localIn.available();\r\n  }", "language": "java", "Allcodes": "@Override\r\n  public synchronized int available() throws IOException {\r\n    final InputStream localIn = in; // 'in' could be invalidated by close()\r\n    if (buf == null || localIn == null) { throw new IOException(\"Stream is closed\"); }\r\n    return count - pos + localIn.available();\r\n  }", "code_tokens": ["@", "Override", "public", "synchronized", "int", "available", "(", ")", "throws", "IOException", "{", "final", "InputStream", "localIn", "=", "in", ";", "// 'in' could be invalidated by close()\r", "if", "(", "buf", "==", "null", "||", "localIn", "==", "null", ")", "{", "throw", "new", "IOException", "(", "\"Stream is closed\"", ")", ";", "}", "return", "count", "-", "pos", "+", "localIn", ".", "available", "(", ")", ";", "}"], "docstring": "Returns the number of bytes that are available before this stream will\nblock. This method returns the number of bytes available in the buffer\nplus those available in the source stream.\n\n@return the number of bytes available before blocking.\n@throws IOException\nif this stream is closed.", "docstring_tokens": ["Returns", "the", "number", "of", "bytes", "that", "are", "available", "before", "this", "stream", "will", "block", ".", "This", "method", "returns", "the", "number", "of", "bytes", "available", "in", "the", "buffer", "plus", "those", "available", "in", "the", "source", "stream", "."]}
{"code": "bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);", "comments": "high quality", "lines": 5, "repo": "stanfy/enroscar", "path": "ui/src/main/java/com/stanfy/enroscar/views/decorator/BufferBitmapDecorator.java", "func_name": "BufferBitmapDecorator.reset", "original_string": "protected void reset(final int width, final int height) {\n    Bitmap bitmap = this.bitmap;\n    // recycle old buffer\n    if (bitmap != null) { bitmap.recycle(); }\n    bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); // high quality\n    this.bitmap = bitmap;\n    this.bitmapCanvas = new Canvas(bitmap);\n  }", "language": "java", "Allcodes": "protected void reset(final int width, final int height) {\n    Bitmap bitmap = this.bitmap;\n    // recycle old buffer\n    if (bitmap != null) { bitmap.recycle(); }\n    bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); // high quality\n    this.bitmap = bitmap;\n    this.bitmapCanvas = new Canvas(bitmap);\n  }", "code_tokens": ["protected", "void", "reset", "(", "final", "int", "width", ",", "final", "int", "height", ")", "{", "Bitmap", "bitmap", "=", "this", ".", "bitmap", ";", "// recycle old buffer", "if", "(", "bitmap", "!=", "null", ")", "{", "bitmap", ".", "recycle", "(", ")", ";", "}", "bitmap", "=", "Bitmap", ".", "createBitmap", "(", "width", ",", "height", ",", "Bitmap", ".", "Config", ".", "ARGB_8888", ")", ";", "// high quality", "this", ".", "bitmap", "=", "bitmap", ";", "this", ".", "bitmapCanvas", "=", "new", "Canvas", "(", "bitmap", ")", ";", "}"], "docstring": "Prepare for new width and hight.\n@param width new width\n@param height new height", "docstring_tokens": ["Prepare", "for", "new", "width", "and", "hight", "."]}
{"code": "setLevelSync(level);", "comments": "seems redundant, but we do this to save to SharedPrefs now that we have Context", "lines": 22, "repo": "ibm-bluemix-mobile-services/bms-clientsdk-android-analytics", "path": "lib/src/main/java/com/ibm/mobilefirstplatform/clientsdk/android/logger/api/LogPersister.java", "func_name": "LogPersister.setContext", "original_string": "static public void setContext(final Context context) {\n        // once setContext is called, we can set up the uncaught exception handler since\n        // it will force logging to the file\n        if (null == LogPersister.context) {\n\n            // set a custom JUL Handler so we can capture third-party and internal java.util.logging.Logger API calls\n            LogManager.getLogManager().getLogger(\"\").addHandler(julHandler);\n            java.util.logging.Logger.getLogger(\"\").setLevel(Level.ALL);\n\n            LogPersister.context = context;\n\n            // now that we have a context, let's set the fileLoggerInstance properly unless it was already set by tests\n            if (fileLoggerInstance == null || fileLoggerInstance instanceof FileLogger) {\n                FileLogger.setContext(context);\n                fileLoggerInstance = FileLogger.getInstance();\n            }\n\n            SharedPreferences prefs = LogPersister.context.getSharedPreferences (SHARED_PREF_KEY, Context.MODE_PRIVATE);\n\n            // level\n            if (null != level) {  // someone called setLevel method before setContext\n                setLevelSync(level);  // seems redundant, but we do this to save to SharedPrefs now that we have Context\n            } else {  // set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet\n                setLevelSync(Logger.LEVEL.fromString(prefs.getString(SHARED_PREF_KEY_level, getLevelDefault().toString())));\n            }\n\n            // logFileMaxSize\n            if (null != logFileMaxSize) {  // someone called setMaxStoreSize method before setContext\n                setMaxLogStoreSize(logFileMaxSize);  // seems redundant, but we do this to save to SharedPrefs now that we have Context\n            } else {  // set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet\n                setMaxLogStoreSize(prefs.getInt(SHARED_PREF_KEY_logFileMaxSize, DEFAULT_logFileMaxSize));\n            }\n\n            // capture\n            if (null != capture) {  // someone called setCapture method before setContext\n                setCaptureSync(capture);  // seems redundant, but we do this to save to SharedPrefs now that we have Context\n            } else {  // set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet\n                setCaptureSync(prefs.getBoolean (SHARED_PREF_KEY_logPersistence, DEFAULT_capture));\n            }\n\n            uncaughtExceptionHandler = new UncaughtExceptionHandler ();\n            Thread.setDefaultUncaughtExceptionHandler (uncaughtExceptionHandler);\n        }\n    }", "language": "java", "Allcodes": "static public void setContext(final Context context) {\n        // once setContext is called, we can set up the uncaught exception handler since\n        // it will force logging to the file\n        if (null == LogPersister.context) {\n\n            // set a custom JUL Handler so we can capture third-party and internal java.util.logging.Logger API calls\n            LogManager.getLogManager().getLogger(\"\").addHandler(julHandler);\n            java.util.logging.Logger.getLogger(\"\").setLevel(Level.ALL);\n\n            LogPersister.context = context;\n\n            // now that we have a context, let's set the fileLoggerInstance properly unless it was already set by tests\n            if (fileLoggerInstance == null || fileLoggerInstance instanceof FileLogger) {\n                FileLogger.setContext(context);\n                fileLoggerInstance = FileLogger.getInstance();\n            }\n\n            SharedPreferences prefs = LogPersister.context.getSharedPreferences (SHARED_PREF_KEY, Context.MODE_PRIVATE);\n\n            // level\n            if (null != level) {  // someone called setLevel method before setContext\n                setLevelSync(level);  // seems redundant, but we do this to save to SharedPrefs now that we have Context\n            } else {  // set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet\n                setLevelSync(Logger.LEVEL.fromString(prefs.getString(SHARED_PREF_KEY_level, getLevelDefault().toString())));\n            }\n\n            // logFileMaxSize\n            if (null != logFileMaxSize) {  // someone called setMaxStoreSize method before setContext\n                setMaxLogStoreSize(logFileMaxSize);  // seems redundant, but we do this to save to SharedPrefs now that we have Context\n            } else {  // set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet\n                setMaxLogStoreSize(prefs.getInt(SHARED_PREF_KEY_logFileMaxSize, DEFAULT_logFileMaxSize));\n            }\n\n            // capture\n            if (null != capture) {  // someone called setCapture method before setContext\n                setCaptureSync(capture);  // seems redundant, but we do this to save to SharedPrefs now that we have Context\n            } else {  // set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet\n                setCaptureSync(prefs.getBoolean (SHARED_PREF_KEY_logPersistence, DEFAULT_capture));\n            }\n\n            uncaughtExceptionHandler = new UncaughtExceptionHandler ();\n            Thread.setDefaultUncaughtExceptionHandler (uncaughtExceptionHandler);\n        }\n    }", "code_tokens": ["static", "public", "void", "setContext", "(", "final", "Context", "context", ")", "{", "// once setContext is called, we can set up the uncaught exception handler since", "// it will force logging to the file", "if", "(", "null", "==", "LogPersister", ".", "context", ")", "{", "// set a custom JUL Handler so we can capture third-party and internal java.util.logging.Logger API calls", "LogManager", ".", "getLogManager", "(", ")", ".", "getLogger", "(", "\"\"", ")", ".", "addHandler", "(", "julHandler", ")", ";", "java", ".", "util", ".", "logging", ".", "Logger", ".", "getLogger", "(", "\"\"", ")", ".", "setLevel", "(", "Level", ".", "ALL", ")", ";", "LogPersister", ".", "context", "=", "context", ";", "// now that we have a context, let's set the fileLoggerInstance properly unless it was already set by tests", "if", "(", "fileLoggerInstance", "==", "null", "||", "fileLoggerInstance", "instanceof", "FileLogger", ")", "{", "FileLogger", ".", "setContext", "(", "context", ")", ";", "fileLoggerInstance", "=", "FileLogger", ".", "getInstance", "(", ")", ";", "}", "SharedPreferences", "prefs", "=", "LogPersister", ".", "context", ".", "getSharedPreferences", "(", "SHARED_PREF_KEY", ",", "Context", ".", "MODE_PRIVATE", ")", ";", "// level", "if", "(", "null", "!=", "level", ")", "{", "// someone called setLevel method before setContext", "setLevelSync", "(", "level", ")", ";", "// seems redundant, but we do this to save to SharedPrefs now that we have Context", "}", "else", "{", "// set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet", "setLevelSync", "(", "Logger", ".", "LEVEL", ".", "fromString", "(", "prefs", ".", "getString", "(", "SHARED_PREF_KEY_level", ",", "getLevelDefault", "(", ")", ".", "toString", "(", ")", ")", ")", ")", ";", "}", "// logFileMaxSize", "if", "(", "null", "!=", "logFileMaxSize", ")", "{", "// someone called setMaxStoreSize method before setContext", "setMaxLogStoreSize", "(", "logFileMaxSize", ")", ";", "// seems redundant, but we do this to save to SharedPrefs now that we have Context", "}", "else", "{", "// set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet", "setMaxLogStoreSize", "(", "prefs", ".", "getInt", "(", "SHARED_PREF_KEY_logFileMaxSize", ",", "DEFAULT_logFileMaxSize", ")", ")", ";", "}", "// capture", "if", "(", "null", "!=", "capture", ")", "{", "// someone called setCapture method before setContext", "setCaptureSync", "(", "capture", ")", ";", "// seems redundant, but we do this to save to SharedPrefs now that we have Context", "}", "else", "{", "// set it to the SharedPrefs value, or DEFAULT if no value in SharedPrefs yet", "setCaptureSync", "(", "prefs", ".", "getBoolean", "(", "SHARED_PREF_KEY_logPersistence", ",", "DEFAULT_capture", ")", ")", ";", "}", "uncaughtExceptionHandler", "=", "new", "UncaughtExceptionHandler", "(", ")", ";", "Thread", ".", "setDefaultUncaughtExceptionHandler", "(", "uncaughtExceptionHandler", ")", ";", "}", "}"], "docstring": "Context object must be set in order to use the Logger API.  This is called automatically by BMSClient.\n\n@param context Android Context object", "docstring_tokens": ["Context", "object", "must", "be", "set", "in", "order", "to", "use", "the", "Logger", "API", ".", "This", "is", "called", "automatically", "by", "BMSClient", "."]}
{"code": "String regionName = args[1];", "comments": "TODO: accept multiple regions", "lines": 24, "repo": "nyla-solutions/gedi-geode", "path": "gedi-geode-extensions-core/src/main/java/gedi/solutions/geode/operations/functions/ReadExportFunction.java", "func_name": "ReadExportFunction.execute", "original_string": "@Override\r\n\tpublic void execute(FunctionContext<Object> functionContext)\r\n\t{\r\n\r\n\t\tResultSender<Object> sender = functionContext.getResultSender();\r\n\t\tCache cache = CacheFactory.getAnyInstance();\r\n\t\tLogger logWriter = LogManager.getLogger(getClass());\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t//export data\r\n\t\t\t\r\n\t\t\tString[] args = (String[])functionContext.getArguments();\r\n\t\t\t\r\n\t\t\tif(args == null || args.length != 2 )\r\n\t\t\t\tthrow new FunctionException(\"Required array args: [region,extension]\");\r\n\r\n\t\t\tString extensionArg = args[0];\r\n\t\t\tif(extensionArg == null || extensionArg.length() == 0)\r\n\t\t\t{\r\n\t\t\t\tthrow new IllegalArgumentException(\"File extension required\");\r\n\t\t\t}\r\n\t\t\tExportFileType extension =  ExportFileType.valueOf(extensionArg);\r\n\t\t\tString regionName = args[1]; //TODO: accept multiple regions\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tRegion<Object,Object> region = cache.getRegion(regionName);\r\n\t\t\t\r\n\t\t\tif(region == null)\r\n\t\t\t{\r\n\t\t\t\tsender.lastResult(null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//TODO: get file from functions\r\n\t\t\tFile file = new File(new StringBuilder(directoryPath).append(\"/\").append(regionName)\r\n\t\t\t\t\t.append(\".\").append(extensionArg).toString());\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//get server name\r\n\t\t\tString serverName = cache.getDistributedSystem().getDistributedMember().getName();\r\n\t\t\t\r\n\t\t\tswitch(extension)\r\n\t\t\t{\r\n\t\t\t\tcase gfd:\r\n\t\t\t\t\tnew GfdExportFunction().exportRegion(region);\r\n\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unsupported extension file type:\"+extension);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSerializable content = readContent(file,extension,logWriter);\r\n\t\t\t\r\n\t\t\tSerializable[] arrayResults = {serverName,content,file.getAbsolutePath()};\r\n\t\t\t\r\n\t\t\tsender.lastResult(arrayResults);\r\n\t\t}\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\tString stackTrace = Debugger.stackTrace(e);\r\n\t\t\tlogWriter.error(stackTrace);\r\n\t\t\t\r\n\t\t\tthrow new FunctionException(stackTrace);\r\n\t\t}\r\n\t\t\t\r\n\t}", "language": "java", "Allcodes": "@Override\r\n\tpublic void execute(FunctionContext<Object> functionContext)\r\n\t{\r\n\r\n\t\tResultSender<Object> sender = functionContext.getResultSender();\r\n\t\tCache cache = CacheFactory.getAnyInstance();\r\n\t\tLogger logWriter = LogManager.getLogger(getClass());\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t//export data\r\n\t\t\t\r\n\t\t\tString[] args = (String[])functionContext.getArguments();\r\n\t\t\t\r\n\t\t\tif(args == null || args.length != 2 )\r\n\t\t\t\tthrow new FunctionException(\"Required array args: [region,extension]\");\r\n\r\n\t\t\tString extensionArg = args[0];\r\n\t\t\tif(extensionArg == null || extensionArg.length() == 0)\r\n\t\t\t{\r\n\t\t\t\tthrow new IllegalArgumentException(\"File extension required\");\r\n\t\t\t}\r\n\t\t\tExportFileType extension =  ExportFileType.valueOf(extensionArg);\r\n\t\t\tString regionName = args[1]; //TODO: accept multiple regions\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tRegion<Object,Object> region = cache.getRegion(regionName);\r\n\t\t\t\r\n\t\t\tif(region == null)\r\n\t\t\t{\r\n\t\t\t\tsender.lastResult(null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//TODO: get file from functions\r\n\t\t\tFile file = new File(new StringBuilder(directoryPath).append(\"/\").append(regionName)\r\n\t\t\t\t\t.append(\".\").append(extensionArg).toString());\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//get server name\r\n\t\t\tString serverName = cache.getDistributedSystem().getDistributedMember().getName();\r\n\t\t\t\r\n\t\t\tswitch(extension)\r\n\t\t\t{\r\n\t\t\t\tcase gfd:\r\n\t\t\t\t\tnew GfdExportFunction().exportRegion(region);\r\n\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unsupported extension file type:\"+extension);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tSerializable content = readContent(file,extension,logWriter);\r\n\t\t\t\r\n\t\t\tSerializable[] arrayResults = {serverName,content,file.getAbsolutePath()};\r\n\t\t\t\r\n\t\t\tsender.lastResult(arrayResults);\r\n\t\t}\r\n\t\tcatch (Exception e)\r\n\t\t{\r\n\t\t\tString stackTrace = Debugger.stackTrace(e);\r\n\t\t\tlogWriter.error(stackTrace);\r\n\t\t\t\r\n\t\t\tthrow new FunctionException(stackTrace);\r\n\t\t}\r\n\t\t\t\r\n\t}", "code_tokens": ["@", "Override", "public", "void", "execute", "(", "FunctionContext", "<", "Object", ">", "functionContext", ")", "{", "ResultSender", "<", "Object", ">", "sender", "=", "functionContext", ".", "getResultSender", "(", ")", ";", "Cache", "cache", "=", "CacheFactory", ".", "getAnyInstance", "(", ")", ";", "Logger", "logWriter", "=", "LogManager", ".", "getLogger", "(", "getClass", "(", ")", ")", ";", "try", "{", "//export data\r", "String", "[", "]", "args", "=", "(", "String", "[", "]", ")", "functionContext", ".", "getArguments", "(", ")", ";", "if", "(", "args", "==", "null", "||", "args", ".", "length", "!=", "2", ")", "throw", "new", "FunctionException", "(", "\"Required array args: [region,extension]\"", ")", ";", "String", "extensionArg", "=", "args", "[", "0", "]", ";", "if", "(", "extensionArg", "==", "null", "||", "extensionArg", ".", "length", "(", ")", "==", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"File extension required\"", ")", ";", "}", "ExportFileType", "extension", "=", "ExportFileType", ".", "valueOf", "(", "extensionArg", ")", ";", "String", "regionName", "=", "args", "[", "1", "]", ";", "//TODO: accept multiple regions\r", "Region", "<", "Object", ",", "Object", ">", "region", "=", "cache", ".", "getRegion", "(", "regionName", ")", ";", "if", "(", "region", "==", "null", ")", "{", "sender", ".", "lastResult", "(", "null", ")", ";", "return", ";", "}", "//TODO: get file from functions\r", "File", "file", "=", "new", "File", "(", "new", "StringBuilder", "(", "directoryPath", ")", ".", "append", "(", "\"/\"", ")", ".", "append", "(", "regionName", ")", ".", "append", "(", "\".\"", ")", ".", "append", "(", "extensionArg", ")", ".", "toString", "(", ")", ")", ";", "//get server name\r", "String", "serverName", "=", "cache", ".", "getDistributedSystem", "(", ")", ".", "getDistributedMember", "(", ")", ".", "getName", "(", ")", ";", "switch", "(", "extension", ")", "{", "case", "gfd", ":", "new", "GfdExportFunction", "(", ")", ".", "exportRegion", "(", "region", ")", ";", "break", ";", "default", ":", "throw", "new", "IllegalArgumentException", "(", "\"Unsupported extension file type:\"", "+", "extension", ")", ";", "}", "Serializable", "content", "=", "readContent", "(", "file", ",", "extension", ",", "logWriter", ")", ";", "Serializable", "[", "]", "arrayResults", "=", "{", "serverName", ",", "content", ",", "file", ".", "getAbsolutePath", "(", ")", "}", ";", "sender", ".", "lastResult", "(", "arrayResults", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "String", "stackTrace", "=", "Debugger", ".", "stackTrace", "(", "e", ")", ";", "logWriter", ".", "error", "(", "stackTrace", ")", ";", "throw", "new", "FunctionException", "(", "stackTrace", ")", ";", "}", "}"], "docstring": "This function will use the JsonExportFunction function\nto export json data and read the results to be returned to callers", "docstring_tokens": ["This", "function", "will", "use", "the", "JsonExportFunction", "function", "to", "export", "json", "data", "and", "read", "the", "results", "to", "be", "returned", "to", "callers"]}
{"code": "final float tv[][] = new float [m_nCols] [m_nRows];", "comments": "transposed values", "lines": 3, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/Matrix.java", "func_name": "Matrix.transpose", "original_string": "public Matrix transpose ()\n  {\n    final float tv[][] = new float [m_nCols] [m_nRows]; // transposed values\n\n    // Set the values of the transpose.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        tv[c][r] = m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (tv);\n  }", "language": "java", "Allcodes": "public Matrix transpose ()\n  {\n    final float tv[][] = new float [m_nCols] [m_nRows]; // transposed values\n\n    // Set the values of the transpose.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        tv[c][r] = m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (tv);\n  }", "code_tokens": ["public", "Matrix", "transpose", "(", ")", "{", "final", "float", "tv", "[", "]", "[", "]", "=", "new", "float", "[", "m_nCols", "]", "[", "m_nRows", "]", ";", "// transposed values", "// Set the values of the transpose.", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nCols", ";", "++", "c", ")", "{", "tv", "[", "c", "]", "[", "r", "]", "=", "m_aValues", "[", "r", "]", "[", "c", "]", ";", "}", "}", "return", "new", "Matrix", "(", "tv", ")", ";", "}"], "docstring": "Return the transpose of this matrix.\n\n@return the transposed matrix", "docstring_tokens": ["Return", "the", "transpose", "of", "this", "matrix", "."]}
{"code": "final float sv[][] = new float [m_nRows] [m_nCols];", "comments": "sum values", "lines": 9, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/Matrix.java", "func_name": "Matrix.add", "original_string": "public Matrix add (final Matrix m) throws MatrixException\n  {\n    // Validate m's size.\n    if ((m_nRows != m.m_nRows) && (m_nCols != m.m_nCols))\n    {\n      throw new MatrixException (MatrixException.INVALID_DIMENSIONS);\n    }\n\n    final float sv[][] = new float [m_nRows] [m_nCols]; // sum values\n\n    // Compute values of the sum.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        sv[r][c] = m_aValues[r][c] + m.m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (sv);\n  }", "language": "java", "Allcodes": "public Matrix add (final Matrix m) throws MatrixException\n  {\n    // Validate m's size.\n    if ((m_nRows != m.m_nRows) && (m_nCols != m.m_nCols))\n    {\n      throw new MatrixException (MatrixException.INVALID_DIMENSIONS);\n    }\n\n    final float sv[][] = new float [m_nRows] [m_nCols]; // sum values\n\n    // Compute values of the sum.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        sv[r][c] = m_aValues[r][c] + m.m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (sv);\n  }", "code_tokens": ["public", "Matrix", "add", "(", "final", "Matrix", "m", ")", "throws", "MatrixException", "{", "// Validate m's size.", "if", "(", "(", "m_nRows", "!=", "m", ".", "m_nRows", ")", "&&", "(", "m_nCols", "!=", "m", ".", "m_nCols", ")", ")", "{", "throw", "new", "MatrixException", "(", "MatrixException", ".", "INVALID_DIMENSIONS", ")", ";", "}", "final", "float", "sv", "[", "]", "[", "]", "=", "new", "float", "[", "m_nRows", "]", "[", "m_nCols", "]", ";", "// sum values", "// Compute values of the sum.", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nCols", ";", "++", "c", ")", "{", "sv", "[", "r", "]", "[", "c", "]", "=", "m_aValues", "[", "r", "]", "[", "c", "]", "+", "m", ".", "m_aValues", "[", "r", "]", "[", "c", "]", ";", "}", "}", "return", "new", "Matrix", "(", "sv", ")", ";", "}"], "docstring": "Add another matrix to this matrix.\n\n@param m\nthe matrix addend\n@return the sum matrix\n@throws MatrixException\nfor invalid size", "docstring_tokens": ["Add", "another", "matrix", "to", "this", "matrix", "."]}
{"code": "final float dv[][] = new float [m_nRows] [m_nCols];", "comments": "difference values", "lines": 9, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/Matrix.java", "func_name": "Matrix.subtract", "original_string": "public Matrix subtract (final Matrix m) throws MatrixException\n  {\n    // Validate m's size.\n    if ((m_nRows != m.m_nRows) && (m_nCols != m.m_nCols))\n    {\n      throw new MatrixException (MatrixException.INVALID_DIMENSIONS);\n    }\n\n    final float dv[][] = new float [m_nRows] [m_nCols]; // difference values\n\n    // Compute values of the difference.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        dv[r][c] = m_aValues[r][c] - m.m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (dv);\n  }", "language": "java", "Allcodes": "public Matrix subtract (final Matrix m) throws MatrixException\n  {\n    // Validate m's size.\n    if ((m_nRows != m.m_nRows) && (m_nCols != m.m_nCols))\n    {\n      throw new MatrixException (MatrixException.INVALID_DIMENSIONS);\n    }\n\n    final float dv[][] = new float [m_nRows] [m_nCols]; // difference values\n\n    // Compute values of the difference.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        dv[r][c] = m_aValues[r][c] - m.m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (dv);\n  }", "code_tokens": ["public", "Matrix", "subtract", "(", "final", "Matrix", "m", ")", "throws", "MatrixException", "{", "// Validate m's size.", "if", "(", "(", "m_nRows", "!=", "m", ".", "m_nRows", ")", "&&", "(", "m_nCols", "!=", "m", ".", "m_nCols", ")", ")", "{", "throw", "new", "MatrixException", "(", "MatrixException", ".", "INVALID_DIMENSIONS", ")", ";", "}", "final", "float", "dv", "[", "]", "[", "]", "=", "new", "float", "[", "m_nRows", "]", "[", "m_nCols", "]", ";", "// difference values", "// Compute values of the difference.", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nCols", ";", "++", "c", ")", "{", "dv", "[", "r", "]", "[", "c", "]", "=", "m_aValues", "[", "r", "]", "[", "c", "]", "-", "m", ".", "m_aValues", "[", "r", "]", "[", "c", "]", ";", "}", "}", "return", "new", "Matrix", "(", "dv", ")", ";", "}"], "docstring": "Subtract another matrix from this matrix.\n\n@param m\nthe matrix subrrahend\n@return the difference matrix\n@throws MatrixException\nfor invalid size", "docstring_tokens": ["Subtract", "another", "matrix", "from", "this", "matrix", "."]}
{"code": "final float pv[][] = new float [m_nRows] [m_nCols];", "comments": "product values", "lines": 3, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/Matrix.java", "func_name": "Matrix.multiply", "original_string": "public Matrix multiply (final float k)\n  {\n    final float pv[][] = new float [m_nRows] [m_nCols]; // product values\n\n    // Compute values of the product.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        pv[r][c] = k * m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (pv);\n  }", "language": "java", "Allcodes": "public Matrix multiply (final float k)\n  {\n    final float pv[][] = new float [m_nRows] [m_nCols]; // product values\n\n    // Compute values of the product.\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        pv[r][c] = k * m_aValues[r][c];\n      }\n    }\n\n    return new Matrix (pv);\n  }", "code_tokens": ["public", "Matrix", "multiply", "(", "final", "float", "k", ")", "{", "final", "float", "pv", "[", "]", "[", "]", "=", "new", "float", "[", "m_nRows", "]", "[", "m_nCols", "]", ";", "// product values", "// Compute values of the product.", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nCols", ";", "++", "c", ")", "{", "pv", "[", "r", "]", "[", "c", "]", "=", "k", "*", "m_aValues", "[", "r", "]", "[", "c", "]", ";", "}", "}", "return", "new", "Matrix", "(", "pv", ")", ";", "}"], "docstring": "Multiply this matrix by a constant.\n\n@param k\nthe constant\n@return the product matrix", "docstring_tokens": ["Multiply", "this", "matrix", "by", "a", "constant", "."]}
{"code": "final float x2 = x1 + h;", "comments": "right bound of the region", "lines": 3, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/TrapezoidalIntegrator.java", "func_name": "TrapezoidalIntegrator._areaOf", "original_string": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "language": "java", "Allcodes": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "code_tokens": ["private", "float", "_areaOf", "(", "final", "float", "x1", ",", "final", "float", "h", ")", "{", "final", "float", "x2", "=", "x1", "+", "h", ";", "// right bound of the region", "final", "float", "y1", "=", "m_aIntegrand", ".", "at", "(", "x1", ")", ";", "// value at left bound", "final", "float", "y2", "=", "m_aIntegrand", ".", "at", "(", "x2", ")", ";", "// value at right bound", "final", "float", "area", "=", "h", "*", "(", "y1", "+", "y2", ")", "/", "2", ";", "// area of the region", "return", "area", ";", "}"], "docstring": "Compute the area of the ith trapezoidal region.\n\n@param x1\nthe left bound of the region\n@param h\nthe interval width\n@return the area of the region", "docstring_tokens": ["Compute", "the", "area", "of", "the", "ith", "trapezoidal", "region", "."]}
{"code": "final float y1 = m_aIntegrand.at (x1);", "comments": "value at left bound", "lines": 4, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/TrapezoidalIntegrator.java", "func_name": "TrapezoidalIntegrator._areaOf", "original_string": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "language": "java", "Allcodes": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "code_tokens": ["private", "float", "_areaOf", "(", "final", "float", "x1", ",", "final", "float", "h", ")", "{", "final", "float", "x2", "=", "x1", "+", "h", ";", "// right bound of the region", "final", "float", "y1", "=", "m_aIntegrand", ".", "at", "(", "x1", ")", ";", "// value at left bound", "final", "float", "y2", "=", "m_aIntegrand", ".", "at", "(", "x2", ")", ";", "// value at right bound", "final", "float", "area", "=", "h", "*", "(", "y1", "+", "y2", ")", "/", "2", ";", "// area of the region", "return", "area", ";", "}"], "docstring": "Compute the area of the ith trapezoidal region.\n\n@param x1\nthe left bound of the region\n@param h\nthe interval width\n@return the area of the region", "docstring_tokens": ["Compute", "the", "area", "of", "the", "ith", "trapezoidal", "region", "."]}
{"code": "final float y2 = m_aIntegrand.at (x2);", "comments": "value at right bound", "lines": 5, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/TrapezoidalIntegrator.java", "func_name": "TrapezoidalIntegrator._areaOf", "original_string": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "language": "java", "Allcodes": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "code_tokens": ["private", "float", "_areaOf", "(", "final", "float", "x1", ",", "final", "float", "h", ")", "{", "final", "float", "x2", "=", "x1", "+", "h", ";", "// right bound of the region", "final", "float", "y1", "=", "m_aIntegrand", ".", "at", "(", "x1", ")", ";", "// value at left bound", "final", "float", "y2", "=", "m_aIntegrand", ".", "at", "(", "x2", ")", ";", "// value at right bound", "final", "float", "area", "=", "h", "*", "(", "y1", "+", "y2", ")", "/", "2", ";", "// area of the region", "return", "area", ";", "}"], "docstring": "Compute the area of the ith trapezoidal region.\n\n@param x1\nthe left bound of the region\n@param h\nthe interval width\n@return the area of the region", "docstring_tokens": ["Compute", "the", "area", "of", "the", "ith", "trapezoidal", "region", "."]}
{"code": "final float area = h * (y1 + y2) / 2;", "comments": "area of the region", "lines": 6, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/TrapezoidalIntegrator.java", "func_name": "TrapezoidalIntegrator._areaOf", "original_string": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "language": "java", "Allcodes": "private float _areaOf (final float x1, final float h)\n  {\n    final float x2 = x1 + h; // right bound of the region\n    final float y1 = m_aIntegrand.at (x1); // value at left bound\n    final float y2 = m_aIntegrand.at (x2); // value at right bound\n    final float area = h * (y1 + y2) / 2; // area of the region\n\n    return area;\n  }", "code_tokens": ["private", "float", "_areaOf", "(", "final", "float", "x1", ",", "final", "float", "h", ")", "{", "final", "float", "x2", "=", "x1", "+", "h", ";", "// right bound of the region", "final", "float", "y1", "=", "m_aIntegrand", ".", "at", "(", "x1", ")", ";", "// value at left bound", "final", "float", "y2", "=", "m_aIntegrand", ".", "at", "(", "x2", ")", ";", "// value at right bound", "final", "float", "area", "=", "h", "*", "(", "y1", "+", "y2", ")", "/", "2", ";", "// area of the region", "return", "area", ";", "}"], "docstring": "Compute the area of the ith trapezoidal region.\n\n@param x1\nthe left bound of the region\n@param h\nthe interval width\n@return the area of the region", "docstring_tokens": ["Compute", "the", "area", "of", "the", "ith", "trapezoidal", "region", "."]}
{"code": "final int pi = m_aPermutation[i];", "comments": "permuted index", "lines": 12, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/InvertibleMatrix.java", "func_name": "InvertibleMatrix.determinant", "original_string": "public float determinant () throws MatrixException\n  {\n    decompose ();\n\n    // Each row exchange during forward elimination flips the sign\n    // of the determinant, so check for an odd number of exchanges.\n    float determinant = ((m_nExchangeCount & 1) == 0) ? 1 : -1;\n\n    // Form the product of the diagonal elements of matrix U.\n    for (int i = 0; i < m_nRows; ++i)\n    {\n      final int pi = m_aPermutation[i]; // permuted index\n      determinant *= m_aLU.at (pi, i);\n    }\n\n    return determinant;\n  }", "language": "java", "Allcodes": "public float determinant () throws MatrixException\n  {\n    decompose ();\n\n    // Each row exchange during forward elimination flips the sign\n    // of the determinant, so check for an odd number of exchanges.\n    float determinant = ((m_nExchangeCount & 1) == 0) ? 1 : -1;\n\n    // Form the product of the diagonal elements of matrix U.\n    for (int i = 0; i < m_nRows; ++i)\n    {\n      final int pi = m_aPermutation[i]; // permuted index\n      determinant *= m_aLU.at (pi, i);\n    }\n\n    return determinant;\n  }", "code_tokens": ["public", "float", "determinant", "(", ")", "throws", "MatrixException", "{", "decompose", "(", ")", ";", "// Each row exchange during forward elimination flips the sign", "// of the determinant, so check for an odd number of exchanges.", "float", "determinant", "=", "(", "(", "m_nExchangeCount", "&", "1", ")", "==", "0", ")", "?", "1", ":", "-", "1", ";", "// Form the product of the diagonal elements of matrix U.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_nRows", ";", "++", "i", ")", "{", "final", "int", "pi", "=", "m_aPermutation", "[", "i", "]", ";", "// permuted index", "determinant", "*=", "m_aLU", ".", "at", "(", "pi", ",", "i", ")", ";", "}", "return", "determinant", ";", "}"], "docstring": "Compute the determinant.\n\n@return the determinant\n@throws MatrixException\nif an error occurred", "docstring_tokens": ["Compute", "the", "determinant", "."]}
{"code": "final int pr = m_aPermutation[r];", "comments": "permuted row index", "lines": 9, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/LinearSystem.java", "func_name": "LinearSystem.printDecomposed", "original_string": "public void printDecomposed (final int width, @Nonnull final PrintStream aPS) throws MatrixException\n  {\n    decompose ();\n\n    final SystemOutAlignRight ar = new SystemOutAlignRight (aPS);\n\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      final int pr = m_aPermutation[r]; // permuted row index\n      ar.print (\"Row \", 0);\n      ar.print (r + 1, 2);\n      ar.print (\":\", 0);\n\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        ar.print (m_aLU.m_aValues[pr][c], width);\n      }\n      ar.println ();\n    }\n  }", "language": "java", "Allcodes": "public void printDecomposed (final int width, @Nonnull final PrintStream aPS) throws MatrixException\n  {\n    decompose ();\n\n    final SystemOutAlignRight ar = new SystemOutAlignRight (aPS);\n\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      final int pr = m_aPermutation[r]; // permuted row index\n      ar.print (\"Row \", 0);\n      ar.print (r + 1, 2);\n      ar.print (\":\", 0);\n\n      for (int c = 0; c < m_nCols; ++c)\n      {\n        ar.print (m_aLU.m_aValues[pr][c], width);\n      }\n      ar.println ();\n    }\n  }", "code_tokens": ["public", "void", "printDecomposed", "(", "final", "int", "width", ",", "@", "Nonnull", "final", "PrintStream", "aPS", ")", "throws", "MatrixException", "{", "decompose", "(", ")", ";", "final", "SystemOutAlignRight", "ar", "=", "new", "SystemOutAlignRight", "(", "aPS", ")", ";", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "final", "int", "pr", "=", "m_aPermutation", "[", "r", "]", ";", "// permuted row index", "ar", ".", "print", "(", "\"Row \"", ",", "0", ")", ";", "ar", ".", "print", "(", "r", "+", "1", ",", "2", ")", ";", "ar", ".", "print", "(", "\":\"", ",", "0", ")", ";", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nCols", ";", "++", "c", ")", "{", "ar", ".", "print", "(", "m_aLU", ".", "m_aValues", "[", "pr", "]", "[", "c", "]", ",", "width", ")", ";", "}", "ar", ".", "println", "(", ")", ";", "}", "}"], "docstring": "Print the decomposed matrix LU.\n\n@param width\nthe column width\n@throws MatrixException\nif an error occurred", "docstring_tokens": ["Print", "the", "decomposed", "matrix", "LU", "."]}
{"code": "dot += elmt * x.at (c);", "comments": "dbl.prec. *", "lines": 30, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/LinearSystem.java", "func_name": "LinearSystem._improve", "original_string": "private void _improve (final ColumnVector b, final ColumnVector x) throws MatrixException\n  {\n    // Find the largest x element.\n    float largestX = 0;\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      final float absX = Math.abs (x.m_aValues[r][0]);\n      if (largestX < absX)\n        largestX = absX;\n    }\n\n    // Is x already as good as possible?\n    if (largestX == 0)\n      return;\n\n    final ColumnVector residuals = new ColumnVector (m_nRows);\n\n    // Iterate to improve x.\n    for (int iter = 0; iter < MAX_ITER; ++iter)\n    {\n\n      // Compute residuals = b - Ax.\n      // Must use double precision!\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        double dot = 0;\n        for (int c = 0; c < m_nRows; ++c)\n        {\n          final double elmt = at (r, c);\n          dot += elmt * x.at (c); // dbl.prec. *\n        }\n        final double value = b.at (r) - dot; // dbl.prec. -\n        residuals.set (r, (float) value);\n      }\n\n      // Solve Az = residuals for z.\n      final ColumnVector z = solve (residuals, false);\n\n      // Set x = x + z.\n      // Find largest the largest difference.\n      float largestDiff = 0;\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        final float oldX = x.at (r);\n        x.set (r, oldX + z.at (r));\n\n        final float diff = Math.abs (x.at (r) - oldX);\n        if (largestDiff < diff)\n          largestDiff = diff;\n      }\n\n      // Is any further improvement possible?\n      if (largestDiff < largestX * TOLERANCE)\n        return;\n    }\n\n    // Failed to converge because A is nearly singular.\n    throw new MatrixException (MatrixException.NO_CONVERGENCE);\n  }", "language": "java", "Allcodes": "private void _improve (final ColumnVector b, final ColumnVector x) throws MatrixException\n  {\n    // Find the largest x element.\n    float largestX = 0;\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      final float absX = Math.abs (x.m_aValues[r][0]);\n      if (largestX < absX)\n        largestX = absX;\n    }\n\n    // Is x already as good as possible?\n    if (largestX == 0)\n      return;\n\n    final ColumnVector residuals = new ColumnVector (m_nRows);\n\n    // Iterate to improve x.\n    for (int iter = 0; iter < MAX_ITER; ++iter)\n    {\n\n      // Compute residuals = b - Ax.\n      // Must use double precision!\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        double dot = 0;\n        for (int c = 0; c < m_nRows; ++c)\n        {\n          final double elmt = at (r, c);\n          dot += elmt * x.at (c); // dbl.prec. *\n        }\n        final double value = b.at (r) - dot; // dbl.prec. -\n        residuals.set (r, (float) value);\n      }\n\n      // Solve Az = residuals for z.\n      final ColumnVector z = solve (residuals, false);\n\n      // Set x = x + z.\n      // Find largest the largest difference.\n      float largestDiff = 0;\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        final float oldX = x.at (r);\n        x.set (r, oldX + z.at (r));\n\n        final float diff = Math.abs (x.at (r) - oldX);\n        if (largestDiff < diff)\n          largestDiff = diff;\n      }\n\n      // Is any further improvement possible?\n      if (largestDiff < largestX * TOLERANCE)\n        return;\n    }\n\n    // Failed to converge because A is nearly singular.\n    throw new MatrixException (MatrixException.NO_CONVERGENCE);\n  }", "code_tokens": ["private", "void", "_improve", "(", "final", "ColumnVector", "b", ",", "final", "ColumnVector", "x", ")", "throws", "MatrixException", "{", "// Find the largest x element.", "float", "largestX", "=", "0", ";", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "final", "float", "absX", "=", "Math", ".", "abs", "(", "x", ".", "m_aValues", "[", "r", "]", "[", "0", "]", ")", ";", "if", "(", "largestX", "<", "absX", ")", "largestX", "=", "absX", ";", "}", "// Is x already as good as possible?", "if", "(", "largestX", "==", "0", ")", "return", ";", "final", "ColumnVector", "residuals", "=", "new", "ColumnVector", "(", "m_nRows", ")", ";", "// Iterate to improve x.", "for", "(", "int", "iter", "=", "0", ";", "iter", "<", "MAX_ITER", ";", "++", "iter", ")", "{", "// Compute residuals = b - Ax.", "// Must use double precision!", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "double", "dot", "=", "0", ";", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nRows", ";", "++", "c", ")", "{", "final", "double", "elmt", "=", "at", "(", "r", ",", "c", ")", ";", "dot", "+=", "elmt", "*", "x", ".", "at", "(", "c", ")", ";", "// dbl.prec. *", "}", "final", "double", "value", "=", "b", ".", "at", "(", "r", ")", "-", "dot", ";", "// dbl.prec. -", "residuals", ".", "set", "(", "r", ",", "(", "float", ")", "value", ")", ";", "}", "// Solve Az = residuals for z.", "final", "ColumnVector", "z", "=", "solve", "(", "residuals", ",", "false", ")", ";", "// Set x = x + z.", "// Find largest the largest difference.", "float", "largestDiff", "=", "0", ";", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "final", "float", "oldX", "=", "x", ".", "at", "(", "r", ")", ";", "x", ".", "set", "(", "r", ",", "oldX", "+", "z", ".", "at", "(", "r", ")", ")", ";", "final", "float", "diff", "=", "Math", ".", "abs", "(", "x", ".", "at", "(", "r", ")", "-", "oldX", ")", ";", "if", "(", "largestDiff", "<", "diff", ")", "largestDiff", "=", "diff", ";", "}", "// Is any further improvement possible?", "if", "(", "largestDiff", "<", "largestX", "*", "TOLERANCE", ")", "return", ";", "}", "// Failed to converge because A is nearly singular.", "throw", "new", "MatrixException", "(", "MatrixException", ".", "NO_CONVERGENCE", ")", ";", "}"], "docstring": "Iteratively improve the solution x to machine accuracy.\n\n@param b\nthe right-hand side column vector\n@param x\nthe improved solution column vector\n@throws MatrixException\nif failed to converge", "docstring_tokens": ["Iteratively", "improve", "the", "solution", "x", "to", "machine", "accuracy", "."]}
{"code": "final double value = b.at (r) - dot;", "comments": "dbl.prec. -", "lines": 32, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/matrix/LinearSystem.java", "func_name": "LinearSystem._improve", "original_string": "private void _improve (final ColumnVector b, final ColumnVector x) throws MatrixException\n  {\n    // Find the largest x element.\n    float largestX = 0;\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      final float absX = Math.abs (x.m_aValues[r][0]);\n      if (largestX < absX)\n        largestX = absX;\n    }\n\n    // Is x already as good as possible?\n    if (largestX == 0)\n      return;\n\n    final ColumnVector residuals = new ColumnVector (m_nRows);\n\n    // Iterate to improve x.\n    for (int iter = 0; iter < MAX_ITER; ++iter)\n    {\n\n      // Compute residuals = b - Ax.\n      // Must use double precision!\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        double dot = 0;\n        for (int c = 0; c < m_nRows; ++c)\n        {\n          final double elmt = at (r, c);\n          dot += elmt * x.at (c); // dbl.prec. *\n        }\n        final double value = b.at (r) - dot; // dbl.prec. -\n        residuals.set (r, (float) value);\n      }\n\n      // Solve Az = residuals for z.\n      final ColumnVector z = solve (residuals, false);\n\n      // Set x = x + z.\n      // Find largest the largest difference.\n      float largestDiff = 0;\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        final float oldX = x.at (r);\n        x.set (r, oldX + z.at (r));\n\n        final float diff = Math.abs (x.at (r) - oldX);\n        if (largestDiff < diff)\n          largestDiff = diff;\n      }\n\n      // Is any further improvement possible?\n      if (largestDiff < largestX * TOLERANCE)\n        return;\n    }\n\n    // Failed to converge because A is nearly singular.\n    throw new MatrixException (MatrixException.NO_CONVERGENCE);\n  }", "language": "java", "Allcodes": "private void _improve (final ColumnVector b, final ColumnVector x) throws MatrixException\n  {\n    // Find the largest x element.\n    float largestX = 0;\n    for (int r = 0; r < m_nRows; ++r)\n    {\n      final float absX = Math.abs (x.m_aValues[r][0]);\n      if (largestX < absX)\n        largestX = absX;\n    }\n\n    // Is x already as good as possible?\n    if (largestX == 0)\n      return;\n\n    final ColumnVector residuals = new ColumnVector (m_nRows);\n\n    // Iterate to improve x.\n    for (int iter = 0; iter < MAX_ITER; ++iter)\n    {\n\n      // Compute residuals = b - Ax.\n      // Must use double precision!\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        double dot = 0;\n        for (int c = 0; c < m_nRows; ++c)\n        {\n          final double elmt = at (r, c);\n          dot += elmt * x.at (c); // dbl.prec. *\n        }\n        final double value = b.at (r) - dot; // dbl.prec. -\n        residuals.set (r, (float) value);\n      }\n\n      // Solve Az = residuals for z.\n      final ColumnVector z = solve (residuals, false);\n\n      // Set x = x + z.\n      // Find largest the largest difference.\n      float largestDiff = 0;\n      for (int r = 0; r < m_nRows; ++r)\n      {\n        final float oldX = x.at (r);\n        x.set (r, oldX + z.at (r));\n\n        final float diff = Math.abs (x.at (r) - oldX);\n        if (largestDiff < diff)\n          largestDiff = diff;\n      }\n\n      // Is any further improvement possible?\n      if (largestDiff < largestX * TOLERANCE)\n        return;\n    }\n\n    // Failed to converge because A is nearly singular.\n    throw new MatrixException (MatrixException.NO_CONVERGENCE);\n  }", "code_tokens": ["private", "void", "_improve", "(", "final", "ColumnVector", "b", ",", "final", "ColumnVector", "x", ")", "throws", "MatrixException", "{", "// Find the largest x element.", "float", "largestX", "=", "0", ";", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "final", "float", "absX", "=", "Math", ".", "abs", "(", "x", ".", "m_aValues", "[", "r", "]", "[", "0", "]", ")", ";", "if", "(", "largestX", "<", "absX", ")", "largestX", "=", "absX", ";", "}", "// Is x already as good as possible?", "if", "(", "largestX", "==", "0", ")", "return", ";", "final", "ColumnVector", "residuals", "=", "new", "ColumnVector", "(", "m_nRows", ")", ";", "// Iterate to improve x.", "for", "(", "int", "iter", "=", "0", ";", "iter", "<", "MAX_ITER", ";", "++", "iter", ")", "{", "// Compute residuals = b - Ax.", "// Must use double precision!", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "double", "dot", "=", "0", ";", "for", "(", "int", "c", "=", "0", ";", "c", "<", "m_nRows", ";", "++", "c", ")", "{", "final", "double", "elmt", "=", "at", "(", "r", ",", "c", ")", ";", "dot", "+=", "elmt", "*", "x", ".", "at", "(", "c", ")", ";", "// dbl.prec. *", "}", "final", "double", "value", "=", "b", ".", "at", "(", "r", ")", "-", "dot", ";", "// dbl.prec. -", "residuals", ".", "set", "(", "r", ",", "(", "float", ")", "value", ")", ";", "}", "// Solve Az = residuals for z.", "final", "ColumnVector", "z", "=", "solve", "(", "residuals", ",", "false", ")", ";", "// Set x = x + z.", "// Find largest the largest difference.", "float", "largestDiff", "=", "0", ";", "for", "(", "int", "r", "=", "0", ";", "r", "<", "m_nRows", ";", "++", "r", ")", "{", "final", "float", "oldX", "=", "x", ".", "at", "(", "r", ")", ";", "x", ".", "set", "(", "r", ",", "oldX", "+", "z", ".", "at", "(", "r", ")", ")", ";", "final", "float", "diff", "=", "Math", ".", "abs", "(", "x", ".", "at", "(", "r", ")", "-", "oldX", ")", ";", "if", "(", "largestDiff", "<", "diff", ")", "largestDiff", "=", "diff", ";", "}", "// Is any further improvement possible?", "if", "(", "largestDiff", "<", "largestX", "*", "TOLERANCE", ")", "return", ";", "}", "// Failed to converge because A is nearly singular.", "throw", "new", "MatrixException", "(", "MatrixException", ".", "NO_CONVERGENCE", ")", ";", "}"], "docstring": "Iteratively improve the solution x to machine accuracy.\n\n@param b\nthe right-hand side column vector\n@param x\nthe improved solution column vector\n@throws MatrixException\nif failed to converge", "docstring_tokens": ["Iteratively", "improve", "the", "solution", "x", "to", "machine", "accuracy", "."]}
{"code": "return u1 + k;", "comments": "return a random value", "lines": 31, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/RandomExponential.java", "func_name": "RandomExponential.nextVonNeumann", "original_string": "public float nextVonNeumann ()\n  {\n    int n;\n    int k = 0;\n    float u1;\n\n    // Loop to try sequences of uniformly-distributed\n    // random values.\n    for (;;)\n    {\n      n = 1;\n      u1 = GENERATOR.nextFloat ();\n\n      float u = u1;\n      float uPrev = Float.NaN;\n\n      // Loop to generate a sequence of ramdom values\n      // as long as they are decreasing.\n      for (;;)\n      {\n        uPrev = u;\n        u = GENERATOR.nextFloat ();\n\n        // No longer decreasing?\n        if (u > uPrev)\n        {\n\n          // n is even.\n          if ((n & 1) == 0)\n          {\n            return u1 + k; // return a random value\n          }\n\n          // n is odd.\n          ++k;\n          break; // try another sequence\n        }\n\n        ++n;\n      }\n    }\n  }", "language": "java", "Allcodes": "public float nextVonNeumann ()\n  {\n    int n;\n    int k = 0;\n    float u1;\n\n    // Loop to try sequences of uniformly-distributed\n    // random values.\n    for (;;)\n    {\n      n = 1;\n      u1 = GENERATOR.nextFloat ();\n\n      float u = u1;\n      float uPrev = Float.NaN;\n\n      // Loop to generate a sequence of ramdom values\n      // as long as they are decreasing.\n      for (;;)\n      {\n        uPrev = u;\n        u = GENERATOR.nextFloat ();\n\n        // No longer decreasing?\n        if (u > uPrev)\n        {\n\n          // n is even.\n          if ((n & 1) == 0)\n          {\n            return u1 + k; // return a random value\n          }\n\n          // n is odd.\n          ++k;\n          break; // try another sequence\n        }\n\n        ++n;\n      }\n    }\n  }", "code_tokens": ["public", "float", "nextVonNeumann", "(", ")", "{", "int", "n", ";", "int", "k", "=", "0", ";", "float", "u1", ";", "// Loop to try sequences of uniformly-distributed", "// random values.", "for", "(", ";", ";", ")", "{", "n", "=", "1", ";", "u1", "=", "GENERATOR", ".", "nextFloat", "(", ")", ";", "float", "u", "=", "u1", ";", "float", "uPrev", "=", "Float", ".", "NaN", ";", "// Loop to generate a sequence of ramdom values", "// as long as they are decreasing.", "for", "(", ";", ";", ")", "{", "uPrev", "=", "u", ";", "u", "=", "GENERATOR", ".", "nextFloat", "(", ")", ";", "// No longer decreasing?", "if", "(", "u", ">", "uPrev", ")", "{", "// n is even.", "if", "(", "(", "n", "&", "1", ")", "==", "0", ")", "{", "return", "u1", "+", "k", ";", "// return a random value", "}", "// n is odd.", "++", "k", ";", "break", ";", "// try another sequence", "}", "++", "n", ";", "}", "}", "}"], "docstring": "Compute the next randomn value using the von Neumann algorithm. Requires\nsequences of uniformly-distributed random values in [0, 1).", "docstring_tokens": ["Compute", "the", "next", "randomn", "value", "using", "the", "von", "Neumann", "algorithm", ".", "Requires", "sequences", "of", "uniformly", "-", "distributed", "random", "values", "in", "[", "0", "1", ")", "."]}
{"code": "break;", "comments": "try another sequence", "lines": 36, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/RandomExponential.java", "func_name": "RandomExponential.nextVonNeumann", "original_string": "public float nextVonNeumann ()\n  {\n    int n;\n    int k = 0;\n    float u1;\n\n    // Loop to try sequences of uniformly-distributed\n    // random values.\n    for (;;)\n    {\n      n = 1;\n      u1 = GENERATOR.nextFloat ();\n\n      float u = u1;\n      float uPrev = Float.NaN;\n\n      // Loop to generate a sequence of ramdom values\n      // as long as they are decreasing.\n      for (;;)\n      {\n        uPrev = u;\n        u = GENERATOR.nextFloat ();\n\n        // No longer decreasing?\n        if (u > uPrev)\n        {\n\n          // n is even.\n          if ((n & 1) == 0)\n          {\n            return u1 + k; // return a random value\n          }\n\n          // n is odd.\n          ++k;\n          break; // try another sequence\n        }\n\n        ++n;\n      }\n    }\n  }", "language": "java", "Allcodes": "public float nextVonNeumann ()\n  {\n    int n;\n    int k = 0;\n    float u1;\n\n    // Loop to try sequences of uniformly-distributed\n    // random values.\n    for (;;)\n    {\n      n = 1;\n      u1 = GENERATOR.nextFloat ();\n\n      float u = u1;\n      float uPrev = Float.NaN;\n\n      // Loop to generate a sequence of ramdom values\n      // as long as they are decreasing.\n      for (;;)\n      {\n        uPrev = u;\n        u = GENERATOR.nextFloat ();\n\n        // No longer decreasing?\n        if (u > uPrev)\n        {\n\n          // n is even.\n          if ((n & 1) == 0)\n          {\n            return u1 + k; // return a random value\n          }\n\n          // n is odd.\n          ++k;\n          break; // try another sequence\n        }\n\n        ++n;\n      }\n    }\n  }", "code_tokens": ["public", "float", "nextVonNeumann", "(", ")", "{", "int", "n", ";", "int", "k", "=", "0", ";", "float", "u1", ";", "// Loop to try sequences of uniformly-distributed", "// random values.", "for", "(", ";", ";", ")", "{", "n", "=", "1", ";", "u1", "=", "GENERATOR", ".", "nextFloat", "(", ")", ";", "float", "u", "=", "u1", ";", "float", "uPrev", "=", "Float", ".", "NaN", ";", "// Loop to generate a sequence of ramdom values", "// as long as they are decreasing.", "for", "(", ";", ";", ")", "{", "uPrev", "=", "u", ";", "u", "=", "GENERATOR", ".", "nextFloat", "(", ")", ";", "// No longer decreasing?", "if", "(", "u", ">", "uPrev", ")", "{", "// n is even.", "if", "(", "(", "n", "&", "1", ")", "==", "0", ")", "{", "return", "u1", "+", "k", ";", "// return a random value", "}", "// n is odd.", "++", "k", ";", "break", ";", "// try another sequence", "}", "++", "n", ";", "}", "}", "}"], "docstring": "Compute the next randomn value using the von Neumann algorithm. Requires\nsequences of uniformly-distributed random values in [0, 1).", "docstring_tokens": ["Compute", "the", "next", "randomn", "value", "using", "the", "von", "Neumann", "algorithm", ".", "Requires", "sequences", "of", "uniformly", "-", "distributed", "random", "values", "in", "[", "0", "1", ")", "."]}
{"code": "return;", "comments": "already initialized", "lines": 5, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/RegulaFalsiRootFinder.java", "func_name": "RegulaFalsiRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fFalse < 0)\n    {\n      m_fXNeg = m_fXFalse; // the root is in the xPos side\n      m_fNeg = m_fFalse;\n    }\n    else\n    {\n      m_fXPos = m_fXFalse; // the root is in the xNeg side\n      m_fPos = m_fFalse;\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fFalse < 0)\n    {\n      m_fXNeg = m_fXFalse; // the root is in the xPos side\n      m_fNeg = m_fFalse;\n    }\n    else\n    {\n      m_fXPos = m_fXFalse; // the root is in the xNeg side\n      m_fPos = m_fFalse;\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "if", "(", "m_fFalse", "<", "0", ")", "{", "m_fXNeg", "=", "m_fXFalse", ";", "// the root is in the xPos side", "m_fNeg", "=", "m_fFalse", ";", "}", "else", "{", "m_fXPos", "=", "m_fXFalse", ";", "// the root is in the xNeg side", "m_fPos", "=", "m_fFalse", ";", "}", "}"], "docstring": "Do the regula falsi iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "regula", "falsi", "iteration", "procedure", "."]}
{"code": "m_fXNeg = m_fXFalse;", "comments": "the root is in the xPos side", "lines": 9, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/RegulaFalsiRootFinder.java", "func_name": "RegulaFalsiRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fFalse < 0)\n    {\n      m_fXNeg = m_fXFalse; // the root is in the xPos side\n      m_fNeg = m_fFalse;\n    }\n    else\n    {\n      m_fXPos = m_fXFalse; // the root is in the xNeg side\n      m_fPos = m_fFalse;\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fFalse < 0)\n    {\n      m_fXNeg = m_fXFalse; // the root is in the xPos side\n      m_fNeg = m_fFalse;\n    }\n    else\n    {\n      m_fXPos = m_fXFalse; // the root is in the xNeg side\n      m_fPos = m_fFalse;\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "if", "(", "m_fFalse", "<", "0", ")", "{", "m_fXNeg", "=", "m_fXFalse", ";", "// the root is in the xPos side", "m_fNeg", "=", "m_fFalse", ";", "}", "else", "{", "m_fXPos", "=", "m_fXFalse", ";", "// the root is in the xNeg side", "m_fPos", "=", "m_fFalse", ";", "}", "}"], "docstring": "Do the regula falsi iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "regula", "falsi", "iteration", "procedure", "."]}
{"code": "m_fXPos = m_fXFalse;", "comments": "the root is in the xNeg side", "lines": 14, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/RegulaFalsiRootFinder.java", "func_name": "RegulaFalsiRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fFalse < 0)\n    {\n      m_fXNeg = m_fXFalse; // the root is in the xPos side\n      m_fNeg = m_fFalse;\n    }\n    else\n    {\n      m_fXPos = m_fXFalse; // the root is in the xNeg side\n      m_fPos = m_fFalse;\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fFalse < 0)\n    {\n      m_fXNeg = m_fXFalse; // the root is in the xPos side\n      m_fNeg = m_fFalse;\n    }\n    else\n    {\n      m_fXPos = m_fXFalse; // the root is in the xNeg side\n      m_fPos = m_fFalse;\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "if", "(", "m_fFalse", "<", "0", ")", "{", "m_fXNeg", "=", "m_fXFalse", ";", "// the root is in the xPos side", "m_fNeg", "=", "m_fFalse", ";", "}", "else", "{", "m_fXPos", "=", "m_fXFalse", ";", "// the root is in the xNeg side", "m_fPos", "=", "m_fFalse", ";", "}", "}"], "docstring": "Do the regula falsi iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "regula", "falsi", "iteration", "procedure", "."]}
{"code": "m_fXnm1 = m_fXn;", "comments": "x[n-1] = x[n]", "lines": 8, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/SecantRootFinder.java", "func_name": "SecantRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "// Use the latest two points.", "m_fXnm1", "=", "m_fXn", ";", "// x[n-1] = x[n]", "m_fXn", "=", "m_fXnp1", ";", "// x[n] = x[n+1]", "m_fFnm1", "=", "m_fFn", ";", "// f(x[n-1]) = f(x[n])", "m_fFn", "=", "m_fFnp1", ";", "// f(x[n]) = f(x[n+1])", "}"], "docstring": "Do the secant iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "secant", "iteration", "procedure", "."]}
{"code": "m_fXn = m_fXnp1;", "comments": "x[n] = x[n+1]", "lines": 9, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/SecantRootFinder.java", "func_name": "SecantRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "// Use the latest two points.", "m_fXnm1", "=", "m_fXn", ";", "// x[n-1] = x[n]", "m_fXn", "=", "m_fXnp1", ";", "// x[n] = x[n+1]", "m_fFnm1", "=", "m_fFn", ";", "// f(x[n-1]) = f(x[n])", "m_fFn", "=", "m_fFnp1", ";", "// f(x[n]) = f(x[n+1])", "}"], "docstring": "Do the secant iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "secant", "iteration", "procedure", "."]}
{"code": "m_fFnm1 = m_fFn;", "comments": "f(x[n-1]) = f(x[n])", "lines": 10, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/SecantRootFinder.java", "func_name": "SecantRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "// Use the latest two points.", "m_fXnm1", "=", "m_fXn", ";", "// x[n-1] = x[n]", "m_fXn", "=", "m_fXnp1", ";", "// x[n] = x[n+1]", "m_fFnm1", "=", "m_fFn", ";", "// f(x[n-1]) = f(x[n])", "m_fFn", "=", "m_fFnp1", ";", "// f(x[n]) = f(x[n+1])", "}"], "docstring": "Do the secant iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "secant", "iteration", "procedure", "."]}
{"code": "m_fFn = m_fFnp1;", "comments": "f(x[n]) = f(x[n+1])", "lines": 11, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/SecantRootFinder.java", "func_name": "SecantRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    // Use the latest two points.\n    m_fXnm1 = m_fXn; // x[n-1] = x[n]\n    m_fXn = m_fXnp1; // x[n] = x[n+1]\n    m_fFnm1 = m_fFn; // f(x[n-1]) = f(x[n])\n    m_fFn = m_fFnp1; // f(x[n]) = f(x[n+1])\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "// Use the latest two points.", "m_fXnm1", "=", "m_fXn", ";", "// x[n-1] = x[n]", "m_fXn", "=", "m_fXnp1", ";", "// x[n] = x[n+1]", "m_fFnm1", "=", "m_fFn", ";", "// f(x[n-1]) = f(x[n])", "m_fFn", "=", "m_fFnp1", ";", "// f(x[n]) = f(x[n+1])", "}"], "docstring": "Do the secant iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "secant", "iteration", "procedure", "."]}
{"code": "int prime = 2;", "comments": "first prime number", "lines": 10, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/PrimeFactors.java", "func_name": "PrimeFactors.primeSieve", "original_string": "public static boolean [] primeSieve (final int n)\n  {\n    final int halfN = (n + 1) >> 1;\n    final boolean sieve[] = new boolean [n + 1];\n\n    // Initialize every integer from 2 onwards to prime.\n    for (int i = 2; i <= n; ++i)\n      sieve[i] = true;\n\n    int prime = 2; // first prime number\n\n    // Loop to create the sieve.\n    while (prime < halfN)\n    {\n\n      // Mark as composites multiples of the prime.\n      for (int composite = prime << 1; composite <= n; composite += prime)\n        sieve[composite] = false;\n\n      // Skip over composites to the next prime.\n      while ((++prime < halfN) && (!sieve[prime]))\n      {}\n    }\n\n    return sieve;\n  }", "language": "java", "Allcodes": "public static boolean [] primeSieve (final int n)\n  {\n    final int halfN = (n + 1) >> 1;\n    final boolean sieve[] = new boolean [n + 1];\n\n    // Initialize every integer from 2 onwards to prime.\n    for (int i = 2; i <= n; ++i)\n      sieve[i] = true;\n\n    int prime = 2; // first prime number\n\n    // Loop to create the sieve.\n    while (prime < halfN)\n    {\n\n      // Mark as composites multiples of the prime.\n      for (int composite = prime << 1; composite <= n; composite += prime)\n        sieve[composite] = false;\n\n      // Skip over composites to the next prime.\n      while ((++prime < halfN) && (!sieve[prime]))\n      {}\n    }\n\n    return sieve;\n  }", "code_tokens": ["public", "static", "boolean", "[", "]", "primeSieve", "(", "final", "int", "n", ")", "{", "final", "int", "halfN", "=", "(", "n", "+", "1", ")", ">>", "1", ";", "final", "boolean", "sieve", "[", "]", "=", "new", "boolean", "[", "n", "+", "1", "]", ";", "// Initialize every integer from 2 onwards to prime.", "for", "(", "int", "i", "=", "2", ";", "i", "<=", "n", ";", "++", "i", ")", "sieve", "[", "i", "]", "=", "true", ";", "int", "prime", "=", "2", ";", "// first prime number", "// Loop to create the sieve.", "while", "(", "prime", "<", "halfN", ")", "{", "// Mark as composites multiples of the prime.", "for", "(", "int", "composite", "=", "prime", "<<", "1", ";", "composite", "<=", "n", ";", "composite", "+=", "prime", ")", "sieve", "[", "composite", "]", "=", "false", ";", "// Skip over composites to the next prime.", "while", "(", "(", "++", "prime", "<", "halfN", ")", "&&", "(", "!", "sieve", "[", "prime", "]", ")", ")", "{", "}", "}", "return", "sieve", ";", "}"], "docstring": "Compute the Sieve of Eratosthenes.\n\n@param n\nthe size of the sieve\n@return the sieve as a boolean array (each element is true if the\ncorresponding number is prime, false if the number is composite)", "docstring_tokens": ["Compute", "the", "Sieve", "of", "Eratosthenes", "."]}
{"code": "final boolean isPrime[] = primeSieve (n);", "comments": "primes <= n", "lines": 4, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/PrimeFactors.java", "func_name": "PrimeFactors.factorsOf", "original_string": "public static int [] factorsOf (final int pn)\n  {\n    int n = pn;\n    final boolean isPrime[] = primeSieve (n); // primes <= n\n    final ICommonsList <Integer> v = new CommonsArrayList<> ();\n\n    // Loop to try prime divisors.\n    for (int factor = 2; n > 1; ++factor)\n    {\n      if (isPrime[factor] && (n % factor == 0))\n      {\n\n        // Prime divisor found.\n        v.add (Integer.valueOf (factor));\n\n        // Factor out multiples of the divisor.\n        do\n        {\n          n /= factor;\n        } while (n % factor == 0);\n      }\n    }\n\n    // Create an array of the distinct prime factors.\n    final int factors[] = new int [v.size ()];\n    for (int i = 0; i < v.size (); ++i)\n    {\n      factors[i] = v.get (i).intValue ();\n    }\n    return factors;\n  }", "language": "java", "Allcodes": "public static int [] factorsOf (final int pn)\n  {\n    int n = pn;\n    final boolean isPrime[] = primeSieve (n); // primes <= n\n    final ICommonsList <Integer> v = new CommonsArrayList<> ();\n\n    // Loop to try prime divisors.\n    for (int factor = 2; n > 1; ++factor)\n    {\n      if (isPrime[factor] && (n % factor == 0))\n      {\n\n        // Prime divisor found.\n        v.add (Integer.valueOf (factor));\n\n        // Factor out multiples of the divisor.\n        do\n        {\n          n /= factor;\n        } while (n % factor == 0);\n      }\n    }\n\n    // Create an array of the distinct prime factors.\n    final int factors[] = new int [v.size ()];\n    for (int i = 0; i < v.size (); ++i)\n    {\n      factors[i] = v.get (i).intValue ();\n    }\n    return factors;\n  }", "code_tokens": ["public", "static", "int", "[", "]", "factorsOf", "(", "final", "int", "pn", ")", "{", "int", "n", "=", "pn", ";", "final", "boolean", "isPrime", "[", "]", "=", "primeSieve", "(", "n", ")", ";", "// primes <= n", "final", "ICommonsList", "<", "Integer", ">", "v", "=", "new", "CommonsArrayList", "<>", "(", ")", ";", "// Loop to try prime divisors.", "for", "(", "int", "factor", "=", "2", ";", "n", ">", "1", ";", "++", "factor", ")", "{", "if", "(", "isPrime", "[", "factor", "]", "&&", "(", "n", "%", "factor", "==", "0", ")", ")", "{", "// Prime divisor found.", "v", ".", "add", "(", "Integer", ".", "valueOf", "(", "factor", ")", ")", ";", "// Factor out multiples of the divisor.", "do", "{", "n", "/=", "factor", ";", "}", "while", "(", "n", "%", "factor", "==", "0", ")", ";", "}", "}", "// Create an array of the distinct prime factors.", "final", "int", "factors", "[", "]", "=", "new", "int", "[", "v", ".", "size", "(", ")", "]", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "v", ".", "size", "(", ")", ";", "++", "i", ")", "{", "factors", "[", "i", "]", "=", "v", ".", "get", "(", "i", ")", ".", "intValue", "(", ")", ";", "}", "return", "factors", ";", "}"], "docstring": "Compute the prime factors of an integer value.\n\n@param pn\nthe value to factor\n@return an array of distinct prime factors", "docstring_tokens": ["Compute", "the", "prime", "factors", "of", "an", "integer", "value", "."]}
{"code": "m_fXNeg = m_fXMid;", "comments": "the root is in the xPos half", "lines": 9, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/BisectionRootFinder.java", "func_name": "BisectionRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fMid < 0)\n    {\n      m_fXNeg = m_fXMid; // the root is in the xPos half\n      m_fNeg = m_fMid;\n    }\n    else\n    {\n      m_fXPos = m_fXMid; // the root is in the xNeg half\n      m_fPos = m_fMid;\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fMid < 0)\n    {\n      m_fXNeg = m_fXMid; // the root is in the xPos half\n      m_fNeg = m_fMid;\n    }\n    else\n    {\n      m_fXPos = m_fXMid; // the root is in the xNeg half\n      m_fPos = m_fMid;\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "if", "(", "m_fMid", "<", "0", ")", "{", "m_fXNeg", "=", "m_fXMid", ";", "// the root is in the xPos half", "m_fNeg", "=", "m_fMid", ";", "}", "else", "{", "m_fXPos", "=", "m_fXMid", ";", "// the root is in the xNeg half", "m_fPos", "=", "m_fMid", ";", "}", "}"], "docstring": "Do the bisection iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "bisection", "iteration", "procedure", "."]}
{"code": "m_fXPos = m_fXMid;", "comments": "the root is in the xNeg half", "lines": 14, "repo": "phax/ph-math", "path": "ph-math/src/main/java/com/helger/numbercruncher/mathutils/BisectionRootFinder.java", "func_name": "BisectionRootFinder.doIterationProcedure", "original_string": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fMid < 0)\n    {\n      m_fXNeg = m_fXMid; // the root is in the xPos half\n      m_fNeg = m_fMid;\n    }\n    else\n    {\n      m_fXPos = m_fXMid; // the root is in the xNeg half\n      m_fPos = m_fMid;\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected void doIterationProcedure (final int n)\n  {\n    if (n == 1)\n      return; // already initialized\n\n    if (m_fMid < 0)\n    {\n      m_fXNeg = m_fXMid; // the root is in the xPos half\n      m_fNeg = m_fMid;\n    }\n    else\n    {\n      m_fXPos = m_fXMid; // the root is in the xNeg half\n      m_fPos = m_fMid;\n    }\n  }", "code_tokens": ["@", "Override", "protected", "void", "doIterationProcedure", "(", "final", "int", "n", ")", "{", "if", "(", "n", "==", "1", ")", "return", ";", "// already initialized", "if", "(", "m_fMid", "<", "0", ")", "{", "m_fXNeg", "=", "m_fXMid", ";", "// the root is in the xPos half", "m_fNeg", "=", "m_fMid", ";", "}", "else", "{", "m_fXPos", "=", "m_fXMid", ";", "// the root is in the xNeg half", "m_fPos", "=", "m_fMid", ";", "}", "}"], "docstring": "Do the bisection iteration procedure.\n\n@param n\nthe iteration count", "docstring_tokens": ["Do", "the", "bisection", "iteration", "procedure", "."]}
{"code": "return e.getEntryArg(1);", "comments": "FIXME check this", "lines": 11, "repo": "jboss/jboss-common-core", "path": "src/main/java/org/jboss/util/xml/catalog/Catalog.java", "func_name": "Catalog.resolveDocument", "original_string": "public String resolveDocument()\n    throws MalformedURLException, IOException {\n    // If there's a DOCUMENT entry, return it\n\n    catalogManager.debug.message(3, \"resolveDocument\");\n\n    Enumeration enumt = catalogEntries.elements();\n    while (enumt.hasMoreElements()) {\n      CatalogEntry e = (CatalogEntry) enumt.nextElement();\n      if (e.getEntryType() == DOCUMENT) {\n\treturn e.getEntryArg(1); //FIXME check this\n      }\n    }\n\n    return resolveSubordinateCatalogs(DOCUMENT,\n\t\t\t\t      null, null, null);\n  }", "language": "java", "Allcodes": "public String resolveDocument()\n    throws MalformedURLException, IOException {\n    // If there's a DOCUMENT entry, return it\n\n    catalogManager.debug.message(3, \"resolveDocument\");\n\n    Enumeration enumt = catalogEntries.elements();\n    while (enumt.hasMoreElements()) {\n      CatalogEntry e = (CatalogEntry) enumt.nextElement();\n      if (e.getEntryType() == DOCUMENT) {\n\treturn e.getEntryArg(1); //FIXME check this\n      }\n    }\n\n    return resolveSubordinateCatalogs(DOCUMENT,\n\t\t\t\t      null, null, null);\n  }", "code_tokens": ["public", "String", "resolveDocument", "(", ")", "throws", "MalformedURLException", ",", "IOException", "{", "// If there's a DOCUMENT entry, return it", "catalogManager", ".", "debug", ".", "message", "(", "3", ",", "\"resolveDocument\"", ")", ";", "Enumeration", "enumt", "=", "catalogEntries", ".", "elements", "(", ")", ";", "while", "(", "enumt", ".", "hasMoreElements", "(", ")", ")", "{", "CatalogEntry", "e", "=", "(", "CatalogEntry", ")", "enumt", ".", "nextElement", "(", ")", ";", "if", "(", "e", ".", "getEntryType", "(", ")", "==", "DOCUMENT", ")", "{", "return", "e", ".", "getEntryArg", "(", "1", ")", ";", "//FIXME check this", "}", "}", "return", "resolveSubordinateCatalogs", "(", "DOCUMENT", ",", "null", ",", "null", ",", "null", ")", ";", "}"], "docstring": "Return the applicable DOCUMENT entry.\n\n@return The system identifier to use for the doctype.\n\n@throws MalformedURLException The formal system identifier of a\nsubordinate catalog cannot be turned into a valid URL.\n@throws IOException Error reading subordinate catalog file.", "docstring_tokens": ["Return", "the", "applicable", "DOCUMENT", "entry", "."]}
{"code": "swap(index, size);", "comments": "Exchange removed node with last leaf node", "lines": 14, "repo": "jboss/jboss-common-core", "path": "src/main/java/org/jboss/util/timeout/TimeoutPriorityQueueImpl.java", "func_name": "TimeoutPriorityQueueImpl.removeNode", "original_string": "private TimeoutExtImpl removeNode(int index)\n   {\n      // INV: assertExpr(index > 0);\n      // INV: assertExpr(index <= size);\n      TimeoutExtImpl res = queue[index];\n      // INV: assertExpr(res != null);\n      // INV: assertExpr(res.index == index);\n      if (index == size)\n      {\n         --size;\n         queue[index] = null;\n         return res;\n      }\n      swap(index, size); // Exchange removed node with last leaf node\n      --size;\n      // INV: assertExpr(res.index == size + 1);\n      queue[res.index] = null;\n      if (normalizeUp(index))\n         return res; // Node moved up, so it shouldn't move down\n      long t = queue[index].time;\n      int c = index << 1;\n      while (c <= size)\n      {\n         // INV: assertExpr(q[index].time == t);\n         TimeoutExtImpl l = queue[c];\n         // INV: assertExpr(l != null);\n         // INV: assertExpr(l.index == c);\n         if (c + 1 <= size)\n         {\n            // two children, swap with smallest\n            TimeoutExtImpl r = queue[c + 1];\n            // INV: assertExpr(r != null);\n            // INV: assertExpr(r.index == c+1);\n            if (l.time <= r.time)\n            {\n               if (t <= l.time)\n                  break; // done\n               swap(index, c);\n               index = c;\n            }\n            else\n            {\n               if (t <= r.time)\n                  break; // done\n               swap(index, c + 1);\n               index = c + 1;\n            }\n         }\n         else\n         { // one child\n            if (t <= l.time)\n               break; // done\n            swap(index, c);\n            index = c;\n         }\n         c = index << 1;\n      }\n      return res;\n   }", "language": "java", "Allcodes": "private TimeoutExtImpl removeNode(int index)\n   {\n      // INV: assertExpr(index > 0);\n      // INV: assertExpr(index <= size);\n      TimeoutExtImpl res = queue[index];\n      // INV: assertExpr(res != null);\n      // INV: assertExpr(res.index == index);\n      if (index == size)\n      {\n         --size;\n         queue[index] = null;\n         return res;\n      }\n      swap(index, size); // Exchange removed node with last leaf node\n      --size;\n      // INV: assertExpr(res.index == size + 1);\n      queue[res.index] = null;\n      if (normalizeUp(index))\n         return res; // Node moved up, so it shouldn't move down\n      long t = queue[index].time;\n      int c = index << 1;\n      while (c <= size)\n      {\n         // INV: assertExpr(q[index].time == t);\n         TimeoutExtImpl l = queue[c];\n         // INV: assertExpr(l != null);\n         // INV: assertExpr(l.index == c);\n         if (c + 1 <= size)\n         {\n            // two children, swap with smallest\n            TimeoutExtImpl r = queue[c + 1];\n            // INV: assertExpr(r != null);\n            // INV: assertExpr(r.index == c+1);\n            if (l.time <= r.time)\n            {\n               if (t <= l.time)\n                  break; // done\n               swap(index, c);\n               index = c;\n            }\n            else\n            {\n               if (t <= r.time)\n                  break; // done\n               swap(index, c + 1);\n               index = c + 1;\n            }\n         }\n         else\n         { // one child\n            if (t <= l.time)\n               break; // done\n            swap(index, c);\n            index = c;\n         }\n         c = index << 1;\n      }\n      return res;\n   }", "code_tokens": ["private", "TimeoutExtImpl", "removeNode", "(", "int", "index", ")", "{", "// INV: assertExpr(index > 0);", "// INV: assertExpr(index <= size);", "TimeoutExtImpl", "res", "=", "queue", "[", "index", "]", ";", "// INV: assertExpr(res != null);", "// INV: assertExpr(res.index == index);", "if", "(", "index", "==", "size", ")", "{", "--", "size", ";", "queue", "[", "index", "]", "=", "null", ";", "return", "res", ";", "}", "swap", "(", "index", ",", "size", ")", ";", "// Exchange removed node with last leaf node", "--", "size", ";", "// INV: assertExpr(res.index == size + 1);", "queue", "[", "res", ".", "index", "]", "=", "null", ";", "if", "(", "normalizeUp", "(", "index", ")", ")", "return", "res", ";", "// Node moved up, so it shouldn't move down", "long", "t", "=", "queue", "[", "index", "]", ".", "time", ";", "int", "c", "=", "index", "<<", "1", ";", "while", "(", "c", "<=", "size", ")", "{", "// INV: assertExpr(q[index].time == t);", "TimeoutExtImpl", "l", "=", "queue", "[", "c", "]", ";", "// INV: assertExpr(l != null);", "// INV: assertExpr(l.index == c);", "if", "(", "c", "+", "1", "<=", "size", ")", "{", "// two children, swap with smallest", "TimeoutExtImpl", "r", "=", "queue", "[", "c", "+", "1", "]", ";", "// INV: assertExpr(r != null);", "// INV: assertExpr(r.index == c+1);", "if", "(", "l", ".", "time", "<=", "r", ".", "time", ")", "{", "if", "(", "t", "<=", "l", ".", "time", ")", "break", ";", "// done", "swap", "(", "index", ",", "c", ")", ";", "index", "=", "c", ";", "}", "else", "{", "if", "(", "t", "<=", "r", ".", "time", ")", "break", ";", "// done", "swap", "(", "index", ",", "c", "+", "1", ")", ";", "index", "=", "c", "+", "1", ";", "}", "}", "else", "{", "// one child", "if", "(", "t", "<=", "l", ".", "time", ")", "break", ";", "// done", "swap", "(", "index", ",", "c", ")", ";", "index", "=", "c", ";", "}", "c", "=", "index", "<<", "1", ";", "}", "return", "res", ";", "}"], "docstring": "Remove a node from the tree and normalize.\n\n@param index the index in the queue\n@return the removed node.", "docstring_tokens": ["Remove", "a", "node", "from", "the", "tree", "and", "normalize", "."]}
{"code": "return res;", "comments": "Node moved up, so it shouldn't move down", "lines": 19, "repo": "jboss/jboss-common-core", "path": "src/main/java/org/jboss/util/timeout/TimeoutPriorityQueueImpl.java", "func_name": "TimeoutPriorityQueueImpl.removeNode", "original_string": "private TimeoutExtImpl removeNode(int index)\n   {\n      // INV: assertExpr(index > 0);\n      // INV: assertExpr(index <= size);\n      TimeoutExtImpl res = queue[index];\n      // INV: assertExpr(res != null);\n      // INV: assertExpr(res.index == index);\n      if (index == size)\n      {\n         --size;\n         queue[index] = null;\n         return res;\n      }\n      swap(index, size); // Exchange removed node with last leaf node\n      --size;\n      // INV: assertExpr(res.index == size + 1);\n      queue[res.index] = null;\n      if (normalizeUp(index))\n         return res; // Node moved up, so it shouldn't move down\n      long t = queue[index].time;\n      int c = index << 1;\n      while (c <= size)\n      {\n         // INV: assertExpr(q[index].time == t);\n         TimeoutExtImpl l = queue[c];\n         // INV: assertExpr(l != null);\n         // INV: assertExpr(l.index == c);\n         if (c + 1 <= size)\n         {\n            // two children, swap with smallest\n            TimeoutExtImpl r = queue[c + 1];\n            // INV: assertExpr(r != null);\n            // INV: assertExpr(r.index == c+1);\n            if (l.time <= r.time)\n            {\n               if (t <= l.time)\n                  break; // done\n               swap(index, c);\n               index = c;\n            }\n            else\n            {\n               if (t <= r.time)\n                  break; // done\n               swap(index, c + 1);\n               index = c + 1;\n            }\n         }\n         else\n         { // one child\n            if (t <= l.time)\n               break; // done\n            swap(index, c);\n            index = c;\n         }\n         c = index << 1;\n      }\n      return res;\n   }", "language": "java", "Allcodes": "private TimeoutExtImpl removeNode(int index)\n   {\n      // INV: assertExpr(index > 0);\n      // INV: assertExpr(index <= size);\n      TimeoutExtImpl res = queue[index];\n      // INV: assertExpr(res != null);\n      // INV: assertExpr(res.index == index);\n      if (index == size)\n      {\n         --size;\n         queue[index] = null;\n         return res;\n      }\n      swap(index, size); // Exchange removed node with last leaf node\n      --size;\n      // INV: assertExpr(res.index == size + 1);\n      queue[res.index] = null;\n      if (normalizeUp(index))\n         return res; // Node moved up, so it shouldn't move down\n      long t = queue[index].time;\n      int c = index << 1;\n      while (c <= size)\n      {\n         // INV: assertExpr(q[index].time == t);\n         TimeoutExtImpl l = queue[c];\n         // INV: assertExpr(l != null);\n         // INV: assertExpr(l.index == c);\n         if (c + 1 <= size)\n         {\n            // two children, swap with smallest\n            TimeoutExtImpl r = queue[c + 1];\n            // INV: assertExpr(r != null);\n            // INV: assertExpr(r.index == c+1);\n            if (l.time <= r.time)\n            {\n               if (t <= l.time)\n                  break; // done\n               swap(index, c);\n               index = c;\n            }\n            else\n            {\n               if (t <= r.time)\n                  break; // done\n               swap(index, c + 1);\n               index = c + 1;\n            }\n         }\n         else\n         { // one child\n            if (t <= l.time)\n               break; // done\n            swap(index, c);\n            index = c;\n         }\n         c = index << 1;\n      }\n      return res;\n   }", "code_tokens": ["private", "TimeoutExtImpl", "removeNode", "(", "int", "index", ")", "{", "// INV: assertExpr(index > 0);", "// INV: assertExpr(index <= size);", "TimeoutExtImpl", "res", "=", "queue", "[", "index", "]", ";", "// INV: assertExpr(res != null);", "// INV: assertExpr(res.index == index);", "if", "(", "index", "==", "size", ")", "{", "--", "size", ";", "queue", "[", "index", "]", "=", "null", ";", "return", "res", ";", "}", "swap", "(", "index", ",", "size", ")", ";", "// Exchange removed node with last leaf node", "--", "size", ";", "// INV: assertExpr(res.index == size + 1);", "queue", "[", "res", ".", "index", "]", "=", "null", ";", "if", "(", "normalizeUp", "(", "index", ")", ")", "return", "res", ";", "// Node moved up, so it shouldn't move down", "long", "t", "=", "queue", "[", "index", "]", ".", "time", ";", "int", "c", "=", "index", "<<", "1", ";", "while", "(", "c", "<=", "size", ")", "{", "// INV: assertExpr(q[index].time == t);", "TimeoutExtImpl", "l", "=", "queue", "[", "c", "]", ";", "// INV: assertExpr(l != null);", "// INV: assertExpr(l.index == c);", "if", "(", "c", "+", "1", "<=", "size", ")", "{", "// two children, swap with smallest", "TimeoutExtImpl", "r", "=", "queue", "[", "c", "+", "1", "]", ";", "// INV: assertExpr(r != null);", "// INV: assertExpr(r.index == c+1);", "if", "(", "l", ".", "time", "<=", "r", ".", "time", ")", "{", "if", "(", "t", "<=", "l", ".", "time", ")", "break", ";", "// done", "swap", "(", "index", ",", "c", ")", ";", "index", "=", "c", ";", "}", "else", "{", "if", "(", "t", "<=", "r", ".", "time", ")", "break", ";", "// done", "swap", "(", "index", ",", "c", "+", "1", ")", ";", "index", "=", "c", "+", "1", ";", "}", "}", "else", "{", "// one child", "if", "(", "t", "<=", "l", ".", "time", ")", "break", ";", "// done", "swap", "(", "index", ",", "c", ")", ";", "index", "=", "c", ";", "}", "c", "=", "index", "<<", "1", ";", "}", "return", "res", ";", "}"], "docstring": "Remove a node from the tree and normalize.\n\n@param index the index in the queue\n@return the removed node.", "docstring_tokens": ["Remove", "a", "node", "from", "the", "tree", "and", "normalize", "."]}
{"code": "logger.detachAndStopAllAppenders();", "comments": "detach console (doesn't seem to work)", "lines": 14, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/util/Log.java", "func_name": "Log.createLogger", "original_string": "public static Logger createLogger(String name, Level level, String file) {\n    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n    PatternLayoutEncoder ple = new PatternLayoutEncoder();\n    ple.setPattern(\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\");\n    ple.setContext(lc);\n    ple.start();\n    FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n    fileAppender.setFile(file);\n    fileAppender.setEncoder(ple);\n    fileAppender.setAppend(false);\n    fileAppender.setContext(lc);\n    fileAppender.start();\n    logger = (Logger) LoggerFactory.getLogger(name);\n    logger.detachAndStopAllAppenders(); // detach console (doesn't seem to work)\n    logger.addAppender(fileAppender); // attach file appender\n    logger.setLevel(level);\n    logger.setAdditive(true); // set to true if root should log too\n\n    return logger;\n  }", "language": "java", "Allcodes": "public static Logger createLogger(String name, Level level, String file) {\n    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n    PatternLayoutEncoder ple = new PatternLayoutEncoder();\n    ple.setPattern(\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\");\n    ple.setContext(lc);\n    ple.start();\n    FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n    fileAppender.setFile(file);\n    fileAppender.setEncoder(ple);\n    fileAppender.setAppend(false);\n    fileAppender.setContext(lc);\n    fileAppender.start();\n    logger = (Logger) LoggerFactory.getLogger(name);\n    logger.detachAndStopAllAppenders(); // detach console (doesn't seem to work)\n    logger.addAppender(fileAppender); // attach file appender\n    logger.setLevel(level);\n    logger.setAdditive(true); // set to true if root should log too\n\n    return logger;\n  }", "code_tokens": ["public", "static", "Logger", "createLogger", "(", "String", "name", ",", "Level", "level", ",", "String", "file", ")", "{", "LoggerContext", "lc", "=", "(", "LoggerContext", ")", "LoggerFactory", ".", "getILoggerFactory", "(", ")", ";", "PatternLayoutEncoder", "ple", "=", "new", "PatternLayoutEncoder", "(", ")", ";", "ple", ".", "setPattern", "(", "\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\"", ")", ";", "ple", ".", "setContext", "(", "lc", ")", ";", "ple", ".", "start", "(", ")", ";", "FileAppender", "<", "ILoggingEvent", ">", "fileAppender", "=", "new", "FileAppender", "<", "ILoggingEvent", ">", "(", ")", ";", "fileAppender", ".", "setFile", "(", "file", ")", ";", "fileAppender", ".", "setEncoder", "(", "ple", ")", ";", "fileAppender", ".", "setAppend", "(", "false", ")", ";", "fileAppender", ".", "setContext", "(", "lc", ")", ";", "fileAppender", ".", "start", "(", ")", ";", "logger", "=", "(", "Logger", ")", "LoggerFactory", ".", "getLogger", "(", "name", ")", ";", "logger", ".", "detachAndStopAllAppenders", "(", ")", ";", "// detach console (doesn't seem to work)", "logger", ".", "addAppender", "(", "fileAppender", ")", ";", "// attach file appender", "logger", ".", "setLevel", "(", "level", ")", ";", "logger", ".", "setAdditive", "(", "true", ")", ";", "// set to true if root should log too", "return", "logger", ";", "}"], "docstring": "Creates a new logger.\n\n@param name a name for the logger\n@param level the logging level for the logger\n@param file the file to output all logging to\n@return the created logger", "docstring_tokens": ["Creates", "a", "new", "logger", "."]}
{"code": "logger.addAppender(fileAppender);", "comments": "attach file appender", "lines": 15, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/util/Log.java", "func_name": "Log.createLogger", "original_string": "public static Logger createLogger(String name, Level level, String file) {\n    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n    PatternLayoutEncoder ple = new PatternLayoutEncoder();\n    ple.setPattern(\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\");\n    ple.setContext(lc);\n    ple.start();\n    FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n    fileAppender.setFile(file);\n    fileAppender.setEncoder(ple);\n    fileAppender.setAppend(false);\n    fileAppender.setContext(lc);\n    fileAppender.start();\n    logger = (Logger) LoggerFactory.getLogger(name);\n    logger.detachAndStopAllAppenders(); // detach console (doesn't seem to work)\n    logger.addAppender(fileAppender); // attach file appender\n    logger.setLevel(level);\n    logger.setAdditive(true); // set to true if root should log too\n\n    return logger;\n  }", "language": "java", "Allcodes": "public static Logger createLogger(String name, Level level, String file) {\n    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n    PatternLayoutEncoder ple = new PatternLayoutEncoder();\n    ple.setPattern(\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\");\n    ple.setContext(lc);\n    ple.start();\n    FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n    fileAppender.setFile(file);\n    fileAppender.setEncoder(ple);\n    fileAppender.setAppend(false);\n    fileAppender.setContext(lc);\n    fileAppender.start();\n    logger = (Logger) LoggerFactory.getLogger(name);\n    logger.detachAndStopAllAppenders(); // detach console (doesn't seem to work)\n    logger.addAppender(fileAppender); // attach file appender\n    logger.setLevel(level);\n    logger.setAdditive(true); // set to true if root should log too\n\n    return logger;\n  }", "code_tokens": ["public", "static", "Logger", "createLogger", "(", "String", "name", ",", "Level", "level", ",", "String", "file", ")", "{", "LoggerContext", "lc", "=", "(", "LoggerContext", ")", "LoggerFactory", ".", "getILoggerFactory", "(", ")", ";", "PatternLayoutEncoder", "ple", "=", "new", "PatternLayoutEncoder", "(", ")", ";", "ple", ".", "setPattern", "(", "\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\"", ")", ";", "ple", ".", "setContext", "(", "lc", ")", ";", "ple", ".", "start", "(", ")", ";", "FileAppender", "<", "ILoggingEvent", ">", "fileAppender", "=", "new", "FileAppender", "<", "ILoggingEvent", ">", "(", ")", ";", "fileAppender", ".", "setFile", "(", "file", ")", ";", "fileAppender", ".", "setEncoder", "(", "ple", ")", ";", "fileAppender", ".", "setAppend", "(", "false", ")", ";", "fileAppender", ".", "setContext", "(", "lc", ")", ";", "fileAppender", ".", "start", "(", ")", ";", "logger", "=", "(", "Logger", ")", "LoggerFactory", ".", "getLogger", "(", "name", ")", ";", "logger", ".", "detachAndStopAllAppenders", "(", ")", ";", "// detach console (doesn't seem to work)", "logger", ".", "addAppender", "(", "fileAppender", ")", ";", "// attach file appender", "logger", ".", "setLevel", "(", "level", ")", ";", "logger", ".", "setAdditive", "(", "true", ")", ";", "// set to true if root should log too", "return", "logger", ";", "}"], "docstring": "Creates a new logger.\n\n@param name a name for the logger\n@param level the logging level for the logger\n@param file the file to output all logging to\n@return the created logger", "docstring_tokens": ["Creates", "a", "new", "logger", "."]}
{"code": "logger.setAdditive(true);", "comments": "set to true if root should log too", "lines": 17, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/util/Log.java", "func_name": "Log.createLogger", "original_string": "public static Logger createLogger(String name, Level level, String file) {\n    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n    PatternLayoutEncoder ple = new PatternLayoutEncoder();\n    ple.setPattern(\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\");\n    ple.setContext(lc);\n    ple.start();\n    FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n    fileAppender.setFile(file);\n    fileAppender.setEncoder(ple);\n    fileAppender.setAppend(false);\n    fileAppender.setContext(lc);\n    fileAppender.start();\n    logger = (Logger) LoggerFactory.getLogger(name);\n    logger.detachAndStopAllAppenders(); // detach console (doesn't seem to work)\n    logger.addAppender(fileAppender); // attach file appender\n    logger.setLevel(level);\n    logger.setAdditive(true); // set to true if root should log too\n\n    return logger;\n  }", "language": "java", "Allcodes": "public static Logger createLogger(String name, Level level, String file) {\n    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n    PatternLayoutEncoder ple = new PatternLayoutEncoder();\n    ple.setPattern(\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\");\n    ple.setContext(lc);\n    ple.start();\n    FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();\n    fileAppender.setFile(file);\n    fileAppender.setEncoder(ple);\n    fileAppender.setAppend(false);\n    fileAppender.setContext(lc);\n    fileAppender.start();\n    logger = (Logger) LoggerFactory.getLogger(name);\n    logger.detachAndStopAllAppenders(); // detach console (doesn't seem to work)\n    logger.addAppender(fileAppender); // attach file appender\n    logger.setLevel(level);\n    logger.setAdditive(true); // set to true if root should log too\n\n    return logger;\n  }", "code_tokens": ["public", "static", "Logger", "createLogger", "(", "String", "name", ",", "Level", "level", ",", "String", "file", ")", "{", "LoggerContext", "lc", "=", "(", "LoggerContext", ")", "LoggerFactory", ".", "getILoggerFactory", "(", ")", ";", "PatternLayoutEncoder", "ple", "=", "new", "PatternLayoutEncoder", "(", ")", ";", "ple", ".", "setPattern", "(", "\"%date %level [%thread] %logger{10} [%file:%line]%n%msg%n%n\"", ")", ";", "ple", ".", "setContext", "(", "lc", ")", ";", "ple", ".", "start", "(", ")", ";", "FileAppender", "<", "ILoggingEvent", ">", "fileAppender", "=", "new", "FileAppender", "<", "ILoggingEvent", ">", "(", ")", ";", "fileAppender", ".", "setFile", "(", "file", ")", ";", "fileAppender", ".", "setEncoder", "(", "ple", ")", ";", "fileAppender", ".", "setAppend", "(", "false", ")", ";", "fileAppender", ".", "setContext", "(", "lc", ")", ";", "fileAppender", ".", "start", "(", ")", ";", "logger", "=", "(", "Logger", ")", "LoggerFactory", ".", "getLogger", "(", "name", ")", ";", "logger", ".", "detachAndStopAllAppenders", "(", ")", ";", "// detach console (doesn't seem to work)", "logger", ".", "addAppender", "(", "fileAppender", ")", ";", "// attach file appender", "logger", ".", "setLevel", "(", "level", ")", ";", "logger", ".", "setAdditive", "(", "true", ")", ";", "// set to true if root should log too", "return", "logger", ";", "}"], "docstring": "Creates a new logger.\n\n@param name a name for the logger\n@param level the logging level for the logger\n@param file the file to output all logging to\n@return the created logger", "docstring_tokens": ["Creates", "a", "new", "logger", "."]}
{"code": "thread.start();", "comments": "start and wait at the entry barrier", "lines": 5, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/Program.java", "func_name": "Program.startIntentionSelectionThreads", "original_string": "static void startIntentionSelectionThreads() {\n    for (int i = 0; i < Main.npools; i++) {\n      Thread thread = new Thread(Main.intentionSelectors[i]);\n      thread.setName(\"jill-\" + i);\n      thread.start(); // start and wait at the entry barrier\n    }\n  }", "language": "java", "Allcodes": "static void startIntentionSelectionThreads() {\n    for (int i = 0; i < Main.npools; i++) {\n      Thread thread = new Thread(Main.intentionSelectors[i]);\n      thread.setName(\"jill-\" + i);\n      thread.start(); // start and wait at the entry barrier\n    }\n  }", "code_tokens": ["static", "void", "startIntentionSelectionThreads", "(", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "Main", ".", "npools", ";", "i", "++", ")", "{", "Thread", "thread", "=", "new", "Thread", "(", "Main", ".", "intentionSelectors", "[", "i", "]", ")", ";", "thread", ".", "setName", "(", "\"jill-\"", "+", "i", ")", ";", "thread", ".", "start", "(", ")", ";", "// start and wait at the entry barrier", "}", "}"], "docstring": "Starts the intention selection threads.", "docstring_tokens": ["Starts", "the", "intention", "selection", "threads", "."]}
{"code": "parseArgumentWithOption(args[i], args[++i]);", "comments": "force increment the counter", "lines": 9, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/util/ArgumentsLoader.java", "func_name": "ArgumentsLoader.parse", "original_string": "public static void parse(String[] args) {\n    for (int i = 0; args != null && i < args.length; i++) {\n      // First parse args that don't require an option\n      if (\"--help\".equals(args[i])) {\n        abort(null);\n      }\n      // Now parse args that must be accompanied by an option\n      if (i + 1 < args.length) {\n        parseArgumentWithOption(args[i], args[++i]); // force increment the counter\n      }\n    }\n    // Abort if required args were not given\n    if (config == null) {\n      abort(\"Configuration file or string was not given\");\n    } else if (config.getAgents() == null || config.getAgents().isEmpty()) {\n      abort(\"Configuration is missing agents specification\");\n    }\n  }", "language": "java", "Allcodes": "public static void parse(String[] args) {\n    for (int i = 0; args != null && i < args.length; i++) {\n      // First parse args that don't require an option\n      if (\"--help\".equals(args[i])) {\n        abort(null);\n      }\n      // Now parse args that must be accompanied by an option\n      if (i + 1 < args.length) {\n        parseArgumentWithOption(args[i], args[++i]); // force increment the counter\n      }\n    }\n    // Abort if required args were not given\n    if (config == null) {\n      abort(\"Configuration file or string was not given\");\n    } else if (config.getAgents() == null || config.getAgents().isEmpty()) {\n      abort(\"Configuration is missing agents specification\");\n    }\n  }", "code_tokens": ["public", "static", "void", "parse", "(", "String", "[", "]", "args", ")", "{", "for", "(", "int", "i", "=", "0", ";", "args", "!=", "null", "&&", "i", "<", "args", ".", "length", ";", "i", "++", ")", "{", "// First parse args that don't require an option", "if", "(", "\"--help\"", ".", "equals", "(", "args", "[", "i", "]", ")", ")", "{", "abort", "(", "null", ")", ";", "}", "// Now parse args that must be accompanied by an option", "if", "(", "i", "+", "1", "<", "args", ".", "length", ")", "{", "parseArgumentWithOption", "(", "args", "[", "i", "]", ",", "args", "[", "++", "i", "]", ")", ";", "// force increment the counter", "}", "}", "// Abort if required args were not given", "if", "(", "config", "==", "null", ")", "{", "abort", "(", "\"Configuration file or string was not given\"", ")", ";", "}", "else", "if", "(", "config", ".", "getAgents", "(", ")", "==", "null", "||", "config", ".", "getAgents", "(", ")", ".", "isEmpty", "(", ")", ")", "{", "abort", "(", "\"Configuration is missing agents specification\"", ")", ";", "}", "}"], "docstring": "Parses the given command line arguments.\n\n@param args the command line arguments", "docstring_tokens": ["Parses", "the", "given", "command", "line", "arguments", "."]}
{"code": "agent.nextActiveStack();", "comments": "select the next active stack for next time", "lines": 28, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/core/IntentionSelector.java", "func_name": "IntentionSelector.run", "original_string": "public void run() {\n    Set<Integer> toRemove = new HashSet<Integer>();\n    do {\n      boolean idle = true;\n      // Remove agents that have have become idle due to an external event\n      removeInactiveAgents();\n      // Add agents that have have become active due to an external event\n      addActiveAgents();\n      for (Integer i : activeAgents) {\n        Agent agent = (Agent) GlobalState.agents.get(i);\n        Stack255 agentExecutionStack = (Stack255) (agent).getExecutionStack();\n        if (!isStackValid(agent, agentExecutionStack)) {\n          // Mark this agent for removal\n          toRemove.add(i);\n          continue;\n        }\n        // At least one agent is active\n        idle = false;\n        // Get the item at the top of the stack\n        Object node = (Object) agentExecutionStack.get((byte) (agentExecutionStack.size() - 1));\n        if (node instanceof Plan) {\n          // If it is a plan then execute a plan step; and if it finished then remove it\n          managePlan(i, agentExecutionStack, (Plan) node, toRemove);\n        } else if (node instanceof Goal) {\n          // If it is a goal then find a plan for it and put it on the stack\n          manageGoal(i, agent, agentExecutionStack, (Goal) node);\n        }\n        agent.nextActiveStack(); // select the next active stack for next time\n      }\n      // remove agents that have finished executing plans and have gone idle in this cycle\n      removeFinishedAgents(toRemove);\n      if (idle) {\n        waitOnExternalMessage();\n        if (shutdown) {\n          break;\n        }\n      }\n    } \n    while (true);\n    logger.debug(\"Pool {} is exiting\", poolid);\n  }", "language": "java", "Allcodes": "public void run() {\n    Set<Integer> toRemove = new HashSet<Integer>();\n    do {\n      boolean idle = true;\n      // Remove agents that have have become idle due to an external event\n      removeInactiveAgents();\n      // Add agents that have have become active due to an external event\n      addActiveAgents();\n      for (Integer i : activeAgents) {\n        Agent agent = (Agent) GlobalState.agents.get(i);\n        Stack255 agentExecutionStack = (Stack255) (agent).getExecutionStack();\n        if (!isStackValid(agent, agentExecutionStack)) {\n          // Mark this agent for removal\n          toRemove.add(i);\n          continue;\n        }\n        // At least one agent is active\n        idle = false;\n        // Get the item at the top of the stack\n        Object node = (Object) agentExecutionStack.get((byte) (agentExecutionStack.size() - 1));\n        if (node instanceof Plan) {\n          // If it is a plan then execute a plan step; and if it finished then remove it\n          managePlan(i, agentExecutionStack, (Plan) node, toRemove);\n        } else if (node instanceof Goal) {\n          // If it is a goal then find a plan for it and put it on the stack\n          manageGoal(i, agent, agentExecutionStack, (Goal) node);\n        }\n        agent.nextActiveStack(); // select the next active stack for next time\n      }\n      // remove agents that have finished executing plans and have gone idle in this cycle\n      removeFinishedAgents(toRemove);\n      if (idle) {\n        waitOnExternalMessage();\n        if (shutdown) {\n          break;\n        }\n      }\n    } \n    while (true);\n    logger.debug(\"Pool {} is exiting\", poolid);\n  }", "code_tokens": ["public", "void", "run", "(", ")", "{", "Set", "<", "Integer", ">", "toRemove", "=", "new", "HashSet", "<", "Integer", ">", "(", ")", ";", "do", "{", "boolean", "idle", "=", "true", ";", "// Remove agents that have have become idle due to an external event", "removeInactiveAgents", "(", ")", ";", "// Add agents that have have become active due to an external event", "addActiveAgents", "(", ")", ";", "for", "(", "Integer", "i", ":", "activeAgents", ")", "{", "Agent", "agent", "=", "(", "Agent", ")", "GlobalState", ".", "agents", ".", "get", "(", "i", ")", ";", "Stack255", "agentExecutionStack", "=", "(", "Stack255", ")", "(", "agent", ")", ".", "getExecutionStack", "(", ")", ";", "if", "(", "!", "isStackValid", "(", "agent", ",", "agentExecutionStack", ")", ")", "{", "// Mark this agent for removal", "toRemove", ".", "add", "(", "i", ")", ";", "continue", ";", "}", "// At least one agent is active", "idle", "=", "false", ";", "// Get the item at the top of the stack", "Object", "node", "=", "(", "Object", ")", "agentExecutionStack", ".", "get", "(", "(", "byte", ")", "(", "agentExecutionStack", ".", "size", "(", ")", "-", "1", ")", ")", ";", "if", "(", "node", "instanceof", "Plan", ")", "{", "// If it is a plan then execute a plan step; and if it finished then remove it", "managePlan", "(", "i", ",", "agentExecutionStack", ",", "(", "Plan", ")", "node", ",", "toRemove", ")", ";", "}", "else", "if", "(", "node", "instanceof", "Goal", ")", "{", "// If it is a goal then find a plan for it and put it on the stack", "manageGoal", "(", "i", ",", "agent", ",", "agentExecutionStack", ",", "(", "Goal", ")", "node", ")", ";", "}", "agent", ".", "nextActiveStack", "(", ")", ";", "// select the next active stack for next time", "}", "// remove agents that have finished executing plans and have gone idle in this cycle", "removeFinishedAgents", "(", "toRemove", ")", ";", "if", "(", "idle", ")", "{", "waitOnExternalMessage", "(", ")", ";", "if", "(", "shutdown", ")", "{", "break", ";", "}", "}", "}", "while", "(", "true", ")", ";", "logger", ".", "debug", "(", "\"Pool {} is exiting\"", ",", "poolid", ")", ";", "}"], "docstring": "Runs this intentions selction thread.", "docstring_tokens": ["Runs", "this", "intentions", "selction", "thread", "."]}
{"code": "lock.notify();", "comments": "NOPMD - ignore notifyall() warning", "lines": 6, "repo": "agentsoz/jill", "path": "jill/src/main/java/io/github/agentsoz/jill/core/IntentionSelector.java", "func_name": "IntentionSelector.shutdown", "original_string": "public void shutdown() {\n    synchronized (lock) {\n      logger.debug(\"Pool {} received shutdown message\", poolid);\n      shutdown = true;\n      hasMessage = true;\n      lock.notify(); // NOPMD - ignore notifyall() warning\n    }\n  }", "language": "java", "Allcodes": "public void shutdown() {\n    synchronized (lock) {\n      logger.debug(\"Pool {} received shutdown message\", poolid);\n      shutdown = true;\n      hasMessage = true;\n      lock.notify(); // NOPMD - ignore notifyall() warning\n    }\n  }", "code_tokens": ["public", "void", "shutdown", "(", ")", "{", "synchronized", "(", "lock", ")", "{", "logger", ".", "debug", "(", "\"Pool {} received shutdown message\"", ",", "poolid", ")", ";", "shutdown", "=", "true", ";", "hasMessage", "=", "true", ";", "lock", ".", "notify", "(", ")", ";", "// NOPMD - ignore notifyall() warning", "}", "}"], "docstring": "Terminates this intention selector thread.", "docstring_tokens": ["Terminates", "this", "intention", "selector", "thread", "."]}
{"code": "int subIndex = index & 0x3f;", "comments": "index within the word", "lines": 5, "repo": "booz-allen-hamilton/lucene-hdfs-directory", "path": "src/main/java/com/bah/lucene/blockcache/BlockLocks.java", "func_name": "BlockLocks.nextClearBit", "original_string": "public int nextClearBit(int index) {\n    int i = index >> 6;\n    if (i >= wlen)\n      return -1;\n    int subIndex = index & 0x3f; // index within the word\n    long word = ~bits.get(i) >> subIndex; // skip all the bits to the right of\n                                          // index\n    if (word != 0) {\n      return (i << 6) + subIndex + Long.numberOfTrailingZeros(word);\n    }\n    while (++i < wlen) {\n      word = ~bits.get(i);\n      if (word != 0) {\n        return (i << 6) + Long.numberOfTrailingZeros(word);\n      }\n    }\n    return -1;\n  }", "language": "java", "Allcodes": "public int nextClearBit(int index) {\n    int i = index >> 6;\n    if (i >= wlen)\n      return -1;\n    int subIndex = index & 0x3f; // index within the word\n    long word = ~bits.get(i) >> subIndex; // skip all the bits to the right of\n                                          // index\n    if (word != 0) {\n      return (i << 6) + subIndex + Long.numberOfTrailingZeros(word);\n    }\n    while (++i < wlen) {\n      word = ~bits.get(i);\n      if (word != 0) {\n        return (i << 6) + Long.numberOfTrailingZeros(word);\n      }\n    }\n    return -1;\n  }", "code_tokens": ["public", "int", "nextClearBit", "(", "int", "index", ")", "{", "int", "i", "=", "index", ">>", "6", ";", "if", "(", "i", ">=", "wlen", ")", "return", "-", "1", ";", "int", "subIndex", "=", "index", "&", "0x3f", ";", "// index within the word", "long", "word", "=", "~", "bits", ".", "get", "(", "i", ")", ">>", "subIndex", ";", "// skip all the bits to the right of", "// index", "if", "(", "word", "!=", "0", ")", "{", "return", "(", "i", "<<", "6", ")", "+", "subIndex", "+", "Long", ".", "numberOfTrailingZeros", "(", "word", ")", ";", "}", "while", "(", "++", "i", "<", "wlen", ")", "{", "word", "=", "~", "bits", ".", "get", "(", "i", ")", ";", "if", "(", "word", "!=", "0", ")", "{", "return", "(", "i", "<<", "6", ")", "+", "Long", ".", "numberOfTrailingZeros", "(", "word", ")", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "Find the next clear bit in the bit set.\n\n@param index\n@return", "docstring_tokens": ["Find", "the", "next", "clear", "bit", "in", "the", "bit", "set", "."]}
{"code": "long word = ~bits.get(i) >> subIndex;", "comments": "skip all the bits to the right of", "lines": 6, "repo": "booz-allen-hamilton/lucene-hdfs-directory", "path": "src/main/java/com/bah/lucene/blockcache/BlockLocks.java", "func_name": "BlockLocks.nextClearBit", "original_string": "public int nextClearBit(int index) {\n    int i = index >> 6;\n    if (i >= wlen)\n      return -1;\n    int subIndex = index & 0x3f; // index within the word\n    long word = ~bits.get(i) >> subIndex; // skip all the bits to the right of\n                                          // index\n    if (word != 0) {\n      return (i << 6) + subIndex + Long.numberOfTrailingZeros(word);\n    }\n    while (++i < wlen) {\n      word = ~bits.get(i);\n      if (word != 0) {\n        return (i << 6) + Long.numberOfTrailingZeros(word);\n      }\n    }\n    return -1;\n  }", "language": "java", "Allcodes": "public int nextClearBit(int index) {\n    int i = index >> 6;\n    if (i >= wlen)\n      return -1;\n    int subIndex = index & 0x3f; // index within the word\n    long word = ~bits.get(i) >> subIndex; // skip all the bits to the right of\n                                          // index\n    if (word != 0) {\n      return (i << 6) + subIndex + Long.numberOfTrailingZeros(word);\n    }\n    while (++i < wlen) {\n      word = ~bits.get(i);\n      if (word != 0) {\n        return (i << 6) + Long.numberOfTrailingZeros(word);\n      }\n    }\n    return -1;\n  }", "code_tokens": ["public", "int", "nextClearBit", "(", "int", "index", ")", "{", "int", "i", "=", "index", ">>", "6", ";", "if", "(", "i", ">=", "wlen", ")", "return", "-", "1", ";", "int", "subIndex", "=", "index", "&", "0x3f", ";", "// index within the word", "long", "word", "=", "~", "bits", ".", "get", "(", "i", ")", ">>", "subIndex", ";", "// skip all the bits to the right of", "// index", "if", "(", "word", "!=", "0", ")", "{", "return", "(", "i", "<<", "6", ")", "+", "subIndex", "+", "Long", ".", "numberOfTrailingZeros", "(", "word", ")", ";", "}", "while", "(", "++", "i", "<", "wlen", ")", "{", "word", "=", "~", "bits", ".", "get", "(", "i", ")", ";", "if", "(", "word", "!=", "0", ")", "{", "return", "(", "i", "<<", "6", ")", "+", "Long", ".", "numberOfTrailingZeros", "(", "word", ")", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "Find the next clear bit in the bit set.\n\n@param index\n@return", "docstring_tokens": ["Find", "the", "next", "clear", "bit", "in", "the", "bit", "set", "."]}
{"code": "int wordNum = index >> 6;", "comments": "div 64", "lines": 2, "repo": "booz-allen-hamilton/lucene-hdfs-directory", "path": "src/main/java/com/bah/lucene/blockcache/BlockLocks.java", "func_name": "BlockLocks.set", "original_string": "public boolean set(int index) {\n    int wordNum = index >> 6; // div 64\n    int bit = index & 0x3f; // mod 64\n    long bitmask = 1L << bit;\n    long word, oword;\n    do {\n      word = bits.get(wordNum);\n      // if set another thread stole the lock\n      if ((word & bitmask) != 0) {\n        return false;\n      }\n      oword = word;\n      word |= bitmask;\n    } while (!bits.compareAndSet(wordNum, oword, word));\n    return true;\n  }", "language": "java", "Allcodes": "public boolean set(int index) {\n    int wordNum = index >> 6; // div 64\n    int bit = index & 0x3f; // mod 64\n    long bitmask = 1L << bit;\n    long word, oword;\n    do {\n      word = bits.get(wordNum);\n      // if set another thread stole the lock\n      if ((word & bitmask) != 0) {\n        return false;\n      }\n      oword = word;\n      word |= bitmask;\n    } while (!bits.compareAndSet(wordNum, oword, word));\n    return true;\n  }", "code_tokens": ["public", "boolean", "set", "(", "int", "index", ")", "{", "int", "wordNum", "=", "index", ">>", "6", ";", "// div 64", "int", "bit", "=", "index", "&", "0x3f", ";", "// mod 64", "long", "bitmask", "=", "1L", "<<", "bit", ";", "long", "word", ",", "oword", ";", "do", "{", "word", "=", "bits", ".", "get", "(", "wordNum", ")", ";", "// if set another thread stole the lock", "if", "(", "(", "word", "&", "bitmask", ")", "!=", "0", ")", "{", "return", "false", ";", "}", "oword", "=", "word", ";", "word", "|=", "bitmask", ";", "}", "while", "(", "!", "bits", ".", "compareAndSet", "(", "wordNum", ",", "oword", ",", "word", ")", ")", ";", "return", "true", ";", "}"], "docstring": "Thread safe set operation that will set the bit if and only if the bit was\nnot previously set.\n\n@param index\nthe index position to set.\n@return returns true if the bit was set and false if it was already set.", "docstring_tokens": ["Thread", "safe", "set", "operation", "that", "will", "set", "the", "bit", "if", "and", "only", "if", "the", "bit", "was", "not", "previously", "set", "."]}
{"code": "int bit = index & 0x3f;", "comments": "mod 64", "lines": 3, "repo": "booz-allen-hamilton/lucene-hdfs-directory", "path": "src/main/java/com/bah/lucene/blockcache/BlockLocks.java", "func_name": "BlockLocks.set", "original_string": "public boolean set(int index) {\n    int wordNum = index >> 6; // div 64\n    int bit = index & 0x3f; // mod 64\n    long bitmask = 1L << bit;\n    long word, oword;\n    do {\n      word = bits.get(wordNum);\n      // if set another thread stole the lock\n      if ((word & bitmask) != 0) {\n        return false;\n      }\n      oword = word;\n      word |= bitmask;\n    } while (!bits.compareAndSet(wordNum, oword, word));\n    return true;\n  }", "language": "java", "Allcodes": "public boolean set(int index) {\n    int wordNum = index >> 6; // div 64\n    int bit = index & 0x3f; // mod 64\n    long bitmask = 1L << bit;\n    long word, oword;\n    do {\n      word = bits.get(wordNum);\n      // if set another thread stole the lock\n      if ((word & bitmask) != 0) {\n        return false;\n      }\n      oword = word;\n      word |= bitmask;\n    } while (!bits.compareAndSet(wordNum, oword, word));\n    return true;\n  }", "code_tokens": ["public", "boolean", "set", "(", "int", "index", ")", "{", "int", "wordNum", "=", "index", ">>", "6", ";", "// div 64", "int", "bit", "=", "index", "&", "0x3f", ";", "// mod 64", "long", "bitmask", "=", "1L", "<<", "bit", ";", "long", "word", ",", "oword", ";", "do", "{", "word", "=", "bits", ".", "get", "(", "wordNum", ")", ";", "// if set another thread stole the lock", "if", "(", "(", "word", "&", "bitmask", ")", "!=", "0", ")", "{", "return", "false", ";", "}", "oword", "=", "word", ";", "word", "|=", "bitmask", ";", "}", "while", "(", "!", "bits", ".", "compareAndSet", "(", "wordNum", ",", "oword", ",", "word", ")", ")", ";", "return", "true", ";", "}"], "docstring": "Thread safe set operation that will set the bit if and only if the bit was\nnot previously set.\n\n@param index\nthe index position to set.\n@return returns true if the bit was set and false if it was already set.", "docstring_tokens": ["Thread", "safe", "set", "operation", "that", "will", "set", "the", "bit", "if", "and", "only", "if", "the", "bit", "was", "not", "previously", "set", "."]}
{"code": "runState = newRunState;", "comments": "clears RSIGNAL bit", "lines": 4, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.unlockRunState", "original_string": "private void unlockRunState(int oldRunState, int newRunState) {\n        if (!U.compareAndSwapInt(this, RUNSTATE, oldRunState, newRunState)) {\n            Object lock = stealCounter;\n            runState = newRunState;              // clears RSIGNAL bit\n            if (lock != null)\n                synchronized (lock) { lock.notifyAll(); }\n        }\n    }", "language": "java", "Allcodes": "private void unlockRunState(int oldRunState, int newRunState) {\n        if (!U.compareAndSwapInt(this, RUNSTATE, oldRunState, newRunState)) {\n            Object lock = stealCounter;\n            runState = newRunState;              // clears RSIGNAL bit\n            if (lock != null)\n                synchronized (lock) { lock.notifyAll(); }\n        }\n    }", "code_tokens": ["private", "void", "unlockRunState", "(", "int", "oldRunState", ",", "int", "newRunState", ")", "{", "if", "(", "!", "U", ".", "compareAndSwapInt", "(", "this", ",", "RUNSTATE", ",", "oldRunState", ",", "newRunState", ")", ")", "{", "Object", "lock", "=", "stealCounter", ";", "runState", "=", "newRunState", ";", "// clears RSIGNAL bit", "if", "(", "lock", "!=", "null", ")", "synchronized", "(", "lock", ")", "{", "lock", ".", "notifyAll", "(", ")", ";", "}", "}", "}"], "docstring": "Unlocks and sets runState to newRunState.\n\n@param oldRunState a value returned from lockRunState\n@param newRunState the next value (must have lock bit clear).", "docstring_tokens": ["Unlocks", "and", "sets", "runState", "to", "newRunState", "."]}
{"code": "int rs, stop;", "comments": "check if terminating", "lines": 7, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.tryAddWorker", "original_string": "private void tryAddWorker(long c) {\n        boolean add = false;\n        do {\n            long nc = ((AC_MASK & (c + AC_UNIT)) |\n                       (TC_MASK & (c + TC_UNIT)));\n            if (ctl == c) {\n                int rs, stop;                 // check if terminating\n                if ((stop = (rs = lockRunState()) & STOP) == 0)\n                    add = U.compareAndSwapLong(this, CTL, c, nc);\n                unlockRunState(rs, rs & ~RSLOCK);\n                if (stop != 0)\n                    break;\n                if (add) {\n                    createWorker();\n                    break;\n                }\n            }\n        } while (((c = ctl) & ADD_WORKER) != 0L && (int)c == 0);\n    }", "language": "java", "Allcodes": "private void tryAddWorker(long c) {\n        boolean add = false;\n        do {\n            long nc = ((AC_MASK & (c + AC_UNIT)) |\n                       (TC_MASK & (c + TC_UNIT)));\n            if (ctl == c) {\n                int rs, stop;                 // check if terminating\n                if ((stop = (rs = lockRunState()) & STOP) == 0)\n                    add = U.compareAndSwapLong(this, CTL, c, nc);\n                unlockRunState(rs, rs & ~RSLOCK);\n                if (stop != 0)\n                    break;\n                if (add) {\n                    createWorker();\n                    break;\n                }\n            }\n        } while (((c = ctl) & ADD_WORKER) != 0L && (int)c == 0);\n    }", "code_tokens": ["private", "void", "tryAddWorker", "(", "long", "c", ")", "{", "boolean", "add", "=", "false", ";", "do", "{", "long", "nc", "=", "(", "(", "AC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "TC_MASK", "&", "(", "c", "+", "TC_UNIT", ")", ")", ")", ";", "if", "(", "ctl", "==", "c", ")", "{", "int", "rs", ",", "stop", ";", "// check if terminating", "if", "(", "(", "stop", "=", "(", "rs", "=", "lockRunState", "(", ")", ")", "&", "STOP", ")", "==", "0", ")", "add", "=", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "nc", ")", ";", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "if", "(", "stop", "!=", "0", ")", "break", ";", "if", "(", "add", ")", "{", "createWorker", "(", ")", ";", "break", ";", "}", "}", "}", "while", "(", "(", "(", "c", "=", "ctl", ")", "&", "ADD_WORKER", ")", "!=", "0L", "&&", "(", "int", ")", "c", "==", "0", ")", ";", "}"], "docstring": "Tries to add one worker, incrementing ctl counts before doing\nso, relying on createWorker to back out on failure.\n\n@param c incoming ctl value, with total count negative and no\nidle workers.  On CAS failure, c is refreshed and retried if\nthis holds (otherwise, a new worker is not needed).", "docstring_tokens": ["Tries", "to", "add", "one", "worker", "incrementing", "ctl", "counts", "before", "doing", "so", "relying", "on", "createWorker", "to", "back", "out", "on", "failure", "."]}
{"code": "wt.setDaemon(true);", "comments": "configure thread", "lines": 3, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "int i = 0;", "comments": "assign a pool index", "lines": 7, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "WorkQueue[] ws; int n;", "comments": "skip if no array", "lines": 11, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "int s = indexSeed += SEED_INCREMENT;", "comments": "unlikely to collide", "lines": 13, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "i = ((s << 1) | 1) & m;", "comments": "odd-numbered indices", "lines": 15, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "int probes = 0;", "comments": "step by approx half n", "lines": 17, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "w.hint = s;", "comments": "use as random seed", "lines": 27, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "w.scanState = i;", "comments": "publication fence", "lines": 29, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.registerWorker", "original_string": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "language": "java", "Allcodes": "final WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        UncaughtExceptionHandler handler;\n        wt.setDaemon(true);                           // configure thread\n        if ((handler = ueh) != null)\n            wt.setUncaughtExceptionHandler(handler);\n        WorkQueue w = new WorkQueue(this, wt);\n        int i = 0;                                    // assign a pool index\n        int mode = config & MODE_MASK;\n        int rs = lockRunState();\n        try {\n            WorkQueue[] ws; int n;                    // skip if no array\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                w.hint = s;                           // use as random seed\n                w.config = i | mode;\n                w.scanState = i;                      // publication fence\n                ws[i] = w;\n            }\n        } finally {\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n        return w;\n    }", "code_tokens": ["final", "WorkQueue", "registerWorker", "(", "ForkJoinWorkerThread", "wt", ")", "{", "UncaughtExceptionHandler", "handler", ";", "wt", ".", "setDaemon", "(", "true", ")", ";", "// configure thread", "if", "(", "(", "handler", "=", "ueh", ")", "!=", "null", ")", "wt", ".", "setUncaughtExceptionHandler", "(", "handler", ")", ";", "WorkQueue", "w", "=", "new", "WorkQueue", "(", "this", ",", "wt", ")", ";", "int", "i", "=", "0", ";", "// assign a pool index", "int", "mode", "=", "config", "&", "MODE_MASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "try", "{", "WorkQueue", "[", "]", "ws", ";", "int", "n", ";", "// skip if no array", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "n", "=", "ws", ".", "length", ")", ">", "0", ")", "{", "int", "s", "=", "indexSeed", "+=", "SEED_INCREMENT", ";", "// unlikely to collide", "int", "m", "=", "n", "-", "1", ";", "i", "=", "(", "(", "s", "<<", "1", ")", "|", "1", ")", "&", "m", ";", "// odd-numbered indices", "if", "(", "ws", "[", "i", "]", "!=", "null", ")", "{", "// collision", "int", "probes", "=", "0", ";", "// step by approx half n", "int", "step", "=", "(", "n", "<=", "4", ")", "?", "2", ":", "(", "(", "n", ">>>", "1", ")", "&", "EVENMASK", ")", "+", "2", ";", "while", "(", "ws", "[", "i", "=", "(", "i", "+", "step", ")", "&", "m", "]", "!=", "null", ")", "{", "if", "(", "++", "probes", ">=", "n", ")", "{", "workQueues", "=", "ws", "=", "Arrays", ".", "copyOf", "(", "ws", ",", "n", "<<=", "1", ")", ";", "m", "=", "n", "-", "1", ";", "probes", "=", "0", ";", "}", "}", "}", "w", ".", "hint", "=", "s", ";", "// use as random seed", "w", ".", "config", "=", "i", "|", "mode", ";", "w", ".", "scanState", "=", "i", ";", "// publication fence", "ws", "[", "i", "]", "=", "w", ";", "}", "}", "finally", "{", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "wt", ".", "setName", "(", "workerNamePrefix", ".", "concat", "(", "Integer", ".", "toString", "(", "i", ">>>", "1", ")", ")", ")", ";", "return", "w", ";", "}"], "docstring": "Callback from ForkJoinWorkerThread constructor to establish and\nrecord its WorkQueue.\n\n@param wt the worker thread\n@return the worker's queue", "docstring_tokens": ["Callback", "from", "ForkJoinWorkerThread", "constructor", "to", "establish", "and", "record", "its", "WorkQueue", "."]}
{"code": "WorkQueue[] ws;", "comments": "remove index from array", "lines": 4, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.deregisterWorker", "original_string": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "language": "java", "Allcodes": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "code_tokens": ["final", "void", "deregisterWorker", "(", "ForkJoinWorkerThread", "wt", ",", "Throwable", "ex", ")", "{", "WorkQueue", "w", "=", "null", ";", "if", "(", "wt", "!=", "null", "&&", "(", "w", "=", "wt", ".", "workQueue", ")", "!=", "null", ")", "{", "WorkQueue", "[", "]", "ws", ";", "// remove index from array", "int", "idx", "=", "w", ".", "config", "&", "SMASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "ws", ".", "length", ">", "idx", "&&", "ws", "[", "idx", "]", "==", "w", ")", "ws", "[", "idx", "]", "=", "null", ";", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "long", "c", ";", "// decrement counts", "do", "{", "}", "while", "(", "!", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", "=", "ctl", ",", "(", "(", "AC_MASK", "&", "(", "c", "-", "AC_UNIT", ")", ")", "|", "(", "TC_MASK", "&", "(", "c", "-", "TC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "c", ")", ")", ")", ")", ";", "if", "(", "w", "!=", "null", ")", "{", "w", ".", "qlock", "=", "-", "1", ";", "// ensure set", "w", ".", "transferStealCount", "(", "this", ")", ";", "w", ".", "cancelAll", "(", ")", ";", "// cancel remaining tasks", "}", "for", "(", ";", ";", ")", "{", "// possibly replace", "WorkQueue", "[", "]", "ws", ";", "int", "m", ",", "sp", ";", "if", "(", "tryTerminate", "(", "false", ",", "false", ")", "||", "w", "==", "null", "||", "w", ".", "array", "==", "null", "||", "(", "runState", "&", "STOP", ")", "!=", "0", "||", "(", "ws", "=", "workQueues", ")", "==", "null", "||", "(", "m", "=", "ws", ".", "length", "-", "1", ")", "<", "0", ")", "// already terminating", "break", ";", "if", "(", "(", "sp", "=", "(", "int", ")", "(", "c", "=", "ctl", ")", ")", "!=", "0", ")", "{", "// wake up replacement", "if", "(", "tryRelease", "(", "c", ",", "ws", "[", "sp", "&", "m", "]", ",", "AC_UNIT", ")", ")", "break", ";", "}", "else", "if", "(", "ex", "!=", "null", "&&", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "{", "tryAddWorker", "(", "c", ")", ";", "// create replacement", "break", ";", "}", "else", "// don't need replacement", "break", ";", "}", "if", "(", "ex", "==", "null", ")", "// help clean on way out", "ForkJoinTask", ".", "helpExpungeStaleExceptions", "(", ")", ";", "else", "// rethrow", "ForkJoinTask", ".", "rethrow", "(", "ex", ")", ";", "}"], "docstring": "Final callback from terminating worker, as well as upon failure\nto construct or start a worker.  Removes record of worker from\narray, and adjusts counts. If pool is shutting down, tries to\ncomplete termination.\n\n@param wt the worker thread, or null if construction failed\n@param ex the exception causing failure, or null if none", "docstring_tokens": ["Final", "callback", "from", "terminating", "worker", "as", "well", "as", "upon", "failure", "to", "construct", "or", "start", "a", "worker", ".", "Removes", "record", "of", "worker", "from", "array", "and", "adjusts", "counts", ".", "If", "pool", "is", "shutting", "down", "tries", "to", "complete", "termination", "."]}
{"code": "long c;", "comments": "decrement counts", "lines": 11, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.deregisterWorker", "original_string": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "language": "java", "Allcodes": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "code_tokens": ["final", "void", "deregisterWorker", "(", "ForkJoinWorkerThread", "wt", ",", "Throwable", "ex", ")", "{", "WorkQueue", "w", "=", "null", ";", "if", "(", "wt", "!=", "null", "&&", "(", "w", "=", "wt", ".", "workQueue", ")", "!=", "null", ")", "{", "WorkQueue", "[", "]", "ws", ";", "// remove index from array", "int", "idx", "=", "w", ".", "config", "&", "SMASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "ws", ".", "length", ">", "idx", "&&", "ws", "[", "idx", "]", "==", "w", ")", "ws", "[", "idx", "]", "=", "null", ";", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "long", "c", ";", "// decrement counts", "do", "{", "}", "while", "(", "!", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", "=", "ctl", ",", "(", "(", "AC_MASK", "&", "(", "c", "-", "AC_UNIT", ")", ")", "|", "(", "TC_MASK", "&", "(", "c", "-", "TC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "c", ")", ")", ")", ")", ";", "if", "(", "w", "!=", "null", ")", "{", "w", ".", "qlock", "=", "-", "1", ";", "// ensure set", "w", ".", "transferStealCount", "(", "this", ")", ";", "w", ".", "cancelAll", "(", ")", ";", "// cancel remaining tasks", "}", "for", "(", ";", ";", ")", "{", "// possibly replace", "WorkQueue", "[", "]", "ws", ";", "int", "m", ",", "sp", ";", "if", "(", "tryTerminate", "(", "false", ",", "false", ")", "||", "w", "==", "null", "||", "w", ".", "array", "==", "null", "||", "(", "runState", "&", "STOP", ")", "!=", "0", "||", "(", "ws", "=", "workQueues", ")", "==", "null", "||", "(", "m", "=", "ws", ".", "length", "-", "1", ")", "<", "0", ")", "// already terminating", "break", ";", "if", "(", "(", "sp", "=", "(", "int", ")", "(", "c", "=", "ctl", ")", ")", "!=", "0", ")", "{", "// wake up replacement", "if", "(", "tryRelease", "(", "c", ",", "ws", "[", "sp", "&", "m", "]", ",", "AC_UNIT", ")", ")", "break", ";", "}", "else", "if", "(", "ex", "!=", "null", "&&", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "{", "tryAddWorker", "(", "c", ")", ";", "// create replacement", "break", ";", "}", "else", "// don't need replacement", "break", ";", "}", "if", "(", "ex", "==", "null", ")", "// help clean on way out", "ForkJoinTask", ".", "helpExpungeStaleExceptions", "(", ")", ";", "else", "// rethrow", "ForkJoinTask", ".", "rethrow", "(", "ex", ")", ";", "}"], "docstring": "Final callback from terminating worker, as well as upon failure\nto construct or start a worker.  Removes record of worker from\narray, and adjusts counts. If pool is shutting down, tries to\ncomplete termination.\n\n@param wt the worker thread, or null if construction failed\n@param ex the exception causing failure, or null if none", "docstring_tokens": ["Final", "callback", "from", "terminating", "worker", "as", "well", "as", "upon", "failure", "to", "construct", "or", "start", "a", "worker", ".", "Removes", "record", "of", "worker", "from", "array", "and", "adjusts", "counts", ".", "If", "pool", "is", "shutting", "down", "tries", "to", "complete", "termination", "."]}
{"code": "w.qlock = -1;", "comments": "ensure set", "lines": 17, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.deregisterWorker", "original_string": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "language": "java", "Allcodes": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "code_tokens": ["final", "void", "deregisterWorker", "(", "ForkJoinWorkerThread", "wt", ",", "Throwable", "ex", ")", "{", "WorkQueue", "w", "=", "null", ";", "if", "(", "wt", "!=", "null", "&&", "(", "w", "=", "wt", ".", "workQueue", ")", "!=", "null", ")", "{", "WorkQueue", "[", "]", "ws", ";", "// remove index from array", "int", "idx", "=", "w", ".", "config", "&", "SMASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "ws", ".", "length", ">", "idx", "&&", "ws", "[", "idx", "]", "==", "w", ")", "ws", "[", "idx", "]", "=", "null", ";", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "long", "c", ";", "// decrement counts", "do", "{", "}", "while", "(", "!", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", "=", "ctl", ",", "(", "(", "AC_MASK", "&", "(", "c", "-", "AC_UNIT", ")", ")", "|", "(", "TC_MASK", "&", "(", "c", "-", "TC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "c", ")", ")", ")", ")", ";", "if", "(", "w", "!=", "null", ")", "{", "w", ".", "qlock", "=", "-", "1", ";", "// ensure set", "w", ".", "transferStealCount", "(", "this", ")", ";", "w", ".", "cancelAll", "(", ")", ";", "// cancel remaining tasks", "}", "for", "(", ";", ";", ")", "{", "// possibly replace", "WorkQueue", "[", "]", "ws", ";", "int", "m", ",", "sp", ";", "if", "(", "tryTerminate", "(", "false", ",", "false", ")", "||", "w", "==", "null", "||", "w", ".", "array", "==", "null", "||", "(", "runState", "&", "STOP", ")", "!=", "0", "||", "(", "ws", "=", "workQueues", ")", "==", "null", "||", "(", "m", "=", "ws", ".", "length", "-", "1", ")", "<", "0", ")", "// already terminating", "break", ";", "if", "(", "(", "sp", "=", "(", "int", ")", "(", "c", "=", "ctl", ")", ")", "!=", "0", ")", "{", "// wake up replacement", "if", "(", "tryRelease", "(", "c", ",", "ws", "[", "sp", "&", "m", "]", ",", "AC_UNIT", ")", ")", "break", ";", "}", "else", "if", "(", "ex", "!=", "null", "&&", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "{", "tryAddWorker", "(", "c", ")", ";", "// create replacement", "break", ";", "}", "else", "// don't need replacement", "break", ";", "}", "if", "(", "ex", "==", "null", ")", "// help clean on way out", "ForkJoinTask", ".", "helpExpungeStaleExceptions", "(", ")", ";", "else", "// rethrow", "ForkJoinTask", ".", "rethrow", "(", "ex", ")", ";", "}"], "docstring": "Final callback from terminating worker, as well as upon failure\nto construct or start a worker.  Removes record of worker from\narray, and adjusts counts. If pool is shutting down, tries to\ncomplete termination.\n\n@param wt the worker thread, or null if construction failed\n@param ex the exception causing failure, or null if none", "docstring_tokens": ["Final", "callback", "from", "terminating", "worker", "as", "well", "as", "upon", "failure", "to", "construct", "or", "start", "a", "worker", ".", "Removes", "record", "of", "worker", "from", "array", "and", "adjusts", "counts", ".", "If", "pool", "is", "shutting", "down", "tries", "to", "complete", "termination", "."]}
{"code": "w.cancelAll();", "comments": "cancel remaining tasks", "lines": 19, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.deregisterWorker", "original_string": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "language": "java", "Allcodes": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "code_tokens": ["final", "void", "deregisterWorker", "(", "ForkJoinWorkerThread", "wt", ",", "Throwable", "ex", ")", "{", "WorkQueue", "w", "=", "null", ";", "if", "(", "wt", "!=", "null", "&&", "(", "w", "=", "wt", ".", "workQueue", ")", "!=", "null", ")", "{", "WorkQueue", "[", "]", "ws", ";", "// remove index from array", "int", "idx", "=", "w", ".", "config", "&", "SMASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "ws", ".", "length", ">", "idx", "&&", "ws", "[", "idx", "]", "==", "w", ")", "ws", "[", "idx", "]", "=", "null", ";", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "long", "c", ";", "// decrement counts", "do", "{", "}", "while", "(", "!", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", "=", "ctl", ",", "(", "(", "AC_MASK", "&", "(", "c", "-", "AC_UNIT", ")", ")", "|", "(", "TC_MASK", "&", "(", "c", "-", "TC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "c", ")", ")", ")", ")", ";", "if", "(", "w", "!=", "null", ")", "{", "w", ".", "qlock", "=", "-", "1", ";", "// ensure set", "w", ".", "transferStealCount", "(", "this", ")", ";", "w", ".", "cancelAll", "(", ")", ";", "// cancel remaining tasks", "}", "for", "(", ";", ";", ")", "{", "// possibly replace", "WorkQueue", "[", "]", "ws", ";", "int", "m", ",", "sp", ";", "if", "(", "tryTerminate", "(", "false", ",", "false", ")", "||", "w", "==", "null", "||", "w", ".", "array", "==", "null", "||", "(", "runState", "&", "STOP", ")", "!=", "0", "||", "(", "ws", "=", "workQueues", ")", "==", "null", "||", "(", "m", "=", "ws", ".", "length", "-", "1", ")", "<", "0", ")", "// already terminating", "break", ";", "if", "(", "(", "sp", "=", "(", "int", ")", "(", "c", "=", "ctl", ")", ")", "!=", "0", ")", "{", "// wake up replacement", "if", "(", "tryRelease", "(", "c", ",", "ws", "[", "sp", "&", "m", "]", ",", "AC_UNIT", ")", ")", "break", ";", "}", "else", "if", "(", "ex", "!=", "null", "&&", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "{", "tryAddWorker", "(", "c", ")", ";", "// create replacement", "break", ";", "}", "else", "// don't need replacement", "break", ";", "}", "if", "(", "ex", "==", "null", ")", "// help clean on way out", "ForkJoinTask", ".", "helpExpungeStaleExceptions", "(", ")", ";", "else", "// rethrow", "ForkJoinTask", ".", "rethrow", "(", "ex", ")", ";", "}"], "docstring": "Final callback from terminating worker, as well as upon failure\nto construct or start a worker.  Removes record of worker from\narray, and adjusts counts. If pool is shutting down, tries to\ncomplete termination.\n\n@param wt the worker thread, or null if construction failed\n@param ex the exception causing failure, or null if none", "docstring_tokens": ["Final", "callback", "from", "terminating", "worker", "as", "well", "as", "upon", "failure", "to", "construct", "or", "start", "a", "worker", ".", "Removes", "record", "of", "worker", "from", "array", "and", "adjusts", "counts", ".", "If", "pool", "is", "shutting", "down", "tries", "to", "complete", "termination", "."]}
{"code": "tryAddWorker(c);", "comments": "create replacement", "lines": 32, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.deregisterWorker", "original_string": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "language": "java", "Allcodes": "final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n        WorkQueue w = null;\n        if (wt != null && (w = wt.workQueue) != null) {\n            WorkQueue[] ws;                           // remove index from array\n            int idx = w.config & SMASK;\n            int rs = lockRunState();\n            if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n                ws[idx] = null;\n            unlockRunState(rs, rs & ~RSLOCK);\n        }\n        long c;                                       // decrement counts\n        do {} while (!U.compareAndSwapLong\n                     (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                           (TC_MASK & (c - TC_UNIT)) |\n                                           (SP_MASK & c))));\n        if (w != null) {\n            w.qlock = -1;                             // ensure set\n            w.transferStealCount(this);\n            w.cancelAll();                            // cancel remaining tasks\n        }\n        for (;;) {                                    // possibly replace\n            WorkQueue[] ws; int m, sp;\n            if (tryTerminate(false, false) || w == null || w.array == null ||\n                (runState & STOP) != 0 || (ws = workQueues) == null ||\n                (m = ws.length - 1) < 0)              // already terminating\n                break;\n            if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n                if (tryRelease(c, ws[sp & m], AC_UNIT))\n                    break;\n            }\n            else if (ex != null && (c & ADD_WORKER) != 0L) {\n                tryAddWorker(c);                      // create replacement\n                break;\n            }\n            else                                      // don't need replacement\n                break;\n        }\n        if (ex == null)                               // help clean on way out\n            ForkJoinTask.helpExpungeStaleExceptions();\n        else                                          // rethrow\n            ForkJoinTask.rethrow(ex);\n    }", "code_tokens": ["final", "void", "deregisterWorker", "(", "ForkJoinWorkerThread", "wt", ",", "Throwable", "ex", ")", "{", "WorkQueue", "w", "=", "null", ";", "if", "(", "wt", "!=", "null", "&&", "(", "w", "=", "wt", ".", "workQueue", ")", "!=", "null", ")", "{", "WorkQueue", "[", "]", "ws", ";", "// remove index from array", "int", "idx", "=", "w", ".", "config", "&", "SMASK", ";", "int", "rs", "=", "lockRunState", "(", ")", ";", "if", "(", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "ws", ".", "length", ">", "idx", "&&", "ws", "[", "idx", "]", "==", "w", ")", "ws", "[", "idx", "]", "=", "null", ";", "unlockRunState", "(", "rs", ",", "rs", "&", "~", "RSLOCK", ")", ";", "}", "long", "c", ";", "// decrement counts", "do", "{", "}", "while", "(", "!", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", "=", "ctl", ",", "(", "(", "AC_MASK", "&", "(", "c", "-", "AC_UNIT", ")", ")", "|", "(", "TC_MASK", "&", "(", "c", "-", "TC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "c", ")", ")", ")", ")", ";", "if", "(", "w", "!=", "null", ")", "{", "w", ".", "qlock", "=", "-", "1", ";", "// ensure set", "w", ".", "transferStealCount", "(", "this", ")", ";", "w", ".", "cancelAll", "(", ")", ";", "// cancel remaining tasks", "}", "for", "(", ";", ";", ")", "{", "// possibly replace", "WorkQueue", "[", "]", "ws", ";", "int", "m", ",", "sp", ";", "if", "(", "tryTerminate", "(", "false", ",", "false", ")", "||", "w", "==", "null", "||", "w", ".", "array", "==", "null", "||", "(", "runState", "&", "STOP", ")", "!=", "0", "||", "(", "ws", "=", "workQueues", ")", "==", "null", "||", "(", "m", "=", "ws", ".", "length", "-", "1", ")", "<", "0", ")", "// already terminating", "break", ";", "if", "(", "(", "sp", "=", "(", "int", ")", "(", "c", "=", "ctl", ")", ")", "!=", "0", ")", "{", "// wake up replacement", "if", "(", "tryRelease", "(", "c", ",", "ws", "[", "sp", "&", "m", "]", ",", "AC_UNIT", ")", ")", "break", ";", "}", "else", "if", "(", "ex", "!=", "null", "&&", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "{", "tryAddWorker", "(", "c", ")", ";", "// create replacement", "break", ";", "}", "else", "// don't need replacement", "break", ";", "}", "if", "(", "ex", "==", "null", ")", "// help clean on way out", "ForkJoinTask", ".", "helpExpungeStaleExceptions", "(", ")", ";", "else", "// rethrow", "ForkJoinTask", ".", "rethrow", "(", "ex", ")", ";", "}"], "docstring": "Final callback from terminating worker, as well as upon failure\nto construct or start a worker.  Removes record of worker from\narray, and adjusts counts. If pool is shutting down, tries to\ncomplete termination.\n\n@param wt the worker thread, or null if construction failed\n@param ex the exception causing failure, or null if none", "docstring_tokens": ["Final", "callback", "from", "terminating", "worker", "as", "well", "as", "upon", "failure", "to", "construct", "or", "start", "a", "worker", ".", "Removes", "record", "of", "worker", "from", "array", "and", "adjusts", "counts", ".", "If", "pool", "is", "shutting", "down", "tries", "to", "complete", "termination", "."]}
{"code": "int vs = (sp + SS_SEQ) & ~INACTIVE;", "comments": "next scanState", "lines": 15, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.signalWork", "original_string": "final void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        while ((c = ctl) < 0L) {                       // too few active\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            int d = sp - v.scanState;                  // screen CAS\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }", "language": "java", "Allcodes": "final void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        while ((c = ctl) < 0L) {                       // too few active\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            int d = sp - v.scanState;                  // screen CAS\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }", "code_tokens": ["final", "void", "signalWork", "(", "WorkQueue", "[", "]", "ws", ",", "WorkQueue", "q", ")", "{", "long", "c", ";", "int", "sp", ",", "i", ";", "WorkQueue", "v", ";", "Thread", "p", ";", "while", "(", "(", "c", "=", "ctl", ")", "<", "0L", ")", "{", "// too few active", "if", "(", "(", "sp", "=", "(", "int", ")", "c", ")", "==", "0", ")", "{", "// no idle workers", "if", "(", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "// too few workers", "tryAddWorker", "(", "c", ")", ";", "break", ";", "}", "if", "(", "ws", "==", "null", ")", "// unstarted/terminated", "break", ";", "if", "(", "ws", ".", "length", "<=", "(", "i", "=", "sp", "&", "SMASK", ")", ")", "// terminated", "break", ";", "if", "(", "(", "v", "=", "ws", "[", "i", "]", ")", "==", "null", ")", "// terminating", "break", ";", "int", "vs", "=", "(", "sp", "+", "SS_SEQ", ")", "&", "~", "INACTIVE", ";", "// next scanState", "int", "d", "=", "sp", "-", "v", ".", "scanState", ";", "// screen CAS", "long", "nc", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "v", ".", "stackPred", ")", ";", "if", "(", "d", "==", "0", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "nc", ")", ")", "{", "v", ".", "scanState", "=", "vs", ";", "// activate v", "if", "(", "(", "p", "=", "v", ".", "parker", ")", "!=", "null", ")", "U", ".", "unpark", "(", "p", ")", ";", "break", ";", "}", "if", "(", "q", "!=", "null", "&&", "q", ".", "base", "==", "q", ".", "top", ")", "// no more work", "break", ";", "}", "}"], "docstring": "Tries to create or activate a worker if too few are active.\n\n@param ws the worker array to use to find signallees\n@param q a WorkQueue --if non-null, don't retry if now empty", "docstring_tokens": ["Tries", "to", "create", "or", "activate", "a", "worker", "if", "too", "few", "are", "active", "."]}
{"code": "int d = sp - v.scanState;", "comments": "screen CAS", "lines": 16, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.signalWork", "original_string": "final void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        while ((c = ctl) < 0L) {                       // too few active\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            int d = sp - v.scanState;                  // screen CAS\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }", "language": "java", "Allcodes": "final void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        while ((c = ctl) < 0L) {                       // too few active\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            int d = sp - v.scanState;                  // screen CAS\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }", "code_tokens": ["final", "void", "signalWork", "(", "WorkQueue", "[", "]", "ws", ",", "WorkQueue", "q", ")", "{", "long", "c", ";", "int", "sp", ",", "i", ";", "WorkQueue", "v", ";", "Thread", "p", ";", "while", "(", "(", "c", "=", "ctl", ")", "<", "0L", ")", "{", "// too few active", "if", "(", "(", "sp", "=", "(", "int", ")", "c", ")", "==", "0", ")", "{", "// no idle workers", "if", "(", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "// too few workers", "tryAddWorker", "(", "c", ")", ";", "break", ";", "}", "if", "(", "ws", "==", "null", ")", "// unstarted/terminated", "break", ";", "if", "(", "ws", ".", "length", "<=", "(", "i", "=", "sp", "&", "SMASK", ")", ")", "// terminated", "break", ";", "if", "(", "(", "v", "=", "ws", "[", "i", "]", ")", "==", "null", ")", "// terminating", "break", ";", "int", "vs", "=", "(", "sp", "+", "SS_SEQ", ")", "&", "~", "INACTIVE", ";", "// next scanState", "int", "d", "=", "sp", "-", "v", ".", "scanState", ";", "// screen CAS", "long", "nc", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "v", ".", "stackPred", ")", ";", "if", "(", "d", "==", "0", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "nc", ")", ")", "{", "v", ".", "scanState", "=", "vs", ";", "// activate v", "if", "(", "(", "p", "=", "v", ".", "parker", ")", "!=", "null", ")", "U", ".", "unpark", "(", "p", ")", ";", "break", ";", "}", "if", "(", "q", "!=", "null", "&&", "q", ".", "base", "==", "q", ".", "top", ")", "// no more work", "break", ";", "}", "}"], "docstring": "Tries to create or activate a worker if too few are active.\n\n@param ws the worker array to use to find signallees\n@param q a WorkQueue --if non-null, don't retry if now empty", "docstring_tokens": ["Tries", "to", "create", "or", "activate", "a", "worker", "if", "too", "few", "are", "active", "."]}
{"code": "v.scanState = vs;", "comments": "activate v", "lines": 19, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.signalWork", "original_string": "final void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        while ((c = ctl) < 0L) {                       // too few active\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            int d = sp - v.scanState;                  // screen CAS\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }", "language": "java", "Allcodes": "final void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        while ((c = ctl) < 0L) {                       // too few active\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            int d = sp - v.scanState;                  // screen CAS\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }", "code_tokens": ["final", "void", "signalWork", "(", "WorkQueue", "[", "]", "ws", ",", "WorkQueue", "q", ")", "{", "long", "c", ";", "int", "sp", ",", "i", ";", "WorkQueue", "v", ";", "Thread", "p", ";", "while", "(", "(", "c", "=", "ctl", ")", "<", "0L", ")", "{", "// too few active", "if", "(", "(", "sp", "=", "(", "int", ")", "c", ")", "==", "0", ")", "{", "// no idle workers", "if", "(", "(", "c", "&", "ADD_WORKER", ")", "!=", "0L", ")", "// too few workers", "tryAddWorker", "(", "c", ")", ";", "break", ";", "}", "if", "(", "ws", "==", "null", ")", "// unstarted/terminated", "break", ";", "if", "(", "ws", ".", "length", "<=", "(", "i", "=", "sp", "&", "SMASK", ")", ")", "// terminated", "break", ";", "if", "(", "(", "v", "=", "ws", "[", "i", "]", ")", "==", "null", ")", "// terminating", "break", ";", "int", "vs", "=", "(", "sp", "+", "SS_SEQ", ")", "&", "~", "INACTIVE", ";", "// next scanState", "int", "d", "=", "sp", "-", "v", ".", "scanState", ";", "// screen CAS", "long", "nc", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "v", ".", "stackPred", ")", ";", "if", "(", "d", "==", "0", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "nc", ")", ")", "{", "v", ".", "scanState", "=", "vs", ";", "// activate v", "if", "(", "(", "p", "=", "v", ".", "parker", ")", "!=", "null", ")", "U", ".", "unpark", "(", "p", ")", ";", "break", ";", "}", "if", "(", "q", "!=", "null", "&&", "q", ".", "base", "==", "q", ".", "top", ")", "// no more work", "break", ";", "}", "}"], "docstring": "Tries to create or activate a worker if too few are active.\n\n@param ws the worker array to use to find signallees\n@param q a WorkQueue --if non-null, don't retry if now empty", "docstring_tokens": ["Tries", "to", "create", "or", "activate", "a", "worker", "if", "too", "few", "are", "active", "."]}
{"code": "w.growArray();", "comments": "allocate queue", "lines": 2, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.runWorker", "original_string": "final void runWorker(WorkQueue w) {\n        w.growArray();                   // allocate queue\n        int seed = w.hint;               // initially holds randomization hint\n        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n        for (ForkJoinTask<?> t;;) {\n            if ((t = scan(w, r)) != null)\n                w.runTask(t);\n            else if (!awaitWork(w, r))\n                break;\n            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift\n        }\n    }", "language": "java", "Allcodes": "final void runWorker(WorkQueue w) {\n        w.growArray();                   // allocate queue\n        int seed = w.hint;               // initially holds randomization hint\n        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n        for (ForkJoinTask<?> t;;) {\n            if ((t = scan(w, r)) != null)\n                w.runTask(t);\n            else if (!awaitWork(w, r))\n                break;\n            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift\n        }\n    }", "code_tokens": ["final", "void", "runWorker", "(", "WorkQueue", "w", ")", "{", "w", ".", "growArray", "(", ")", ";", "// allocate queue", "int", "seed", "=", "w", ".", "hint", ";", "// initially holds randomization hint", "int", "r", "=", "(", "seed", "==", "0", ")", "?", "1", ":", "seed", ";", "// avoid 0 for xorShift", "for", "(", "ForkJoinTask", "<", "?", ">", "t", ";", ";", ")", "{", "if", "(", "(", "t", "=", "scan", "(", "w", ",", "r", ")", ")", "!=", "null", ")", "w", ".", "runTask", "(", "t", ")", ";", "else", "if", "(", "!", "awaitWork", "(", "w", ",", "r", ")", ")", "break", ";", "r", "^=", "r", "<<", "13", ";", "r", "^=", "r", ">>>", "17", ";", "r", "^=", "r", "<<", "5", ";", "// xorshift", "}", "}"], "docstring": "Top-level runloop for workers, called by ForkJoinWorkerThread.run.", "docstring_tokens": ["Top", "-", "level", "runloop", "for", "workers", "called", "by", "ForkJoinWorkerThread", ".", "run", "."]}
{"code": "int seed = w.hint;", "comments": "initially holds randomization hint", "lines": 3, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.runWorker", "original_string": "final void runWorker(WorkQueue w) {\n        w.growArray();                   // allocate queue\n        int seed = w.hint;               // initially holds randomization hint\n        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n        for (ForkJoinTask<?> t;;) {\n            if ((t = scan(w, r)) != null)\n                w.runTask(t);\n            else if (!awaitWork(w, r))\n                break;\n            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift\n        }\n    }", "language": "java", "Allcodes": "final void runWorker(WorkQueue w) {\n        w.growArray();                   // allocate queue\n        int seed = w.hint;               // initially holds randomization hint\n        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n        for (ForkJoinTask<?> t;;) {\n            if ((t = scan(w, r)) != null)\n                w.runTask(t);\n            else if (!awaitWork(w, r))\n                break;\n            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift\n        }\n    }", "code_tokens": ["final", "void", "runWorker", "(", "WorkQueue", "w", ")", "{", "w", ".", "growArray", "(", ")", ";", "// allocate queue", "int", "seed", "=", "w", ".", "hint", ";", "// initially holds randomization hint", "int", "r", "=", "(", "seed", "==", "0", ")", "?", "1", ":", "seed", ";", "// avoid 0 for xorShift", "for", "(", "ForkJoinTask", "<", "?", ">", "t", ";", ";", ")", "{", "if", "(", "(", "t", "=", "scan", "(", "w", ",", "r", ")", ")", "!=", "null", ")", "w", ".", "runTask", "(", "t", ")", ";", "else", "if", "(", "!", "awaitWork", "(", "w", ",", "r", ")", ")", "break", ";", "r", "^=", "r", "<<", "13", ";", "r", "^=", "r", ">>>", "17", ";", "r", "^=", "r", "<<", "5", ";", "// xorshift", "}", "}"], "docstring": "Top-level runloop for workers, called by ForkJoinWorkerThread.run.", "docstring_tokens": ["Top", "-", "level", "runloop", "for", "workers", "called", "by", "ForkJoinWorkerThread", ".", "run", "."]}
{"code": "int r = (seed == 0) ? 1 : seed;", "comments": "avoid 0 for xorShift", "lines": 4, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.runWorker", "original_string": "final void runWorker(WorkQueue w) {\n        w.growArray();                   // allocate queue\n        int seed = w.hint;               // initially holds randomization hint\n        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n        for (ForkJoinTask<?> t;;) {\n            if ((t = scan(w, r)) != null)\n                w.runTask(t);\n            else if (!awaitWork(w, r))\n                break;\n            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift\n        }\n    }", "language": "java", "Allcodes": "final void runWorker(WorkQueue w) {\n        w.growArray();                   // allocate queue\n        int seed = w.hint;               // initially holds randomization hint\n        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n        for (ForkJoinTask<?> t;;) {\n            if ((t = scan(w, r)) != null)\n                w.runTask(t);\n            else if (!awaitWork(w, r))\n                break;\n            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift\n        }\n    }", "code_tokens": ["final", "void", "runWorker", "(", "WorkQueue", "w", ")", "{", "w", ".", "growArray", "(", ")", ";", "// allocate queue", "int", "seed", "=", "w", ".", "hint", ";", "// initially holds randomization hint", "int", "r", "=", "(", "seed", "==", "0", ")", "?", "1", ":", "seed", ";", "// avoid 0 for xorShift", "for", "(", "ForkJoinTask", "<", "?", ">", "t", ";", ";", ")", "{", "if", "(", "(", "t", "=", "scan", "(", "w", ",", "r", ")", ")", "!=", "null", ")", "w", ".", "runTask", "(", "t", ")", ";", "else", "if", "(", "!", "awaitWork", "(", "w", ",", "r", ")", ")", "break", ";", "r", "^=", "r", "<<", "13", ";", "r", "^=", "r", ">>>", "17", ";", "r", "^=", "r", "<<", "5", ";", "// xorshift", "}", "}"], "docstring": "Top-level runloop for workers, called by ForkJoinWorkerThread.run.", "docstring_tokens": ["Top", "-", "level", "runloop", "for", "workers", "called", "by", "ForkJoinWorkerThread", ".", "run", "."]}
{"code": "spins = SPINS;", "comments": "continue spinning", "lines": 15, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.awaitWork", "original_string": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "language": "java", "Allcodes": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "awaitWork", "(", "WorkQueue", "w", ",", "int", "r", ")", "{", "if", "(", "w", "==", "null", "||", "w", ".", "qlock", "<", "0", ")", "// w is terminating", "return", "false", ";", "for", "(", "int", "pred", "=", "w", ".", "stackPred", ",", "spins", "=", "SPINS", ",", "ss", ";", ";", ")", "{", "if", "(", "(", "ss", "=", "w", ".", "scanState", ")", ">=", "0", ")", "break", ";", "else", "if", "(", "spins", ">", "0", ")", "{", "r", "^=", "r", "<<", "6", ";", "r", "^=", "r", ">>>", "21", ";", "r", "^=", "r", "<<", "7", ";", "if", "(", "r", ">=", "0", "&&", "--", "spins", "==", "0", ")", "{", "// randomize spins", "WorkQueue", "v", ";", "WorkQueue", "[", "]", "ws", ";", "int", "s", ",", "j", ";", "AtomicLong", "sc", ";", "if", "(", "pred", "!=", "0", "&&", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "j", "=", "pred", "&", "SMASK", ")", "<", "ws", ".", "length", "&&", "(", "v", "=", "ws", "[", "j", "]", ")", "!=", "null", "&&", "// see if pred parking", "(", "v", ".", "parker", "==", "null", "||", "v", ".", "scanState", ">=", "0", ")", ")", "spins", "=", "SPINS", ";", "// continue spinning", "}", "}", "else", "if", "(", "w", ".", "qlock", "<", "0", ")", "// recheck after spins", "return", "false", ";", "else", "if", "(", "!", "Thread", ".", "interrupted", "(", ")", ")", "{", "long", "c", ",", "prevctl", ",", "parkTime", ",", "deadline", ";", "int", "ac", "=", "(", "int", ")", "(", "(", "c", "=", "ctl", ")", ">>", "AC_SHIFT", ")", "+", "(", "config", "&", "SMASK", ")", ";", "if", "(", "(", "ac", "<=", "0", "&&", "tryTerminate", "(", "false", ",", "false", ")", ")", "||", "(", "runState", "&", "STOP", ")", "!=", "0", ")", "// pool terminating", "return", "false", ";", "if", "(", "ac", "<=", "0", "&&", "ss", "==", "(", "int", ")", "c", ")", "{", "// is last waiter", "prevctl", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "pred", ")", ";", "int", "t", "=", "(", "short", ")", "(", "c", ">>>", "TC_SHIFT", ")", ";", "// shrink excess spares", "if", "(", "t", ">", "2", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// else use timed wait", "parkTime", "=", "IDLE_TIMEOUT", "*", "(", "(", "t", ">=", "0", ")", "?", "1", ":", "1", "-", "t", ")", ";", "deadline", "=", "System", ".", "nanoTime", "(", ")", "+", "parkTime", "-", "TIMEOUT_SLOP", ";", "}", "else", "prevctl", "=", "parkTime", "=", "deadline", "=", "0L", ";", "Thread", "wt", "=", "Thread", ".", "currentThread", "(", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "this", ")", ";", "// emulate LockSupport", "w", ".", "parker", "=", "wt", ";", "if", "(", "w", ".", "scanState", "<", "0", "&&", "ctl", "==", "c", ")", "// recheck before park", "U", ".", "park", "(", "false", ",", "parkTime", ")", ";", "U", ".", "putOrderedObject", "(", "w", ",", "QPARKER", ",", "null", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "null", ")", ";", "if", "(", "w", ".", "scanState", ">=", "0", ")", "break", ";", "if", "(", "parkTime", "!=", "0L", "&&", "ctl", "==", "c", "&&", "deadline", "-", "System", ".", "nanoTime", "(", ")", "<=", "0L", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// shrink pool", "}", "}", "return", "true", ";", "}"], "docstring": "Possibly blocks worker w waiting for a task to steal, or\nreturns false if the worker should terminate.  If inactivating\nw has caused the pool to become quiescent, checks for pool\ntermination, and, so long as this is not the only worker, waits\nfor up to a given duration.  On timeout, if ctl has not\nchanged, terminates the worker, which will in turn wake up\nanother worker to possibly repeat this process.\n\n@param w the calling worker\n@param r a random seed (for spins)\n@return false if the worker should terminate", "docstring_tokens": ["Possibly", "blocks", "worker", "w", "waiting", "for", "a", "task", "to", "steal", "or", "returns", "false", "if", "the", "worker", "should", "terminate", ".", "If", "inactivating", "w", "has", "caused", "the", "pool", "to", "become", "quiescent", "checks", "for", "pool", "termination", "and", "so", "long", "as", "this", "is", "not", "the", "only", "worker", "waits", "for", "up", "to", "a", "given", "duration", ".", "On", "timeout", "if", "ctl", "has", "not", "changed", "terminates", "the", "worker", "which", "will", "in", "turn", "wake", "up", "another", "worker", "to", "possibly", "repeat", "this", "process", "."]}
{"code": "int t = (short)(c >>> TC_SHIFT);", "comments": "shrink excess spares", "lines": 28, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.awaitWork", "original_string": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "language": "java", "Allcodes": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "awaitWork", "(", "WorkQueue", "w", ",", "int", "r", ")", "{", "if", "(", "w", "==", "null", "||", "w", ".", "qlock", "<", "0", ")", "// w is terminating", "return", "false", ";", "for", "(", "int", "pred", "=", "w", ".", "stackPred", ",", "spins", "=", "SPINS", ",", "ss", ";", ";", ")", "{", "if", "(", "(", "ss", "=", "w", ".", "scanState", ")", ">=", "0", ")", "break", ";", "else", "if", "(", "spins", ">", "0", ")", "{", "r", "^=", "r", "<<", "6", ";", "r", "^=", "r", ">>>", "21", ";", "r", "^=", "r", "<<", "7", ";", "if", "(", "r", ">=", "0", "&&", "--", "spins", "==", "0", ")", "{", "// randomize spins", "WorkQueue", "v", ";", "WorkQueue", "[", "]", "ws", ";", "int", "s", ",", "j", ";", "AtomicLong", "sc", ";", "if", "(", "pred", "!=", "0", "&&", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "j", "=", "pred", "&", "SMASK", ")", "<", "ws", ".", "length", "&&", "(", "v", "=", "ws", "[", "j", "]", ")", "!=", "null", "&&", "// see if pred parking", "(", "v", ".", "parker", "==", "null", "||", "v", ".", "scanState", ">=", "0", ")", ")", "spins", "=", "SPINS", ";", "// continue spinning", "}", "}", "else", "if", "(", "w", ".", "qlock", "<", "0", ")", "// recheck after spins", "return", "false", ";", "else", "if", "(", "!", "Thread", ".", "interrupted", "(", ")", ")", "{", "long", "c", ",", "prevctl", ",", "parkTime", ",", "deadline", ";", "int", "ac", "=", "(", "int", ")", "(", "(", "c", "=", "ctl", ")", ">>", "AC_SHIFT", ")", "+", "(", "config", "&", "SMASK", ")", ";", "if", "(", "(", "ac", "<=", "0", "&&", "tryTerminate", "(", "false", ",", "false", ")", ")", "||", "(", "runState", "&", "STOP", ")", "!=", "0", ")", "// pool terminating", "return", "false", ";", "if", "(", "ac", "<=", "0", "&&", "ss", "==", "(", "int", ")", "c", ")", "{", "// is last waiter", "prevctl", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "pred", ")", ";", "int", "t", "=", "(", "short", ")", "(", "c", ">>>", "TC_SHIFT", ")", ";", "// shrink excess spares", "if", "(", "t", ">", "2", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// else use timed wait", "parkTime", "=", "IDLE_TIMEOUT", "*", "(", "(", "t", ">=", "0", ")", "?", "1", ":", "1", "-", "t", ")", ";", "deadline", "=", "System", ".", "nanoTime", "(", ")", "+", "parkTime", "-", "TIMEOUT_SLOP", ";", "}", "else", "prevctl", "=", "parkTime", "=", "deadline", "=", "0L", ";", "Thread", "wt", "=", "Thread", ".", "currentThread", "(", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "this", ")", ";", "// emulate LockSupport", "w", ".", "parker", "=", "wt", ";", "if", "(", "w", ".", "scanState", "<", "0", "&&", "ctl", "==", "c", ")", "// recheck before park", "U", ".", "park", "(", "false", ",", "parkTime", ")", ";", "U", ".", "putOrderedObject", "(", "w", ",", "QPARKER", ",", "null", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "null", ")", ";", "if", "(", "w", ".", "scanState", ">=", "0", ")", "break", ";", "if", "(", "parkTime", "!=", "0L", "&&", "ctl", "==", "c", "&&", "deadline", "-", "System", ".", "nanoTime", "(", ")", "<=", "0L", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// shrink pool", "}", "}", "return", "true", ";", "}"], "docstring": "Possibly blocks worker w waiting for a task to steal, or\nreturns false if the worker should terminate.  If inactivating\nw has caused the pool to become quiescent, checks for pool\ntermination, and, so long as this is not the only worker, waits\nfor up to a given duration.  On timeout, if ctl has not\nchanged, terminates the worker, which will in turn wake up\nanother worker to possibly repeat this process.\n\n@param w the calling worker\n@param r a random seed (for spins)\n@return false if the worker should terminate", "docstring_tokens": ["Possibly", "blocks", "worker", "w", "waiting", "for", "a", "task", "to", "steal", "or", "returns", "false", "if", "the", "worker", "should", "terminate", ".", "If", "inactivating", "w", "has", "caused", "the", "pool", "to", "become", "quiescent", "checks", "for", "pool", "termination", "and", "so", "long", "as", "this", "is", "not", "the", "only", "worker", "waits", "for", "up", "to", "a", "given", "duration", ".", "On", "timeout", "if", "ctl", "has", "not", "changed", "terminates", "the", "worker", "which", "will", "in", "turn", "wake", "up", "another", "worker", "to", "possibly", "repeat", "this", "process", "."]}
{"code": "return false;", "comments": "else use timed wait", "lines": 30, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.awaitWork", "original_string": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "language": "java", "Allcodes": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "awaitWork", "(", "WorkQueue", "w", ",", "int", "r", ")", "{", "if", "(", "w", "==", "null", "||", "w", ".", "qlock", "<", "0", ")", "// w is terminating", "return", "false", ";", "for", "(", "int", "pred", "=", "w", ".", "stackPred", ",", "spins", "=", "SPINS", ",", "ss", ";", ";", ")", "{", "if", "(", "(", "ss", "=", "w", ".", "scanState", ")", ">=", "0", ")", "break", ";", "else", "if", "(", "spins", ">", "0", ")", "{", "r", "^=", "r", "<<", "6", ";", "r", "^=", "r", ">>>", "21", ";", "r", "^=", "r", "<<", "7", ";", "if", "(", "r", ">=", "0", "&&", "--", "spins", "==", "0", ")", "{", "// randomize spins", "WorkQueue", "v", ";", "WorkQueue", "[", "]", "ws", ";", "int", "s", ",", "j", ";", "AtomicLong", "sc", ";", "if", "(", "pred", "!=", "0", "&&", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "j", "=", "pred", "&", "SMASK", ")", "<", "ws", ".", "length", "&&", "(", "v", "=", "ws", "[", "j", "]", ")", "!=", "null", "&&", "// see if pred parking", "(", "v", ".", "parker", "==", "null", "||", "v", ".", "scanState", ">=", "0", ")", ")", "spins", "=", "SPINS", ";", "// continue spinning", "}", "}", "else", "if", "(", "w", ".", "qlock", "<", "0", ")", "// recheck after spins", "return", "false", ";", "else", "if", "(", "!", "Thread", ".", "interrupted", "(", ")", ")", "{", "long", "c", ",", "prevctl", ",", "parkTime", ",", "deadline", ";", "int", "ac", "=", "(", "int", ")", "(", "(", "c", "=", "ctl", ")", ">>", "AC_SHIFT", ")", "+", "(", "config", "&", "SMASK", ")", ";", "if", "(", "(", "ac", "<=", "0", "&&", "tryTerminate", "(", "false", ",", "false", ")", ")", "||", "(", "runState", "&", "STOP", ")", "!=", "0", ")", "// pool terminating", "return", "false", ";", "if", "(", "ac", "<=", "0", "&&", "ss", "==", "(", "int", ")", "c", ")", "{", "// is last waiter", "prevctl", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "pred", ")", ";", "int", "t", "=", "(", "short", ")", "(", "c", ">>>", "TC_SHIFT", ")", ";", "// shrink excess spares", "if", "(", "t", ">", "2", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// else use timed wait", "parkTime", "=", "IDLE_TIMEOUT", "*", "(", "(", "t", ">=", "0", ")", "?", "1", ":", "1", "-", "t", ")", ";", "deadline", "=", "System", ".", "nanoTime", "(", ")", "+", "parkTime", "-", "TIMEOUT_SLOP", ";", "}", "else", "prevctl", "=", "parkTime", "=", "deadline", "=", "0L", ";", "Thread", "wt", "=", "Thread", ".", "currentThread", "(", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "this", ")", ";", "// emulate LockSupport", "w", ".", "parker", "=", "wt", ";", "if", "(", "w", ".", "scanState", "<", "0", "&&", "ctl", "==", "c", ")", "// recheck before park", "U", ".", "park", "(", "false", ",", "parkTime", ")", ";", "U", ".", "putOrderedObject", "(", "w", ",", "QPARKER", ",", "null", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "null", ")", ";", "if", "(", "w", ".", "scanState", ">=", "0", ")", "break", ";", "if", "(", "parkTime", "!=", "0L", "&&", "ctl", "==", "c", "&&", "deadline", "-", "System", ".", "nanoTime", "(", ")", "<=", "0L", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// shrink pool", "}", "}", "return", "true", ";", "}"], "docstring": "Possibly blocks worker w waiting for a task to steal, or\nreturns false if the worker should terminate.  If inactivating\nw has caused the pool to become quiescent, checks for pool\ntermination, and, so long as this is not the only worker, waits\nfor up to a given duration.  On timeout, if ctl has not\nchanged, terminates the worker, which will in turn wake up\nanother worker to possibly repeat this process.\n\n@param w the calling worker\n@param r a random seed (for spins)\n@return false if the worker should terminate", "docstring_tokens": ["Possibly", "blocks", "worker", "w", "waiting", "for", "a", "task", "to", "steal", "or", "returns", "false", "if", "the", "worker", "should", "terminate", ".", "If", "inactivating", "w", "has", "caused", "the", "pool", "to", "become", "quiescent", "checks", "for", "pool", "termination", "and", "so", "long", "as", "this", "is", "not", "the", "only", "worker", "waits", "for", "up", "to", "a", "given", "duration", ".", "On", "timeout", "if", "ctl", "has", "not", "changed", "terminates", "the", "worker", "which", "will", "in", "turn", "wake", "up", "another", "worker", "to", "possibly", "repeat", "this", "process", "."]}
{"code": "U.putObject(wt, PARKBLOCKER, this);", "comments": "emulate LockSupport", "lines": 37, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.awaitWork", "original_string": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "language": "java", "Allcodes": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "awaitWork", "(", "WorkQueue", "w", ",", "int", "r", ")", "{", "if", "(", "w", "==", "null", "||", "w", ".", "qlock", "<", "0", ")", "// w is terminating", "return", "false", ";", "for", "(", "int", "pred", "=", "w", ".", "stackPred", ",", "spins", "=", "SPINS", ",", "ss", ";", ";", ")", "{", "if", "(", "(", "ss", "=", "w", ".", "scanState", ")", ">=", "0", ")", "break", ";", "else", "if", "(", "spins", ">", "0", ")", "{", "r", "^=", "r", "<<", "6", ";", "r", "^=", "r", ">>>", "21", ";", "r", "^=", "r", "<<", "7", ";", "if", "(", "r", ">=", "0", "&&", "--", "spins", "==", "0", ")", "{", "// randomize spins", "WorkQueue", "v", ";", "WorkQueue", "[", "]", "ws", ";", "int", "s", ",", "j", ";", "AtomicLong", "sc", ";", "if", "(", "pred", "!=", "0", "&&", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "j", "=", "pred", "&", "SMASK", ")", "<", "ws", ".", "length", "&&", "(", "v", "=", "ws", "[", "j", "]", ")", "!=", "null", "&&", "// see if pred parking", "(", "v", ".", "parker", "==", "null", "||", "v", ".", "scanState", ">=", "0", ")", ")", "spins", "=", "SPINS", ";", "// continue spinning", "}", "}", "else", "if", "(", "w", ".", "qlock", "<", "0", ")", "// recheck after spins", "return", "false", ";", "else", "if", "(", "!", "Thread", ".", "interrupted", "(", ")", ")", "{", "long", "c", ",", "prevctl", ",", "parkTime", ",", "deadline", ";", "int", "ac", "=", "(", "int", ")", "(", "(", "c", "=", "ctl", ")", ">>", "AC_SHIFT", ")", "+", "(", "config", "&", "SMASK", ")", ";", "if", "(", "(", "ac", "<=", "0", "&&", "tryTerminate", "(", "false", ",", "false", ")", ")", "||", "(", "runState", "&", "STOP", ")", "!=", "0", ")", "// pool terminating", "return", "false", ";", "if", "(", "ac", "<=", "0", "&&", "ss", "==", "(", "int", ")", "c", ")", "{", "// is last waiter", "prevctl", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "pred", ")", ";", "int", "t", "=", "(", "short", ")", "(", "c", ">>>", "TC_SHIFT", ")", ";", "// shrink excess spares", "if", "(", "t", ">", "2", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// else use timed wait", "parkTime", "=", "IDLE_TIMEOUT", "*", "(", "(", "t", ">=", "0", ")", "?", "1", ":", "1", "-", "t", ")", ";", "deadline", "=", "System", ".", "nanoTime", "(", ")", "+", "parkTime", "-", "TIMEOUT_SLOP", ";", "}", "else", "prevctl", "=", "parkTime", "=", "deadline", "=", "0L", ";", "Thread", "wt", "=", "Thread", ".", "currentThread", "(", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "this", ")", ";", "// emulate LockSupport", "w", ".", "parker", "=", "wt", ";", "if", "(", "w", ".", "scanState", "<", "0", "&&", "ctl", "==", "c", ")", "// recheck before park", "U", ".", "park", "(", "false", ",", "parkTime", ")", ";", "U", ".", "putOrderedObject", "(", "w", ",", "QPARKER", ",", "null", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "null", ")", ";", "if", "(", "w", ".", "scanState", ">=", "0", ")", "break", ";", "if", "(", "parkTime", "!=", "0L", "&&", "ctl", "==", "c", "&&", "deadline", "-", "System", ".", "nanoTime", "(", ")", "<=", "0L", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// shrink pool", "}", "}", "return", "true", ";", "}"], "docstring": "Possibly blocks worker w waiting for a task to steal, or\nreturns false if the worker should terminate.  If inactivating\nw has caused the pool to become quiescent, checks for pool\ntermination, and, so long as this is not the only worker, waits\nfor up to a given duration.  On timeout, if ctl has not\nchanged, terminates the worker, which will in turn wake up\nanother worker to possibly repeat this process.\n\n@param w the calling worker\n@param r a random seed (for spins)\n@return false if the worker should terminate", "docstring_tokens": ["Possibly", "blocks", "worker", "w", "waiting", "for", "a", "task", "to", "steal", "or", "returns", "false", "if", "the", "worker", "should", "terminate", ".", "If", "inactivating", "w", "has", "caused", "the", "pool", "to", "become", "quiescent", "checks", "for", "pool", "termination", "and", "so", "long", "as", "this", "is", "not", "the", "only", "worker", "waits", "for", "up", "to", "a", "given", "duration", ".", "On", "timeout", "if", "ctl", "has", "not", "changed", "terminates", "the", "worker", "which", "will", "in", "turn", "wake", "up", "another", "worker", "to", "possibly", "repeat", "this", "process", "."]}
{"code": "return false;", "comments": "shrink pool", "lines": 48, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinPool.java", "func_name": "ForkJoinPool.awaitWork", "original_string": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "language": "java", "Allcodes": "private boolean awaitWork(WorkQueue w, int r) {\n        if (w == null || w.qlock < 0)                 // w is terminating\n            return false;\n        for (int pred = w.stackPred, spins = SPINS, ss;;) {\n            if ((ss = w.scanState) >= 0)\n                break;\n            else if (spins > 0) {\n                r ^= r << 6; r ^= r >>> 21; r ^= r << 7;\n                if (r >= 0 && --spins == 0) {         // randomize spins\n                    WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;\n                    if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                        spins = SPINS;                // continue spinning\n                }\n            }\n            else if (w.qlock < 0)                     // recheck after spins\n                return false;\n            else if (!Thread.interrupted()) {\n                long c, prevctl, parkTime, deadline;\n                int ac = (int)((c = ctl) >> AC_SHIFT) + (config & SMASK);\n                if ((ac <= 0 && tryTerminate(false, false)) ||\n                    (runState & STOP) != 0)           // pool terminating\n                    return false;\n                if (ac <= 0 && ss == (int)c) {        // is last waiter\n                    prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                    int t = (short)(c >>> TC_SHIFT);  // shrink excess spares\n                    if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))\n                        return false;                 // else use timed wait\n                    parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n                }\n                else\n                    prevctl = parkTime = deadline = 0L;\n                Thread wt = Thread.currentThread();\n                U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n                w.parker = wt;\n                if (w.scanState < 0 && ctl == c)      // recheck before park\n                    U.park(false, parkTime);\n                U.putOrderedObject(w, QPARKER, null);\n                U.putObject(wt, PARKBLOCKER, null);\n                if (w.scanState >= 0)\n                    break;\n                if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))\n                    return false;                     // shrink pool\n            }\n        }\n        return true;\n    }", "code_tokens": ["private", "boolean", "awaitWork", "(", "WorkQueue", "w", ",", "int", "r", ")", "{", "if", "(", "w", "==", "null", "||", "w", ".", "qlock", "<", "0", ")", "// w is terminating", "return", "false", ";", "for", "(", "int", "pred", "=", "w", ".", "stackPred", ",", "spins", "=", "SPINS", ",", "ss", ";", ";", ")", "{", "if", "(", "(", "ss", "=", "w", ".", "scanState", ")", ">=", "0", ")", "break", ";", "else", "if", "(", "spins", ">", "0", ")", "{", "r", "^=", "r", "<<", "6", ";", "r", "^=", "r", ">>>", "21", ";", "r", "^=", "r", "<<", "7", ";", "if", "(", "r", ">=", "0", "&&", "--", "spins", "==", "0", ")", "{", "// randomize spins", "WorkQueue", "v", ";", "WorkQueue", "[", "]", "ws", ";", "int", "s", ",", "j", ";", "AtomicLong", "sc", ";", "if", "(", "pred", "!=", "0", "&&", "(", "ws", "=", "workQueues", ")", "!=", "null", "&&", "(", "j", "=", "pred", "&", "SMASK", ")", "<", "ws", ".", "length", "&&", "(", "v", "=", "ws", "[", "j", "]", ")", "!=", "null", "&&", "// see if pred parking", "(", "v", ".", "parker", "==", "null", "||", "v", ".", "scanState", ">=", "0", ")", ")", "spins", "=", "SPINS", ";", "// continue spinning", "}", "}", "else", "if", "(", "w", ".", "qlock", "<", "0", ")", "// recheck after spins", "return", "false", ";", "else", "if", "(", "!", "Thread", ".", "interrupted", "(", ")", ")", "{", "long", "c", ",", "prevctl", ",", "parkTime", ",", "deadline", ";", "int", "ac", "=", "(", "int", ")", "(", "(", "c", "=", "ctl", ")", ">>", "AC_SHIFT", ")", "+", "(", "config", "&", "SMASK", ")", ";", "if", "(", "(", "ac", "<=", "0", "&&", "tryTerminate", "(", "false", ",", "false", ")", ")", "||", "(", "runState", "&", "STOP", ")", "!=", "0", ")", "// pool terminating", "return", "false", ";", "if", "(", "ac", "<=", "0", "&&", "ss", "==", "(", "int", ")", "c", ")", "{", "// is last waiter", "prevctl", "=", "(", "UC_MASK", "&", "(", "c", "+", "AC_UNIT", ")", ")", "|", "(", "SP_MASK", "&", "pred", ")", ";", "int", "t", "=", "(", "short", ")", "(", "c", ">>>", "TC_SHIFT", ")", ";", "// shrink excess spares", "if", "(", "t", ">", "2", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// else use timed wait", "parkTime", "=", "IDLE_TIMEOUT", "*", "(", "(", "t", ">=", "0", ")", "?", "1", ":", "1", "-", "t", ")", ";", "deadline", "=", "System", ".", "nanoTime", "(", ")", "+", "parkTime", "-", "TIMEOUT_SLOP", ";", "}", "else", "prevctl", "=", "parkTime", "=", "deadline", "=", "0L", ";", "Thread", "wt", "=", "Thread", ".", "currentThread", "(", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "this", ")", ";", "// emulate LockSupport", "w", ".", "parker", "=", "wt", ";", "if", "(", "w", ".", "scanState", "<", "0", "&&", "ctl", "==", "c", ")", "// recheck before park", "U", ".", "park", "(", "false", ",", "parkTime", ")", ";", "U", ".", "putOrderedObject", "(", "w", ",", "QPARKER", ",", "null", ")", ";", "U", ".", "putObject", "(", "wt", ",", "PARKBLOCKER", ",", "null", ")", ";", "if", "(", "w", ".", "scanState", ">=", "0", ")", "break", ";", "if", "(", "parkTime", "!=", "0L", "&&", "ctl", "==", "c", "&&", "deadline", "-", "System", ".", "nanoTime", "(", ")", "<=", "0L", "&&", "U", ".", "compareAndSwapLong", "(", "this", ",", "CTL", ",", "c", ",", "prevctl", ")", ")", "return", "false", ";", "// shrink pool", "}", "}", "return", "true", ";", "}"], "docstring": "Possibly blocks worker w waiting for a task to steal, or\nreturns false if the worker should terminate.  If inactivating\nw has caused the pool to become quiescent, checks for pool\ntermination, and, so long as this is not the only worker, waits\nfor up to a given duration.  On timeout, if ctl has not\nchanged, terminates the worker, which will in turn wake up\nanother worker to possibly repeat this process.\n\n@param w the calling worker\n@param r a random seed (for spins)\n@return false if the worker should terminate", "docstring_tokens": ["Possibly", "blocks", "worker", "w", "waiting", "for", "a", "task", "to", "steal", "or", "returns", "false", "if", "the", "worker", "should", "terminate", ".", "If", "inactivating", "w", "has", "caused", "the", "pool", "to", "become", "quiescent", "checks", "for", "pool", "termination", "and", "so", "long", "as", "this", "is", "not", "the", "only", "worker", "waits", "for", "up", "to", "a", "given", "duration", ".", "On", "timeout", "if", "ctl", "has", "not", "changed", "terminates", "the", "worker", "which", "will", "in", "turn", "wake", "up", "another", "worker", "to", "possibly", "repeat", "this", "process", "."]}
{"code": "long deadline = (d == 0L) ? 1L : d;", "comments": "avoid 0", "lines": 9, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinTask.java", "func_name": "ForkJoinTask.get", "original_string": "public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        int s;\n        long nanos = unit.toNanos(timeout);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if ((s = status) >= 0 && nanos > 0L) {\n            long d = System.nanoTime() + nanos;\n            long deadline = (d == 0L) ? 1L : d; // avoid 0\n            Thread t = Thread.currentThread();\n            if (t instanceof ForkJoinWorkerThread) {\n                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n            }\n            else if ((s = ((this instanceof CountedCompleter) ?\n                           ForkJoinPool.common.externalHelpComplete(\n                               (CountedCompleter<?>)this, 0) :\n                           ForkJoinPool.common.tryExternalUnpush(this) ?\n                           doExec() : 0)) >= 0) {\n                long ns, ms; // measure in nanosecs, but wait in millisecs\n                while ((s = status) >= 0 &&\n                       (ns = deadline - System.nanoTime()) > 0L) {\n                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n                        U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                        synchronized (this) {\n                            if (status >= 0)\n                                wait(ms); // OK to throw InterruptedException\n                            else\n                                notifyAll();\n                        }\n                    }\n                }\n            }\n        }\n        if (s >= 0)\n            s = status;\n        if ((s &= DONE_MASK) != NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s != EXCEPTIONAL)\n                throw new TimeoutException();\n            if ((ex = getThrowableException()) != null)\n                throw new ExecutionException(ex);\n        }\n        return getRawResult();\n    }", "language": "java", "Allcodes": "public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        int s;\n        long nanos = unit.toNanos(timeout);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if ((s = status) >= 0 && nanos > 0L) {\n            long d = System.nanoTime() + nanos;\n            long deadline = (d == 0L) ? 1L : d; // avoid 0\n            Thread t = Thread.currentThread();\n            if (t instanceof ForkJoinWorkerThread) {\n                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n            }\n            else if ((s = ((this instanceof CountedCompleter) ?\n                           ForkJoinPool.common.externalHelpComplete(\n                               (CountedCompleter<?>)this, 0) :\n                           ForkJoinPool.common.tryExternalUnpush(this) ?\n                           doExec() : 0)) >= 0) {\n                long ns, ms; // measure in nanosecs, but wait in millisecs\n                while ((s = status) >= 0 &&\n                       (ns = deadline - System.nanoTime()) > 0L) {\n                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n                        U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                        synchronized (this) {\n                            if (status >= 0)\n                                wait(ms); // OK to throw InterruptedException\n                            else\n                                notifyAll();\n                        }\n                    }\n                }\n            }\n        }\n        if (s >= 0)\n            s = status;\n        if ((s &= DONE_MASK) != NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s != EXCEPTIONAL)\n                throw new TimeoutException();\n            if ((ex = getThrowableException()) != null)\n                throw new ExecutionException(ex);\n        }\n        return getRawResult();\n    }", "code_tokens": ["public", "final", "V", "get", "(", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", ",", "ExecutionException", ",", "TimeoutException", "{", "int", "s", ";", "long", "nanos", "=", "unit", ".", "toNanos", "(", "timeout", ")", ";", "if", "(", "Thread", ".", "interrupted", "(", ")", ")", "throw", "new", "InterruptedException", "(", ")", ";", "if", "(", "(", "s", "=", "status", ")", ">=", "0", "&&", "nanos", ">", "0L", ")", "{", "long", "d", "=", "System", ".", "nanoTime", "(", ")", "+", "nanos", ";", "long", "deadline", "=", "(", "d", "==", "0L", ")", "?", "1L", ":", "d", ";", "// avoid 0", "Thread", "t", "=", "Thread", ".", "currentThread", "(", ")", ";", "if", "(", "t", "instanceof", "ForkJoinWorkerThread", ")", "{", "ForkJoinWorkerThread", "wt", "=", "(", "ForkJoinWorkerThread", ")", "t", ";", "s", "=", "wt", ".", "pool", ".", "awaitJoin", "(", "wt", ".", "workQueue", ",", "this", ",", "deadline", ")", ";", "}", "else", "if", "(", "(", "s", "=", "(", "(", "this", "instanceof", "CountedCompleter", ")", "?", "ForkJoinPool", ".", "common", ".", "externalHelpComplete", "(", "(", "CountedCompleter", "<", "?", ">", ")", "this", ",", "0", ")", ":", "ForkJoinPool", ".", "common", ".", "tryExternalUnpush", "(", "this", ")", "?", "doExec", "(", ")", ":", "0", ")", ")", ">=", "0", ")", "{", "long", "ns", ",", "ms", ";", "// measure in nanosecs, but wait in millisecs", "while", "(", "(", "s", "=", "status", ")", ">=", "0", "&&", "(", "ns", "=", "deadline", "-", "System", ".", "nanoTime", "(", ")", ")", ">", "0L", ")", "{", "if", "(", "(", "ms", "=", "TimeUnit", ".", "NANOSECONDS", ".", "toMillis", "(", "ns", ")", ")", ">", "0L", "&&", "U", ".", "compareAndSwapInt", "(", "this", ",", "STATUS", ",", "s", ",", "s", "|", "SIGNAL", ")", ")", "{", "synchronized", "(", "this", ")", "{", "if", "(", "status", ">=", "0", ")", "wait", "(", "ms", ")", ";", "// OK to throw InterruptedException", "else", "notifyAll", "(", ")", ";", "}", "}", "}", "}", "}", "if", "(", "s", ">=", "0", ")", "s", "=", "status", ";", "if", "(", "(", "s", "&=", "DONE_MASK", ")", "!=", "NORMAL", ")", "{", "Throwable", "ex", ";", "if", "(", "s", "==", "CANCELLED", ")", "throw", "new", "CancellationException", "(", ")", ";", "if", "(", "s", "!=", "EXCEPTIONAL", ")", "throw", "new", "TimeoutException", "(", ")", ";", "if", "(", "(", "ex", "=", "getThrowableException", "(", ")", ")", "!=", "null", ")", "throw", "new", "ExecutionException", "(", "ex", ")", ";", "}", "return", "getRawResult", "(", ")", ";", "}"], "docstring": "Waits if necessary for at most the given time for the computation\nto complete, and then retrieves its result, if available.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the timeout argument\n@return the computed result\n@throws CancellationException if the computation was cancelled\n@throws ExecutionException if the computation threw an\nexception\n@throws InterruptedException if the current thread is not a\nmember of a ForkJoinPool and was interrupted while waiting\n@throws TimeoutException if the wait timed out", "docstring_tokens": ["Waits", "if", "necessary", "for", "at", "most", "the", "given", "time", "for", "the", "computation", "to", "complete", "and", "then", "retrieves", "its", "result", "if", "available", "."]}
{"code": "long ns, ms;", "comments": "measure in nanosecs, but wait in millisecs", "lines": 20, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinTask.java", "func_name": "ForkJoinTask.get", "original_string": "public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        int s;\n        long nanos = unit.toNanos(timeout);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if ((s = status) >= 0 && nanos > 0L) {\n            long d = System.nanoTime() + nanos;\n            long deadline = (d == 0L) ? 1L : d; // avoid 0\n            Thread t = Thread.currentThread();\n            if (t instanceof ForkJoinWorkerThread) {\n                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n            }\n            else if ((s = ((this instanceof CountedCompleter) ?\n                           ForkJoinPool.common.externalHelpComplete(\n                               (CountedCompleter<?>)this, 0) :\n                           ForkJoinPool.common.tryExternalUnpush(this) ?\n                           doExec() : 0)) >= 0) {\n                long ns, ms; // measure in nanosecs, but wait in millisecs\n                while ((s = status) >= 0 &&\n                       (ns = deadline - System.nanoTime()) > 0L) {\n                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n                        U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                        synchronized (this) {\n                            if (status >= 0)\n                                wait(ms); // OK to throw InterruptedException\n                            else\n                                notifyAll();\n                        }\n                    }\n                }\n            }\n        }\n        if (s >= 0)\n            s = status;\n        if ((s &= DONE_MASK) != NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s != EXCEPTIONAL)\n                throw new TimeoutException();\n            if ((ex = getThrowableException()) != null)\n                throw new ExecutionException(ex);\n        }\n        return getRawResult();\n    }", "language": "java", "Allcodes": "public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        int s;\n        long nanos = unit.toNanos(timeout);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if ((s = status) >= 0 && nanos > 0L) {\n            long d = System.nanoTime() + nanos;\n            long deadline = (d == 0L) ? 1L : d; // avoid 0\n            Thread t = Thread.currentThread();\n            if (t instanceof ForkJoinWorkerThread) {\n                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n            }\n            else if ((s = ((this instanceof CountedCompleter) ?\n                           ForkJoinPool.common.externalHelpComplete(\n                               (CountedCompleter<?>)this, 0) :\n                           ForkJoinPool.common.tryExternalUnpush(this) ?\n                           doExec() : 0)) >= 0) {\n                long ns, ms; // measure in nanosecs, but wait in millisecs\n                while ((s = status) >= 0 &&\n                       (ns = deadline - System.nanoTime()) > 0L) {\n                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n                        U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                        synchronized (this) {\n                            if (status >= 0)\n                                wait(ms); // OK to throw InterruptedException\n                            else\n                                notifyAll();\n                        }\n                    }\n                }\n            }\n        }\n        if (s >= 0)\n            s = status;\n        if ((s &= DONE_MASK) != NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s != EXCEPTIONAL)\n                throw new TimeoutException();\n            if ((ex = getThrowableException()) != null)\n                throw new ExecutionException(ex);\n        }\n        return getRawResult();\n    }", "code_tokens": ["public", "final", "V", "get", "(", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", ",", "ExecutionException", ",", "TimeoutException", "{", "int", "s", ";", "long", "nanos", "=", "unit", ".", "toNanos", "(", "timeout", ")", ";", "if", "(", "Thread", ".", "interrupted", "(", ")", ")", "throw", "new", "InterruptedException", "(", ")", ";", "if", "(", "(", "s", "=", "status", ")", ">=", "0", "&&", "nanos", ">", "0L", ")", "{", "long", "d", "=", "System", ".", "nanoTime", "(", ")", "+", "nanos", ";", "long", "deadline", "=", "(", "d", "==", "0L", ")", "?", "1L", ":", "d", ";", "// avoid 0", "Thread", "t", "=", "Thread", ".", "currentThread", "(", ")", ";", "if", "(", "t", "instanceof", "ForkJoinWorkerThread", ")", "{", "ForkJoinWorkerThread", "wt", "=", "(", "ForkJoinWorkerThread", ")", "t", ";", "s", "=", "wt", ".", "pool", ".", "awaitJoin", "(", "wt", ".", "workQueue", ",", "this", ",", "deadline", ")", ";", "}", "else", "if", "(", "(", "s", "=", "(", "(", "this", "instanceof", "CountedCompleter", ")", "?", "ForkJoinPool", ".", "common", ".", "externalHelpComplete", "(", "(", "CountedCompleter", "<", "?", ">", ")", "this", ",", "0", ")", ":", "ForkJoinPool", ".", "common", ".", "tryExternalUnpush", "(", "this", ")", "?", "doExec", "(", ")", ":", "0", ")", ")", ">=", "0", ")", "{", "long", "ns", ",", "ms", ";", "// measure in nanosecs, but wait in millisecs", "while", "(", "(", "s", "=", "status", ")", ">=", "0", "&&", "(", "ns", "=", "deadline", "-", "System", ".", "nanoTime", "(", ")", ")", ">", "0L", ")", "{", "if", "(", "(", "ms", "=", "TimeUnit", ".", "NANOSECONDS", ".", "toMillis", "(", "ns", ")", ")", ">", "0L", "&&", "U", ".", "compareAndSwapInt", "(", "this", ",", "STATUS", ",", "s", ",", "s", "|", "SIGNAL", ")", ")", "{", "synchronized", "(", "this", ")", "{", "if", "(", "status", ">=", "0", ")", "wait", "(", "ms", ")", ";", "// OK to throw InterruptedException", "else", "notifyAll", "(", ")", ";", "}", "}", "}", "}", "}", "if", "(", "s", ">=", "0", ")", "s", "=", "status", ";", "if", "(", "(", "s", "&=", "DONE_MASK", ")", "!=", "NORMAL", ")", "{", "Throwable", "ex", ";", "if", "(", "s", "==", "CANCELLED", ")", "throw", "new", "CancellationException", "(", ")", ";", "if", "(", "s", "!=", "EXCEPTIONAL", ")", "throw", "new", "TimeoutException", "(", ")", ";", "if", "(", "(", "ex", "=", "getThrowableException", "(", ")", ")", "!=", "null", ")", "throw", "new", "ExecutionException", "(", "ex", ")", ";", "}", "return", "getRawResult", "(", ")", ";", "}"], "docstring": "Waits if necessary for at most the given time for the computation\nto complete, and then retrieves its result, if available.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the timeout argument\n@return the computed result\n@throws CancellationException if the computation was cancelled\n@throws ExecutionException if the computation threw an\nexception\n@throws InterruptedException if the current thread is not a\nmember of a ForkJoinPool and was interrupted while waiting\n@throws TimeoutException if the wait timed out", "docstring_tokens": ["Waits", "if", "necessary", "for", "at", "most", "the", "given", "time", "for", "the", "computation", "to", "complete", "and", "then", "retrieves", "its", "result", "if", "available", "."]}
{"code": "wait(ms);", "comments": "OK to throw InterruptedException", "lines": 27, "repo": "arnohaase/a-foundation", "path": "a-foundation-benchmark/src/main/java/com/ajjpj/afoundation/concurrent/jdk/j9new/ForkJoinTask.java", "func_name": "ForkJoinTask.get", "original_string": "public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        int s;\n        long nanos = unit.toNanos(timeout);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if ((s = status) >= 0 && nanos > 0L) {\n            long d = System.nanoTime() + nanos;\n            long deadline = (d == 0L) ? 1L : d; // avoid 0\n            Thread t = Thread.currentThread();\n            if (t instanceof ForkJoinWorkerThread) {\n                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n            }\n            else if ((s = ((this instanceof CountedCompleter) ?\n                           ForkJoinPool.common.externalHelpComplete(\n                               (CountedCompleter<?>)this, 0) :\n                           ForkJoinPool.common.tryExternalUnpush(this) ?\n                           doExec() : 0)) >= 0) {\n                long ns, ms; // measure in nanosecs, but wait in millisecs\n                while ((s = status) >= 0 &&\n                       (ns = deadline - System.nanoTime()) > 0L) {\n                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n                        U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                        synchronized (this) {\n                            if (status >= 0)\n                                wait(ms); // OK to throw InterruptedException\n                            else\n                                notifyAll();\n                        }\n                    }\n                }\n            }\n        }\n        if (s >= 0)\n            s = status;\n        if ((s &= DONE_MASK) != NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s != EXCEPTIONAL)\n                throw new TimeoutException();\n            if ((ex = getThrowableException()) != null)\n                throw new ExecutionException(ex);\n        }\n        return getRawResult();\n    }", "language": "java", "Allcodes": "public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        int s;\n        long nanos = unit.toNanos(timeout);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if ((s = status) >= 0 && nanos > 0L) {\n            long d = System.nanoTime() + nanos;\n            long deadline = (d == 0L) ? 1L : d; // avoid 0\n            Thread t = Thread.currentThread();\n            if (t instanceof ForkJoinWorkerThread) {\n                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;\n                s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\n            }\n            else if ((s = ((this instanceof CountedCompleter) ?\n                           ForkJoinPool.common.externalHelpComplete(\n                               (CountedCompleter<?>)this, 0) :\n                           ForkJoinPool.common.tryExternalUnpush(this) ?\n                           doExec() : 0)) >= 0) {\n                long ns, ms; // measure in nanosecs, but wait in millisecs\n                while ((s = status) >= 0 &&\n                       (ns = deadline - System.nanoTime()) > 0L) {\n                    if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&\n                        U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\n                        synchronized (this) {\n                            if (status >= 0)\n                                wait(ms); // OK to throw InterruptedException\n                            else\n                                notifyAll();\n                        }\n                    }\n                }\n            }\n        }\n        if (s >= 0)\n            s = status;\n        if ((s &= DONE_MASK) != NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s != EXCEPTIONAL)\n                throw new TimeoutException();\n            if ((ex = getThrowableException()) != null)\n                throw new ExecutionException(ex);\n        }\n        return getRawResult();\n    }", "code_tokens": ["public", "final", "V", "get", "(", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", ",", "ExecutionException", ",", "TimeoutException", "{", "int", "s", ";", "long", "nanos", "=", "unit", ".", "toNanos", "(", "timeout", ")", ";", "if", "(", "Thread", ".", "interrupted", "(", ")", ")", "throw", "new", "InterruptedException", "(", ")", ";", "if", "(", "(", "s", "=", "status", ")", ">=", "0", "&&", "nanos", ">", "0L", ")", "{", "long", "d", "=", "System", ".", "nanoTime", "(", ")", "+", "nanos", ";", "long", "deadline", "=", "(", "d", "==", "0L", ")", "?", "1L", ":", "d", ";", "// avoid 0", "Thread", "t", "=", "Thread", ".", "currentThread", "(", ")", ";", "if", "(", "t", "instanceof", "ForkJoinWorkerThread", ")", "{", "ForkJoinWorkerThread", "wt", "=", "(", "ForkJoinWorkerThread", ")", "t", ";", "s", "=", "wt", ".", "pool", ".", "awaitJoin", "(", "wt", ".", "workQueue", ",", "this", ",", "deadline", ")", ";", "}", "else", "if", "(", "(", "s", "=", "(", "(", "this", "instanceof", "CountedCompleter", ")", "?", "ForkJoinPool", ".", "common", ".", "externalHelpComplete", "(", "(", "CountedCompleter", "<", "?", ">", ")", "this", ",", "0", ")", ":", "ForkJoinPool", ".", "common", ".", "tryExternalUnpush", "(", "this", ")", "?", "doExec", "(", ")", ":", "0", ")", ")", ">=", "0", ")", "{", "long", "ns", ",", "ms", ";", "// measure in nanosecs, but wait in millisecs", "while", "(", "(", "s", "=", "status", ")", ">=", "0", "&&", "(", "ns", "=", "deadline", "-", "System", ".", "nanoTime", "(", ")", ")", ">", "0L", ")", "{", "if", "(", "(", "ms", "=", "TimeUnit", ".", "NANOSECONDS", ".", "toMillis", "(", "ns", ")", ")", ">", "0L", "&&", "U", ".", "compareAndSwapInt", "(", "this", ",", "STATUS", ",", "s", ",", "s", "|", "SIGNAL", ")", ")", "{", "synchronized", "(", "this", ")", "{", "if", "(", "status", ">=", "0", ")", "wait", "(", "ms", ")", ";", "// OK to throw InterruptedException", "else", "notifyAll", "(", ")", ";", "}", "}", "}", "}", "}", "if", "(", "s", ">=", "0", ")", "s", "=", "status", ";", "if", "(", "(", "s", "&=", "DONE_MASK", ")", "!=", "NORMAL", ")", "{", "Throwable", "ex", ";", "if", "(", "s", "==", "CANCELLED", ")", "throw", "new", "CancellationException", "(", ")", ";", "if", "(", "s", "!=", "EXCEPTIONAL", ")", "throw", "new", "TimeoutException", "(", ")", ";", "if", "(", "(", "ex", "=", "getThrowableException", "(", ")", ")", "!=", "null", ")", "throw", "new", "ExecutionException", "(", "ex", ")", ";", "}", "return", "getRawResult", "(", ")", ";", "}"], "docstring": "Waits if necessary for at most the given time for the computation\nto complete, and then retrieves its result, if available.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the timeout argument\n@return the computed result\n@throws CancellationException if the computation was cancelled\n@throws ExecutionException if the computation threw an\nexception\n@throws InterruptedException if the current thread is not a\nmember of a ForkJoinPool and was interrupted while waiting\n@throws TimeoutException if the wait timed out", "docstring_tokens": ["Waits", "if", "necessary", "for", "at", "most", "the", "given", "time", "for", "the", "computation", "to", "complete", "and", "then", "retrieves", "its", "result", "if", "available", "."]}
{"code": "final long _base = UNSAFE.getLongVolatile (this, OFFS_BASE);", "comments": "read base first (and only once)", "lines": 2, "repo": "arnohaase/a-foundation", "path": "a-foundation/src/main/java/com/ajjpj/afoundation/concurrent/LocalQueue.java", "func_name": "LocalQueue.push", "original_string": "void push (Runnable task) {\n        final long _base = UNSAFE.getLongVolatile (this, OFFS_BASE); // read base first (and only once)\n        final long _top = top;\n        if (_top == _base + mask) {\n            throw new RejectedExecutionExceptionWithoutStacktrace (\"local queue overflow\");\n        }\n\n        tasks[asArrayindex (_top)] = task;\n        // 'top' is only ever modified by the owning thread, so we need no CAS here. Storing 'top' with volatile semantics publishes the task and ensures that changes to the task\n        //  can never overtake changes to 'top' wrt visibility.\n        UNSAFE.putLongVolatile (this, OFFS_TOP, _top+1);\n\n        // Notify pool only for the first added item per queue.\n        if (_top - _base <= 1) {\n            pool.onAvailableTask();\n        }\n    }", "language": "java", "Allcodes": "void push (Runnable task) {\n        final long _base = UNSAFE.getLongVolatile (this, OFFS_BASE); // read base first (and only once)\n        final long _top = top;\n        if (_top == _base + mask) {\n            throw new RejectedExecutionExceptionWithoutStacktrace (\"local queue overflow\");\n        }\n\n        tasks[asArrayindex (_top)] = task;\n        // 'top' is only ever modified by the owning thread, so we need no CAS here. Storing 'top' with volatile semantics publishes the task and ensures that changes to the task\n        //  can never overtake changes to 'top' wrt visibility.\n        UNSAFE.putLongVolatile (this, OFFS_TOP, _top+1);\n\n        // Notify pool only for the first added item per queue.\n        if (_top - _base <= 1) {\n            pool.onAvailableTask();\n        }\n    }", "code_tokens": ["void", "push", "(", "Runnable", "task", ")", "{", "final", "long", "_base", "=", "UNSAFE", ".", "getLongVolatile", "(", "this", ",", "OFFS_BASE", ")", ";", "// read base first (and only once)", "final", "long", "_top", "=", "top", ";", "if", "(", "_top", "==", "_base", "+", "mask", ")", "{", "throw", "new", "RejectedExecutionExceptionWithoutStacktrace", "(", "\"local queue overflow\"", ")", ";", "}", "tasks", "[", "asArrayindex", "(", "_top", ")", "]", "=", "task", ";", "// 'top' is only ever modified by the owning thread, so we need no CAS here. Storing 'top' with volatile semantics publishes the task and ensures that changes to the task", "//  can never overtake changes to 'top' wrt visibility.", "UNSAFE", ".", "putLongVolatile", "(", "this", ",", "OFFS_TOP", ",", "_top", "+", "1", ")", ";", "// Notify pool only for the first added item per queue.", "if", "(", "_top", "-", "_base", "<=", "1", ")", "{", "pool", ".", "onAvailableTask", "(", ")", ";", "}", "}"], "docstring": "Add a new task to the top of the localQueue, incrementing 'top'. This is only ever called from the owning thread.", "docstring_tokens": ["Add", "a", "new", "task", "to", "the", "top", "of", "the", "localQueue", "incrementing", "top", ".", "This", "is", "only", "ever", "called", "from", "the", "owning", "thread", "."]}
{"code": "return value;", "comments": "return value as is - it does not contain any special characters", "lines": 17, "repo": "truward/brikar", "path": "brikar-common/src/main/java/com/truward/brikar/common/log/LogUtil.java", "func_name": "LogUtil.encodeString", "original_string": "public static String encodeString(String value) {\n    int estimatedSize = 0;\n    final int len = value.length();\n\n    // estimate output string size to find out whether encoding is required and avoid reallocations in string builder\n    for (int i = 0; i < len; ++i) {\n      final char ch = value.charAt(i);\n      if (ch <= ' ' || ch == ',') {\n        estimatedSize += 3;\n        continue;\n      }\n\n      ++estimatedSize;\n    }\n\n    if (value.length() == estimatedSize) {\n      return value; // return value as is - it does not contain any special characters\n    }\n\n    final StringBuilder builder = new StringBuilder(estimatedSize);\n    for (int i = 0; i < len; ++i) {\n      final char ch = value.charAt(i);\n      if (ch <= ' ') {\n        builder.append(\"%20\");\n        continue;\n      }\n\n      if (ch == ',') {\n        builder.append(\"%2c\");\n        continue;\n      }\n\n      builder.append(ch);\n    }\n\n    return builder.toString();\n  }", "language": "java", "Allcodes": "public static String encodeString(String value) {\n    int estimatedSize = 0;\n    final int len = value.length();\n\n    // estimate output string size to find out whether encoding is required and avoid reallocations in string builder\n    for (int i = 0; i < len; ++i) {\n      final char ch = value.charAt(i);\n      if (ch <= ' ' || ch == ',') {\n        estimatedSize += 3;\n        continue;\n      }\n\n      ++estimatedSize;\n    }\n\n    if (value.length() == estimatedSize) {\n      return value; // return value as is - it does not contain any special characters\n    }\n\n    final StringBuilder builder = new StringBuilder(estimatedSize);\n    for (int i = 0; i < len; ++i) {\n      final char ch = value.charAt(i);\n      if (ch <= ' ') {\n        builder.append(\"%20\");\n        continue;\n      }\n\n      if (ch == ',') {\n        builder.append(\"%2c\");\n        continue;\n      }\n\n      builder.append(ch);\n    }\n\n    return builder.toString();\n  }", "code_tokens": ["public", "static", "String", "encodeString", "(", "String", "value", ")", "{", "int", "estimatedSize", "=", "0", ";", "final", "int", "len", "=", "value", ".", "length", "(", ")", ";", "// estimate output string size to find out whether encoding is required and avoid reallocations in string builder", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "++", "i", ")", "{", "final", "char", "ch", "=", "value", ".", "charAt", "(", "i", ")", ";", "if", "(", "ch", "<=", "'", "'", "||", "ch", "==", "'", "'", ")", "{", "estimatedSize", "+=", "3", ";", "continue", ";", "}", "++", "estimatedSize", ";", "}", "if", "(", "value", ".", "length", "(", ")", "==", "estimatedSize", ")", "{", "return", "value", ";", "// return value as is - it does not contain any special characters", "}", "final", "StringBuilder", "builder", "=", "new", "StringBuilder", "(", "estimatedSize", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "++", "i", ")", "{", "final", "char", "ch", "=", "value", ".", "charAt", "(", "i", ")", ";", "if", "(", "ch", "<=", "'", "'", ")", "{", "builder", ".", "append", "(", "\"%20\"", ")", ";", "continue", ";", "}", "if", "(", "ch", "==", "'", "'", ")", "{", "builder", ".", "append", "(", "\"%2c\"", ")", ";", "continue", ";", "}", "builder", ".", "append", "(", "ch", ")", ";", "}", "return", "builder", ".", "toString", "(", ")", ";", "}"], "docstring": "Encodes a value, so that it won't contain spaces, commas and equal signs.\n\n@param value Value to be encoded\n@return Encoded value or same value if passed argument does not contain whitespace, comma or equals sign", "docstring_tokens": ["Encodes", "a", "value", "so", "that", "it", "won", "t", "contain", "spaces", "commas", "and", "equal", "signs", "."]}
{"code": "\"^(\\\\d{4})(/|-|\\\\.|\u5e74)(\\\\d{1,2})(/|-|\\\\.|\u6708)(\\\\d{1,2})(\u65e5)?(\\\\s+\\\\d{1,2}(:|\u65f6)\\\\d{1,2}(:|\u5206)?(\\\\d{1,2}(\u79d2)?)?)?$\";", "comments": "check = \"^(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\";", "lines": 3, "repo": "GojaFramework/goja", "path": "goja-core/src/main/java/goja/core/Validator.java", "func_name": "Validator.isDateTime", "original_string": "public static boolean isDateTime(String value) {\n        String check =\n                \"^(\\\\d{4})(/|-|\\\\.|\u5e74)(\\\\d{1,2})(/|-|\\\\.|\u6708)(\\\\d{1,2})(\u65e5)?(\\\\s+\\\\d{1,2}(:|\u65f6)\\\\d{1,2}(:|\u5206)?(\\\\d{1,2}(\u79d2)?)?)?$\";// check = \"^(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\";\n        return match(check, Pattern.CASE_INSENSITIVE, value);\n    }", "language": "java", "Allcodes": "public static boolean isDateTime(String value) {\n        String check =\n                \"^(\\\\d{4})(/|-|\\\\.|\u5e74)(\\\\d{1,2})(/|-|\\\\.|\u6708)(\\\\d{1,2})(\u65e5)?(\\\\s+\\\\d{1,2}(:|\u65f6)\\\\d{1,2}(:|\u5206)?(\\\\d{1,2}(\u79d2)?)?)?$\";// check = \"^(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\";\n        return match(check, Pattern.CASE_INSENSITIVE, value);\n    }", "code_tokens": ["public", "static", "boolean", "isDateTime", "(", "String", "value", ")", "{", "String", "check", "=", "\"^(\\\\d{4})(/|-|\\\\.|\u5e74)(\\\\d{1,2})(/|-|\\\\.|\u6708)(\\\\d{1,2})(\u65e5)?(\\\\s+\\\\d{1,2}(:|\u65f6)\\\\d{1,2}(:|\u5206)?(\\\\d{1,2}(\u79d2)?)?)?$\";// check = ", "\"", "^(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\";", "return", "match", "(", "check", ",", "Pattern", ".", "CASE_INSENSITIVE", ",", "value", ")", ";", "}"], "docstring": "Tell the time\n\n@param value value\n@return boolean", "docstring_tokens": ["Tell", "the", "time"]}
{"code": "map.remove(sv.key);", "comments": "we can access private data!", "lines": 5, "repo": "subchen/jetbrick-all-1x", "path": "jetbrick-commons/src/main/java/jetbrick/collections/ConcurrentSoftHashMap.java", "func_name": "ConcurrentSoftHashMap.processQueue", "original_string": "private void processQueue() {\n        SoftValue<?, ?> sv;\n        while ((sv = (SoftValue<?, ?>) queue.poll()) != null) {\n            //noinspection SuspiciousMethodCalls\n            map.remove(sv.key); // we can access private data!\n        }\n    }", "language": "java", "Allcodes": "private void processQueue() {\n        SoftValue<?, ?> sv;\n        while ((sv = (SoftValue<?, ?>) queue.poll()) != null) {\n            //noinspection SuspiciousMethodCalls\n            map.remove(sv.key); // we can access private data!\n        }\n    }", "code_tokens": ["private", "void", "processQueue", "(", ")", "{", "SoftValue", "<", "?", ",", "?", ">", "sv", ";", "while", "(", "(", "sv", "=", "(", "SoftValue", "<", "?", ",", "?", ">", ")", "queue", ".", "poll", "(", ")", ")", "!=", "null", ")", "{", "//noinspection SuspiciousMethodCalls", "map", ".", "remove", "(", "sv", ".", "key", ")", ";", "// we can access private data!", "}", "}"], "docstring": "Traverses the ReferenceQueue and removes garbage-collected SoftValue objects from the backing map\nby looking them up using the SoftValue.key data member.", "docstring_tokens": ["Traverses", "the", "ReferenceQueue", "and", "removes", "garbage", "-", "collected", "SoftValue", "objects", "from", "the", "backing", "map", "by", "looking", "them", "up", "using", "the", "SoftValue", ".", "key", "data", "member", "."]}
{"code": "processQueue();", "comments": "throw out garbage collected values first", "lines": 3, "repo": "subchen/jetbrick-all-1x", "path": "jetbrick-commons/src/main/java/jetbrick/collections/ConcurrentSoftHashMap.java", "func_name": "ConcurrentSoftHashMap.put", "original_string": "@Override\n    public V put(K key, V value) {\n        processQueue(); // throw out garbage collected values first\n        SoftValue<V, K> sv = new SoftValue<V, K>(value, key, queue);\n        SoftValue<V, K> previous = map.put(key, sv);\n        addToStrongReferences(value);\n        return previous != null ? previous.get() : null;\n    }", "language": "java", "Allcodes": "@Override\n    public V put(K key, V value) {\n        processQueue(); // throw out garbage collected values first\n        SoftValue<V, K> sv = new SoftValue<V, K>(value, key, queue);\n        SoftValue<V, K> previous = map.put(key, sv);\n        addToStrongReferences(value);\n        return previous != null ? previous.get() : null;\n    }", "code_tokens": ["@", "Override", "public", "V", "put", "(", "K", "key", ",", "V", "value", ")", "{", "processQueue", "(", ")", ";", "// throw out garbage collected values first", "SoftValue", "<", "V", ",", "K", ">", "sv", "=", "new", "SoftValue", "<", "V", ",", "K", ">", "(", "value", ",", "key", ",", "queue", ")", ";", "SoftValue", "<", "V", ",", "K", ">", "previous", "=", "map", ".", "put", "(", "key", ",", "sv", ")", ";", "addToStrongReferences", "(", "value", ")", ";", "return", "previous", "!=", "null", "?", "previous", ".", "get", "(", ")", ":", "null", ";", "}"], "docstring": "Creates a new entry, but wraps the value in a SoftValue instance to enable auto garbage collection.", "docstring_tokens": ["Creates", "a", "new", "entry", "but", "wraps", "the", "value", "in", "a", "SoftValue", "instance", "to", "enable", "auto", "garbage", "collection", "."]}
{"code": "m_scheme = p_scheme;", "comments": ".toLowerCase();", "lines": 9, "repo": "retog/wymiwyg-commons-core", "path": "src/main/java/org/wymiwyg/commons/util/URI.java", "func_name": "URI.setScheme", "original_string": "private void setScheme(String p_scheme) throws MalformedURIException {\r\n\t\tif (p_scheme == null) {\r\n\t\t\tthrow new MalformedURIException(\"Cannot set scheme from null string!\");\r\n\t\t}\r\n\t\tif (!isConformantSchemeName(p_scheme)) {\r\n\t\t\tthrow new MalformedURIException(\"The scheme is not conformant.\");\r\n\t\t}\r\n\r\n\t\tm_scheme = p_scheme; //.toLowerCase();\r\n\t}", "language": "java", "Allcodes": "private void setScheme(String p_scheme) throws MalformedURIException {\r\n\t\tif (p_scheme == null) {\r\n\t\t\tthrow new MalformedURIException(\"Cannot set scheme from null string!\");\r\n\t\t}\r\n\t\tif (!isConformantSchemeName(p_scheme)) {\r\n\t\t\tthrow new MalformedURIException(\"The scheme is not conformant.\");\r\n\t\t}\r\n\r\n\t\tm_scheme = p_scheme; //.toLowerCase();\r\n\t}", "code_tokens": ["private", "void", "setScheme", "(", "String", "p_scheme", ")", "throws", "MalformedURIException", "{", "if", "(", "p_scheme", "==", "null", ")", "{", "throw", "new", "MalformedURIException", "(", "\"Cannot set scheme from null string!\"", ")", ";", "}", "if", "(", "!", "isConformantSchemeName", "(", "p_scheme", ")", ")", "{", "throw", "new", "MalformedURIException", "(", "\"The scheme is not conformant.\"", ")", ";", "}", "m_scheme", "=", "p_scheme", ";", "//.toLowerCase();\r", "}"], "docstring": "Set the scheme for this URI. The scheme is converted to lowercase\nbefore it is set.\n\n@param p_scheme the scheme for this URI (cannot be null)\n\n@exception MalformedURIException if p_scheme is not a conformant\nscheme name", "docstring_tokens": ["Set", "the", "scheme", "for", "this", "URI", ".", "The", "scheme", "is", "converted", "to", "lowercase", "before", "it", "is", "set", "."]}
{"code": "fc.getMaxLength();", "comments": "This will throw an exception if there is no muffin yet.", "lines": 12, "repo": "jbundle/util", "path": "muffinmanager/src/main/java/org/jbundle/util/muffinmanager/MuffinManager.java", "func_name": "MuffinManager.setMuffin", "original_string": "public void setMuffin(String strParam, String strValue)\n    {\n        FileContents fc = null;\n        URL url = null;\n        try   {\n            url = new URL(m_strCodeBase + strParam);\n        } catch (Exception ex)  {\n            return;\n        }\n        try   {\n            fc = m_ps.get(url);\n            fc.getMaxLength(); // This will throw an exception if there is no muffin yet.\n        } catch (Exception ex)  {\n            fc = null;\n        }\n        try   {\n            if (fc == null)\n            {\n                m_ps.create(url, 100);\n                fc = m_ps.get(url);\n            }          // don't append\n            if (strValue != null)\n            {\n                OutputStream os = fc.getOutputStream(false);\n                byte[] buf = strValue.getBytes(ENCODING);\n                os.write(buf);\n                os.close();\n                m_ps.setTag(url, PersistenceService.DIRTY);\n            }\n            else\n                m_ps.delete(url);\n        } catch (Exception ex)  {\n            ex.printStackTrace(); // Return null for any exception\n        }\n    }", "language": "java", "Allcodes": "public void setMuffin(String strParam, String strValue)\n    {\n        FileContents fc = null;\n        URL url = null;\n        try   {\n            url = new URL(m_strCodeBase + strParam);\n        } catch (Exception ex)  {\n            return;\n        }\n        try   {\n            fc = m_ps.get(url);\n            fc.getMaxLength(); // This will throw an exception if there is no muffin yet.\n        } catch (Exception ex)  {\n            fc = null;\n        }\n        try   {\n            if (fc == null)\n            {\n                m_ps.create(url, 100);\n                fc = m_ps.get(url);\n            }          // don't append\n            if (strValue != null)\n            {\n                OutputStream os = fc.getOutputStream(false);\n                byte[] buf = strValue.getBytes(ENCODING);\n                os.write(buf);\n                os.close();\n                m_ps.setTag(url, PersistenceService.DIRTY);\n            }\n            else\n                m_ps.delete(url);\n        } catch (Exception ex)  {\n            ex.printStackTrace(); // Return null for any exception\n        }\n    }", "code_tokens": ["public", "void", "setMuffin", "(", "String", "strParam", ",", "String", "strValue", ")", "{", "FileContents", "fc", "=", "null", ";", "URL", "url", "=", "null", ";", "try", "{", "url", "=", "new", "URL", "(", "m_strCodeBase", "+", "strParam", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "return", ";", "}", "try", "{", "fc", "=", "m_ps", ".", "get", "(", "url", ")", ";", "fc", ".", "getMaxLength", "(", ")", ";", "// This will throw an exception if there is no muffin yet.", "}", "catch", "(", "Exception", "ex", ")", "{", "fc", "=", "null", ";", "}", "try", "{", "if", "(", "fc", "==", "null", ")", "{", "m_ps", ".", "create", "(", "url", ",", "100", ")", ";", "fc", "=", "m_ps", ".", "get", "(", "url", ")", ";", "}", "// don't append", "if", "(", "strValue", "!=", "null", ")", "{", "OutputStream", "os", "=", "fc", ".", "getOutputStream", "(", "false", ")", ";", "byte", "[", "]", "buf", "=", "strValue", ".", "getBytes", "(", "ENCODING", ")", ";", "os", ".", "write", "(", "buf", ")", ";", "os", ".", "close", "(", ")", ";", "m_ps", ".", "setTag", "(", "url", ",", "PersistenceService", ".", "DIRTY", ")", ";", "}", "else", "m_ps", ".", "delete", "(", "url", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "// Return null for any exception", "}", "}"], "docstring": "Set the current value for this muffin.\n@param strParam The key for this muffin parameter.\n@param strValue The value for this muffin.", "docstring_tokens": ["Set", "the", "current", "value", "for", "this", "muffin", "."]}
{"code": "ex.printStackTrace();", "comments": "Return null for any exception", "lines": 33, "repo": "jbundle/util", "path": "muffinmanager/src/main/java/org/jbundle/util/muffinmanager/MuffinManager.java", "func_name": "MuffinManager.setMuffin", "original_string": "public void setMuffin(String strParam, String strValue)\n    {\n        FileContents fc = null;\n        URL url = null;\n        try   {\n            url = new URL(m_strCodeBase + strParam);\n        } catch (Exception ex)  {\n            return;\n        }\n        try   {\n            fc = m_ps.get(url);\n            fc.getMaxLength(); // This will throw an exception if there is no muffin yet.\n        } catch (Exception ex)  {\n            fc = null;\n        }\n        try   {\n            if (fc == null)\n            {\n                m_ps.create(url, 100);\n                fc = m_ps.get(url);\n            }          // don't append\n            if (strValue != null)\n            {\n                OutputStream os = fc.getOutputStream(false);\n                byte[] buf = strValue.getBytes(ENCODING);\n                os.write(buf);\n                os.close();\n                m_ps.setTag(url, PersistenceService.DIRTY);\n            }\n            else\n                m_ps.delete(url);\n        } catch (Exception ex)  {\n            ex.printStackTrace(); // Return null for any exception\n        }\n    }", "language": "java", "Allcodes": "public void setMuffin(String strParam, String strValue)\n    {\n        FileContents fc = null;\n        URL url = null;\n        try   {\n            url = new URL(m_strCodeBase + strParam);\n        } catch (Exception ex)  {\n            return;\n        }\n        try   {\n            fc = m_ps.get(url);\n            fc.getMaxLength(); // This will throw an exception if there is no muffin yet.\n        } catch (Exception ex)  {\n            fc = null;\n        }\n        try   {\n            if (fc == null)\n            {\n                m_ps.create(url, 100);\n                fc = m_ps.get(url);\n            }          // don't append\n            if (strValue != null)\n            {\n                OutputStream os = fc.getOutputStream(false);\n                byte[] buf = strValue.getBytes(ENCODING);\n                os.write(buf);\n                os.close();\n                m_ps.setTag(url, PersistenceService.DIRTY);\n            }\n            else\n                m_ps.delete(url);\n        } catch (Exception ex)  {\n            ex.printStackTrace(); // Return null for any exception\n        }\n    }", "code_tokens": ["public", "void", "setMuffin", "(", "String", "strParam", ",", "String", "strValue", ")", "{", "FileContents", "fc", "=", "null", ";", "URL", "url", "=", "null", ";", "try", "{", "url", "=", "new", "URL", "(", "m_strCodeBase", "+", "strParam", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "return", ";", "}", "try", "{", "fc", "=", "m_ps", ".", "get", "(", "url", ")", ";", "fc", ".", "getMaxLength", "(", ")", ";", "// This will throw an exception if there is no muffin yet.", "}", "catch", "(", "Exception", "ex", ")", "{", "fc", "=", "null", ";", "}", "try", "{", "if", "(", "fc", "==", "null", ")", "{", "m_ps", ".", "create", "(", "url", ",", "100", ")", ";", "fc", "=", "m_ps", ".", "get", "(", "url", ")", ";", "}", "// don't append", "if", "(", "strValue", "!=", "null", ")", "{", "OutputStream", "os", "=", "fc", ".", "getOutputStream", "(", "false", ")", ";", "byte", "[", "]", "buf", "=", "strValue", ".", "getBytes", "(", "ENCODING", ")", ";", "os", ".", "write", "(", "buf", ")", ";", "os", ".", "close", "(", ")", ";", "m_ps", ".", "setTag", "(", "url", ",", "PersistenceService", ".", "DIRTY", ")", ";", "}", "else", "m_ps", ".", "delete", "(", "url", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "ex", ".", "printStackTrace", "(", ")", ";", "// Return null for any exception", "}", "}"], "docstring": "Set the current value for this muffin.\n@param strParam The key for this muffin parameter.\n@param strValue The value for this muffin.", "docstring_tokens": ["Set", "the", "current", "value", "for", "this", "muffin", "."]}
{"code": "return null;", "comments": "Rejected it last time, don't ask again", "lines": 4, "repo": "jbundle/util", "path": "muffinmanager/src/main/java/org/jbundle/util/muffinmanager/MuffinManager.java", "func_name": "MuffinManager.getClipboardContents", "original_string": "public Transferable getClipboardContents()\n    {\n        if ((clipboardReadStatus & CLIPBOARD_DISABLED) == CLIPBOARD_DISABLED)\n            return null;    // Rejected it last time, don't ask again\n        clipboardReadStatus = CLIPBOARD_DISABLED;\n        if (cs == null)\n        {\n            try {\n                cs = (ClipboardService)ServiceManager.lookup(\"javax.jnlp.ClipboardService\"); \n            } catch (UnavailableServiceException e) { \n                cs = null;\n            }\n        }\n\n        if (cs != null) { \n            // get the contents of the system clipboard and print them \n            Transferable tr = cs.getContents(); \n            if (tr != null)\n                clipboardReadStatus = CLIPBOARD_ENABLED;\n            return tr;\n        }\n        return null;\n    }", "language": "java", "Allcodes": "public Transferable getClipboardContents()\n    {\n        if ((clipboardReadStatus & CLIPBOARD_DISABLED) == CLIPBOARD_DISABLED)\n            return null;    // Rejected it last time, don't ask again\n        clipboardReadStatus = CLIPBOARD_DISABLED;\n        if (cs == null)\n        {\n            try {\n                cs = (ClipboardService)ServiceManager.lookup(\"javax.jnlp.ClipboardService\"); \n            } catch (UnavailableServiceException e) { \n                cs = null;\n            }\n        }\n\n        if (cs != null) { \n            // get the contents of the system clipboard and print them \n            Transferable tr = cs.getContents(); \n            if (tr != null)\n                clipboardReadStatus = CLIPBOARD_ENABLED;\n            return tr;\n        }\n        return null;\n    }", "code_tokens": ["public", "Transferable", "getClipboardContents", "(", ")", "{", "if", "(", "(", "clipboardReadStatus", "&", "CLIPBOARD_DISABLED", ")", "==", "CLIPBOARD_DISABLED", ")", "return", "null", ";", "// Rejected it last time, don't ask again", "clipboardReadStatus", "=", "CLIPBOARD_DISABLED", ";", "if", "(", "cs", "==", "null", ")", "{", "try", "{", "cs", "=", "(", "ClipboardService", ")", "ServiceManager", ".", "lookup", "(", "\"javax.jnlp.ClipboardService\"", ")", ";", "}", "catch", "(", "UnavailableServiceException", "e", ")", "{", "cs", "=", "null", ";", "}", "}", "if", "(", "cs", "!=", "null", ")", "{", "// get the contents of the system clipboard and print them ", "Transferable", "tr", "=", "cs", ".", "getContents", "(", ")", ";", "if", "(", "tr", "!=", "null", ")", "clipboardReadStatus", "=", "CLIPBOARD_ENABLED", ";", "return", "tr", ";", "}", "return", "null", ";", "}"], "docstring": "Get data from the system clipboard.\n@return", "docstring_tokens": ["Get", "data", "from", "the", "system", "clipboard", "."]}
{"code": "c = '?';", "comments": "replace the parameter with a question mark", "lines": 30, "repo": "subchen/jetbrick-all-1x", "path": "jetbrick-orm/src/main/java/jetbrick/dao/orm/utils/NamedParameterStatement.java", "func_name": "NamedParameterStatement.parseNamedSql", "original_string": "private static String parseNamedSql(String sql, Map<String, List<Integer>> nameIndexMap) {\n        // I was originally using regular expressions, but they didn't work well for ignoring\n        // parameter-like strings inside quotes.\n        int length = sql.length();\n        StringBuffer parsedSql = new StringBuffer(length);\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        int index = 1;\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (inSingleQuote) {\n                if (c == '\\'') {\n                    inSingleQuote = false;\n                }\n            } else if (inDoubleQuote) {\n                if (c == '\"') {\n                    inDoubleQuote = false;\n                }\n            } else {\n                if (c == '\\'') {\n                    inSingleQuote = true;\n                } else if (c == '\"') {\n                    inDoubleQuote = true;\n                } else if (c == ':' && i + 1 < length && Character.isJavaIdentifierStart(sql.charAt(i + 1))) {\n                    int j = i + 2;\n                    while (j < length && Character.isJavaIdentifierPart(sql.charAt(j))) {\n                        j++;\n                    }\n                    String name = sql.substring(i + 1, j);\n                    c = '?'; // replace the parameter with a question mark\n                    i += name.length(); // skip past the end if the parameter\n                    List<Integer> indexList = nameIndexMap.get(name);\n                    if (indexList == null) {\n                        indexList = new LinkedList<Integer>();\n                        nameIndexMap.put(name, indexList);\n                    }\n                    indexList.add(index);\n                    index++;\n                }\n            }\n            parsedSql.append(c);\n        }\n\n        return parsedSql.toString();\n    }", "language": "java", "Allcodes": "private static String parseNamedSql(String sql, Map<String, List<Integer>> nameIndexMap) {\n        // I was originally using regular expressions, but they didn't work well for ignoring\n        // parameter-like strings inside quotes.\n        int length = sql.length();\n        StringBuffer parsedSql = new StringBuffer(length);\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        int index = 1;\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (inSingleQuote) {\n                if (c == '\\'') {\n                    inSingleQuote = false;\n                }\n            } else if (inDoubleQuote) {\n                if (c == '\"') {\n                    inDoubleQuote = false;\n                }\n            } else {\n                if (c == '\\'') {\n                    inSingleQuote = true;\n                } else if (c == '\"') {\n                    inDoubleQuote = true;\n                } else if (c == ':' && i + 1 < length && Character.isJavaIdentifierStart(sql.charAt(i + 1))) {\n                    int j = i + 2;\n                    while (j < length && Character.isJavaIdentifierPart(sql.charAt(j))) {\n                        j++;\n                    }\n                    String name = sql.substring(i + 1, j);\n                    c = '?'; // replace the parameter with a question mark\n                    i += name.length(); // skip past the end if the parameter\n                    List<Integer> indexList = nameIndexMap.get(name);\n                    if (indexList == null) {\n                        indexList = new LinkedList<Integer>();\n                        nameIndexMap.put(name, indexList);\n                    }\n                    indexList.add(index);\n                    index++;\n                }\n            }\n            parsedSql.append(c);\n        }\n\n        return parsedSql.toString();\n    }", "code_tokens": ["private", "static", "String", "parseNamedSql", "(", "String", "sql", ",", "Map", "<", "String", ",", "List", "<", "Integer", ">", ">", "nameIndexMap", ")", "{", "// I was originally using regular expressions, but they didn't work well for ignoring", "// parameter-like strings inside quotes.", "int", "length", "=", "sql", ".", "length", "(", ")", ";", "StringBuffer", "parsedSql", "=", "new", "StringBuffer", "(", "length", ")", ";", "boolean", "inSingleQuote", "=", "false", ";", "boolean", "inDoubleQuote", "=", "false", ";", "int", "index", "=", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "length", ";", "i", "++", ")", "{", "char", "c", "=", "sql", ".", "charAt", "(", "i", ")", ";", "if", "(", "inSingleQuote", ")", "{", "if", "(", "c", "==", "'", "'", ")", "{", "inSingleQuote", "=", "false", ";", "}", "}", "else", "if", "(", "inDoubleQuote", ")", "{", "if", "(", "c", "==", "'", "'", ")", "{", "inDoubleQuote", "=", "false", ";", "}", "}", "else", "{", "if", "(", "c", "==", "'", "'", ")", "{", "inSingleQuote", "=", "true", ";", "}", "else", "if", "(", "c", "==", "'", "'", ")", "{", "inDoubleQuote", "=", "true", ";", "}", "else", "if", "(", "c", "==", "'", "'", "&&", "i", "+", "1", "<", "length", "&&", "Character", ".", "isJavaIdentifierStart", "(", "sql", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "int", "j", "=", "i", "+", "2", ";", "while", "(", "j", "<", "length", "&&", "Character", ".", "isJavaIdentifierPart", "(", "sql", ".", "charAt", "(", "j", ")", ")", ")", "{", "j", "++", ";", "}", "String", "name", "=", "sql", ".", "substring", "(", "i", "+", "1", ",", "j", ")", ";", "c", "=", "'", "'", ";", "// replace the parameter with a question mark", "i", "+=", "name", ".", "length", "(", ")", ";", "// skip past the end if the parameter", "List", "<", "Integer", ">", "indexList", "=", "nameIndexMap", ".", "get", "(", "name", ")", ";", "if", "(", "indexList", "==", "null", ")", "{", "indexList", "=", "new", "LinkedList", "<", "Integer", ">", "(", ")", ";", "nameIndexMap", ".", "put", "(", "name", ",", "indexList", ")", ";", "}", "indexList", ".", "add", "(", "index", ")", ";", "index", "++", ";", "}", "}", "parsedSql", ".", "append", "(", "c", ")", ";", "}", "return", "parsedSql", ".", "toString", "(", ")", ";", "}"], "docstring": "Parses a sql with named parameters. The parameter-index mappings\nare put into the map, and the parsed sql is returned.\n@param sql    sql with named parameters\n@return the parsed sql", "docstring_tokens": ["Parses", "a", "sql", "with", "named", "parameters", ".", "The", "parameter", "-", "index", "mappings", "are", "put", "into", "the", "map", "and", "the", "parsed", "sql", "is", "returned", "."]}
{"code": "i += name.length();", "comments": "skip past the end if the parameter", "lines": 31, "repo": "subchen/jetbrick-all-1x", "path": "jetbrick-orm/src/main/java/jetbrick/dao/orm/utils/NamedParameterStatement.java", "func_name": "NamedParameterStatement.parseNamedSql", "original_string": "private static String parseNamedSql(String sql, Map<String, List<Integer>> nameIndexMap) {\n        // I was originally using regular expressions, but they didn't work well for ignoring\n        // parameter-like strings inside quotes.\n        int length = sql.length();\n        StringBuffer parsedSql = new StringBuffer(length);\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        int index = 1;\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (inSingleQuote) {\n                if (c == '\\'') {\n                    inSingleQuote = false;\n                }\n            } else if (inDoubleQuote) {\n                if (c == '\"') {\n                    inDoubleQuote = false;\n                }\n            } else {\n                if (c == '\\'') {\n                    inSingleQuote = true;\n                } else if (c == '\"') {\n                    inDoubleQuote = true;\n                } else if (c == ':' && i + 1 < length && Character.isJavaIdentifierStart(sql.charAt(i + 1))) {\n                    int j = i + 2;\n                    while (j < length && Character.isJavaIdentifierPart(sql.charAt(j))) {\n                        j++;\n                    }\n                    String name = sql.substring(i + 1, j);\n                    c = '?'; // replace the parameter with a question mark\n                    i += name.length(); // skip past the end if the parameter\n                    List<Integer> indexList = nameIndexMap.get(name);\n                    if (indexList == null) {\n                        indexList = new LinkedList<Integer>();\n                        nameIndexMap.put(name, indexList);\n                    }\n                    indexList.add(index);\n                    index++;\n                }\n            }\n            parsedSql.append(c);\n        }\n\n        return parsedSql.toString();\n    }", "language": "java", "Allcodes": "private static String parseNamedSql(String sql, Map<String, List<Integer>> nameIndexMap) {\n        // I was originally using regular expressions, but they didn't work well for ignoring\n        // parameter-like strings inside quotes.\n        int length = sql.length();\n        StringBuffer parsedSql = new StringBuffer(length);\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        int index = 1;\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (inSingleQuote) {\n                if (c == '\\'') {\n                    inSingleQuote = false;\n                }\n            } else if (inDoubleQuote) {\n                if (c == '\"') {\n                    inDoubleQuote = false;\n                }\n            } else {\n                if (c == '\\'') {\n                    inSingleQuote = true;\n                } else if (c == '\"') {\n                    inDoubleQuote = true;\n                } else if (c == ':' && i + 1 < length && Character.isJavaIdentifierStart(sql.charAt(i + 1))) {\n                    int j = i + 2;\n                    while (j < length && Character.isJavaIdentifierPart(sql.charAt(j))) {\n                        j++;\n                    }\n                    String name = sql.substring(i + 1, j);\n                    c = '?'; // replace the parameter with a question mark\n                    i += name.length(); // skip past the end if the parameter\n                    List<Integer> indexList = nameIndexMap.get(name);\n                    if (indexList == null) {\n                        indexList = new LinkedList<Integer>();\n                        nameIndexMap.put(name, indexList);\n                    }\n                    indexList.add(index);\n                    index++;\n                }\n            }\n            parsedSql.append(c);\n        }\n\n        return parsedSql.toString();\n    }", "code_tokens": ["private", "static", "String", "parseNamedSql", "(", "String", "sql", ",", "Map", "<", "String", ",", "List", "<", "Integer", ">", ">", "nameIndexMap", ")", "{", "// I was originally using regular expressions, but they didn't work well for ignoring", "// parameter-like strings inside quotes.", "int", "length", "=", "sql", ".", "length", "(", ")", ";", "StringBuffer", "parsedSql", "=", "new", "StringBuffer", "(", "length", ")", ";", "boolean", "inSingleQuote", "=", "false", ";", "boolean", "inDoubleQuote", "=", "false", ";", "int", "index", "=", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "length", ";", "i", "++", ")", "{", "char", "c", "=", "sql", ".", "charAt", "(", "i", ")", ";", "if", "(", "inSingleQuote", ")", "{", "if", "(", "c", "==", "'", "'", ")", "{", "inSingleQuote", "=", "false", ";", "}", "}", "else", "if", "(", "inDoubleQuote", ")", "{", "if", "(", "c", "==", "'", "'", ")", "{", "inDoubleQuote", "=", "false", ";", "}", "}", "else", "{", "if", "(", "c", "==", "'", "'", ")", "{", "inSingleQuote", "=", "true", ";", "}", "else", "if", "(", "c", "==", "'", "'", ")", "{", "inDoubleQuote", "=", "true", ";", "}", "else", "if", "(", "c", "==", "'", "'", "&&", "i", "+", "1", "<", "length", "&&", "Character", ".", "isJavaIdentifierStart", "(", "sql", ".", "charAt", "(", "i", "+", "1", ")", ")", ")", "{", "int", "j", "=", "i", "+", "2", ";", "while", "(", "j", "<", "length", "&&", "Character", ".", "isJavaIdentifierPart", "(", "sql", ".", "charAt", "(", "j", ")", ")", ")", "{", "j", "++", ";", "}", "String", "name", "=", "sql", ".", "substring", "(", "i", "+", "1", ",", "j", ")", ";", "c", "=", "'", "'", ";", "// replace the parameter with a question mark", "i", "+=", "name", ".", "length", "(", ")", ";", "// skip past the end if the parameter", "List", "<", "Integer", ">", "indexList", "=", "nameIndexMap", ".", "get", "(", "name", ")", ";", "if", "(", "indexList", "==", "null", ")", "{", "indexList", "=", "new", "LinkedList", "<", "Integer", ">", "(", ")", ";", "nameIndexMap", ".", "put", "(", "name", ",", "indexList", ")", ";", "}", "indexList", ".", "add", "(", "index", ")", ";", "index", "++", ";", "}", "}", "parsedSql", ".", "append", "(", "c", ")", ";", "}", "return", "parsedSql", ".", "toString", "(", ")", ";", "}"], "docstring": "Parses a sql with named parameters. The parameter-index mappings\nare put into the map, and the parsed sql is returned.\n@param sql    sql with named parameters\n@return the parsed sql", "docstring_tokens": ["Parses", "a", "sql", "with", "named", "parameters", ".", "The", "parameter", "-", "index", "mappings", "are", "put", "into", "the", "map", "and", "the", "parsed", "sql", "is", "returned", "."]}
{"code": "return true;", "comments": "Accept", "lines": 14, "repo": "jbundle/util", "path": "jbackup/src/main/java/org/jbundle/jbackup/util/FileExtensionFilter.java", "func_name": "FileExtensionFilter.accept", "original_string": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "language": "java", "Allcodes": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "code_tokens": ["public", "boolean", "accept", "(", "File", "pathname", ")", "{", "String", "name", "=", "pathname", ".", "getName", "(", ")", ";", "int", "iLastDot", "=", "name", ".", "lastIndexOf", "(", "'", "'", ")", ";", "String", "strExtension", "=", "\"\"", ";", "if", "(", "(", "iLastDot", "!=", "-", "1", ")", "&&", "(", "iLastDot", "!=", "name", ".", "length", "(", ")", "-", "1", ")", ")", "strExtension", "=", "name", ".", "substring", "(", "iLastDot", "+", "1", ")", ";", "if", "(", "m_rgstrIncludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrIncludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrIncludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "true", ";", "// Accept", "}", "return", "false", ";", "// Not in included - return", "}", "if", "(", "m_rgstrExcludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrExcludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrExcludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "false", ";", "// Don't accept", "}", "}", "return", "true", ";", "// Accept this file", "}"], "docstring": "Tests whether or not the specified abstract pathname should be\nincluded in a pathname list.\n\n@param  pathname  The abstract pathname to be tested\n@return  <code>true</code> if and only if <code>pathname</code>\nshould be included", "docstring_tokens": ["Tests", "whether", "or", "not", "the", "specified", "abstract", "pathname", "should", "be", "included", "in", "a", "pathname", "list", "."]}
{"code": "return false;", "comments": "Not in included - return", "lines": 16, "repo": "jbundle/util", "path": "jbackup/src/main/java/org/jbundle/jbackup/util/FileExtensionFilter.java", "func_name": "FileExtensionFilter.accept", "original_string": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "language": "java", "Allcodes": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "code_tokens": ["public", "boolean", "accept", "(", "File", "pathname", ")", "{", "String", "name", "=", "pathname", ".", "getName", "(", ")", ";", "int", "iLastDot", "=", "name", ".", "lastIndexOf", "(", "'", "'", ")", ";", "String", "strExtension", "=", "\"\"", ";", "if", "(", "(", "iLastDot", "!=", "-", "1", ")", "&&", "(", "iLastDot", "!=", "name", ".", "length", "(", ")", "-", "1", ")", ")", "strExtension", "=", "name", ".", "substring", "(", "iLastDot", "+", "1", ")", ";", "if", "(", "m_rgstrIncludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrIncludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrIncludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "true", ";", "// Accept", "}", "return", "false", ";", "// Not in included - return", "}", "if", "(", "m_rgstrExcludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrExcludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrExcludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "false", ";", "// Don't accept", "}", "}", "return", "true", ";", "// Accept this file", "}"], "docstring": "Tests whether or not the specified abstract pathname should be\nincluded in a pathname list.\n\n@param  pathname  The abstract pathname to be tested\n@return  <code>true</code> if and only if <code>pathname</code>\nshould be included", "docstring_tokens": ["Tests", "whether", "or", "not", "the", "specified", "abstract", "pathname", "should", "be", "included", "in", "a", "pathname", "list", "."]}
{"code": "return false;", "comments": "Don't accept", "lines": 23, "repo": "jbundle/util", "path": "jbackup/src/main/java/org/jbundle/jbackup/util/FileExtensionFilter.java", "func_name": "FileExtensionFilter.accept", "original_string": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "language": "java", "Allcodes": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "code_tokens": ["public", "boolean", "accept", "(", "File", "pathname", ")", "{", "String", "name", "=", "pathname", ".", "getName", "(", ")", ";", "int", "iLastDot", "=", "name", ".", "lastIndexOf", "(", "'", "'", ")", ";", "String", "strExtension", "=", "\"\"", ";", "if", "(", "(", "iLastDot", "!=", "-", "1", ")", "&&", "(", "iLastDot", "!=", "name", ".", "length", "(", ")", "-", "1", ")", ")", "strExtension", "=", "name", ".", "substring", "(", "iLastDot", "+", "1", ")", ";", "if", "(", "m_rgstrIncludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrIncludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrIncludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "true", ";", "// Accept", "}", "return", "false", ";", "// Not in included - return", "}", "if", "(", "m_rgstrExcludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrExcludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrExcludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "false", ";", "// Don't accept", "}", "}", "return", "true", ";", "// Accept this file", "}"], "docstring": "Tests whether or not the specified abstract pathname should be\nincluded in a pathname list.\n\n@param  pathname  The abstract pathname to be tested\n@return  <code>true</code> if and only if <code>pathname</code>\nshould be included", "docstring_tokens": ["Tests", "whether", "or", "not", "the", "specified", "abstract", "pathname", "should", "be", "included", "in", "a", "pathname", "list", "."]}
{"code": "return true;", "comments": "Accept this file", "lines": 26, "repo": "jbundle/util", "path": "jbackup/src/main/java/org/jbundle/jbackup/util/FileExtensionFilter.java", "func_name": "FileExtensionFilter.accept", "original_string": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "language": "java", "Allcodes": "public boolean accept(File pathname)\n\t{\n\t\tString name = pathname.getName();\n\t\tint iLastDot = name.lastIndexOf('.');\n\t\tString strExtension = \"\";\n\t\tif ((iLastDot != -1)\n\t\t\t&& (iLastDot != name.length() -1 ))\n\t\t\t\tstrExtension = name.substring(iLastDot + 1);\n\t\tif (m_rgstrIncludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrIncludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrIncludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn true;\t// Accept\n\t\t\t}\n\t\t\treturn false;\t// Not in included - return\n\t\t}\n\t\tif (m_rgstrExcludeExtensions != null)\n\t\t{\n\t\t\tfor (int i = 0; i < m_rgstrExcludeExtensions.length; i++)\n\t\t\t{\n\t\t\t\tif (m_rgstrExcludeExtensions[i].equalsIgnoreCase(strExtension))\n\t\t\t\t\treturn false;\t// Don't accept\n\t\t\t}\n\t\t}\n\t\treturn true;\t// Accept this file\n\t}", "code_tokens": ["public", "boolean", "accept", "(", "File", "pathname", ")", "{", "String", "name", "=", "pathname", ".", "getName", "(", ")", ";", "int", "iLastDot", "=", "name", ".", "lastIndexOf", "(", "'", "'", ")", ";", "String", "strExtension", "=", "\"\"", ";", "if", "(", "(", "iLastDot", "!=", "-", "1", ")", "&&", "(", "iLastDot", "!=", "name", ".", "length", "(", ")", "-", "1", ")", ")", "strExtension", "=", "name", ".", "substring", "(", "iLastDot", "+", "1", ")", ";", "if", "(", "m_rgstrIncludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrIncludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrIncludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "true", ";", "// Accept", "}", "return", "false", ";", "// Not in included - return", "}", "if", "(", "m_rgstrExcludeExtensions", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "m_rgstrExcludeExtensions", ".", "length", ";", "i", "++", ")", "{", "if", "(", "m_rgstrExcludeExtensions", "[", "i", "]", ".", "equalsIgnoreCase", "(", "strExtension", ")", ")", "return", "false", ";", "// Don't accept", "}", "}", "return", "true", ";", "// Accept this file", "}"], "docstring": "Tests whether or not the specified abstract pathname should be\nincluded in a pathname list.\n\n@param  pathname  The abstract pathname to be tested\n@return  <code>true</code> if and only if <code>pathname</code>\nshould be included", "docstring_tokens": ["Tests", "whether", "or", "not", "the", "specified", "abstract", "pathname", "should", "be", "included", "in", "a", "pathname", "list", "."]}
{"code": "System.out.println(\"Warning: scanned file does not exist: \" + m_inputFile.getPath());", "comments": "Skip this file", "lines": 8, "repo": "jbundle/util", "path": "jbackup/src/main/java/org/jbundle/jbackup/source/BaseSourceFile.java", "func_name": "BaseSourceFile.makeInStream", "original_string": "public InputStream makeInStream()\n\t{\n\t\tif (m_InputStream != null)\n\t\t\treturn m_InputStream;\n\t\ttry\t{\n\t\t\treturn new FileInputStream(m_inputFile);\n\t\t} catch (FileNotFoundException ex)\t{\n\t\t\tSystem.out.println(\"Warning: scanned file does not exist: \" + m_inputFile.getPath());\t\t// Skip this file\n\t\t}\n\t\treturn null;\n\t}", "language": "java", "Allcodes": "public InputStream makeInStream()\n\t{\n\t\tif (m_InputStream != null)\n\t\t\treturn m_InputStream;\n\t\ttry\t{\n\t\t\treturn new FileInputStream(m_inputFile);\n\t\t} catch (FileNotFoundException ex)\t{\n\t\t\tSystem.out.println(\"Warning: scanned file does not exist: \" + m_inputFile.getPath());\t\t// Skip this file\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["public", "InputStream", "makeInStream", "(", ")", "{", "if", "(", "m_InputStream", "!=", "null", ")", "return", "m_InputStream", ";", "try", "{", "return", "new", "FileInputStream", "(", "m_inputFile", ")", ";", "}", "catch", "(", "FileNotFoundException", "ex", ")", "{", "System", ".", "out", ".", "println", "(", "\"Warning: scanned file does not exist: \"", "+", "m_inputFile", ".", "getPath", "(", ")", ")", ";", "// Skip this file", "}", "return", "null", ";", "}"], "docstring": "If there is no input stream, use the file to create one.", "docstring_tokens": ["If", "there", "is", "no", "input", "stream", "use", "the", "file", "to", "create", "one", "."]}
{"code": "return false;", "comments": "string is not finished, but pattern is", "lines": 27, "repo": "subchen/jetbrick-all-1x", "path": "jetbrick-commons/src/main/java/jetbrick/lang/WildcharPathUtils.java", "func_name": "WildcharPathUtils.matchTokens", "original_string": "protected static boolean matchTokens(String[] tokens, String[] patterns) {\n        int patNdxStart = 0;\n        int patNdxEnd = patterns.length - 1;\n        int tokNdxStart = 0;\n        int tokNdxEnd = tokens.length - 1;\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // find first **\n            String patDir = patterns[patNdxStart];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxStart], patDir)) {\n                return false;\n            }\n            patNdxStart++;\n            tokNdxStart++;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (patNdxStart > patNdxEnd) {\n            return false; // string is not finished, but pattern is\n        }\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // to the last **\n            String patDir = patterns[patNdxEnd];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxEnd], patDir)) {\n                return false;\n            }\n            patNdxEnd--;\n            tokNdxEnd--;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        while ((patNdxStart != patNdxEnd) && (tokNdxStart <= tokNdxEnd)) {\n            int patIdxTmp = -1;\n            for (int i = patNdxStart + 1; i <= patNdxEnd; i++) {\n                if (patterns[i].equals(PATH_MATCH)) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patNdxStart + 1) {\n                patNdxStart++; // skip **/** situation\n                continue;\n            }\n            // find the pattern between padIdxStart & padIdxTmp in str between strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patNdxStart - 1);\n            int strLength = (tokNdxEnd - tokNdxStart + 1);\n            int ndx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = patterns[patNdxStart + j + 1];\n                    String subStr = tokens[tokNdxStart + i + j];\n                    if (!WildcharUtils.match(subStr, subPat)) {\n                        continue strLoop;\n                    }\n                }\n\n                ndx = tokNdxStart + i;\n                break;\n            }\n\n            if (ndx == -1) {\n                return false;\n            }\n\n            patNdxStart = patIdxTmp;\n            tokNdxStart = ndx + patLength;\n        }\n\n        for (int i = patNdxStart; i <= patNdxEnd; i++) {\n            if (!patterns[i].equals(PATH_MATCH)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "language": "java", "Allcodes": "protected static boolean matchTokens(String[] tokens, String[] patterns) {\n        int patNdxStart = 0;\n        int patNdxEnd = patterns.length - 1;\n        int tokNdxStart = 0;\n        int tokNdxEnd = tokens.length - 1;\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // find first **\n            String patDir = patterns[patNdxStart];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxStart], patDir)) {\n                return false;\n            }\n            patNdxStart++;\n            tokNdxStart++;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (patNdxStart > patNdxEnd) {\n            return false; // string is not finished, but pattern is\n        }\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // to the last **\n            String patDir = patterns[patNdxEnd];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxEnd], patDir)) {\n                return false;\n            }\n            patNdxEnd--;\n            tokNdxEnd--;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        while ((patNdxStart != patNdxEnd) && (tokNdxStart <= tokNdxEnd)) {\n            int patIdxTmp = -1;\n            for (int i = patNdxStart + 1; i <= patNdxEnd; i++) {\n                if (patterns[i].equals(PATH_MATCH)) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patNdxStart + 1) {\n                patNdxStart++; // skip **/** situation\n                continue;\n            }\n            // find the pattern between padIdxStart & padIdxTmp in str between strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patNdxStart - 1);\n            int strLength = (tokNdxEnd - tokNdxStart + 1);\n            int ndx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = patterns[patNdxStart + j + 1];\n                    String subStr = tokens[tokNdxStart + i + j];\n                    if (!WildcharUtils.match(subStr, subPat)) {\n                        continue strLoop;\n                    }\n                }\n\n                ndx = tokNdxStart + i;\n                break;\n            }\n\n            if (ndx == -1) {\n                return false;\n            }\n\n            patNdxStart = patIdxTmp;\n            tokNdxStart = ndx + patLength;\n        }\n\n        for (int i = patNdxStart; i <= patNdxEnd; i++) {\n            if (!patterns[i].equals(PATH_MATCH)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "code_tokens": ["protected", "static", "boolean", "matchTokens", "(", "String", "[", "]", "tokens", ",", "String", "[", "]", "patterns", ")", "{", "int", "patNdxStart", "=", "0", ";", "int", "patNdxEnd", "=", "patterns", ".", "length", "-", "1", ";", "int", "tokNdxStart", "=", "0", ";", "int", "tokNdxEnd", "=", "tokens", ".", "length", "-", "1", ";", "while", "(", "patNdxStart", "<=", "patNdxEnd", "&&", "tokNdxStart", "<=", "tokNdxEnd", ")", "{", "// find first **", "String", "patDir", "=", "patterns", "[", "patNdxStart", "]", ";", "if", "(", "patDir", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "break", ";", "}", "if", "(", "!", "WildcharUtils", ".", "match", "(", "tokens", "[", "tokNdxStart", "]", ",", "patDir", ")", ")", "{", "return", "false", ";", "}", "patNdxStart", "++", ";", "tokNdxStart", "++", ";", "}", "if", "(", "tokNdxStart", ">", "tokNdxEnd", ")", "{", "for", "(", "int", "i", "=", "patNdxStart", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "// string is finished", "if", "(", "!", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}", "if", "(", "patNdxStart", ">", "patNdxEnd", ")", "{", "return", "false", ";", "// string is not finished, but pattern is", "}", "while", "(", "patNdxStart", "<=", "patNdxEnd", "&&", "tokNdxStart", "<=", "tokNdxEnd", ")", "{", "// to the last **", "String", "patDir", "=", "patterns", "[", "patNdxEnd", "]", ";", "if", "(", "patDir", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "break", ";", "}", "if", "(", "!", "WildcharUtils", ".", "match", "(", "tokens", "[", "tokNdxEnd", "]", ",", "patDir", ")", ")", "{", "return", "false", ";", "}", "patNdxEnd", "--", ";", "tokNdxEnd", "--", ";", "}", "if", "(", "tokNdxStart", ">", "tokNdxEnd", ")", "{", "for", "(", "int", "i", "=", "patNdxStart", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "// string is finished", "if", "(", "!", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}", "while", "(", "(", "patNdxStart", "!=", "patNdxEnd", ")", "&&", "(", "tokNdxStart", "<=", "tokNdxEnd", ")", ")", "{", "int", "patIdxTmp", "=", "-", "1", ";", "for", "(", "int", "i", "=", "patNdxStart", "+", "1", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "if", "(", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "patIdxTmp", "=", "i", ";", "break", ";", "}", "}", "if", "(", "patIdxTmp", "==", "patNdxStart", "+", "1", ")", "{", "patNdxStart", "++", ";", "// skip **/** situation", "continue", ";", "}", "// find the pattern between padIdxStart & padIdxTmp in str between strIdxStart & strIdxEnd", "int", "patLength", "=", "(", "patIdxTmp", "-", "patNdxStart", "-", "1", ")", ";", "int", "strLength", "=", "(", "tokNdxEnd", "-", "tokNdxStart", "+", "1", ")", ";", "int", "ndx", "=", "-", "1", ";", "strLoop", ":", "for", "(", "int", "i", "=", "0", ";", "i", "<=", "strLength", "-", "patLength", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "patLength", ";", "j", "++", ")", "{", "String", "subPat", "=", "patterns", "[", "patNdxStart", "+", "j", "+", "1", "]", ";", "String", "subStr", "=", "tokens", "[", "tokNdxStart", "+", "i", "+", "j", "]", ";", "if", "(", "!", "WildcharUtils", ".", "match", "(", "subStr", ",", "subPat", ")", ")", "{", "continue", "strLoop", ";", "}", "}", "ndx", "=", "tokNdxStart", "+", "i", ";", "break", ";", "}", "if", "(", "ndx", "==", "-", "1", ")", "{", "return", "false", ";", "}", "patNdxStart", "=", "patIdxTmp", ";", "tokNdxStart", "=", "ndx", "+", "patLength", ";", "}", "for", "(", "int", "i", "=", "patNdxStart", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "if", "(", "!", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "docstring": "Match tokenized string and pattern.", "docstring_tokens": ["Match", "tokenized", "string", "and", "pattern", "."]}
{"code": "patNdxStart++;", "comments": "skip **/** situation", "lines": 59, "repo": "subchen/jetbrick-all-1x", "path": "jetbrick-commons/src/main/java/jetbrick/lang/WildcharPathUtils.java", "func_name": "WildcharPathUtils.matchTokens", "original_string": "protected static boolean matchTokens(String[] tokens, String[] patterns) {\n        int patNdxStart = 0;\n        int patNdxEnd = patterns.length - 1;\n        int tokNdxStart = 0;\n        int tokNdxEnd = tokens.length - 1;\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // find first **\n            String patDir = patterns[patNdxStart];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxStart], patDir)) {\n                return false;\n            }\n            patNdxStart++;\n            tokNdxStart++;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (patNdxStart > patNdxEnd) {\n            return false; // string is not finished, but pattern is\n        }\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // to the last **\n            String patDir = patterns[patNdxEnd];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxEnd], patDir)) {\n                return false;\n            }\n            patNdxEnd--;\n            tokNdxEnd--;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        while ((patNdxStart != patNdxEnd) && (tokNdxStart <= tokNdxEnd)) {\n            int patIdxTmp = -1;\n            for (int i = patNdxStart + 1; i <= patNdxEnd; i++) {\n                if (patterns[i].equals(PATH_MATCH)) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patNdxStart + 1) {\n                patNdxStart++; // skip **/** situation\n                continue;\n            }\n            // find the pattern between padIdxStart & padIdxTmp in str between strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patNdxStart - 1);\n            int strLength = (tokNdxEnd - tokNdxStart + 1);\n            int ndx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = patterns[patNdxStart + j + 1];\n                    String subStr = tokens[tokNdxStart + i + j];\n                    if (!WildcharUtils.match(subStr, subPat)) {\n                        continue strLoop;\n                    }\n                }\n\n                ndx = tokNdxStart + i;\n                break;\n            }\n\n            if (ndx == -1) {\n                return false;\n            }\n\n            patNdxStart = patIdxTmp;\n            tokNdxStart = ndx + patLength;\n        }\n\n        for (int i = patNdxStart; i <= patNdxEnd; i++) {\n            if (!patterns[i].equals(PATH_MATCH)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "language": "java", "Allcodes": "protected static boolean matchTokens(String[] tokens, String[] patterns) {\n        int patNdxStart = 0;\n        int patNdxEnd = patterns.length - 1;\n        int tokNdxStart = 0;\n        int tokNdxEnd = tokens.length - 1;\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // find first **\n            String patDir = patterns[patNdxStart];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxStart], patDir)) {\n                return false;\n            }\n            patNdxStart++;\n            tokNdxStart++;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (patNdxStart > patNdxEnd) {\n            return false; // string is not finished, but pattern is\n        }\n\n        while (patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd) { // to the last **\n            String patDir = patterns[patNdxEnd];\n            if (patDir.equals(PATH_MATCH)) {\n                break;\n            }\n            if (!WildcharUtils.match(tokens[tokNdxEnd], patDir)) {\n                return false;\n            }\n            patNdxEnd--;\n            tokNdxEnd--;\n        }\n        if (tokNdxStart > tokNdxEnd) {\n            for (int i = patNdxStart; i <= patNdxEnd; i++) { // string is finished\n                if (!patterns[i].equals(PATH_MATCH)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        while ((patNdxStart != patNdxEnd) && (tokNdxStart <= tokNdxEnd)) {\n            int patIdxTmp = -1;\n            for (int i = patNdxStart + 1; i <= patNdxEnd; i++) {\n                if (patterns[i].equals(PATH_MATCH)) {\n                    patIdxTmp = i;\n                    break;\n                }\n            }\n            if (patIdxTmp == patNdxStart + 1) {\n                patNdxStart++; // skip **/** situation\n                continue;\n            }\n            // find the pattern between padIdxStart & padIdxTmp in str between strIdxStart & strIdxEnd\n            int patLength = (patIdxTmp - patNdxStart - 1);\n            int strLength = (tokNdxEnd - tokNdxStart + 1);\n            int ndx = -1;\n            strLoop: for (int i = 0; i <= strLength - patLength; i++) {\n                for (int j = 0; j < patLength; j++) {\n                    String subPat = patterns[patNdxStart + j + 1];\n                    String subStr = tokens[tokNdxStart + i + j];\n                    if (!WildcharUtils.match(subStr, subPat)) {\n                        continue strLoop;\n                    }\n                }\n\n                ndx = tokNdxStart + i;\n                break;\n            }\n\n            if (ndx == -1) {\n                return false;\n            }\n\n            patNdxStart = patIdxTmp;\n            tokNdxStart = ndx + patLength;\n        }\n\n        for (int i = patNdxStart; i <= patNdxEnd; i++) {\n            if (!patterns[i].equals(PATH_MATCH)) {\n                return false;\n            }\n        }\n\n        return true;\n    }", "code_tokens": ["protected", "static", "boolean", "matchTokens", "(", "String", "[", "]", "tokens", ",", "String", "[", "]", "patterns", ")", "{", "int", "patNdxStart", "=", "0", ";", "int", "patNdxEnd", "=", "patterns", ".", "length", "-", "1", ";", "int", "tokNdxStart", "=", "0", ";", "int", "tokNdxEnd", "=", "tokens", ".", "length", "-", "1", ";", "while", "(", "patNdxStart", "<=", "patNdxEnd", "&&", "tokNdxStart", "<=", "tokNdxEnd", ")", "{", "// find first **", "String", "patDir", "=", "patterns", "[", "patNdxStart", "]", ";", "if", "(", "patDir", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "break", ";", "}", "if", "(", "!", "WildcharUtils", ".", "match", "(", "tokens", "[", "tokNdxStart", "]", ",", "patDir", ")", ")", "{", "return", "false", ";", "}", "patNdxStart", "++", ";", "tokNdxStart", "++", ";", "}", "if", "(", "tokNdxStart", ">", "tokNdxEnd", ")", "{", "for", "(", "int", "i", "=", "patNdxStart", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "// string is finished", "if", "(", "!", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}", "if", "(", "patNdxStart", ">", "patNdxEnd", ")", "{", "return", "false", ";", "// string is not finished, but pattern is", "}", "while", "(", "patNdxStart", "<=", "patNdxEnd", "&&", "tokNdxStart", "<=", "tokNdxEnd", ")", "{", "// to the last **", "String", "patDir", "=", "patterns", "[", "patNdxEnd", "]", ";", "if", "(", "patDir", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "break", ";", "}", "if", "(", "!", "WildcharUtils", ".", "match", "(", "tokens", "[", "tokNdxEnd", "]", ",", "patDir", ")", ")", "{", "return", "false", ";", "}", "patNdxEnd", "--", ";", "tokNdxEnd", "--", ";", "}", "if", "(", "tokNdxStart", ">", "tokNdxEnd", ")", "{", "for", "(", "int", "i", "=", "patNdxStart", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "// string is finished", "if", "(", "!", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}", "while", "(", "(", "patNdxStart", "!=", "patNdxEnd", ")", "&&", "(", "tokNdxStart", "<=", "tokNdxEnd", ")", ")", "{", "int", "patIdxTmp", "=", "-", "1", ";", "for", "(", "int", "i", "=", "patNdxStart", "+", "1", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "if", "(", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "patIdxTmp", "=", "i", ";", "break", ";", "}", "}", "if", "(", "patIdxTmp", "==", "patNdxStart", "+", "1", ")", "{", "patNdxStart", "++", ";", "// skip **/** situation", "continue", ";", "}", "// find the pattern between padIdxStart & padIdxTmp in str between strIdxStart & strIdxEnd", "int", "patLength", "=", "(", "patIdxTmp", "-", "patNdxStart", "-", "1", ")", ";", "int", "strLength", "=", "(", "tokNdxEnd", "-", "tokNdxStart", "+", "1", ")", ";", "int", "ndx", "=", "-", "1", ";", "strLoop", ":", "for", "(", "int", "i", "=", "0", ";", "i", "<=", "strLength", "-", "patLength", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "patLength", ";", "j", "++", ")", "{", "String", "subPat", "=", "patterns", "[", "patNdxStart", "+", "j", "+", "1", "]", ";", "String", "subStr", "=", "tokens", "[", "tokNdxStart", "+", "i", "+", "j", "]", ";", "if", "(", "!", "WildcharUtils", ".", "match", "(", "subStr", ",", "subPat", ")", ")", "{", "continue", "strLoop", ";", "}", "}", "ndx", "=", "tokNdxStart", "+", "i", ";", "break", ";", "}", "if", "(", "ndx", "==", "-", "1", ")", "{", "return", "false", ";", "}", "patNdxStart", "=", "patIdxTmp", ";", "tokNdxStart", "=", "ndx", "+", "patLength", ";", "}", "for", "(", "int", "i", "=", "patNdxStart", ";", "i", "<=", "patNdxEnd", ";", "i", "++", ")", "{", "if", "(", "!", "patterns", "[", "i", "]", ".", "equals", "(", "PATH_MATCH", ")", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}"], "docstring": "Match tokenized string and pattern.", "docstring_tokens": ["Match", "tokenized", "string", "and", "pattern", "."]}
{"code": "return new Rectangular();", "comments": "an empty rectangle", "lines": 12, "repo": "FitLayout/api", "path": "src/main/java/org/fit/layout/model/Rectangular.java", "func_name": "Rectangular.intersection", "original_string": "public Rectangular intersection(Rectangular other)\n    {\n    \tif (this.intersects(other))\n\t    {\n    \t\treturn new Rectangular(Math.max(x1, other.x1),\n    \t\t\t\t\t\t\t   Math.max(y1, other.y1),\n    \t\t\t\t\t\t\t   Math.min(x2, other.x2),\n    \t\t\t\t\t\t\t   Math.min(y2, other.y2));\n\t    }\n\t    else\n\t    {\n\t        return new Rectangular(); //an empty rectangle\n\t    }    \t\n    }", "language": "java", "Allcodes": "public Rectangular intersection(Rectangular other)\n    {\n    \tif (this.intersects(other))\n\t    {\n    \t\treturn new Rectangular(Math.max(x1, other.x1),\n    \t\t\t\t\t\t\t   Math.max(y1, other.y1),\n    \t\t\t\t\t\t\t   Math.min(x2, other.x2),\n    \t\t\t\t\t\t\t   Math.min(y2, other.y2));\n\t    }\n\t    else\n\t    {\n\t        return new Rectangular(); //an empty rectangle\n\t    }    \t\n    }", "code_tokens": ["public", "Rectangular", "intersection", "(", "Rectangular", "other", ")", "{", "if", "(", "this", ".", "intersects", "(", "other", ")", ")", "{", "return", "new", "Rectangular", "(", "Math", ".", "max", "(", "x1", ",", "other", ".", "x1", ")", ",", "Math", ".", "max", "(", "y1", ",", "other", ".", "y1", ")", ",", "Math", ".", "min", "(", "x2", ",", "other", ".", "x2", ")", ",", "Math", ".", "min", "(", "y2", ",", "other", ".", "y2", ")", ")", ";", "}", "else", "{", "return", "new", "Rectangular", "(", ")", ";", "//an empty rectangle", "}", "}"], "docstring": "Computes the intersection of this rectangle with another one.\n@param other the other rectangle\n@return the resulting intersection or an empty rectangle when there is no intersection", "docstring_tokens": ["Computes", "the", "intersection", "of", "this", "rectangle", "with", "another", "one", "."]}
{"code": "cnt++;", "comments": "last column finishes the whole area", "lines": 26, "repo": "FitLayout/api", "path": "src/main/java/org/fit/layout/impl/AreaGrid.java", "func_name": "AreaGrid.calculateColumns", "original_string": "private void calculateColumns()\n    {\n        //create the sorted list of points\n        GridPoint points[] = new GridPoint[areas.size() * 2];\n        int pi = 0;\n        for (Area area : areas)\n        {\n            points[pi] = new GridPoint(area.getX1(), area, true);\n            points[pi+1] = new GridPoint(area.getX2() + 1, area, false);\n            pi += 2;\n            //X2+1 ensures that the end of one box will be on the same point\n            //as the start of the following box\n        }\n        Arrays.sort(points);\n        \n        //calculate the number of columns\n        int cnt = 0;\n        int last = abspos.getX1();\n        for (int i = 0; i < points.length; i++)\n            if (!theSame(points[i].value, last))\n            { \n                last = points[i].value;\n                cnt++;\n            }\n        if (!theSame(last, abspos.getX2()))\n        \tcnt++; //last column finishes the whole area\n        width = cnt;\n        \n        //calculate the column widths and the layout\n        maxindent = 0;\n        minindent = -1;\n        cols = new int[width];\n        cnt = 0;\n        last = abspos.getX1();\n        for (int i = 0; i < points.length; i++)\n        {\n            if (!theSame(points[i].value, last)) \n            {\n                cols[cnt] = points[i].value - last;\n                last = points[i].value;\n                cnt++;\n            }\n            if (points[i].begin)\n            {\n                target.getPosition(points[i].area).setX1(cnt);\n                maxindent = cnt;\n                if (minindent == -1) minindent = maxindent;\n                //points[i].node.getArea().setX1(parent.getArea().getX1() + getColOfs(cnt));\n            }\n            else\n            {\n                Rectangular pos = target.getPosition(points[i].area); \n                pos.setX2(cnt-1);\n                if (pos.getX2() < pos.getX1())\n                    pos.setX2(pos.getX1());\n                //points[i].node.getArea().setX2(parent.getArea().getX1() + getColOfs(pos.getX2()+1));\n            }\n        }\n        if (!theSame(last, abspos.getX2()))\n        \tcols[cnt] = abspos.getX2() - last;\n        if (minindent == -1)\n            minindent = 0;\n    }", "language": "java", "Allcodes": "private void calculateColumns()\n    {\n        //create the sorted list of points\n        GridPoint points[] = new GridPoint[areas.size() * 2];\n        int pi = 0;\n        for (Area area : areas)\n        {\n            points[pi] = new GridPoint(area.getX1(), area, true);\n            points[pi+1] = new GridPoint(area.getX2() + 1, area, false);\n            pi += 2;\n            //X2+1 ensures that the end of one box will be on the same point\n            //as the start of the following box\n        }\n        Arrays.sort(points);\n        \n        //calculate the number of columns\n        int cnt = 0;\n        int last = abspos.getX1();\n        for (int i = 0; i < points.length; i++)\n            if (!theSame(points[i].value, last))\n            { \n                last = points[i].value;\n                cnt++;\n            }\n        if (!theSame(last, abspos.getX2()))\n        \tcnt++; //last column finishes the whole area\n        width = cnt;\n        \n        //calculate the column widths and the layout\n        maxindent = 0;\n        minindent = -1;\n        cols = new int[width];\n        cnt = 0;\n        last = abspos.getX1();\n        for (int i = 0; i < points.length; i++)\n        {\n            if (!theSame(points[i].value, last)) \n            {\n                cols[cnt] = points[i].value - last;\n                last = points[i].value;\n                cnt++;\n            }\n            if (points[i].begin)\n            {\n                target.getPosition(points[i].area).setX1(cnt);\n                maxindent = cnt;\n                if (minindent == -1) minindent = maxindent;\n                //points[i].node.getArea().setX1(parent.getArea().getX1() + getColOfs(cnt));\n            }\n            else\n            {\n                Rectangular pos = target.getPosition(points[i].area); \n                pos.setX2(cnt-1);\n                if (pos.getX2() < pos.getX1())\n                    pos.setX2(pos.getX1());\n                //points[i].node.getArea().setX2(parent.getArea().getX1() + getColOfs(pos.getX2()+1));\n            }\n        }\n        if (!theSame(last, abspos.getX2()))\n        \tcols[cnt] = abspos.getX2() - last;\n        if (minindent == -1)\n            minindent = 0;\n    }", "code_tokens": ["private", "void", "calculateColumns", "(", ")", "{", "//create the sorted list of points", "GridPoint", "points", "[", "]", "=", "new", "GridPoint", "[", "areas", ".", "size", "(", ")", "*", "2", "]", ";", "int", "pi", "=", "0", ";", "for", "(", "Area", "area", ":", "areas", ")", "{", "points", "[", "pi", "]", "=", "new", "GridPoint", "(", "area", ".", "getX1", "(", ")", ",", "area", ",", "true", ")", ";", "points", "[", "pi", "+", "1", "]", "=", "new", "GridPoint", "(", "area", ".", "getX2", "(", ")", "+", "1", ",", "area", ",", "false", ")", ";", "pi", "+=", "2", ";", "//X2+1 ensures that the end of one box will be on the same point", "//as the start of the following box", "}", "Arrays", ".", "sort", "(", "points", ")", ";", "//calculate the number of columns", "int", "cnt", "=", "0", ";", "int", "last", "=", "abspos", ".", "getX1", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "points", ".", "length", ";", "i", "++", ")", "if", "(", "!", "theSame", "(", "points", "[", "i", "]", ".", "value", ",", "last", ")", ")", "{", "last", "=", "points", "[", "i", "]", ".", "value", ";", "cnt", "++", ";", "}", "if", "(", "!", "theSame", "(", "last", ",", "abspos", ".", "getX2", "(", ")", ")", ")", "cnt", "++", ";", "//last column finishes the whole area", "width", "=", "cnt", ";", "//calculate the column widths and the layout", "maxindent", "=", "0", ";", "minindent", "=", "-", "1", ";", "cols", "=", "new", "int", "[", "width", "]", ";", "cnt", "=", "0", ";", "last", "=", "abspos", ".", "getX1", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "points", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "theSame", "(", "points", "[", "i", "]", ".", "value", ",", "last", ")", ")", "{", "cols", "[", "cnt", "]", "=", "points", "[", "i", "]", ".", "value", "-", "last", ";", "last", "=", "points", "[", "i", "]", ".", "value", ";", "cnt", "++", ";", "}", "if", "(", "points", "[", "i", "]", ".", "begin", ")", "{", "target", ".", "getPosition", "(", "points", "[", "i", "]", ".", "area", ")", ".", "setX1", "(", "cnt", ")", ";", "maxindent", "=", "cnt", ";", "if", "(", "minindent", "==", "-", "1", ")", "minindent", "=", "maxindent", ";", "//points[i].node.getArea().setX1(parent.getArea().getX1() + getColOfs(cnt));", "}", "else", "{", "Rectangular", "pos", "=", "target", ".", "getPosition", "(", "points", "[", "i", "]", ".", "area", ")", ";", "pos", ".", "setX2", "(", "cnt", "-", "1", ")", ";", "if", "(", "pos", ".", "getX2", "(", ")", "<", "pos", ".", "getX1", "(", ")", ")", "pos", ".", "setX2", "(", "pos", ".", "getX1", "(", ")", ")", ";", "//points[i].node.getArea().setX2(parent.getArea().getX1() + getColOfs(pos.getX2()+1));", "}", "}", "if", "(", "!", "theSame", "(", "last", ",", "abspos", ".", "getX2", "(", ")", ")", ")", "cols", "[", "cnt", "]", "=", "abspos", ".", "getX2", "(", ")", "-", "last", ";", "if", "(", "minindent", "==", "-", "1", ")", "minindent", "=", "0", ";", "}"], "docstring": "Goes through the child areas and creates a list of collumns", "docstring_tokens": ["Goes", "through", "the", "child", "areas", "and", "creates", "a", "list", "of", "collumns"]}
{"code": "cnt++;", "comments": "last row finishes the whole area", "lines": 26, "repo": "FitLayout/api", "path": "src/main/java/org/fit/layout/impl/AreaGrid.java", "func_name": "AreaGrid.calculateRows", "original_string": "private void calculateRows()\n    {\n        //create the sorted list of points\n        GridPoint points[] = new GridPoint[areas.size() * 2];\n        int pi = 0;\n        for (Area area : areas)\n        {\n            points[pi] = new GridPoint(area.getY1(), area, true);\n            points[pi+1] = new GridPoint(area.getY2() + 1, area, false);\n            pi += 2;\n            //Y2+1 ensures that the end of one box will be on the same point\n            //as the start of the following box\n        }\n        Arrays.sort(points);\n        \n        //calculate the number of rows\n        int cnt = 0;\n        int last = abspos.getY1();\n        for (int i = 0; i < points.length; i++)\n            if (!theSame(points[i].value, last))\n            { \n                last = points[i].value;\n                cnt++;\n            }\n        if (!theSame(last, abspos.getY2()))\n        \tcnt++; //last row finishes the whole area\n        height = cnt;\n        \n        //calculate the row heights and the layout\n        rows = new int[height];\n        cnt = 0;\n        last = abspos.getY1();\n        for (int i = 0; i < points.length; i++)\n        {\n            if (!theSame(points[i].value, last)) \n            {\n                rows[cnt] = points[i].value - last;\n                last = points[i].value;\n                cnt++;\n            }\n            if (points[i].begin)\n            {\n                target.getPosition(points[i].area).setY1(cnt);\n                //points[i].node.getArea().setY1(parent.getArea().getY1() + getRowOfs(cnt));\n            }\n            else\n            {\n                Rectangular pos = target.getPosition(points[i].area); \n                pos.setY2(cnt-1);\n                if (pos.getY2() < pos.getY1())\n                    pos.setY2(pos.getY1());\n                //points[i].node.getArea().setY2(parent.getArea().getY1() + getRowOfs(pos.getY2()+1));\n            }\n        }\n        if (!theSame(last, abspos.getY2()))\n        \trows[cnt] = abspos.getY2() - last;\n    }", "language": "java", "Allcodes": "private void calculateRows()\n    {\n        //create the sorted list of points\n        GridPoint points[] = new GridPoint[areas.size() * 2];\n        int pi = 0;\n        for (Area area : areas)\n        {\n            points[pi] = new GridPoint(area.getY1(), area, true);\n            points[pi+1] = new GridPoint(area.getY2() + 1, area, false);\n            pi += 2;\n            //Y2+1 ensures that the end of one box will be on the same point\n            //as the start of the following box\n        }\n        Arrays.sort(points);\n        \n        //calculate the number of rows\n        int cnt = 0;\n        int last = abspos.getY1();\n        for (int i = 0; i < points.length; i++)\n            if (!theSame(points[i].value, last))\n            { \n                last = points[i].value;\n                cnt++;\n            }\n        if (!theSame(last, abspos.getY2()))\n        \tcnt++; //last row finishes the whole area\n        height = cnt;\n        \n        //calculate the row heights and the layout\n        rows = new int[height];\n        cnt = 0;\n        last = abspos.getY1();\n        for (int i = 0; i < points.length; i++)\n        {\n            if (!theSame(points[i].value, last)) \n            {\n                rows[cnt] = points[i].value - last;\n                last = points[i].value;\n                cnt++;\n            }\n            if (points[i].begin)\n            {\n                target.getPosition(points[i].area).setY1(cnt);\n                //points[i].node.getArea().setY1(parent.getArea().getY1() + getRowOfs(cnt));\n            }\n            else\n            {\n                Rectangular pos = target.getPosition(points[i].area); \n                pos.setY2(cnt-1);\n                if (pos.getY2() < pos.getY1())\n                    pos.setY2(pos.getY1());\n                //points[i].node.getArea().setY2(parent.getArea().getY1() + getRowOfs(pos.getY2()+1));\n            }\n        }\n        if (!theSame(last, abspos.getY2()))\n        \trows[cnt] = abspos.getY2() - last;\n    }", "code_tokens": ["private", "void", "calculateRows", "(", ")", "{", "//create the sorted list of points", "GridPoint", "points", "[", "]", "=", "new", "GridPoint", "[", "areas", ".", "size", "(", ")", "*", "2", "]", ";", "int", "pi", "=", "0", ";", "for", "(", "Area", "area", ":", "areas", ")", "{", "points", "[", "pi", "]", "=", "new", "GridPoint", "(", "area", ".", "getY1", "(", ")", ",", "area", ",", "true", ")", ";", "points", "[", "pi", "+", "1", "]", "=", "new", "GridPoint", "(", "area", ".", "getY2", "(", ")", "+", "1", ",", "area", ",", "false", ")", ";", "pi", "+=", "2", ";", "//Y2+1 ensures that the end of one box will be on the same point", "//as the start of the following box", "}", "Arrays", ".", "sort", "(", "points", ")", ";", "//calculate the number of rows", "int", "cnt", "=", "0", ";", "int", "last", "=", "abspos", ".", "getY1", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "points", ".", "length", ";", "i", "++", ")", "if", "(", "!", "theSame", "(", "points", "[", "i", "]", ".", "value", ",", "last", ")", ")", "{", "last", "=", "points", "[", "i", "]", ".", "value", ";", "cnt", "++", ";", "}", "if", "(", "!", "theSame", "(", "last", ",", "abspos", ".", "getY2", "(", ")", ")", ")", "cnt", "++", ";", "//last row finishes the whole area", "height", "=", "cnt", ";", "//calculate the row heights and the layout", "rows", "=", "new", "int", "[", "height", "]", ";", "cnt", "=", "0", ";", "last", "=", "abspos", ".", "getY1", "(", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "points", ".", "length", ";", "i", "++", ")", "{", "if", "(", "!", "theSame", "(", "points", "[", "i", "]", ".", "value", ",", "last", ")", ")", "{", "rows", "[", "cnt", "]", "=", "points", "[", "i", "]", ".", "value", "-", "last", ";", "last", "=", "points", "[", "i", "]", ".", "value", ";", "cnt", "++", ";", "}", "if", "(", "points", "[", "i", "]", ".", "begin", ")", "{", "target", ".", "getPosition", "(", "points", "[", "i", "]", ".", "area", ")", ".", "setY1", "(", "cnt", ")", ";", "//points[i].node.getArea().setY1(parent.getArea().getY1() + getRowOfs(cnt));", "}", "else", "{", "Rectangular", "pos", "=", "target", ".", "getPosition", "(", "points", "[", "i", "]", ".", "area", ")", ";", "pos", ".", "setY2", "(", "cnt", "-", "1", ")", ";", "if", "(", "pos", ".", "getY2", "(", ")", "<", "pos", ".", "getY1", "(", ")", ")", "pos", ".", "setY2", "(", "pos", ".", "getY1", "(", ")", ")", ";", "//points[i].node.getArea().setY2(parent.getArea().getY1() + getRowOfs(pos.getY2()+1));", "}", "}", "if", "(", "!", "theSame", "(", "last", ",", "abspos", ".", "getY2", "(", ")", ")", ")", "rows", "[", "cnt", "]", "=", "abspos", ".", "getY2", "(", ")", "-", "last", ";", "}"], "docstring": "Goes through the child areas and creates a list of rows", "docstring_tokens": ["Goes", "through", "the", "child", "areas", "and", "creates", "a", "list", "of", "rows"]}
{"code": "start++;", "comments": "Stop padding code overwriting minus sign.", "lines": 21, "repo": "rupertlssmith/lojix", "path": "lojix/power_model/src/main/com/thesett/aima/attribute/time/ByteBufferUtils.java", "func_name": "ByteBufferUtils.putPaddedInt32AsString", "original_string": "public static ByteBuffer putPaddedInt32AsString(ByteBuffer buffer, int value, int length)\n    {\n        // Ensure there is sufficient space in the buffer to hold the result.\n        int charsRequired = BitHackUtils.getCharacterCountInt32(value);\n        length = (charsRequired < length) ? length : charsRequired;\n\n        // Take an explicit index into the buffer to start writing to, as the numbers will be written backwards.\n        int index = buffer.position() + length - 1;\n\n        // Record the start position, to remember if a minus sign was written or not, so that it does not get\n        // overwritten by the zero padding.\n        int start = buffer.position();\n\n        // Advance the buffer position manually, as the characters will be written to specific indexes backwards.\n        buffer.position(buffer.position() + length);\n\n        // Take care of the minus sign for negative numbers.\n        if (value < 0)\n        {\n            buffer.put(MINUS_ASCII);\n            start++; // Stop padding code overwriting minus sign.\n        }\n        else\n        {\n            value = -value;\n        }\n\n        // Write the digits least significant to most significant into the buffer. As the number was converted to be\n        // negative the remainders will be negative too.\n        do\n        {\n            int remainder = value % 10;\n            value = value / 10;\n\n            buffer.put(index--, ((byte) (ZERO_ASCII - remainder)));\n        }\n        while (value != 0);\n\n        // Write out the padding zeros.\n        while (index >= start)\n        {\n            buffer.put(index--, ZERO_ASCII);\n        }\n\n        return buffer;\n    }", "language": "java", "Allcodes": "public static ByteBuffer putPaddedInt32AsString(ByteBuffer buffer, int value, int length)\n    {\n        // Ensure there is sufficient space in the buffer to hold the result.\n        int charsRequired = BitHackUtils.getCharacterCountInt32(value);\n        length = (charsRequired < length) ? length : charsRequired;\n\n        // Take an explicit index into the buffer to start writing to, as the numbers will be written backwards.\n        int index = buffer.position() + length - 1;\n\n        // Record the start position, to remember if a minus sign was written or not, so that it does not get\n        // overwritten by the zero padding.\n        int start = buffer.position();\n\n        // Advance the buffer position manually, as the characters will be written to specific indexes backwards.\n        buffer.position(buffer.position() + length);\n\n        // Take care of the minus sign for negative numbers.\n        if (value < 0)\n        {\n            buffer.put(MINUS_ASCII);\n            start++; // Stop padding code overwriting minus sign.\n        }\n        else\n        {\n            value = -value;\n        }\n\n        // Write the digits least significant to most significant into the buffer. As the number was converted to be\n        // negative the remainders will be negative too.\n        do\n        {\n            int remainder = value % 10;\n            value = value / 10;\n\n            buffer.put(index--, ((byte) (ZERO_ASCII - remainder)));\n        }\n        while (value != 0);\n\n        // Write out the padding zeros.\n        while (index >= start)\n        {\n            buffer.put(index--, ZERO_ASCII);\n        }\n\n        return buffer;\n    }", "code_tokens": ["public", "static", "ByteBuffer", "putPaddedInt32AsString", "(", "ByteBuffer", "buffer", ",", "int", "value", ",", "int", "length", ")", "{", "// Ensure there is sufficient space in the buffer to hold the result.", "int", "charsRequired", "=", "BitHackUtils", ".", "getCharacterCountInt32", "(", "value", ")", ";", "length", "=", "(", "charsRequired", "<", "length", ")", "?", "length", ":", "charsRequired", ";", "// Take an explicit index into the buffer to start writing to, as the numbers will be written backwards.", "int", "index", "=", "buffer", ".", "position", "(", ")", "+", "length", "-", "1", ";", "// Record the start position, to remember if a minus sign was written or not, so that it does not get", "// overwritten by the zero padding.", "int", "start", "=", "buffer", ".", "position", "(", ")", ";", "// Advance the buffer position manually, as the characters will be written to specific indexes backwards.", "buffer", ".", "position", "(", "buffer", ".", "position", "(", ")", "+", "length", ")", ";", "// Take care of the minus sign for negative numbers.", "if", "(", "value", "<", "0", ")", "{", "buffer", ".", "put", "(", "MINUS_ASCII", ")", ";", "start", "++", ";", "// Stop padding code overwriting minus sign.", "}", "else", "{", "value", "=", "-", "value", ";", "}", "// Write the digits least significant to most significant into the buffer. As the number was converted to be", "// negative the remainders will be negative too.", "do", "{", "int", "remainder", "=", "value", "%", "10", ";", "value", "=", "value", "/", "10", ";", "buffer", ".", "put", "(", "index", "--", ",", "(", "(", "byte", ")", "(", "ZERO_ASCII", "-", "remainder", ")", ")", ")", ";", "}", "while", "(", "value", "!=", "0", ")", ";", "// Write out the padding zeros.", "while", "(", "index", ">=", "start", ")", "{", "buffer", ".", "put", "(", "index", "--", ",", "ZERO_ASCII", ")", ";", "}", "return", "buffer", ";", "}"], "docstring": "Writes the specified integer value as an ASCII string into the specified byte buffer. If the integer value is\nshorted than the specified length, the number will be padded with leading zeros, so that it fills the required\nlength. If there is insufficient space in the buffer to write the value into, then the buffer size is increased\nusing the supplied byte buffer pool.\n\n@param  buffer The byte buffer to write to.\n@param  value  The value to write.\n@param  length The length to pad the number to with leading zeros.\n\n@return The byte buffer with the value written to it. This may be a different buffer to the one passed in if the\nbuffer had to be copied in order to increase its size.", "docstring_tokens": ["Writes", "the", "specified", "integer", "value", "as", "an", "ASCII", "string", "into", "the", "specified", "byte", "buffer", ".", "If", "the", "integer", "value", "is", "shorted", "than", "the", "specified", "length", "the", "number", "will", "be", "padded", "with", "leading", "zeros", "so", "that", "it", "fills", "the", "required", "length", ".", "If", "there", "is", "insufficient", "space", "in", "the", "buffer", "to", "write", "the", "value", "into", "then", "the", "buffer", "size", "is", "increased", "using", "the", "supplied", "byte", "buffer", "pool", "."]}
{"code": "return _name;", "comments": "Unable to find the variable's value, return the name for now (helpful for debugging)", "lines": 11, "repo": "jryans/jless", "path": "src/main/java/com/bazaarvoice/jless/ast/node/VariableReferenceNode.java", "func_name": "VariableReferenceNode.getValue", "original_string": "public String getValue() {\n        for (ScopeNode scope = NodeTreeUtils.getParentScope(this); scope != null; scope = NodeTreeUtils.getParentScope(scope)) {\n            ExpressionGroupNode value = scope.getVariable(_name);\n            if (value == null) {\n                continue;\n            }\n\n            return value.toString();\n        }\n\n        return _name; // Unable to find the variable's value, return the name for now (helpful for debugging)\n    }", "language": "java", "Allcodes": "public String getValue() {\n        for (ScopeNode scope = NodeTreeUtils.getParentScope(this); scope != null; scope = NodeTreeUtils.getParentScope(scope)) {\n            ExpressionGroupNode value = scope.getVariable(_name);\n            if (value == null) {\n                continue;\n            }\n\n            return value.toString();\n        }\n\n        return _name; // Unable to find the variable's value, return the name for now (helpful for debugging)\n    }", "code_tokens": ["public", "String", "getValue", "(", ")", "{", "for", "(", "ScopeNode", "scope", "=", "NodeTreeUtils", ".", "getParentScope", "(", "this", ")", ";", "scope", "!=", "null", ";", "scope", "=", "NodeTreeUtils", ".", "getParentScope", "(", "scope", ")", ")", "{", "ExpressionGroupNode", "value", "=", "scope", ".", "getVariable", "(", "_name", ")", ";", "if", "(", "value", "==", "null", ")", "{", "continue", ";", "}", "return", "value", ".", "toString", "(", ")", ";", "}", "return", "_name", ";", "// Unable to find the variable's value, return the name for now (helpful for debugging)", "}"], "docstring": "Search up the scope tree to locate the variable's value. The parser has already verified that\nthe variable is defined.", "docstring_tokens": ["Search", "up", "the", "scope", "tree", "to", "locate", "the", "variable", "s", "value", ".", "The", "parser", "has", "already", "verified", "that", "the", "variable", "is", "defined", "."]}
{"code": "currentNode = decision.decide(state);", "comments": ", currentNode);", "lines": 17, "repo": "rupertlssmith/lojix", "path": "lojix/learning/src/main/com/thesett/aima/learning/decisiontree/prototype/ProtoDTMachine.java", "func_name": "ProtoDTMachine.classify", "original_string": "public Map<String, OrdinalAttribute> classify(State state) throws ClassifyingFailureException\n    {\n        // Start at the root of the decision tree.\n        DecisionTree currentNode = dt;\n\n        // Loop down the decision tree until a leaf node is found.\n        while (true) // !currentNode.isLeaf())\n        {\n            DecisionTreeElement element = currentNode.getElement();\n\n            // Check that the current element really is a decision.\n            if (element instanceof Decision)\n            {\n                Decision decision = (Decision) element;\n\n                // Apply the decision at the current node to the state to be classified to get a new tree.\n                currentNode = decision.decide(state); // , currentNode);\n            }\n            else if (element instanceof Assignment)\n            {\n                // Cast the element to an Assignment as this is the only type of leaf that is possible.\n                Assignment assignment = (Assignment) element;\n\n                // Return the assignment in a map.\n                Map<String, OrdinalAttribute> assignmentMap = new HashMap<String, OrdinalAttribute>();\n\n                assignmentMap.put(assignment.getPropertyName(), assignment.getAttribute());\n\n                return assignmentMap;\n            }\n\n            // It is possible that a node may be of type Pending if an incomplete tree has been used to\n            // run this classification on.\n            else\n            {\n                // Throw a classification exception due to an incomplete decision tree.\n                throw new ClassifyingFailureException(\"A node which is not a decision was encountered.\", null);\n            }\n            // What happens if the decision could not operate on the state, either because of a missing property or\n            // because its property was not of the type that the decision was expecting? Can either throw an exception,\n            // return an empty assignment, or implement an algorithm for coping with missing properties.\n        }\n    }", "language": "java", "Allcodes": "public Map<String, OrdinalAttribute> classify(State state) throws ClassifyingFailureException\n    {\n        // Start at the root of the decision tree.\n        DecisionTree currentNode = dt;\n\n        // Loop down the decision tree until a leaf node is found.\n        while (true) // !currentNode.isLeaf())\n        {\n            DecisionTreeElement element = currentNode.getElement();\n\n            // Check that the current element really is a decision.\n            if (element instanceof Decision)\n            {\n                Decision decision = (Decision) element;\n\n                // Apply the decision at the current node to the state to be classified to get a new tree.\n                currentNode = decision.decide(state); // , currentNode);\n            }\n            else if (element instanceof Assignment)\n            {\n                // Cast the element to an Assignment as this is the only type of leaf that is possible.\n                Assignment assignment = (Assignment) element;\n\n                // Return the assignment in a map.\n                Map<String, OrdinalAttribute> assignmentMap = new HashMap<String, OrdinalAttribute>();\n\n                assignmentMap.put(assignment.getPropertyName(), assignment.getAttribute());\n\n                return assignmentMap;\n            }\n\n            // It is possible that a node may be of type Pending if an incomplete tree has been used to\n            // run this classification on.\n            else\n            {\n                // Throw a classification exception due to an incomplete decision tree.\n                throw new ClassifyingFailureException(\"A node which is not a decision was encountered.\", null);\n            }\n            // What happens if the decision could not operate on the state, either because of a missing property or\n            // because its property was not of the type that the decision was expecting? Can either throw an exception,\n            // return an empty assignment, or implement an algorithm for coping with missing properties.\n        }\n    }", "code_tokens": ["public", "Map", "<", "String", ",", "OrdinalAttribute", ">", "classify", "(", "State", "state", ")", "throws", "ClassifyingFailureException", "{", "// Start at the root of the decision tree.", "DecisionTree", "currentNode", "=", "dt", ";", "// Loop down the decision tree until a leaf node is found.", "while", "(", "true", ")", "// !currentNode.isLeaf())", "{", "DecisionTreeElement", "element", "=", "currentNode", ".", "getElement", "(", ")", ";", "// Check that the current element really is a decision.", "if", "(", "element", "instanceof", "Decision", ")", "{", "Decision", "decision", "=", "(", "Decision", ")", "element", ";", "// Apply the decision at the current node to the state to be classified to get a new tree.", "currentNode", "=", "decision", ".", "decide", "(", "state", ")", ";", "// , currentNode);", "}", "else", "if", "(", "element", "instanceof", "Assignment", ")", "{", "// Cast the element to an Assignment as this is the only type of leaf that is possible.", "Assignment", "assignment", "=", "(", "Assignment", ")", "element", ";", "// Return the assignment in a map.", "Map", "<", "String", ",", "OrdinalAttribute", ">", "assignmentMap", "=", "new", "HashMap", "<", "String", ",", "OrdinalAttribute", ">", "(", ")", ";", "assignmentMap", ".", "put", "(", "assignment", ".", "getPropertyName", "(", ")", ",", "assignment", ".", "getAttribute", "(", ")", ")", ";", "return", "assignmentMap", ";", "}", "// It is possible that a node may be of type Pending if an incomplete tree has been used to", "// run this classification on.", "else", "{", "// Throw a classification exception due to an incomplete decision tree.", "throw", "new", "ClassifyingFailureException", "(", "\"A node which is not a decision was encountered.\"", ",", "null", ")", ";", "}", "// What happens if the decision could not operate on the state, either because of a missing property or", "// because its property was not of the type that the decision was expecting? Can either throw an exception,", "// return an empty assignment, or implement an algorithm for coping with missing properties.", "}", "}"], "docstring": "Classifies a state using the decision tree.\n\n@param  state The input data point to classify.\n\n@return A classification of the data point as an mapping from the output property that the decision tree was\ntrained on to this classifiers belief abouts its value.\n\n@throws ClassifyingFailureException If the decision tree is not completed and this classifier encounters a\npending node in the tree that is still to be built.", "docstring_tokens": ["Classifies", "a", "state", "using", "the", "decision", "tree", "."]}
{"code": "totalDigits--;", "comments": "Minus sign already accounted for.", "lines": 12, "repo": "rupertlssmith/lojix", "path": "lojix/power_model/src/main/com/thesett/aima/attribute/time/BitHackUtils.java", "func_name": "BitHackUtils.getCharacterCountDecimal", "original_string": "public static int getCharacterCountDecimal(long integerValue, int scale)\n    {\n        boolean isNeg = integerValue < 0;\n\n        // Work out how many digits will be needed for the number, adding space for the minus sign, the decimal\n        // point and leading zeros if needed.\n        int totalDigits = BitHackUtils.getCharacterCountInt64(integerValue);\n        int totalLength = totalDigits;\n\n        if (isNeg)\n        {\n            totalDigits--; // Minus sign already accounted for.\n        }\n\n        if (scale > 0)\n        {\n            totalLength++; // For the decimal point.\n\n            if (scale >= totalDigits)\n            {\n                // For the leading zeros (+ 1 for the zero before decimal point).\n                totalLength += (scale - totalDigits) + 1;\n            }\n        }\n        else\n        {\n            // Add a zero for each negative point in scale\n            totalLength -= scale;\n        }\n\n        return totalLength;\n    }", "language": "java", "Allcodes": "public static int getCharacterCountDecimal(long integerValue, int scale)\n    {\n        boolean isNeg = integerValue < 0;\n\n        // Work out how many digits will be needed for the number, adding space for the minus sign, the decimal\n        // point and leading zeros if needed.\n        int totalDigits = BitHackUtils.getCharacterCountInt64(integerValue);\n        int totalLength = totalDigits;\n\n        if (isNeg)\n        {\n            totalDigits--; // Minus sign already accounted for.\n        }\n\n        if (scale > 0)\n        {\n            totalLength++; // For the decimal point.\n\n            if (scale >= totalDigits)\n            {\n                // For the leading zeros (+ 1 for the zero before decimal point).\n                totalLength += (scale - totalDigits) + 1;\n            }\n        }\n        else\n        {\n            // Add a zero for each negative point in scale\n            totalLength -= scale;\n        }\n\n        return totalLength;\n    }", "code_tokens": ["public", "static", "int", "getCharacterCountDecimal", "(", "long", "integerValue", ",", "int", "scale", ")", "{", "boolean", "isNeg", "=", "integerValue", "<", "0", ";", "// Work out how many digits will be needed for the number, adding space for the minus sign, the decimal", "// point and leading zeros if needed.", "int", "totalDigits", "=", "BitHackUtils", ".", "getCharacterCountInt64", "(", "integerValue", ")", ";", "int", "totalLength", "=", "totalDigits", ";", "if", "(", "isNeg", ")", "{", "totalDigits", "--", ";", "// Minus sign already accounted for.", "}", "if", "(", "scale", ">", "0", ")", "{", "totalLength", "++", ";", "// For the decimal point.", "if", "(", "scale", ">=", "totalDigits", ")", "{", "// For the leading zeros (+ 1 for the zero before decimal point).", "totalLength", "+=", "(", "scale", "-", "totalDigits", ")", "+", "1", ";", "}", "}", "else", "{", "// Add a zero for each negative point in scale", "totalLength", "-=", "scale", ";", "}", "return", "totalLength", ";", "}"], "docstring": "Calculates the number of ASCII characters that will be needed to represent a specified signed decimal number.\n\n@param  integerValue The integer component of the decimal number.\n@param  scale        The scale component of the decimal number.\n\n@return The number of ASCII character need to represent a signed decimal number.", "docstring_tokens": ["Calculates", "the", "number", "of", "ASCII", "characters", "that", "will", "be", "needed", "to", "represent", "a", "specified", "signed", "decimal", "number", "."]}
{"code": "totalLength++;", "comments": "For the decimal point.", "lines": 17, "repo": "rupertlssmith/lojix", "path": "lojix/power_model/src/main/com/thesett/aima/attribute/time/BitHackUtils.java", "func_name": "BitHackUtils.getCharacterCountDecimal", "original_string": "public static int getCharacterCountDecimal(long integerValue, int scale)\n    {\n        boolean isNeg = integerValue < 0;\n\n        // Work out how many digits will be needed for the number, adding space for the minus sign, the decimal\n        // point and leading zeros if needed.\n        int totalDigits = BitHackUtils.getCharacterCountInt64(integerValue);\n        int totalLength = totalDigits;\n\n        if (isNeg)\n        {\n            totalDigits--; // Minus sign already accounted for.\n        }\n\n        if (scale > 0)\n        {\n            totalLength++; // For the decimal point.\n\n            if (scale >= totalDigits)\n            {\n                // For the leading zeros (+ 1 for the zero before decimal point).\n                totalLength += (scale - totalDigits) + 1;\n            }\n        }\n        else\n        {\n            // Add a zero for each negative point in scale\n            totalLength -= scale;\n        }\n\n        return totalLength;\n    }", "language": "java", "Allcodes": "public static int getCharacterCountDecimal(long integerValue, int scale)\n    {\n        boolean isNeg = integerValue < 0;\n\n        // Work out how many digits will be needed for the number, adding space for the minus sign, the decimal\n        // point and leading zeros if needed.\n        int totalDigits = BitHackUtils.getCharacterCountInt64(integerValue);\n        int totalLength = totalDigits;\n\n        if (isNeg)\n        {\n            totalDigits--; // Minus sign already accounted for.\n        }\n\n        if (scale > 0)\n        {\n            totalLength++; // For the decimal point.\n\n            if (scale >= totalDigits)\n            {\n                // For the leading zeros (+ 1 for the zero before decimal point).\n                totalLength += (scale - totalDigits) + 1;\n            }\n        }\n        else\n        {\n            // Add a zero for each negative point in scale\n            totalLength -= scale;\n        }\n\n        return totalLength;\n    }", "code_tokens": ["public", "static", "int", "getCharacterCountDecimal", "(", "long", "integerValue", ",", "int", "scale", ")", "{", "boolean", "isNeg", "=", "integerValue", "<", "0", ";", "// Work out how many digits will be needed for the number, adding space for the minus sign, the decimal", "// point and leading zeros if needed.", "int", "totalDigits", "=", "BitHackUtils", ".", "getCharacterCountInt64", "(", "integerValue", ")", ";", "int", "totalLength", "=", "totalDigits", ";", "if", "(", "isNeg", ")", "{", "totalDigits", "--", ";", "// Minus sign already accounted for.", "}", "if", "(", "scale", ">", "0", ")", "{", "totalLength", "++", ";", "// For the decimal point.", "if", "(", "scale", ">=", "totalDigits", ")", "{", "// For the leading zeros (+ 1 for the zero before decimal point).", "totalLength", "+=", "(", "scale", "-", "totalDigits", ")", "+", "1", ";", "}", "}", "else", "{", "// Add a zero for each negative point in scale", "totalLength", "-=", "scale", ";", "}", "return", "totalLength", ";", "}"], "docstring": "Calculates the number of ASCII characters that will be needed to represent a specified signed decimal number.\n\n@param  integerValue The integer component of the decimal number.\n@param  scale        The scale component of the decimal number.\n\n@return The number of ASCII character need to represent a signed decimal number.", "docstring_tokens": ["Calculates", "the", "number", "of", "ASCII", "characters", "that", "will", "be", "needed", "to", "represent", "a", "specified", "signed", "decimal", "number", "."]}
{"code": "connector = null;", "comments": "allow gc", "lines": 21, "repo": "rupertlssmith/lojix", "path": "base/base/src/main/com/thesett/util/log4j/SilentFailSocketAppender.java", "func_name": "SilentFailSocketAppender.cleanUp", "original_string": "public void cleanUp()\n    {\n        if (oos != null)\n        {\n            try\n            {\n                oos.close();\n            }\n            catch (IOException e)\n            {\n                LogLog.error(\"Could not close oos.\", e);\n            }\n\n            oos = null;\n        }\n\n        if (connector != null)\n        {\n            // LogLog.debug(\"Interrupting the connector.\");\n            connector.interrupted = true;\n            connector = null; // allow gc\n        }\n    }", "language": "java", "Allcodes": "public void cleanUp()\n    {\n        if (oos != null)\n        {\n            try\n            {\n                oos.close();\n            }\n            catch (IOException e)\n            {\n                LogLog.error(\"Could not close oos.\", e);\n            }\n\n            oos = null;\n        }\n\n        if (connector != null)\n        {\n            // LogLog.debug(\"Interrupting the connector.\");\n            connector.interrupted = true;\n            connector = null; // allow gc\n        }\n    }", "code_tokens": ["public", "void", "cleanUp", "(", ")", "{", "if", "(", "oos", "!=", "null", ")", "{", "try", "{", "oos", ".", "close", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "LogLog", ".", "error", "(", "\"Could not close oos.\"", ",", "e", ")", ";", "}", "oos", "=", "null", ";", "}", "if", "(", "connector", "!=", "null", ")", "{", "// LogLog.debug(\"Interrupting the connector.\");", "connector", ".", "interrupted", "=", "true", ";", "connector", "=", "null", ";", "// allow gc", "}", "}"], "docstring": "Drop the connection to the remote host and release the underlying connector thread if it has been created.", "docstring_tokens": ["Drop", "the", "connection", "to", "the", "remote", "host", "and", "release", "the", "underlying", "connector", "thread", "if", "it", "has", "been", "created", "."]}
{"code": "notEmpty.signal();", "comments": "propagate to non-interrupted thread", "lines": 23, "repo": "rupertlssmith/lojix", "path": "base/common/src/main/com/thesett/common/util/concurrent/BatchSynchQueueBase.java", "func_name": "BatchSynchQueueBase.poll", "original_string": "public E poll(long timeout, TimeUnit unit) throws InterruptedException\n    {\n        ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        try\n        {\n            long nanos = unit.toNanos(timeout);\n\n            do\n            {\n                if (count != 0)\n                {\n                    return extract(true, true).getElement();\n                }\n\n                try\n                {\n                    nanos = notEmpty.awaitNanos(nanos);\n                }\n                catch (InterruptedException ie)\n                {\n                    notEmpty.signal(); // propagate to non-interrupted thread\n                    throw ie;\n                }\n            }\n            while (nanos > 0);\n\n            return null;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }", "language": "java", "Allcodes": "public E poll(long timeout, TimeUnit unit) throws InterruptedException\n    {\n        ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n\n        try\n        {\n            long nanos = unit.toNanos(timeout);\n\n            do\n            {\n                if (count != 0)\n                {\n                    return extract(true, true).getElement();\n                }\n\n                try\n                {\n                    nanos = notEmpty.awaitNanos(nanos);\n                }\n                catch (InterruptedException ie)\n                {\n                    notEmpty.signal(); // propagate to non-interrupted thread\n                    throw ie;\n                }\n            }\n            while (nanos > 0);\n\n            return null;\n        }\n        finally\n        {\n            lock.unlock();\n        }\n    }", "code_tokens": ["public", "E", "poll", "(", "long", "timeout", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", "{", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "lock", ".", "lockInterruptibly", "(", ")", ";", "try", "{", "long", "nanos", "=", "unit", ".", "toNanos", "(", "timeout", ")", ";", "do", "{", "if", "(", "count", "!=", "0", ")", "{", "return", "extract", "(", "true", ",", "true", ")", ".", "getElement", "(", ")", ";", "}", "try", "{", "nanos", "=", "notEmpty", ".", "awaitNanos", "(", "nanos", ")", ";", "}", "catch", "(", "InterruptedException", "ie", ")", "{", "notEmpty", ".", "signal", "(", ")", ";", "// propagate to non-interrupted thread", "throw", "ie", ";", "}", "}", "while", "(", "nanos", ">", "0", ")", ";", "return", "null", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time if no elements\nare present on this queue.\n\n@param  timeout How long to wait before giving up, in units of <tt>unit</tt>.\n@param  unit    A <tt>TimeUnit</tt> determining how to interpret the <tt>timeout</tt> parameter.\n\n@return The head of this queue, or <tt>null</tt> if the specified waiting time elapses before an element is\npresent.\n\n@throws InterruptedException If interrupted while waiting.", "docstring_tokens": ["Retrieves", "and", "removes", "the", "head", "of", "this", "queue", "waiting", "if", "necessary", "up", "to", "the", "specified", "wait", "time", "if", "no", "elements", "are", "present", "on", "this", "queue", "."]}
{"code": "return false;", "comments": "Don't add the original scope itself", "lines": 41, "repo": "jryans/jless", "path": "src/main/java/com/bazaarvoice/jless/ast/node/ScopeNode.java", "func_name": "ScopeNode.setAdditionVisitor", "original_string": "private void setAdditionVisitor() {\n        setAdditionVisitor(new InclusiveNodeVisitor() {\n            /**\n             * Add parameter set as a child for printing input, but also add each defined value to the variable map.\n             */\n            @Override\n            public boolean add(ParametersNode node) {\n                for (VariableDefinitionNode variable : NodeTreeUtils.getChildren(node, VariableDefinitionNode.class)) {\n                    _parameterDefinitions.add(variable);\n                    add(variable);\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Store the rule set's scope by selector group\n             */\n            @Override\n            public boolean add(RuleSetNode node) {\n                SelectorGroupNode selectorGroup = NodeTreeUtils.getFirstChild(node, SelectorGroupNode.class);\n                for (SelectorNode selectorNode : NodeTreeUtils.getChildren(selectorGroup, SelectorNode.class)) {\n                    StringBuilder sb = new StringBuilder();\n                    for (Node selectorChild : selectorNode.getChildren()) {\n                        sb.append(selectorChild.toString());\n                    }\n                    String selector = sb.toString();\n                    // Mixins lock on first definition\n                    if (!_selectorToRuleSetMap.containsKey(selector)) {\n                        _selectorToRuleSetMap.put(selector, node);\n                    }\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Absorb all children of the given scope. This assumes that cloning is not necessary.\n             */\n            @Override\n            public boolean add(ScopeNode node) {\n                NodeTreeUtils.moveChildren(node, ScopeNode.this);\n                return false; // Don't add the original scope itself\n            }\n\n            /**\n             * Store variable definitions in a map by name\n             */\n            @Override\n            public boolean add(VariableDefinitionNode node) {\n                String name = node.getName();\n                // \"Variables\" lock on first definition\n                if (!_variableNameToValueMap.containsKey(name)) {\n                    _variableNameToValueMap.put(name, NodeTreeUtils.getFirstChild(node, ExpressionGroupNode.class));\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Store property nodes by name. If there are multiple properties for a given name, only retain the last one.\n             */\n            @Override\n            public boolean add(PropertyNode node) {\n                String name = node.getName();\n\n                // If this is the IE-specific \"filter\" property, always add it\n                if (name.equals(FILTER_PROPERTY)) {\n                    return super.add(node);\n                }\n\n                // If the value of this property node is a vendor-specific keyword, always add it\n                if (node.getChildren().get(0).toString().startsWith(\"-\")) {\n                    return super.add(node);\n                }\n\n                // Check if this property has been seen before\n                if (_propertyNameToNodeMap.containsKey(name)) {\n                    PropertyNode oldPropertyNode = _propertyNameToNodeMap.get(name);\n                    int oldPropertyIndex = getChildren().indexOf(oldPropertyNode);\n\n                    if (oldPropertyNode.isVisible()) {\n                        // Hide the unneeded property\n                        oldPropertyNode.setVisible(false);\n\n                        // Attempt to hide one surrounding white space node\n                        if (!hideWhiteSpaceNode(oldPropertyIndex - 1)) {\n                            hideWhiteSpaceNode(oldPropertyIndex + 1);\n                        }\n                    }\n                }\n\n                // Store the property as the latest for this name\n                _propertyNameToNodeMap.put(name, node);\n\n                return super.add(node);\n            }\n        });\n    }", "language": "java", "Allcodes": "private void setAdditionVisitor() {\n        setAdditionVisitor(new InclusiveNodeVisitor() {\n            /**\n             * Add parameter set as a child for printing input, but also add each defined value to the variable map.\n             */\n            @Override\n            public boolean add(ParametersNode node) {\n                for (VariableDefinitionNode variable : NodeTreeUtils.getChildren(node, VariableDefinitionNode.class)) {\n                    _parameterDefinitions.add(variable);\n                    add(variable);\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Store the rule set's scope by selector group\n             */\n            @Override\n            public boolean add(RuleSetNode node) {\n                SelectorGroupNode selectorGroup = NodeTreeUtils.getFirstChild(node, SelectorGroupNode.class);\n                for (SelectorNode selectorNode : NodeTreeUtils.getChildren(selectorGroup, SelectorNode.class)) {\n                    StringBuilder sb = new StringBuilder();\n                    for (Node selectorChild : selectorNode.getChildren()) {\n                        sb.append(selectorChild.toString());\n                    }\n                    String selector = sb.toString();\n                    // Mixins lock on first definition\n                    if (!_selectorToRuleSetMap.containsKey(selector)) {\n                        _selectorToRuleSetMap.put(selector, node);\n                    }\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Absorb all children of the given scope. This assumes that cloning is not necessary.\n             */\n            @Override\n            public boolean add(ScopeNode node) {\n                NodeTreeUtils.moveChildren(node, ScopeNode.this);\n                return false; // Don't add the original scope itself\n            }\n\n            /**\n             * Store variable definitions in a map by name\n             */\n            @Override\n            public boolean add(VariableDefinitionNode node) {\n                String name = node.getName();\n                // \"Variables\" lock on first definition\n                if (!_variableNameToValueMap.containsKey(name)) {\n                    _variableNameToValueMap.put(name, NodeTreeUtils.getFirstChild(node, ExpressionGroupNode.class));\n                }\n                return super.add(node);\n            }\n\n            /**\n             * Store property nodes by name. If there are multiple properties for a given name, only retain the last one.\n             */\n            @Override\n            public boolean add(PropertyNode node) {\n                String name = node.getName();\n\n                // If this is the IE-specific \"filter\" property, always add it\n                if (name.equals(FILTER_PROPERTY)) {\n                    return super.add(node);\n                }\n\n                // If the value of this property node is a vendor-specific keyword, always add it\n                if (node.getChildren().get(0).toString().startsWith(\"-\")) {\n                    return super.add(node);\n                }\n\n                // Check if this property has been seen before\n                if (_propertyNameToNodeMap.containsKey(name)) {\n                    PropertyNode oldPropertyNode = _propertyNameToNodeMap.get(name);\n                    int oldPropertyIndex = getChildren().indexOf(oldPropertyNode);\n\n                    if (oldPropertyNode.isVisible()) {\n                        // Hide the unneeded property\n                        oldPropertyNode.setVisible(false);\n\n                        // Attempt to hide one surrounding white space node\n                        if (!hideWhiteSpaceNode(oldPropertyIndex - 1)) {\n                            hideWhiteSpaceNode(oldPropertyIndex + 1);\n                        }\n                    }\n                }\n\n                // Store the property as the latest for this name\n                _propertyNameToNodeMap.put(name, node);\n\n                return super.add(node);\n            }\n        });\n    }", "code_tokens": ["private", "void", "setAdditionVisitor", "(", ")", "{", "setAdditionVisitor", "(", "new", "InclusiveNodeVisitor", "(", ")", "{", "/**\n             * Add parameter set as a child for printing input, but also add each defined value to the variable map.\n             */", "@", "Override", "public", "boolean", "add", "(", "ParametersNode", "node", ")", "{", "for", "(", "VariableDefinitionNode", "variable", ":", "NodeTreeUtils", ".", "getChildren", "(", "node", ",", "VariableDefinitionNode", ".", "class", ")", ")", "{", "_parameterDefinitions", ".", "add", "(", "variable", ")", ";", "add", "(", "variable", ")", ";", "}", "return", "super", ".", "add", "(", "node", ")", ";", "}", "/**\n             * Store the rule set's scope by selector group\n             */", "@", "Override", "public", "boolean", "add", "(", "RuleSetNode", "node", ")", "{", "SelectorGroupNode", "selectorGroup", "=", "NodeTreeUtils", ".", "getFirstChild", "(", "node", ",", "SelectorGroupNode", ".", "class", ")", ";", "for", "(", "SelectorNode", "selectorNode", ":", "NodeTreeUtils", ".", "getChildren", "(", "selectorGroup", ",", "SelectorNode", ".", "class", ")", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", ")", ";", "for", "(", "Node", "selectorChild", ":", "selectorNode", ".", "getChildren", "(", ")", ")", "{", "sb", ".", "append", "(", "selectorChild", ".", "toString", "(", ")", ")", ";", "}", "String", "selector", "=", "sb", ".", "toString", "(", ")", ";", "// Mixins lock on first definition", "if", "(", "!", "_selectorToRuleSetMap", ".", "containsKey", "(", "selector", ")", ")", "{", "_selectorToRuleSetMap", ".", "put", "(", "selector", ",", "node", ")", ";", "}", "}", "return", "super", ".", "add", "(", "node", ")", ";", "}", "/**\n             * Absorb all children of the given scope. This assumes that cloning is not necessary.\n             */", "@", "Override", "public", "boolean", "add", "(", "ScopeNode", "node", ")", "{", "NodeTreeUtils", ".", "moveChildren", "(", "node", ",", "ScopeNode", ".", "this", ")", ";", "return", "false", ";", "// Don't add the original scope itself", "}", "/**\n             * Store variable definitions in a map by name\n             */", "@", "Override", "public", "boolean", "add", "(", "VariableDefinitionNode", "node", ")", "{", "String", "name", "=", "node", ".", "getName", "(", ")", ";", "// \"Variables\" lock on first definition", "if", "(", "!", "_variableNameToValueMap", ".", "containsKey", "(", "name", ")", ")", "{", "_variableNameToValueMap", ".", "put", "(", "name", ",", "NodeTreeUtils", ".", "getFirstChild", "(", "node", ",", "ExpressionGroupNode", ".", "class", ")", ")", ";", "}", "return", "super", ".", "add", "(", "node", ")", ";", "}", "/**\n             * Store property nodes by name. If there are multiple properties for a given name, only retain the last one.\n             */", "@", "Override", "public", "boolean", "add", "(", "PropertyNode", "node", ")", "{", "String", "name", "=", "node", ".", "getName", "(", ")", ";", "// If this is the IE-specific \"filter\" property, always add it", "if", "(", "name", ".", "equals", "(", "FILTER_PROPERTY", ")", ")", "{", "return", "super", ".", "add", "(", "node", ")", ";", "}", "// If the value of this property node is a vendor-specific keyword, always add it", "if", "(", "node", ".", "getChildren", "(", ")", ".", "get", "(", "0", ")", ".", "toString", "(", ")", ".", "startsWith", "(", "\"-\"", ")", ")", "{", "return", "super", ".", "add", "(", "node", ")", ";", "}", "// Check if this property has been seen before", "if", "(", "_propertyNameToNodeMap", ".", "containsKey", "(", "name", ")", ")", "{", "PropertyNode", "oldPropertyNode", "=", "_propertyNameToNodeMap", ".", "get", "(", "name", ")", ";", "int", "oldPropertyIndex", "=", "getChildren", "(", ")", ".", "indexOf", "(", "oldPropertyNode", ")", ";", "if", "(", "oldPropertyNode", ".", "isVisible", "(", ")", ")", "{", "// Hide the unneeded property", "oldPropertyNode", ".", "setVisible", "(", "false", ")", ";", "// Attempt to hide one surrounding white space node", "if", "(", "!", "hideWhiteSpaceNode", "(", "oldPropertyIndex", "-", "1", ")", ")", "{", "hideWhiteSpaceNode", "(", "oldPropertyIndex", "+", "1", ")", ";", "}", "}", "}", "// Store the property as the latest for this name", "_propertyNameToNodeMap", ".", "put", "(", "name", ",", "node", ")", ";", "return", "super", ".", "add", "(", "node", ")", ";", "}", "}", ")", ";", "}"], "docstring": "Some nodes are captured in additional structures to aid later resolution.", "docstring_tokens": ["Some", "nodes", "are", "captured", "in", "additional", "structures", "to", "aid", "later", "resolution", "."]}
{"code": "_counter = 0;", "comments": "reset counter", "lines": 4, "repo": "ieb/sparsemapcontent", "path": "core/src/main/java/org/sakaiproject/nakamura/api/lite/util/Type1UUID.java", "func_name": "Type1UUID.getUUIDTime", "original_string": "private static long getUUIDTime() {\n        if (_currentMillis != System.currentTimeMillis()) {\n            _currentMillis = System.currentTimeMillis();\n            _counter = 0; // reset counter\n        }\n\n        // check to see if we have created too many uuid's for this timestamp\n        if (_counter + 1 >= MILLI_MULT) {\n            // Original algorithm threw exception. Seemed like overkill.\n            // Let's just increment the timestamp instead and start over...\n            _currentMillis++;\n            _counter = 0;\n        }\n\n        // calculate time as current millis plus offset times 100 ns ticks\n        long currentTime = (_currentMillis + GREG_OFFSET) * MILLI_MULT;\n\n        // return the uuid time plus the artificial tick counter incremented\n        return currentTime + _counter++;\n    }", "language": "java", "Allcodes": "private static long getUUIDTime() {\n        if (_currentMillis != System.currentTimeMillis()) {\n            _currentMillis = System.currentTimeMillis();\n            _counter = 0; // reset counter\n        }\n\n        // check to see if we have created too many uuid's for this timestamp\n        if (_counter + 1 >= MILLI_MULT) {\n            // Original algorithm threw exception. Seemed like overkill.\n            // Let's just increment the timestamp instead and start over...\n            _currentMillis++;\n            _counter = 0;\n        }\n\n        // calculate time as current millis plus offset times 100 ns ticks\n        long currentTime = (_currentMillis + GREG_OFFSET) * MILLI_MULT;\n\n        // return the uuid time plus the artificial tick counter incremented\n        return currentTime + _counter++;\n    }", "code_tokens": ["private", "static", "long", "getUUIDTime", "(", ")", "{", "if", "(", "_currentMillis", "!=", "System", ".", "currentTimeMillis", "(", ")", ")", "{", "_currentMillis", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "_counter", "=", "0", ";", "// reset counter", "}", "// check to see if we have created too many uuid's for this timestamp", "if", "(", "_counter", "+", "1", ">=", "MILLI_MULT", ")", "{", "// Original algorithm threw exception. Seemed like overkill.", "// Let's just increment the timestamp instead and start over...", "_currentMillis", "++", ";", "_counter", "=", "0", ";", "}", "// calculate time as current millis plus offset times 100 ns ticks", "long", "currentTime", "=", "(", "_currentMillis", "+", "GREG_OFFSET", ")", "*", "MILLI_MULT", ";", "// return the uuid time plus the artificial tick counter incremented", "return", "currentTime", "+", "_counter", "++", ";", "}"], "docstring": "Gets the appropriately modified timestamep for the UUID. Must be called\nfrom a synchronized block.\n\n@return long timestamp in 100ns intervals since the Gregorian change\noffset", "docstring_tokens": ["Gets", "the", "appropriately", "modified", "timestamep", "for", "the", "UUID", ".", "Must", "be", "called", "from", "a", "synchronized", "block", "."]}
{"code": ".orElse(null);", "comments": "should not happen", "lines": 8, "repo": "intellimate/IzouSDK", "path": "src/main/java/org/intellimate/izou/sdk/frameworks/music/player/template/Player.java", "func_name": "Player.handleResourceRequest", "original_string": "private void handleResourceRequest(EventModel eventModel) {\n        if (MusicUsageResource.isPermanent(eventModel)) {\n            ResourceModel resourceModel = eventModel.getListResourceContainer()\n                    .provideResource(MusicUsageResource.ID)\n                    .stream()\n                    .filter(MusicUsageResource::isPermanent)\n                    .findAny()\n                    .orElse(null);//should not happen\n\n            //a partially applied function which takes an Identification an returns an Optional StartMusicRequest\n            Function<Identification, Optional<StartMusicRequest>> getStartMusicRequest = own ->\n                    StartMusicRequest.createStartMusicRequest(resourceModel.getProvider(), own);\n\n            //if we have a trackInfo we create it with the trackInfo as a parameter\n            getStartMusicRequest = TrackInfoResource.getTrackInfo(eventModel)\n                    .map(trackInfo -> (Function<Identification, Optional<StartMusicRequest>>) own ->\n                            StartMusicRequest.createStartMusicRequest(resourceModel.getProvider(), own, trackInfo))\n                    .orElse(getStartMusicRequest);\n\n            //if we have a trackInfo we create it with the playlist as a parameter\n            getStartMusicRequest = PlaylistResource.getPlaylist(eventModel)\n                    .map(playlist -> (Function<Identification, Optional<StartMusicRequest>>) own ->\n                            StartMusicRequest.createStartMusicRequest(resourceModel.getProvider(), own, playlist))\n                    .orElse(getStartMusicRequest);\n\n            //composes a new Function which appends the Volume to the result\n            getStartMusicRequest = getStartMusicRequest.andThen(\n                    VolumeResource.getVolume(eventModel)\n                    .flatMap(volume -> IdentificationManagerM.getInstance().getIdentification(this)\n                            .map(identification -> new VolumeResource(identification, volume)))\n                    .map(resource -> (Function<Optional<StartMusicRequest>, Optional<StartMusicRequest>>) opt ->\n                                    opt.map(event -> (StartMusicRequest) event.addResource(resource))\n                    )\n                    .orElse(Function.identity())::apply);\n\n            IdentificationManagerM.getInstance().getIdentification(this)\n                    .flatMap(getStartMusicRequest::apply)\n                    .ifPresent(this::fire);\n        } else {\n            play(eventModel);\n            if (!runsInPlay) {\n                blockRequest = lock.newCondition();\n                lock.lock();\n                try {\n                    blockRequest.await(10, TimeUnit.MINUTES);\n                } catch (InterruptedException e) {\n                    debug(\"interrupted\", e);\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }", "language": "java", "Allcodes": "private void handleResourceRequest(EventModel eventModel) {\n        if (MusicUsageResource.isPermanent(eventModel)) {\n            ResourceModel resourceModel = eventModel.getListResourceContainer()\n                    .provideResource(MusicUsageResource.ID)\n                    .stream()\n                    .filter(MusicUsageResource::isPermanent)\n                    .findAny()\n                    .orElse(null);//should not happen\n\n            //a partially applied function which takes an Identification an returns an Optional StartMusicRequest\n            Function<Identification, Optional<StartMusicRequest>> getStartMusicRequest = own ->\n                    StartMusicRequest.createStartMusicRequest(resourceModel.getProvider(), own);\n\n            //if we have a trackInfo we create it with the trackInfo as a parameter\n            getStartMusicRequest = TrackInfoResource.getTrackInfo(eventModel)\n                    .map(trackInfo -> (Function<Identification, Optional<StartMusicRequest>>) own ->\n                            StartMusicRequest.createStartMusicRequest(resourceModel.getProvider(), own, trackInfo))\n                    .orElse(getStartMusicRequest);\n\n            //if we have a trackInfo we create it with the playlist as a parameter\n            getStartMusicRequest = PlaylistResource.getPlaylist(eventModel)\n                    .map(playlist -> (Function<Identification, Optional<StartMusicRequest>>) own ->\n                            StartMusicRequest.createStartMusicRequest(resourceModel.getProvider(), own, playlist))\n                    .orElse(getStartMusicRequest);\n\n            //composes a new Function which appends the Volume to the result\n            getStartMusicRequest = getStartMusicRequest.andThen(\n                    VolumeResource.getVolume(eventModel)\n                    .flatMap(volume -> IdentificationManagerM.getInstance().getIdentification(this)\n                            .map(identification -> new VolumeResource(identification, volume)))\n                    .map(resource -> (Function<Optional<StartMusicRequest>, Optional<StartMusicRequest>>) opt ->\n                                    opt.map(event -> (StartMusicRequest) event.addResource(resource))\n                    )\n                    .orElse(Function.identity())::apply);\n\n            IdentificationManagerM.getInstance().getIdentification(this)\n                    .flatMap(getStartMusicRequest::apply)\n                    .ifPresent(this::fire);\n        } else {\n            play(eventModel);\n            if (!runsInPlay) {\n                blockRequest = lock.newCondition();\n                lock.lock();\n                try {\n                    blockRequest.await(10, TimeUnit.MINUTES);\n                } catch (InterruptedException e) {\n                    debug(\"interrupted\", e);\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }", "code_tokens": ["private", "void", "handleResourceRequest", "(", "EventModel", "eventModel", ")", "{", "if", "(", "MusicUsageResource", ".", "isPermanent", "(", "eventModel", ")", ")", "{", "ResourceModel", "resourceModel", "=", "eventModel", ".", "getListResourceContainer", "(", ")", ".", "provideResource", "(", "MusicUsageResource", ".", "ID", ")", ".", "stream", "(", ")", ".", "filter", "(", "MusicUsageResource", "::", "isPermanent", ")", ".", "findAny", "(", ")", ".", "orElse", "(", "null", ")", ";", "//should not happen", "//a partially applied function which takes an Identification an returns an Optional StartMusicRequest", "Function", "<", "Identification", ",", "Optional", "<", "StartMusicRequest", ">", ">", "getStartMusicRequest", "=", "own", "->", "StartMusicRequest", ".", "createStartMusicRequest", "(", "resourceModel", ".", "getProvider", "(", ")", ",", "own", ")", ";", "//if we have a trackInfo we create it with the trackInfo as a parameter", "getStartMusicRequest", "=", "TrackInfoResource", ".", "getTrackInfo", "(", "eventModel", ")", ".", "map", "(", "trackInfo", "->", "(", "Function", "<", "Identification", ",", "Optional", "<", "StartMusicRequest", ">", ">", ")", "own", "->", "StartMusicRequest", ".", "createStartMusicRequest", "(", "resourceModel", ".", "getProvider", "(", ")", ",", "own", ",", "trackInfo", ")", ")", ".", "orElse", "(", "getStartMusicRequest", ")", ";", "//if we have a trackInfo we create it with the playlist as a parameter", "getStartMusicRequest", "=", "PlaylistResource", ".", "getPlaylist", "(", "eventModel", ")", ".", "map", "(", "playlist", "->", "(", "Function", "<", "Identification", ",", "Optional", "<", "StartMusicRequest", ">", ">", ")", "own", "->", "StartMusicRequest", ".", "createStartMusicRequest", "(", "resourceModel", ".", "getProvider", "(", ")", ",", "own", ",", "playlist", ")", ")", ".", "orElse", "(", "getStartMusicRequest", ")", ";", "//composes a new Function which appends the Volume to the result", "getStartMusicRequest", "=", "getStartMusicRequest", ".", "andThen", "(", "VolumeResource", ".", "getVolume", "(", "eventModel", ")", ".", "flatMap", "(", "volume", "->", "IdentificationManagerM", ".", "getInstance", "(", ")", ".", "getIdentification", "(", "this", ")", ".", "map", "(", "identification", "->", "new", "VolumeResource", "(", "identification", ",", "volume", ")", ")", ")", ".", "map", "(", "resource", "->", "(", "Function", "<", "Optional", "<", "StartMusicRequest", ">", ",", "Optional", "<", "StartMusicRequest", ">", ">", ")", "opt", "->", "opt", ".", "map", "(", "event", "->", "(", "StartMusicRequest", ")", "event", ".", "addResource", "(", "resource", ")", ")", ")", ".", "orElse", "(", "Function", ".", "identity", "(", ")", ")", "::", "apply", ")", ";", "IdentificationManagerM", ".", "getInstance", "(", ")", ".", "getIdentification", "(", "this", ")", ".", "flatMap", "(", "getStartMusicRequest", "::", "apply", ")", ".", "ifPresent", "(", "this", "::", "fire", ")", ";", "}", "else", "{", "play", "(", "eventModel", ")", ";", "if", "(", "!", "runsInPlay", ")", "{", "blockRequest", "=", "lock", ".", "newCondition", "(", ")", ";", "lock", ".", "lock", "(", ")", ";", "try", "{", "blockRequest", ".", "await", "(", "10", ",", "TimeUnit", ".", "MINUTES", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "debug", "(", "\"interrupted\"", ",", "e", ")", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "}", "}"], "docstring": "handles the a request to start playing music via Resource\n@param eventModel the eventModel", "docstring_tokens": ["handles", "the", "a", "request", "to", "start", "playing", "music", "via", "Resource"]}
{"code": "return null;", "comments": "nothing to return", "lines": 24, "repo": "kolotyluk/java-file-utilities", "path": "src/main/java/net/kolotyluk/java/files/Files.java", "func_name": "Files.cleanDirectByteBuffer", "original_string": "public static void cleanDirectByteBuffer(final ByteBuffer byteBuffer)\n  {\n\t  \n\tif (byteBuffer == null) return;\n\n    if (!byteBuffer.isDirect())\n    \tthrow new IllegalArgumentException(\"byteBuffer isn't direct!\");\n    \n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n        \ttry\n        \t{\n        \t\tMethod cleanerMethod = byteBuffer.getClass().getMethod(\"cleaner\");\n        \t    cleanerMethod.setAccessible(true);\n        \t    Object cleaner = cleanerMethod.invoke(byteBuffer);\n        \t    Method cleanMethod = cleaner.getClass().getMethod(\"clean\");\n        \t    cleanMethod.setAccessible(true);\n        \t    cleanMethod.invoke(cleaner);\n        \t}\n        \tcatch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e)\n        \t{\n        \t\tthrow new RuntimeException(\"Could not clean MappedByteBuffer -- File may still be locked!\");\n        \t}\n           return null; // nothing to return\n        }\n    });\n\n\n  }", "language": "java", "Allcodes": "public static void cleanDirectByteBuffer(final ByteBuffer byteBuffer)\n  {\n\t  \n\tif (byteBuffer == null) return;\n\n    if (!byteBuffer.isDirect())\n    \tthrow new IllegalArgumentException(\"byteBuffer isn't direct!\");\n    \n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n        \ttry\n        \t{\n        \t\tMethod cleanerMethod = byteBuffer.getClass().getMethod(\"cleaner\");\n        \t    cleanerMethod.setAccessible(true);\n        \t    Object cleaner = cleanerMethod.invoke(byteBuffer);\n        \t    Method cleanMethod = cleaner.getClass().getMethod(\"clean\");\n        \t    cleanMethod.setAccessible(true);\n        \t    cleanMethod.invoke(cleaner);\n        \t}\n        \tcatch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e)\n        \t{\n        \t\tthrow new RuntimeException(\"Could not clean MappedByteBuffer -- File may still be locked!\");\n        \t}\n           return null; // nothing to return\n        }\n    });\n\n\n  }", "code_tokens": ["public", "static", "void", "cleanDirectByteBuffer", "(", "final", "ByteBuffer", "byteBuffer", ")", "{", "if", "(", "byteBuffer", "==", "null", ")", "return", ";", "if", "(", "!", "byteBuffer", ".", "isDirect", "(", ")", ")", "throw", "new", "IllegalArgumentException", "(", "\"byteBuffer isn't direct!\"", ")", ";", "AccessController", ".", "doPrivileged", "(", "new", "PrivilegedAction", "<", "Void", ">", "(", ")", "{", "public", "Void", "run", "(", ")", "{", "try", "{", "Method", "cleanerMethod", "=", "byteBuffer", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"cleaner\"", ")", ";", "cleanerMethod", ".", "setAccessible", "(", "true", ")", ";", "Object", "cleaner", "=", "cleanerMethod", ".", "invoke", "(", "byteBuffer", ")", ";", "Method", "cleanMethod", "=", "cleaner", ".", "getClass", "(", ")", ".", "getMethod", "(", "\"clean\"", ")", ";", "cleanMethod", ".", "setAccessible", "(", "true", ")", ";", "cleanMethod", ".", "invoke", "(", "cleaner", ")", ";", "}", "catch", "(", "NoSuchMethodException", "|", "SecurityException", "|", "IllegalAccessException", "|", "IllegalArgumentException", "|", "InvocationTargetException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "\"Could not clean MappedByteBuffer -- File may still be locked!\"", ")", ";", "}", "return", "null", ";", "// nothing to return", "}", "}", ")", ";", "}"], "docstring": "Clean or unmap a direct ByteBuffer\n\n<p>DirectByteBuffers are garbage collected by using a phantom reference and a\nreference queue. Every once a while, the JVM checks the reference queue and\ncleans the DirectByteBuffers. However, as this doesn't happen immediately\nafter discarding all references to a DirectByteBuffer, it's easy get\n{@link OutOfMemoryError} problems using direct ByteBuffers.</p>\n\n<p>Also, if a file is still mapped, via {@link MappedByteBuffer}, then it is\nlocked and cannot be destroyed or possibly written to if it was previously\nmapped read. Trying to destroy or write to a locked file will result in an\n{@link IOException}</p>\n\n<p>This function explicitly calls the cleaner method of a {@link ByteBuffer} using\nreflection because it is not publicly accessible.</p>\n\n@param byteBuffer The DirectByteBuffer that will be \"cleaned\". Returns immediately if\nthe argument is null.\n@throws IllegalArgumentException if byteBuffer isn't direct\n@throws RuntimeException if cleaning may have failed", "docstring_tokens": ["Clean", "or", "unmap", "a", "direct", "ByteBuffer"]}
{"code": "throw ex;", "comments": "Everything stoppped. Now throw the exception.", "lines": 91, "repo": "abmargb/jamppa", "path": "src/main/java/org/jivesoftware/smack/XMPPConnection.java", "func_name": "XMPPConnection.initConnection", "original_string": "private void initConnection() throws XMPPException {\n        boolean isFirstInitialization = packetReader == null\n                || packetWriter == null;\n        compressionHandler = null;\n        serverAckdCompression = false;\n\n        // Set the reader and writer instance variables\n        initReaderAndWriter();\n\n        try {\n            if (isFirstInitialization) {\n                packetWriter = new PacketWriter(this);\n                packetReader = new PacketReader(this);\n\n                // If debugging is enabled, we should start the thread that will\n                // listen for\n                // all packets and then log them.\n                if (config.isDebuggerEnabled()) {\n                    addPacketListener(debugger.getReaderListener(), null);\n                    if (debugger.getWriterListener() != null) {\n                        addPacketSendingListener(debugger.getWriterListener(),\n                                null);\n                    }\n                }\n            } else {\n                packetWriter.init();\n                packetReader.init();\n            }\n\n            // Start the packet writer. This will open a XMPP stream to the\n            // server\n            packetWriter.startup();\n            // Start the packet reader. The startup() method will block until we\n            // get an opening stream packet back from server.\n            packetReader.startup();\n\n            // Make note of the fact that we're now connected.\n            connected = true;\n\n            if (isFirstInitialization) {\n                // Notify listeners that a new connection has been established\n                for (ConnectionCreationListener listener : getConnectionCreationListeners()) {\n                    listener.connectionCreated(this);\n                }\n            }\n\n        } catch (XMPPException ex) {\n            // An exception occurred in setting up the connection. Make sure we\n            // shut down the\n            // readers and writers and close the socket.\n\n            if (packetWriter != null) {\n                try {\n                    packetWriter.shutdown();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                packetWriter = null;\n            }\n            if (packetReader != null) {\n                try {\n                    packetReader.shutdown();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                packetReader = null;\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                reader = null;\n            }\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                writer = null;\n            }\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (Exception e) { /* ignore */\n                }\n                socket = null;\n            }\n            this.setWasAuthenticated(authenticated);\n            authenticated = false;\n            connected = false;\n\n            throw ex; // Everything stoppped. Now throw the exception.\n        }\n    }", "language": "java", "Allcodes": "private void initConnection() throws XMPPException {\n        boolean isFirstInitialization = packetReader == null\n                || packetWriter == null;\n        compressionHandler = null;\n        serverAckdCompression = false;\n\n        // Set the reader and writer instance variables\n        initReaderAndWriter();\n\n        try {\n            if (isFirstInitialization) {\n                packetWriter = new PacketWriter(this);\n                packetReader = new PacketReader(this);\n\n                // If debugging is enabled, we should start the thread that will\n                // listen for\n                // all packets and then log them.\n                if (config.isDebuggerEnabled()) {\n                    addPacketListener(debugger.getReaderListener(), null);\n                    if (debugger.getWriterListener() != null) {\n                        addPacketSendingListener(debugger.getWriterListener(),\n                                null);\n                    }\n                }\n            } else {\n                packetWriter.init();\n                packetReader.init();\n            }\n\n            // Start the packet writer. This will open a XMPP stream to the\n            // server\n            packetWriter.startup();\n            // Start the packet reader. The startup() method will block until we\n            // get an opening stream packet back from server.\n            packetReader.startup();\n\n            // Make note of the fact that we're now connected.\n            connected = true;\n\n            if (isFirstInitialization) {\n                // Notify listeners that a new connection has been established\n                for (ConnectionCreationListener listener : getConnectionCreationListeners()) {\n                    listener.connectionCreated(this);\n                }\n            }\n\n        } catch (XMPPException ex) {\n            // An exception occurred in setting up the connection. Make sure we\n            // shut down the\n            // readers and writers and close the socket.\n\n            if (packetWriter != null) {\n                try {\n                    packetWriter.shutdown();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                packetWriter = null;\n            }\n            if (packetReader != null) {\n                try {\n                    packetReader.shutdown();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                packetReader = null;\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                reader = null;\n            }\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (Throwable ignore) { /* ignore */\n                }\n                writer = null;\n            }\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (Exception e) { /* ignore */\n                }\n                socket = null;\n            }\n            this.setWasAuthenticated(authenticated);\n            authenticated = false;\n            connected = false;\n\n            throw ex; // Everything stoppped. Now throw the exception.\n        }\n    }", "code_tokens": ["private", "void", "initConnection", "(", ")", "throws", "XMPPException", "{", "boolean", "isFirstInitialization", "=", "packetReader", "==", "null", "||", "packetWriter", "==", "null", ";", "compressionHandler", "=", "null", ";", "serverAckdCompression", "=", "false", ";", "// Set the reader and writer instance variables", "initReaderAndWriter", "(", ")", ";", "try", "{", "if", "(", "isFirstInitialization", ")", "{", "packetWriter", "=", "new", "PacketWriter", "(", "this", ")", ";", "packetReader", "=", "new", "PacketReader", "(", "this", ")", ";", "// If debugging is enabled, we should start the thread that will", "// listen for", "// all packets and then log them.", "if", "(", "config", ".", "isDebuggerEnabled", "(", ")", ")", "{", "addPacketListener", "(", "debugger", ".", "getReaderListener", "(", ")", ",", "null", ")", ";", "if", "(", "debugger", ".", "getWriterListener", "(", ")", "!=", "null", ")", "{", "addPacketSendingListener", "(", "debugger", ".", "getWriterListener", "(", ")", ",", "null", ")", ";", "}", "}", "}", "else", "{", "packetWriter", ".", "init", "(", ")", ";", "packetReader", ".", "init", "(", ")", ";", "}", "// Start the packet writer. This will open a XMPP stream to the", "// server", "packetWriter", ".", "startup", "(", ")", ";", "// Start the packet reader. The startup() method will block until we", "// get an opening stream packet back from server.", "packetReader", ".", "startup", "(", ")", ";", "// Make note of the fact that we're now connected.", "connected", "=", "true", ";", "if", "(", "isFirstInitialization", ")", "{", "// Notify listeners that a new connection has been established", "for", "(", "ConnectionCreationListener", "listener", ":", "getConnectionCreationListeners", "(", ")", ")", "{", "listener", ".", "connectionCreated", "(", "this", ")", ";", "}", "}", "}", "catch", "(", "XMPPException", "ex", ")", "{", "// An exception occurred in setting up the connection. Make sure we", "// shut down the", "// readers and writers and close the socket.", "if", "(", "packetWriter", "!=", "null", ")", "{", "try", "{", "packetWriter", ".", "shutdown", "(", ")", ";", "}", "catch", "(", "Throwable", "ignore", ")", "{", "/* ignore */", "}", "packetWriter", "=", "null", ";", "}", "if", "(", "packetReader", "!=", "null", ")", "{", "try", "{", "packetReader", ".", "shutdown", "(", ")", ";", "}", "catch", "(", "Throwable", "ignore", ")", "{", "/* ignore */", "}", "packetReader", "=", "null", ";", "}", "if", "(", "reader", "!=", "null", ")", "{", "try", "{", "reader", ".", "close", "(", ")", ";", "}", "catch", "(", "Throwable", "ignore", ")", "{", "/* ignore */", "}", "reader", "=", "null", ";", "}", "if", "(", "writer", "!=", "null", ")", "{", "try", "{", "writer", ".", "close", "(", ")", ";", "}", "catch", "(", "Throwable", "ignore", ")", "{", "/* ignore */", "}", "writer", "=", "null", ";", "}", "if", "(", "socket", "!=", "null", ")", "{", "try", "{", "socket", ".", "close", "(", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "/* ignore */", "}", "socket", "=", "null", ";", "}", "this", ".", "setWasAuthenticated", "(", "authenticated", ")", ";", "authenticated", "=", "false", ";", "connected", "=", "false", ";", "throw", "ex", ";", "// Everything stoppped. Now throw the exception.", "}", "}"], "docstring": "Initializes the connection by creating a packet reader and writer and\nopening a XMPP stream to the server.\n\n@throws XMPPException\nif establishing a connection to the server fails.", "docstring_tokens": ["Initializes", "the", "connection", "by", "creating", "a", "packet", "reader", "and", "writer", "and", "opening", "a", "XMPP", "stream", "to", "the", "server", "."]}
{"code": "return;", "comments": "catch the case where another method creates while", "lines": 11, "repo": "ieb/sparsemapcontent", "path": "core/src/main/java/org/sakaiproject/nakamura/lite/CachingManagerImpl.java", "func_name": "CachingManagerImpl.putCached", "original_string": "protected void putCached(String keySpace, String columnFamily, String key, Map<String, Object> encodedProperties,\n            boolean probablyNew) throws StorageClientException {\n        String cacheKey = null;\n        if (sharedCache != null) {\n            cacheKey = getCacheKey(keySpace, columnFamily, key);\n        }\n        if (sharedCache != null && !probablyNew) {\n            CacheHolder ch = getFromCacheInternal(cacheKey);\n            if (ch != null && ch.isLocked(this.managerId)) {\n                LOGGER.debug(\"Is Locked {} \", ch);\n                return; // catch the case where another method creates while\n                // something is in the cache.\n                // this is a big assumption since if the item is not in the\n                // cache it will get updated\n                // there is no difference in sparsemap between create and\n                // update, they are all insert operations\n                // what we are really saying here is that inorder to update the\n                // item you have to have just got it\n                // and if you failed to get it, your update must have been a\n                // create operation. As long as the dwell time\n                // in the cache is longer than the lifetime of an active session\n                // then this will be true.\n                // if the lifetime of an active session is longer (like with a\n                // long running background operation)\n                // then you should expect to see race conditions at this point\n                // since the marker in the cache will have\n                // gone, and the marker in the database has gone, so the put\n                // operation, must be a create operation.\n                // To change this behavior we would need to differentiate more\n                // strongly between new and update and change\n                // probablyNew into certainlyNew, but that would probably break\n                // the BASIC assumption of the whole system.\n                // Update 2011-12-06 related to issue 136\n                // I am not certain this code is correct. What happens if the\n                // session wants to remove and then add items.\n                // the session will never get past this point, since sitting in\n                // the cache is a null CacheHolder preventing the session\n                // removing then adding.\n                // also, how long should the null cache holder be placed in\n                // there for ?\n                // I think the solution is to bind the null Cache holder to the\n                // instance of the caching manager that created it,\n                // let the null Cache holder last for 10s, and during that time\n                // only the CachingManagerImpl that created it can remove it.\n            }\n        }\n        LOGGER.debug(\"Saving {} {} {} {} \", new Object[] { keySpace, columnFamily, key, encodedProperties });\n        client.insert(keySpace, columnFamily, key, encodedProperties, probablyNew);\n        if (sharedCache != null) {\n            // if we just added a value in, remove the key so that any stale\n            // state (including a previously deleted object is removed)\n            sharedCache.remove(cacheKey);\n        }\n    }", "language": "java", "Allcodes": "protected void putCached(String keySpace, String columnFamily, String key, Map<String, Object> encodedProperties,\n            boolean probablyNew) throws StorageClientException {\n        String cacheKey = null;\n        if (sharedCache != null) {\n            cacheKey = getCacheKey(keySpace, columnFamily, key);\n        }\n        if (sharedCache != null && !probablyNew) {\n            CacheHolder ch = getFromCacheInternal(cacheKey);\n            if (ch != null && ch.isLocked(this.managerId)) {\n                LOGGER.debug(\"Is Locked {} \", ch);\n                return; // catch the case where another method creates while\n                // something is in the cache.\n                // this is a big assumption since if the item is not in the\n                // cache it will get updated\n                // there is no difference in sparsemap between create and\n                // update, they are all insert operations\n                // what we are really saying here is that inorder to update the\n                // item you have to have just got it\n                // and if you failed to get it, your update must have been a\n                // create operation. As long as the dwell time\n                // in the cache is longer than the lifetime of an active session\n                // then this will be true.\n                // if the lifetime of an active session is longer (like with a\n                // long running background operation)\n                // then you should expect to see race conditions at this point\n                // since the marker in the cache will have\n                // gone, and the marker in the database has gone, so the put\n                // operation, must be a create operation.\n                // To change this behavior we would need to differentiate more\n                // strongly between new and update and change\n                // probablyNew into certainlyNew, but that would probably break\n                // the BASIC assumption of the whole system.\n                // Update 2011-12-06 related to issue 136\n                // I am not certain this code is correct. What happens if the\n                // session wants to remove and then add items.\n                // the session will never get past this point, since sitting in\n                // the cache is a null CacheHolder preventing the session\n                // removing then adding.\n                // also, how long should the null cache holder be placed in\n                // there for ?\n                // I think the solution is to bind the null Cache holder to the\n                // instance of the caching manager that created it,\n                // let the null Cache holder last for 10s, and during that time\n                // only the CachingManagerImpl that created it can remove it.\n            }\n        }\n        LOGGER.debug(\"Saving {} {} {} {} \", new Object[] { keySpace, columnFamily, key, encodedProperties });\n        client.insert(keySpace, columnFamily, key, encodedProperties, probablyNew);\n        if (sharedCache != null) {\n            // if we just added a value in, remove the key so that any stale\n            // state (including a previously deleted object is removed)\n            sharedCache.remove(cacheKey);\n        }\n    }", "code_tokens": ["protected", "void", "putCached", "(", "String", "keySpace", ",", "String", "columnFamily", ",", "String", "key", ",", "Map", "<", "String", ",", "Object", ">", "encodedProperties", ",", "boolean", "probablyNew", ")", "throws", "StorageClientException", "{", "String", "cacheKey", "=", "null", ";", "if", "(", "sharedCache", "!=", "null", ")", "{", "cacheKey", "=", "getCacheKey", "(", "keySpace", ",", "columnFamily", ",", "key", ")", ";", "}", "if", "(", "sharedCache", "!=", "null", "&&", "!", "probablyNew", ")", "{", "CacheHolder", "ch", "=", "getFromCacheInternal", "(", "cacheKey", ")", ";", "if", "(", "ch", "!=", "null", "&&", "ch", ".", "isLocked", "(", "this", ".", "managerId", ")", ")", "{", "LOGGER", ".", "debug", "(", "\"Is Locked {} \"", ",", "ch", ")", ";", "return", ";", "// catch the case where another method creates while", "// something is in the cache.", "// this is a big assumption since if the item is not in the", "// cache it will get updated", "// there is no difference in sparsemap between create and", "// update, they are all insert operations", "// what we are really saying here is that inorder to update the", "// item you have to have just got it", "// and if you failed to get it, your update must have been a", "// create operation. As long as the dwell time", "// in the cache is longer than the lifetime of an active session", "// then this will be true.", "// if the lifetime of an active session is longer (like with a", "// long running background operation)", "// then you should expect to see race conditions at this point", "// since the marker in the cache will have", "// gone, and the marker in the database has gone, so the put", "// operation, must be a create operation.", "// To change this behavior we would need to differentiate more", "// strongly between new and update and change", "// probablyNew into certainlyNew, but that would probably break", "// the BASIC assumption of the whole system.", "// Update 2011-12-06 related to issue 136", "// I am not certain this code is correct. What happens if the", "// session wants to remove and then add items.", "// the session will never get past this point, since sitting in", "// the cache is a null CacheHolder preventing the session", "// removing then adding.", "// also, how long should the null cache holder be placed in", "// there for ?", "// I think the solution is to bind the null Cache holder to the", "// instance of the caching manager that created it,", "// let the null Cache holder last for 10s, and during that time", "// only the CachingManagerImpl that created it can remove it.", "}", "}", "LOGGER", ".", "debug", "(", "\"Saving {} {} {} {} \"", ",", "new", "Object", "[", "]", "{", "keySpace", ",", "columnFamily", ",", "key", ",", "encodedProperties", "}", ")", ";", "client", ".", "insert", "(", "keySpace", ",", "columnFamily", ",", "key", ",", "encodedProperties", ",", "probablyNew", ")", ";", "if", "(", "sharedCache", "!=", "null", ")", "{", "// if we just added a value in, remove the key so that any stale", "// state (including a previously deleted object is removed)", "sharedCache", ".", "remove", "(", "cacheKey", ")", ";", "}", "}"], "docstring": "Put an object in the cache\n\n@param keySpace\n@param columnFamily\n@param key\n@param encodedProperties\nthe object to be stored\n@param probablyNew\nwhether or not this object is new.\n@throws StorageClientException", "docstring_tokens": ["Put", "an", "object", "in", "the", "cache"]}
{"code": "throw new FireRESTException(e);", "comments": "Should not happen", "lines": 8, "repo": "firepick1/firerest-client", "path": "src/main/java/org/firepick/IPv4Scanner.java", "func_name": "IPv4Scanner.scanRange", "original_string": "public static Collection<InetAddress> scanRange(InetAddress addr, int count, int msTimeout) {\n    Collection<InetAddress> addresses = new ArrayList<InetAddress>();\n    Collection<InetAddress> result = new ArrayList<InetAddress>();\n    if (addr == null) {\n      try {\n\taddresses.addAll(localhostNetworkAddresses());\n      } catch (Exception e) {\n\tthrow new FireRESTException(e); // Should not happen\n      }\n    } else {\n      addresses.add(addr);\n    }\n\n    for (InetAddress a: addresses) {\n      if (a instanceof Inet4Address) {\n\tInetAddress start = subnetAddress0(a, 24);\n\tresult.addAll(scanRangeCore(start, count, msTimeout));\n      }\n    }\n\n    return result;\n  }", "language": "java", "Allcodes": "public static Collection<InetAddress> scanRange(InetAddress addr, int count, int msTimeout) {\n    Collection<InetAddress> addresses = new ArrayList<InetAddress>();\n    Collection<InetAddress> result = new ArrayList<InetAddress>();\n    if (addr == null) {\n      try {\n\taddresses.addAll(localhostNetworkAddresses());\n      } catch (Exception e) {\n\tthrow new FireRESTException(e); // Should not happen\n      }\n    } else {\n      addresses.add(addr);\n    }\n\n    for (InetAddress a: addresses) {\n      if (a instanceof Inet4Address) {\n\tInetAddress start = subnetAddress0(a, 24);\n\tresult.addAll(scanRangeCore(start, count, msTimeout));\n      }\n    }\n\n    return result;\n  }", "code_tokens": ["public", "static", "Collection", "<", "InetAddress", ">", "scanRange", "(", "InetAddress", "addr", ",", "int", "count", ",", "int", "msTimeout", ")", "{", "Collection", "<", "InetAddress", ">", "addresses", "=", "new", "ArrayList", "<", "InetAddress", ">", "(", ")", ";", "Collection", "<", "InetAddress", ">", "result", "=", "new", "ArrayList", "<", "InetAddress", ">", "(", ")", ";", "if", "(", "addr", "==", "null", ")", "{", "try", "{", "addresses", ".", "addAll", "(", "localhostNetworkAddresses", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "FireRESTException", "(", "e", ")", ";", "// Should not happen", "}", "}", "else", "{", "addresses", ".", "add", "(", "addr", ")", ";", "}", "for", "(", "InetAddress", "a", ":", "addresses", ")", "{", "if", "(", "a", "instanceof", "Inet4Address", ")", "{", "InetAddress", "start", "=", "subnetAddress0", "(", "a", ",", "24", ")", ";", "result", ".", "addAll", "(", "scanRangeCore", "(", "start", ",", "count", ",", "msTimeout", ")", ")", ";", "}", "}", "return", "result", ";", "}"], "docstring": "Scan a range of InetAddresses starting with the given address\n\n@param start starting address of search; null implies subnetAddress0(null,24)\n@param count number of addresses in range\n@param msTimeout maximum time to wait for each host", "docstring_tokens": ["Scan", "a", "range", "of", "InetAddresses", "starting", "with", "the", "given", "address"]}
{"code": "float sizeForWidth = 1.8f * (imageWidth - padding - padding) / maxLen;", "comments": "should use TextLayout", "lines": 18, "repo": "firepick1/firerest-client", "path": "src/main/java/org/firepick/FireREST.java", "func_name": "FireREST.errorImage", "original_string": "public BufferedImage errorImage(String... lines) {\n    if (imageBuffer == null || imageBuffer.getWidth() != imageWidth || imageBuffer.getHeight() != imageHeight) {\n      imageBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);\n    }\n    Graphics2D g = (Graphics2D) imageBuffer.getGraphics();\n    g.setBackground(new Color(64, 32, 32));\n    g.setColor(new Color(255, 64, 64));\n    g.clearRect(0, 0, imageWidth, imageHeight);\n    int maxLen = 0;\n    for (String line : lines) {\n      if (line != null) {\n        for (String innerLine : line.split(\"\\n\")) {\n          maxLen = Math.max(innerLine.length(), maxLen);\n        }\n      }\n    }\n    int padding = 20;\n    float sizeForWidth = 1.8f * (imageWidth - padding - padding) / maxLen; // should use TextLayout\n    float sizeForHeight = (imageHeight - padding - padding) / lines.length;\n    float lineHeight = Math.min(80, Math.max(12, Math.min(sizeForWidth, sizeForHeight)));\n    float fontSize = 0.8f * lineHeight;\n    Font font = g.getFont().deriveFont(fontSize);\n    g.setFont(font);\n    float y = fontSize + padding;\n    for (String line : lines) {\n      if (line != null) {\n        g.drawString(line, padding, y);\n        y += lineHeight;\n      }\n    }\n    return imageBuffer;\n  }", "language": "java", "Allcodes": "public BufferedImage errorImage(String... lines) {\n    if (imageBuffer == null || imageBuffer.getWidth() != imageWidth || imageBuffer.getHeight() != imageHeight) {\n      imageBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);\n    }\n    Graphics2D g = (Graphics2D) imageBuffer.getGraphics();\n    g.setBackground(new Color(64, 32, 32));\n    g.setColor(new Color(255, 64, 64));\n    g.clearRect(0, 0, imageWidth, imageHeight);\n    int maxLen = 0;\n    for (String line : lines) {\n      if (line != null) {\n        for (String innerLine : line.split(\"\\n\")) {\n          maxLen = Math.max(innerLine.length(), maxLen);\n        }\n      }\n    }\n    int padding = 20;\n    float sizeForWidth = 1.8f * (imageWidth - padding - padding) / maxLen; // should use TextLayout\n    float sizeForHeight = (imageHeight - padding - padding) / lines.length;\n    float lineHeight = Math.min(80, Math.max(12, Math.min(sizeForWidth, sizeForHeight)));\n    float fontSize = 0.8f * lineHeight;\n    Font font = g.getFont().deriveFont(fontSize);\n    g.setFont(font);\n    float y = fontSize + padding;\n    for (String line : lines) {\n      if (line != null) {\n        g.drawString(line, padding, y);\n        y += lineHeight;\n      }\n    }\n    return imageBuffer;\n  }", "code_tokens": ["public", "BufferedImage", "errorImage", "(", "String", "...", "lines", ")", "{", "if", "(", "imageBuffer", "==", "null", "||", "imageBuffer", ".", "getWidth", "(", ")", "!=", "imageWidth", "||", "imageBuffer", ".", "getHeight", "(", ")", "!=", "imageHeight", ")", "{", "imageBuffer", "=", "new", "BufferedImage", "(", "imageWidth", ",", "imageHeight", ",", "BufferedImage", ".", "TYPE_INT_RGB", ")", ";", "}", "Graphics2D", "g", "=", "(", "Graphics2D", ")", "imageBuffer", ".", "getGraphics", "(", ")", ";", "g", ".", "setBackground", "(", "new", "Color", "(", "64", ",", "32", ",", "32", ")", ")", ";", "g", ".", "setColor", "(", "new", "Color", "(", "255", ",", "64", ",", "64", ")", ")", ";", "g", ".", "clearRect", "(", "0", ",", "0", ",", "imageWidth", ",", "imageHeight", ")", ";", "int", "maxLen", "=", "0", ";", "for", "(", "String", "line", ":", "lines", ")", "{", "if", "(", "line", "!=", "null", ")", "{", "for", "(", "String", "innerLine", ":", "line", ".", "split", "(", "\"\\n\"", ")", ")", "{", "maxLen", "=", "Math", ".", "max", "(", "innerLine", ".", "length", "(", ")", ",", "maxLen", ")", ";", "}", "}", "}", "int", "padding", "=", "20", ";", "float", "sizeForWidth", "=", "1.8f", "*", "(", "imageWidth", "-", "padding", "-", "padding", ")", "/", "maxLen", ";", "// should use TextLayout", "float", "sizeForHeight", "=", "(", "imageHeight", "-", "padding", "-", "padding", ")", "/", "lines", ".", "length", ";", "float", "lineHeight", "=", "Math", ".", "min", "(", "80", ",", "Math", ".", "max", "(", "12", ",", "Math", ".", "min", "(", "sizeForWidth", ",", "sizeForHeight", ")", ")", ")", ";", "float", "fontSize", "=", "0.8f", "*", "lineHeight", ";", "Font", "font", "=", "g", ".", "getFont", "(", ")", ".", "deriveFont", "(", "fontSize", ")", ";", "g", ".", "setFont", "(", "font", ")", ";", "float", "y", "=", "fontSize", "+", "padding", ";", "for", "(", "String", "line", ":", "lines", ")", "{", "if", "(", "line", "!=", "null", ")", "{", "g", ".", "drawString", "(", "line", ",", "padding", ",", "y", ")", ";", "y", "+=", "lineHeight", ";", "}", "}", "return", "imageBuffer", ";", "}"], "docstring": "Return an red image with the given text auto-sized to fit the current imageWidthximageHeight\n\n@param lines one or more lines of text\n@return image", "docstring_tokens": ["Return", "an", "red", "image", "with", "the", "given", "text", "auto", "-", "sized", "to", "fit", "the", "current", "imageWidthximageHeight"]}
{"code": "event = blockingQueueHandling();", "comments": "gets the new Event if one was added to the blockingQueue", "lines": 6, "repo": "intellimate/IzouSDK", "path": "src/main/java/org/intellimate/izou/sdk/output/OutputPluginArgument.java", "func_name": "OutputPluginArgument.run", "original_string": "@Override\n    public void run() {\n        while (!stop) {\n            EventModel event;\n            try {\n                event = blockingQueueHandling();  //gets the new Event if one was added to the blockingQueue\n            } catch (InterruptedException e) {\n                getContext().getLogger().warn(e);\n                continue;\n            }\n\n            List<CompletableFuture<X>> outputExtensions = getContext().getOutput()\n                    .generateAllOutputExtensions(this, getArgument(), event);\n\n            try {\n                outputExtensions = timeOut(outputExtensions, getTimeoutLimit());\n            } catch (InterruptedException e) {\n                getContext().getLogger().warn(e);\n            }\n\n            handleFutures(outputExtensions, event);\n\n            //notifies output-manager when done processing\n            isDone(event);\n        }\n    }", "language": "java", "Allcodes": "@Override\n    public void run() {\n        while (!stop) {\n            EventModel event;\n            try {\n                event = blockingQueueHandling();  //gets the new Event if one was added to the blockingQueue\n            } catch (InterruptedException e) {\n                getContext().getLogger().warn(e);\n                continue;\n            }\n\n            List<CompletableFuture<X>> outputExtensions = getContext().getOutput()\n                    .generateAllOutputExtensions(this, getArgument(), event);\n\n            try {\n                outputExtensions = timeOut(outputExtensions, getTimeoutLimit());\n            } catch (InterruptedException e) {\n                getContext().getLogger().warn(e);\n            }\n\n            handleFutures(outputExtensions, event);\n\n            //notifies output-manager when done processing\n            isDone(event);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "run", "(", ")", "{", "while", "(", "!", "stop", ")", "{", "EventModel", "event", ";", "try", "{", "event", "=", "blockingQueueHandling", "(", ")", ";", "//gets the new Event if one was added to the blockingQueue", "}", "catch", "(", "InterruptedException", "e", ")", "{", "getContext", "(", ")", ".", "getLogger", "(", ")", ".", "warn", "(", "e", ")", ";", "continue", ";", "}", "List", "<", "CompletableFuture", "<", "X", ">", ">", "outputExtensions", "=", "getContext", "(", ")", ".", "getOutput", "(", ")", ".", "generateAllOutputExtensions", "(", "this", ",", "getArgument", "(", ")", ",", "event", ")", ";", "try", "{", "outputExtensions", "=", "timeOut", "(", "outputExtensions", ",", "getTimeoutLimit", "(", ")", ")", ";", "}", "catch", "(", "InterruptedException", "e", ")", "{", "getContext", "(", ")", ".", "getLogger", "(", ")", ".", "warn", "(", "e", ")", ";", "}", "handleFutures", "(", "outputExtensions", ",", "event", ")", ";", "//notifies output-manager when done processing", "isDone", "(", "event", ")", ";", "}", "}"], "docstring": "main method for outputPlugin, runs the data-conversion and output-renderer\n\nit will instruct the outputManager to let the outputExtensions generate the data. Wait for the time specified\nin getTimeoutLimit() (standard is 1000 milliseconds) abd the call renderFinalOutput() with the resulting data.", "docstring_tokens": ["main", "method", "for", "outputPlugin", "runs", "the", "data", "-", "conversion", "and", "output", "-", "renderer"]}
{"code": "HashEntry entry = data[hashIndex(hashCode, data.length)];", "comments": "no local", "lines": 3, "repo": "abmargb/jamppa", "path": "src/main/java/org/jivesoftware/smack/util/collections/AbstractHashedMap.java", "func_name": "AbstractHashedMap.containsKey", "original_string": "public boolean containsKey(Object key) {\n        int hashCode = hash((key == null) ? NULL : key);\n        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local\n                                                                  // for hash\n                                                                  // index\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(key, entry.getKey())) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }", "language": "java", "Allcodes": "public boolean containsKey(Object key) {\n        int hashCode = hash((key == null) ? NULL : key);\n        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local\n                                                                  // for hash\n                                                                  // index\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(key, entry.getKey())) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }", "code_tokens": ["public", "boolean", "containsKey", "(", "Object", "key", ")", "{", "int", "hashCode", "=", "hash", "(", "(", "key", "==", "null", ")", "?", "NULL", ":", "key", ")", ";", "HashEntry", "entry", "=", "data", "[", "hashIndex", "(", "hashCode", ",", "data", ".", "length", ")", "]", ";", "// no local", "// for hash", "// index", "while", "(", "entry", "!=", "null", ")", "{", "if", "(", "entry", ".", "hashCode", "==", "hashCode", "&&", "isEqualKey", "(", "key", ",", "entry", ".", "getKey", "(", ")", ")", ")", "{", "return", "true", ";", "}", "entry", "=", "entry", ".", "next", ";", "}", "return", "false", ";", "}"], "docstring": "Checks whether the map contains the specified key.\n\n@param key\nthe key to search for\n@return true if the map contains the key", "docstring_tokens": ["Checks", "whether", "the", "map", "contains", "the", "specified", "key", "."]}
{"code": "oldEntries[i] = null;", "comments": "gc", "lines": 17, "repo": "abmargb/jamppa", "path": "src/main/java/org/jivesoftware/smack/util/collections/AbstractHashedMap.java", "func_name": "AbstractHashedMap.ensureCapacity", "original_string": "protected void ensureCapacity(int newCapacity) {\n        int oldCapacity = data.length;\n        if (newCapacity <= oldCapacity) {\n            return;\n        }\n        if (size == 0) {\n            threshold = calculateThreshold(newCapacity, loadFactor);\n            data = new HashEntry[newCapacity];\n        } else {\n            HashEntry<K, V> oldEntries[] = data;\n            HashEntry<K, V> newEntries[] = new HashEntry[newCapacity];\n\n            modCount++;\n            for (int i = oldCapacity - 1; i >= 0; i--) {\n                HashEntry<K, V> entry = oldEntries[i];\n                if (entry != null) {\n                    oldEntries[i] = null; // gc\n                    do {\n                        HashEntry<K, V> next = entry.next;\n                        int index = hashIndex(entry.hashCode, newCapacity);\n                        entry.next = newEntries[index];\n                        newEntries[index] = entry;\n                        entry = next;\n                    } while (entry != null);\n                }\n            }\n            threshold = calculateThreshold(newCapacity, loadFactor);\n            data = newEntries;\n        }\n    }", "language": "java", "Allcodes": "protected void ensureCapacity(int newCapacity) {\n        int oldCapacity = data.length;\n        if (newCapacity <= oldCapacity) {\n            return;\n        }\n        if (size == 0) {\n            threshold = calculateThreshold(newCapacity, loadFactor);\n            data = new HashEntry[newCapacity];\n        } else {\n            HashEntry<K, V> oldEntries[] = data;\n            HashEntry<K, V> newEntries[] = new HashEntry[newCapacity];\n\n            modCount++;\n            for (int i = oldCapacity - 1; i >= 0; i--) {\n                HashEntry<K, V> entry = oldEntries[i];\n                if (entry != null) {\n                    oldEntries[i] = null; // gc\n                    do {\n                        HashEntry<K, V> next = entry.next;\n                        int index = hashIndex(entry.hashCode, newCapacity);\n                        entry.next = newEntries[index];\n                        newEntries[index] = entry;\n                        entry = next;\n                    } while (entry != null);\n                }\n            }\n            threshold = calculateThreshold(newCapacity, loadFactor);\n            data = newEntries;\n        }\n    }", "code_tokens": ["protected", "void", "ensureCapacity", "(", "int", "newCapacity", ")", "{", "int", "oldCapacity", "=", "data", ".", "length", ";", "if", "(", "newCapacity", "<=", "oldCapacity", ")", "{", "return", ";", "}", "if", "(", "size", "==", "0", ")", "{", "threshold", "=", "calculateThreshold", "(", "newCapacity", ",", "loadFactor", ")", ";", "data", "=", "new", "HashEntry", "[", "newCapacity", "]", ";", "}", "else", "{", "HashEntry", "<", "K", ",", "V", ">", "oldEntries", "[", "]", "=", "data", ";", "HashEntry", "<", "K", ",", "V", ">", "newEntries", "[", "]", "=", "new", "HashEntry", "[", "newCapacity", "]", ";", "modCount", "++", ";", "for", "(", "int", "i", "=", "oldCapacity", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "HashEntry", "<", "K", ",", "V", ">", "entry", "=", "oldEntries", "[", "i", "]", ";", "if", "(", "entry", "!=", "null", ")", "{", "oldEntries", "[", "i", "]", "=", "null", ";", "// gc", "do", "{", "HashEntry", "<", "K", ",", "V", ">", "next", "=", "entry", ".", "next", ";", "int", "index", "=", "hashIndex", "(", "entry", ".", "hashCode", ",", "newCapacity", ")", ";", "entry", ".", "next", "=", "newEntries", "[", "index", "]", ";", "newEntries", "[", "index", "]", "=", "entry", ";", "entry", "=", "next", ";", "}", "while", "(", "entry", "!=", "null", ")", ";", "}", "}", "threshold", "=", "calculateThreshold", "(", "newCapacity", ",", "loadFactor", ")", ";", "data", "=", "newEntries", ";", "}", "}"], "docstring": "Changes the size of the data structure to the capacity proposed.\n\n@param newCapacity\nthe new capacity of the array (a power of two, less or equal\nto max)", "docstring_tokens": ["Changes", "the", "size", "of", "the", "data", "structure", "to", "the", "capacity", "proposed", "."]}
{"code": "newCapacity <<= 1;", "comments": "multiply by two", "lines": 7, "repo": "abmargb/jamppa", "path": "src/main/java/org/jivesoftware/smack/util/collections/AbstractHashedMap.java", "func_name": "AbstractHashedMap.calculateNewCapacity", "original_string": "protected int calculateNewCapacity(int proposedCapacity) {\n        int newCapacity = 1;\n        if (proposedCapacity > MAXIMUM_CAPACITY) {\n            newCapacity = MAXIMUM_CAPACITY;\n        } else {\n            while (newCapacity < proposedCapacity) {\n                newCapacity <<= 1; // multiply by two\n            }\n            if (newCapacity > MAXIMUM_CAPACITY) {\n                newCapacity = MAXIMUM_CAPACITY;\n            }\n        }\n        return newCapacity;\n    }", "language": "java", "Allcodes": "protected int calculateNewCapacity(int proposedCapacity) {\n        int newCapacity = 1;\n        if (proposedCapacity > MAXIMUM_CAPACITY) {\n            newCapacity = MAXIMUM_CAPACITY;\n        } else {\n            while (newCapacity < proposedCapacity) {\n                newCapacity <<= 1; // multiply by two\n            }\n            if (newCapacity > MAXIMUM_CAPACITY) {\n                newCapacity = MAXIMUM_CAPACITY;\n            }\n        }\n        return newCapacity;\n    }", "code_tokens": ["protected", "int", "calculateNewCapacity", "(", "int", "proposedCapacity", ")", "{", "int", "newCapacity", "=", "1", ";", "if", "(", "proposedCapacity", ">", "MAXIMUM_CAPACITY", ")", "{", "newCapacity", "=", "MAXIMUM_CAPACITY", ";", "}", "else", "{", "while", "(", "newCapacity", "<", "proposedCapacity", ")", "{", "newCapacity", "<<=", "1", ";", "// multiply by two", "}", "if", "(", "newCapacity", ">", "MAXIMUM_CAPACITY", ")", "{", "newCapacity", "=", "MAXIMUM_CAPACITY", ";", "}", "}", "return", "newCapacity", ";", "}"], "docstring": "Calculates the new capacity of the map. This implementation normalizes\nthe capacity to a power of two.\n\n@param proposedCapacity\nthe proposed capacity\n@return the normalized new capacity", "docstring_tokens": ["Calculates", "the", "new", "capacity", "of", "the", "map", ".", "This", "implementation", "normalizes", "the", "capacity", "to", "a", "power", "of", "two", "."]}
