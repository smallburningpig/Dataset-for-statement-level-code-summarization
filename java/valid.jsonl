{"code": "return 0;", "comments": "Not called.", "lines": 59, "repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.read", "original_string": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "code_tokens": ["@", "Override", "public", "int", "read", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Obey InputStream contract.", "checkPositionIndexes", "(", "off", ",", "off", "+", "len", ",", "b", ".", "length", ")", ";", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "// The rest of this method implements the process described by the CharsetEncoder javadoc.", "int", "totalBytesRead", "=", "0", ";", "boolean", "doneEncoding", "=", "endOfInput", ";", "DRAINING", ":", "while", "(", "true", ")", "{", "// We stay in draining mode until there are no bytes left in the output buffer. Then we go", "// back to encoding/flushing.", "if", "(", "draining", ")", "{", "totalBytesRead", "+=", "drain", "(", "b", ",", "off", "+", "totalBytesRead", ",", "len", "-", "totalBytesRead", ")", ";", "if", "(", "totalBytesRead", "==", "len", "||", "doneFlushing", ")", "{", "return", "(", "totalBytesRead", ">", "0", ")", "?", "totalBytesRead", ":", "-", "1", ";", "}", "draining", "=", "false", ";", "byteBuffer", ".", "clear", "(", ")", ";", "}", "while", "(", "true", ")", "{", "// We call encode until there is no more input. The last call to encode will have endOfInput", "// == true. Then there is a final call to flush.", "CoderResult", "result", ";", "if", "(", "doneFlushing", ")", "{", "result", "=", "CoderResult", ".", "UNDERFLOW", ";", "}", "else", "if", "(", "doneEncoding", ")", "{", "result", "=", "encoder", ".", "flush", "(", "byteBuffer", ")", ";", "}", "else", "{", "result", "=", "encoder", ".", "encode", "(", "charBuffer", ",", "byteBuffer", ",", "endOfInput", ")", ";", "}", "if", "(", "result", ".", "isOverflow", "(", ")", ")", "{", "// Not enough room in output buffer--drain it, creating a bigger buffer if necessary.", "startDraining", "(", "true", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "result", ".", "isUnderflow", "(", ")", ")", "{", "// If encoder underflows, it means either:", "// a) the final flush() succeeded; next drain (then done)", "// b) we encoded all of the input; next flush", "// c) we ran of out input to encode; next read more input", "if", "(", "doneEncoding", ")", "{", "// (a)", "doneFlushing", "=", "true", ";", "startDraining", "(", "false", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "endOfInput", ")", "{", "// (b)", "doneEncoding", "=", "true", ";", "}", "else", "{", "// (c)", "readMoreChars", "(", ")", ";", "}", "}", "else", "if", "(", "result", ".", "isError", "(", ")", ")", "{", "// Only reach here if a CharsetEncoder with non-REPLACE settings is used.", "result", ".", "throwException", "(", ")", ";", "return", "0", ";", "// Not called.", "}", "}", "}", "}"], "docstring": "buffer when possible.", "docstring_tokens": ["buffer", "when", "possible", "."]}
{"code": "out.flush();", "comments": "https://code.google.com/p/guava-libraries/issues/detail?id=1330", "lines": 8, "repo": "google/guava", "path": "android/guava/src/com/google/common/io/ByteSink.java", "func_name": "ByteSink.write", "original_string": "public void write(byte[] bytes) throws IOException {\n    checkNotNull(bytes);\n\n    Closer closer = Closer.create();\n    try {\n      OutputStream out = closer.register(openStream());\n      out.write(bytes);\n      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "Allcodes": "public void write(byte[] bytes) throws IOException {\n    checkNotNull(bytes);\n\n    Closer closer = Closer.create();\n    try {\n      OutputStream out = closer.register(openStream());\n      out.write(bytes);\n      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "void", "write", "(", "byte", "[", "]", "bytes", ")", "throws", "IOException", "{", "checkNotNull", "(", "bytes", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "OutputStream", "out", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "out", ".", "write", "(", "bytes", ")", ";", "out", ".", "flush", "(", ")", ";", "// https://code.google.com/p/guava-libraries/issues/detail?id=1330", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Writes all the given bytes to this sink.\n\n@throws IOException if an I/O occurs while writing to this sink", "docstring_tokens": ["Writes", "all", "the", "given", "bytes", "to", "this", "sink", "."]}
{"code": "throw new AssertionError(e);", "comments": "programmer error", "lines": 6, "repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.getFieldSetter", "original_string": "static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName) {\n    try {\n      Field field = clazz.getDeclaredField(fieldName);\n      return new FieldSetter<T>(field);\n    } catch (NoSuchFieldException e) {\n      throw new AssertionError(e); // programmer error\n    }\n  }", "language": "java", "Allcodes": "static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName) {\n    try {\n      Field field = clazz.getDeclaredField(fieldName);\n      return new FieldSetter<T>(field);\n    } catch (NoSuchFieldException e) {\n      throw new AssertionError(e); // programmer error\n    }\n  }", "code_tokens": ["static", "<", "T", ">", "FieldSetter", "<", "T", ">", "getFieldSetter", "(", "final", "Class", "<", "T", ">", "clazz", ",", "String", "fieldName", ")", "{", "try", "{", "Field", "field", "=", "clazz", ".", "getDeclaredField", "(", "fieldName", ")", ";", "return", "new", "FieldSetter", "<", "T", ">", "(", "field", ")", ";", "}", "catch", "(", "NoSuchFieldException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "// programmer error", "}", "}"], "docstring": "Secret sauce for setting final fields; don't make it public.", "docstring_tokens": ["Secret", "sauce", "for", "setting", "final", "fields", ";", "don", "t", "make", "it", "public", "."]}
{"code": "p.next = null;", "comments": "help GC", "lines": 13, "repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.endWaitingFor", "original_string": "@GuardedBy(\"lock\")\n  private void endWaitingFor(Guard guard) {\n    int waiters = --guard.waiterCount;\n    if (waiters == 0) {\n      // unlink guard from activeGuards\n      for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\n        if (p == guard) {\n          if (pred == null) {\n            activeGuards = p.next;\n          } else {\n            pred.next = p.next;\n          }\n          p.next = null; // help GC\n          break;\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "@GuardedBy(\"lock\")\n  private void endWaitingFor(Guard guard) {\n    int waiters = --guard.waiterCount;\n    if (waiters == 0) {\n      // unlink guard from activeGuards\n      for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\n        if (p == guard) {\n          if (pred == null) {\n            activeGuards = p.next;\n          } else {\n            pred.next = p.next;\n          }\n          p.next = null; // help GC\n          break;\n        }\n      }\n    }\n  }", "code_tokens": ["@", "GuardedBy", "(", "\"lock\"", ")", "private", "void", "endWaitingFor", "(", "Guard", "guard", ")", "{", "int", "waiters", "=", "--", "guard", ".", "waiterCount", ";", "if", "(", "waiters", "==", "0", ")", "{", "// unlink guard from activeGuards", "for", "(", "Guard", "p", "=", "activeGuards", ",", "pred", "=", "null", ";", ";", "pred", "=", "p", ",", "p", "=", "p", ".", "next", ")", "{", "if", "(", "p", "==", "guard", ")", "{", "if", "(", "pred", "==", "null", ")", "{", "activeGuards", "=", "p", ".", "next", ";", "}", "else", "{", "pred", ".", "next", "=", "p", ".", "next", ";", "}", "p", ".", "next", "=", "null", ";", "// help GC", "break", ";", "}", "}", "}", "}"], "docstring": "Records that the current thread is no longer waiting on the specified guard.", "docstring_tokens": ["Records", "that", "the", "current", "thread", "is", "no", "longer", "waiting", "on", "the", "specified", "guard", "."]}
{"code": "runnables = null;", "comments": "allow GC to free listeners even if this stays around for a while.", "lines": 11, "repo": "google/guava", "path": "guava/src/com/google/common/util/concurrent/ExecutionList.java", "func_name": "ExecutionList.execute", "original_string": "public void execute() {\n    // Lock while we update our state so the add method above will finish adding any listeners\n    // before we start to run them.\n    RunnableExecutorPair list;\n    synchronized (this) {\n      if (executed) {\n        return;\n      }\n      executed = true;\n      list = runnables;\n      runnables = null; // allow GC to free listeners even if this stays around for a while.\n    }\n    // If we succeeded then list holds all the runnables we to execute. The pairs in the stack are\n    // in the opposite order from how they were added so we need to reverse the list to fulfill our\n    // contract.\n    // This is somewhat annoying, but turns out to be very fast in practice. Alternatively, we could\n    // drop the contract on the method that enforces this queue like behavior since depending on it\n    // is likely to be a bug anyway.\n\n    // N.B. All writes to the list and the next pointers must have happened before the above\n    // synchronized block, so we can iterate the list without the lock held here.\n    RunnableExecutorPair reversedList = null;\n    while (list != null) {\n      RunnableExecutorPair tmp = list;\n      list = list.next;\n      tmp.next = reversedList;\n      reversedList = tmp;\n    }\n    while (reversedList != null) {\n      executeListener(reversedList.runnable, reversedList.executor);\n      reversedList = reversedList.next;\n    }\n  }", "language": "java", "Allcodes": "public void execute() {\n    // Lock while we update our state so the add method above will finish adding any listeners\n    // before we start to run them.\n    RunnableExecutorPair list;\n    synchronized (this) {\n      if (executed) {\n        return;\n      }\n      executed = true;\n      list = runnables;\n      runnables = null; // allow GC to free listeners even if this stays around for a while.\n    }\n    // If we succeeded then list holds all the runnables we to execute. The pairs in the stack are\n    // in the opposite order from how they were added so we need to reverse the list to fulfill our\n    // contract.\n    // This is somewhat annoying, but turns out to be very fast in practice. Alternatively, we could\n    // drop the contract on the method that enforces this queue like behavior since depending on it\n    // is likely to be a bug anyway.\n\n    // N.B. All writes to the list and the next pointers must have happened before the above\n    // synchronized block, so we can iterate the list without the lock held here.\n    RunnableExecutorPair reversedList = null;\n    while (list != null) {\n      RunnableExecutorPair tmp = list;\n      list = list.next;\n      tmp.next = reversedList;\n      reversedList = tmp;\n    }\n    while (reversedList != null) {\n      executeListener(reversedList.runnable, reversedList.executor);\n      reversedList = reversedList.next;\n    }\n  }", "code_tokens": ["public", "void", "execute", "(", ")", "{", "// Lock while we update our state so the add method above will finish adding any listeners", "// before we start to run them.", "RunnableExecutorPair", "list", ";", "synchronized", "(", "this", ")", "{", "if", "(", "executed", ")", "{", "return", ";", "}", "executed", "=", "true", ";", "list", "=", "runnables", ";", "runnables", "=", "null", ";", "// allow GC to free listeners even if this stays around for a while.", "}", "// If we succeeded then list holds all the runnables we to execute. The pairs in the stack are", "// in the opposite order from how they were added so we need to reverse the list to fulfill our", "// contract.", "// This is somewhat annoying, but turns out to be very fast in practice. Alternatively, we could", "// drop the contract on the method that enforces this queue like behavior since depending on it", "// is likely to be a bug anyway.", "// N.B. All writes to the list and the next pointers must have happened before the above", "// synchronized block, so we can iterate the list without the lock held here.", "RunnableExecutorPair", "reversedList", "=", "null", ";", "while", "(", "list", "!=", "null", ")", "{", "RunnableExecutorPair", "tmp", "=", "list", ";", "list", "=", "list", ".", "next", ";", "tmp", ".", "next", "=", "reversedList", ";", "reversedList", "=", "tmp", ";", "}", "while", "(", "reversedList", "!=", "null", ")", "{", "executeListener", "(", "reversedList", ".", "runnable", ",", "reversedList", ".", "executor", ")", ";", "reversedList", "=", "reversedList", ".", "next", ";", "}", "}"], "docstring": "Runs this execution list, executing all existing pairs in the order they were added. However,\nnote that listeners added after this point may be executed before those previously added, and\nnote that the execution order of all listeners is ultimately chosen by the implementations of\nthe supplied executors.\n\n<p>This method is idempotent. Calling it several times in parallel is semantically equivalent\nto calling it exactly once.\n\n@since 10.0 (present in 1.0 as {@code run})", "docstring_tokens": ["Runs", "this", "execution", "list", "executing", "all", "existing", "pairs", "in", "the", "order", "they", "were", "added", ".", "However", "note", "that", "listeners", "added", "after", "this", "point", "may", "be", "executed", "before", "those", "previously", "added", "and", "note", "that", "the", "execution", "order", "of", "all", "listeners", "is", "ultimately", "chosen", "by", "the", "implementations", "of", "the", "supplied", "executors", "."]}
{"code": "checkNotNull(string);", "comments": "GWT specific check (do not optimize)", "lines": 3, "repo": "google/guava", "path": "android/guava/src/com/google/common/escape/CharEscaper.java", "func_name": "CharEscaper.escape", "original_string": "@Override\n  public String escape(String string) {\n    checkNotNull(string); // GWT specific check (do not optimize)\n    // Inlineable fast-path loop which hands off to escapeSlow() only if needed\n    int length = string.length();\n    for (int index = 0; index < length; index++) {\n      if (escape(string.charAt(index)) != null) {\n        return escapeSlow(string, index);\n      }\n    }\n    return string;\n  }", "language": "java", "Allcodes": "@Override\n  public String escape(String string) {\n    checkNotNull(string); // GWT specific check (do not optimize)\n    // Inlineable fast-path loop which hands off to escapeSlow() only if needed\n    int length = string.length();\n    for (int index = 0; index < length; index++) {\n      if (escape(string.charAt(index)) != null) {\n        return escapeSlow(string, index);\n      }\n    }\n    return string;\n  }", "code_tokens": ["@", "Override", "public", "String", "escape", "(", "String", "string", ")", "{", "checkNotNull", "(", "string", ")", ";", "// GWT specific check (do not optimize)", "// Inlineable fast-path loop which hands off to escapeSlow() only if needed", "int", "length", "=", "string", ".", "length", "(", ")", ";", "for", "(", "int", "index", "=", "0", ";", "index", "<", "length", ";", "index", "++", ")", "{", "if", "(", "escape", "(", "string", ".", "charAt", "(", "index", ")", ")", "!=", "null", ")", "{", "return", "escapeSlow", "(", "string", ",", "index", ")", ";", "}", "}", "return", "string", ";", "}"], "docstring": "Returns the escaped form of a given literal string.\n\n@param string the literal string to be escaped\n@return the escaped form of {@code string}\n@throws NullPointerException if {@code string} is null", "docstring_tokens": ["Returns", "the", "escaped", "form", "of", "a", "given", "literal", "string", "."]}
{"code": "String styleableName = null;", "comments": "Current styleable name", "lines": 4, "repo": "robolectric/robolectric", "path": "resources/src/main/java/org/robolectric/res/ResourceTableFactory.java", "func_name": "ResourceTableFactory.addMissingStyleableAttributes", "original_string": "private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {\n    for (Class innerClass : rClass.getClasses()) {\n      if (innerClass.getSimpleName().equals(\"styleable\")) {\n        String styleableName = null; // Current styleable name\n        int[] styleableArray = null; // Current styleable value array or references\n        for (Field field : innerClass.getDeclaredFields()) {\n          if (field.getType().equals(int[].class) && Modifier.isStatic(field.getModifiers())) {\n            styleableName = field.getName();\n            try {\n              styleableArray = (int[]) (field.get(null));\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          } else if (field.getType().equals(Integer.TYPE) && Modifier.isStatic(field.getModifiers())) {\n            String attributeName = field.getName().substring(styleableName.length() + 1);\n            try {\n              int styleableIndex = field.getInt(null);\n              int attributeResId = styleableArray[styleableIndex];\n              resourceTable.addResource(attributeResId, \"attr\", attributeName);\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {\n    for (Class innerClass : rClass.getClasses()) {\n      if (innerClass.getSimpleName().equals(\"styleable\")) {\n        String styleableName = null; // Current styleable name\n        int[] styleableArray = null; // Current styleable value array or references\n        for (Field field : innerClass.getDeclaredFields()) {\n          if (field.getType().equals(int[].class) && Modifier.isStatic(field.getModifiers())) {\n            styleableName = field.getName();\n            try {\n              styleableArray = (int[]) (field.get(null));\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          } else if (field.getType().equals(Integer.TYPE) && Modifier.isStatic(field.getModifiers())) {\n            String attributeName = field.getName().substring(styleableName.length() + 1);\n            try {\n              int styleableIndex = field.getInt(null);\n              int attributeResId = styleableArray[styleableIndex];\n              resourceTable.addResource(attributeResId, \"attr\", attributeName);\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      }\n    }\n  }", "code_tokens": ["private", "void", "addMissingStyleableAttributes", "(", "PackageResourceTable", "resourceTable", ",", "Class", "<", "?", ">", "rClass", ")", "{", "for", "(", "Class", "innerClass", ":", "rClass", ".", "getClasses", "(", ")", ")", "{", "if", "(", "innerClass", ".", "getSimpleName", "(", ")", ".", "equals", "(", "\"styleable\"", ")", ")", "{", "String", "styleableName", "=", "null", ";", "// Current styleable name", "int", "[", "]", "styleableArray", "=", "null", ";", "// Current styleable value array or references", "for", "(", "Field", "field", ":", "innerClass", ".", "getDeclaredFields", "(", ")", ")", "{", "if", "(", "field", ".", "getType", "(", ")", ".", "equals", "(", "int", "[", "]", ".", "class", ")", "&&", "Modifier", ".", "isStatic", "(", "field", ".", "getModifiers", "(", ")", ")", ")", "{", "styleableName", "=", "field", ".", "getName", "(", ")", ";", "try", "{", "styleableArray", "=", "(", "int", "[", "]", ")", "(", "field", ".", "get", "(", "null", ")", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "else", "if", "(", "field", ".", "getType", "(", ")", ".", "equals", "(", "Integer", ".", "TYPE", ")", "&&", "Modifier", ".", "isStatic", "(", "field", ".", "getModifiers", "(", ")", ")", ")", "{", "String", "attributeName", "=", "field", ".", "getName", "(", ")", ".", "substring", "(", "styleableName", ".", "length", "(", ")", "+", "1", ")", ";", "try", "{", "int", "styleableIndex", "=", "field", ".", "getInt", "(", "null", ")", ";", "int", "attributeResId", "=", "styleableArray", "[", "styleableIndex", "]", ";", "resourceTable", ".", "addResource", "(", "attributeResId", ",", "\"attr\"", ",", "attributeName", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "}", "}", "}", "}"], "docstring": "Check the stylable elements. Not for aapt generated R files but for framework R files it is possible to\nhave attributes in the styleable array for which there is no corresponding R.attr field.", "docstring_tokens": ["Check", "the", "stylable", "elements", ".", "Not", "for", "aapt", "generated", "R", "files", "but", "for", "framework", "R", "files", "it", "is", "possible", "to", "have", "attributes", "in", "the", "styleable", "array", "for", "which", "there", "is", "no", "corresponding", "R", ".", "attr", "field", "."]}
{"code": "int[] styleableArray = null;", "comments": "Current styleable value array or references", "lines": 5, "repo": "robolectric/robolectric", "path": "resources/src/main/java/org/robolectric/res/ResourceTableFactory.java", "func_name": "ResourceTableFactory.addMissingStyleableAttributes", "original_string": "private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {\n    for (Class innerClass : rClass.getClasses()) {\n      if (innerClass.getSimpleName().equals(\"styleable\")) {\n        String styleableName = null; // Current styleable name\n        int[] styleableArray = null; // Current styleable value array or references\n        for (Field field : innerClass.getDeclaredFields()) {\n          if (field.getType().equals(int[].class) && Modifier.isStatic(field.getModifiers())) {\n            styleableName = field.getName();\n            try {\n              styleableArray = (int[]) (field.get(null));\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          } else if (field.getType().equals(Integer.TYPE) && Modifier.isStatic(field.getModifiers())) {\n            String attributeName = field.getName().substring(styleableName.length() + 1);\n            try {\n              int styleableIndex = field.getInt(null);\n              int attributeResId = styleableArray[styleableIndex];\n              resourceTable.addResource(attributeResId, \"attr\", attributeName);\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      }\n    }\n  }", "language": "java", "Allcodes": "private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {\n    for (Class innerClass : rClass.getClasses()) {\n      if (innerClass.getSimpleName().equals(\"styleable\")) {\n        String styleableName = null; // Current styleable name\n        int[] styleableArray = null; // Current styleable value array or references\n        for (Field field : innerClass.getDeclaredFields()) {\n          if (field.getType().equals(int[].class) && Modifier.isStatic(field.getModifiers())) {\n            styleableName = field.getName();\n            try {\n              styleableArray = (int[]) (field.get(null));\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          } else if (field.getType().equals(Integer.TYPE) && Modifier.isStatic(field.getModifiers())) {\n            String attributeName = field.getName().substring(styleableName.length() + 1);\n            try {\n              int styleableIndex = field.getInt(null);\n              int attributeResId = styleableArray[styleableIndex];\n              resourceTable.addResource(attributeResId, \"attr\", attributeName);\n            } catch (IllegalAccessException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      }\n    }\n  }", "code_tokens": ["private", "void", "addMissingStyleableAttributes", "(", "PackageResourceTable", "resourceTable", ",", "Class", "<", "?", ">", "rClass", ")", "{", "for", "(", "Class", "innerClass", ":", "rClass", ".", "getClasses", "(", ")", ")", "{", "if", "(", "innerClass", ".", "getSimpleName", "(", ")", ".", "equals", "(", "\"styleable\"", ")", ")", "{", "String", "styleableName", "=", "null", ";", "// Current styleable name", "int", "[", "]", "styleableArray", "=", "null", ";", "// Current styleable value array or references", "for", "(", "Field", "field", ":", "innerClass", ".", "getDeclaredFields", "(", ")", ")", "{", "if", "(", "field", ".", "getType", "(", ")", ".", "equals", "(", "int", "[", "]", ".", "class", ")", "&&", "Modifier", ".", "isStatic", "(", "field", ".", "getModifiers", "(", ")", ")", ")", "{", "styleableName", "=", "field", ".", "getName", "(", ")", ";", "try", "{", "styleableArray", "=", "(", "int", "[", "]", ")", "(", "field", ".", "get", "(", "null", ")", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "else", "if", "(", "field", ".", "getType", "(", ")", ".", "equals", "(", "Integer", ".", "TYPE", ")", "&&", "Modifier", ".", "isStatic", "(", "field", ".", "getModifiers", "(", ")", ")", ")", "{", "String", "attributeName", "=", "field", ".", "getName", "(", ")", ".", "substring", "(", "styleableName", ".", "length", "(", ")", "+", "1", ")", ";", "try", "{", "int", "styleableIndex", "=", "field", ".", "getInt", "(", "null", ")", ";", "int", "attributeResId", "=", "styleableArray", "[", "styleableIndex", "]", ";", "resourceTable", ".", "addResource", "(", "attributeResId", ",", "\"attr\"", ",", "attributeName", ")", ";", "}", "catch", "(", "IllegalAccessException", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}", "}", "}", "}", "}"], "docstring": "Check the stylable elements. Not for aapt generated R files but for framework R files it is possible to\nhave attributes in the styleable array for which there is no corresponding R.attr field.", "docstring_tokens": ["Check", "the", "stylable", "elements", ".", "Not", "for", "aapt", "generated", "R", "files", "but", "for", "framework", "R", "files", "it", "is", "possible", "to", "have", "attributes", "in", "the", "styleable", "array", "for", "which", "there", "is", "no", "corresponding", "R", ".", "attr", "field", "."]}
{"code": "fieldInsnNode.desc = mutableClass.config.mappedTypeName(fieldInsnNode.desc);", "comments": "todo test", "lines": 20, "repo": "robolectric/robolectric", "path": "sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java", "func_name": "ClassInstrumentor.rewriteMethodBody", "original_string": "private void rewriteMethodBody(MutableClass mutableClass, MethodNode callingMethod) {\n    ListIterator<AbstractInsnNode> instructions = callingMethod.instructions.iterator();\n    while (instructions.hasNext()) {\n      AbstractInsnNode node = instructions.next();\n\n      switch (node.getOpcode()) {\n        case Opcodes.NEW:\n          TypeInsnNode newInsnNode = (TypeInsnNode) node;\n          newInsnNode.desc = mutableClass.config.mappedTypeName(newInsnNode.desc);\n          break;\n\n        case Opcodes.GETFIELD:\n          /* falls through */\n        case Opcodes.PUTFIELD:\n          /* falls through */\n        case Opcodes.GETSTATIC:\n          /* falls through */\n        case Opcodes.PUTSTATIC:\n          FieldInsnNode fieldInsnNode = (FieldInsnNode) node;\n          fieldInsnNode.desc = mutableClass.config.mappedTypeName(fieldInsnNode.desc); // todo test\n          break;\n\n        case Opcodes.INVOKESTATIC:\n          /* falls through */\n        case Opcodes.INVOKEINTERFACE:\n          /* falls through */\n        case Opcodes.INVOKESPECIAL:\n          /* falls through */\n        case Opcodes.INVOKEVIRTUAL:\n          MethodInsnNode targetMethod = (MethodInsnNode) node;\n          targetMethod.desc = mutableClass.config.remapParams(targetMethod.desc);\n          if (isGregorianCalendarBooleanConstructor(targetMethod)) {\n            replaceGregorianCalendarBooleanConstructor(instructions, targetMethod);\n          } else if (mutableClass.config.shouldIntercept(targetMethod)) {\n            interceptInvokeVirtualMethod(mutableClass, instructions, targetMethod);\n          }\n          break;\n\n        case Opcodes.INVOKEDYNAMIC:\n          /* no unusual behavior */\n          break;\n\n        default:\n          break;\n      }\n    }\n  }", "language": "java", "Allcodes": "private void rewriteMethodBody(MutableClass mutableClass, MethodNode callingMethod) {\n    ListIterator<AbstractInsnNode> instructions = callingMethod.instructions.iterator();\n    while (instructions.hasNext()) {\n      AbstractInsnNode node = instructions.next();\n\n      switch (node.getOpcode()) {\n        case Opcodes.NEW:\n          TypeInsnNode newInsnNode = (TypeInsnNode) node;\n          newInsnNode.desc = mutableClass.config.mappedTypeName(newInsnNode.desc);\n          break;\n\n        case Opcodes.GETFIELD:\n          /* falls through */\n        case Opcodes.PUTFIELD:\n          /* falls through */\n        case Opcodes.GETSTATIC:\n          /* falls through */\n        case Opcodes.PUTSTATIC:\n          FieldInsnNode fieldInsnNode = (FieldInsnNode) node;\n          fieldInsnNode.desc = mutableClass.config.mappedTypeName(fieldInsnNode.desc); // todo test\n          break;\n\n        case Opcodes.INVOKESTATIC:\n          /* falls through */\n        case Opcodes.INVOKEINTERFACE:\n          /* falls through */\n        case Opcodes.INVOKESPECIAL:\n          /* falls through */\n        case Opcodes.INVOKEVIRTUAL:\n          MethodInsnNode targetMethod = (MethodInsnNode) node;\n          targetMethod.desc = mutableClass.config.remapParams(targetMethod.desc);\n          if (isGregorianCalendarBooleanConstructor(targetMethod)) {\n            replaceGregorianCalendarBooleanConstructor(instructions, targetMethod);\n          } else if (mutableClass.config.shouldIntercept(targetMethod)) {\n            interceptInvokeVirtualMethod(mutableClass, instructions, targetMethod);\n          }\n          break;\n\n        case Opcodes.INVOKEDYNAMIC:\n          /* no unusual behavior */\n          break;\n\n        default:\n          break;\n      }\n    }\n  }", "code_tokens": ["private", "void", "rewriteMethodBody", "(", "MutableClass", "mutableClass", ",", "MethodNode", "callingMethod", ")", "{", "ListIterator", "<", "AbstractInsnNode", ">", "instructions", "=", "callingMethod", ".", "instructions", ".", "iterator", "(", ")", ";", "while", "(", "instructions", ".", "hasNext", "(", ")", ")", "{", "AbstractInsnNode", "node", "=", "instructions", ".", "next", "(", ")", ";", "switch", "(", "node", ".", "getOpcode", "(", ")", ")", "{", "case", "Opcodes", ".", "NEW", ":", "TypeInsnNode", "newInsnNode", "=", "(", "TypeInsnNode", ")", "node", ";", "newInsnNode", ".", "desc", "=", "mutableClass", ".", "config", ".", "mappedTypeName", "(", "newInsnNode", ".", "desc", ")", ";", "break", ";", "case", "Opcodes", ".", "GETFIELD", ":", "/* falls through */", "case", "Opcodes", ".", "PUTFIELD", ":", "/* falls through */", "case", "Opcodes", ".", "GETSTATIC", ":", "/* falls through */", "case", "Opcodes", ".", "PUTSTATIC", ":", "FieldInsnNode", "fieldInsnNode", "=", "(", "FieldInsnNode", ")", "node", ";", "fieldInsnNode", ".", "desc", "=", "mutableClass", ".", "config", ".", "mappedTypeName", "(", "fieldInsnNode", ".", "desc", ")", ";", "// todo test", "break", ";", "case", "Opcodes", ".", "INVOKESTATIC", ":", "/* falls through */", "case", "Opcodes", ".", "INVOKEINTERFACE", ":", "/* falls through */", "case", "Opcodes", ".", "INVOKESPECIAL", ":", "/* falls through */", "case", "Opcodes", ".", "INVOKEVIRTUAL", ":", "MethodInsnNode", "targetMethod", "=", "(", "MethodInsnNode", ")", "node", ";", "targetMethod", ".", "desc", "=", "mutableClass", ".", "config", ".", "remapParams", "(", "targetMethod", ".", "desc", ")", ";", "if", "(", "isGregorianCalendarBooleanConstructor", "(", "targetMethod", ")", ")", "{", "replaceGregorianCalendarBooleanConstructor", "(", "instructions", ",", "targetMethod", ")", ";", "}", "else", "if", "(", "mutableClass", ".", "config", ".", "shouldIntercept", "(", "targetMethod", ")", ")", "{", "interceptInvokeVirtualMethod", "(", "mutableClass", ",", "instructions", ",", "targetMethod", ")", ";", "}", "break", ";", "case", "Opcodes", ".", "INVOKEDYNAMIC", ":", "/* no unusual behavior */", "break", ";", "default", ":", "break", ";", "}", "}", "}"], "docstring": "Filters methods that might need special treatment because of various reasons", "docstring_tokens": ["Filters", "methods", "that", "might", "need", "special", "treatment", "because", "of", "various", "reasons"]}
{"code": "int startPosition = buffer.position();", "comments": "The starting buffer position to calculate bytes read.", "lines": 2, "repo": "robolectric/robolectric", "path": "resources/src/main/java/org/robolectric/res/android/ResTable_config.java", "func_name": "ResTable_config.createConfig", "original_string": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "language": "java", "Allcodes": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "code_tokens": ["static", "ResTable_config", "createConfig", "(", "ByteBuffer", "buffer", ")", "{", "int", "startPosition", "=", "buffer", ".", "position", "(", ")", ";", "// The starting buffer position to calculate bytes read.", "int", "size", "=", "buffer", ".", "getInt", "(", ")", ";", "int", "mcc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "mnc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "byte", "[", "]", "language", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "language", ")", ";", "byte", "[", "]", "region", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "region", ")", ";", "int", "orientation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "touchscreen", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "density", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "keyboard", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "navigation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "inputFlags", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "buffer", ".", "get", "(", ")", ";", "// 1 byte of padding", "int", "screenWidth", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "screenHeight", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "sdkVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "minorVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "// At this point, the configuration's size needs to be taken into account as not all", "// configurations have all values.", "int", "screenLayout", "=", "0", ";", "int", "uiMode", "=", "0", ";", "int", "smallestScreenWidthDp", "=", "0", ";", "int", "screenWidthDp", "=", "0", ";", "int", "screenHeightDp", "=", "0", ";", "byte", "[", "]", "localeScript", "=", "new", "byte", "[", "4", "]", ";", "byte", "[", "]", "localeVariant", "=", "new", "byte", "[", "8", "]", ";", "byte", "screenLayout2", "=", "0", ";", "byte", "screenConfigPad1", "=", "0", ";", "short", "screenConfigPad2", "=", "0", ";", "if", "(", "size", ">=", "SCREEN_CONFIG_MIN_SIZE", ")", "{", "screenLayout", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "uiMode", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "smallestScreenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "SCREEN_DP_MIN_SIZE", ")", "{", "screenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "screenHeightDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "LOCALE_MIN_SIZE", ")", "{", "buffer", ".", "get", "(", "localeScript", ")", ";", "buffer", ".", "get", "(", "localeVariant", ")", ";", "}", "if", "(", "size", ">=", "SCREEN_CONFIG_EXTENSION_MIN_SIZE", ")", "{", "screenLayout2", "=", "(", "byte", ")", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "screenConfigPad1", "=", "buffer", ".", "get", "(", ")", ";", "// Reserved padding", "screenConfigPad2", "=", "buffer", ".", "getShort", "(", ")", ";", "// More reserved padding", "}", "// After parsing everything that's known, account for anything that's unknown.", "int", "bytesRead", "=", "buffer", ".", "position", "(", ")", "-", "startPosition", ";", "byte", "[", "]", "unknown", "=", "new", "byte", "[", "size", "-", "bytesRead", "]", ";", "buffer", ".", "get", "(", "unknown", ")", ";", "return", "new", "ResTable_config", "(", "size", ",", "mcc", ",", "mnc", ",", "language", ",", "region", ",", "orientation", ",", "touchscreen", ",", "density", ",", "keyboard", ",", "navigation", ",", "inputFlags", ",", "screenWidth", ",", "screenHeight", ",", "sdkVersion", ",", "minorVersion", ",", "screenLayout", ",", "uiMode", ",", "smallestScreenWidthDp", ",", "screenWidthDp", ",", "screenHeightDp", ",", "localeScript", ",", "localeVariant", ",", "screenLayout2", ",", "screenConfigPad1", ",", "screenConfigPad2", ",", "unknown", ")", ";", "}"], "docstring": "packed version of \"tl\"", "docstring_tokens": ["packed", "version", "of", "tl"]}
{"code": "buffer.get();", "comments": "1 byte of padding", "lines": 16, "repo": "robolectric/robolectric", "path": "resources/src/main/java/org/robolectric/res/android/ResTable_config.java", "func_name": "ResTable_config.createConfig", "original_string": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "language": "java", "Allcodes": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "code_tokens": ["static", "ResTable_config", "createConfig", "(", "ByteBuffer", "buffer", ")", "{", "int", "startPosition", "=", "buffer", ".", "position", "(", ")", ";", "// The starting buffer position to calculate bytes read.", "int", "size", "=", "buffer", ".", "getInt", "(", ")", ";", "int", "mcc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "mnc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "byte", "[", "]", "language", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "language", ")", ";", "byte", "[", "]", "region", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "region", ")", ";", "int", "orientation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "touchscreen", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "density", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "keyboard", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "navigation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "inputFlags", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "buffer", ".", "get", "(", ")", ";", "// 1 byte of padding", "int", "screenWidth", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "screenHeight", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "sdkVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "minorVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "// At this point, the configuration's size needs to be taken into account as not all", "// configurations have all values.", "int", "screenLayout", "=", "0", ";", "int", "uiMode", "=", "0", ";", "int", "smallestScreenWidthDp", "=", "0", ";", "int", "screenWidthDp", "=", "0", ";", "int", "screenHeightDp", "=", "0", ";", "byte", "[", "]", "localeScript", "=", "new", "byte", "[", "4", "]", ";", "byte", "[", "]", "localeVariant", "=", "new", "byte", "[", "8", "]", ";", "byte", "screenLayout2", "=", "0", ";", "byte", "screenConfigPad1", "=", "0", ";", "short", "screenConfigPad2", "=", "0", ";", "if", "(", "size", ">=", "SCREEN_CONFIG_MIN_SIZE", ")", "{", "screenLayout", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "uiMode", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "smallestScreenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "SCREEN_DP_MIN_SIZE", ")", "{", "screenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "screenHeightDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "LOCALE_MIN_SIZE", ")", "{", "buffer", ".", "get", "(", "localeScript", ")", ";", "buffer", ".", "get", "(", "localeVariant", ")", ";", "}", "if", "(", "size", ">=", "SCREEN_CONFIG_EXTENSION_MIN_SIZE", ")", "{", "screenLayout2", "=", "(", "byte", ")", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "screenConfigPad1", "=", "buffer", ".", "get", "(", ")", ";", "// Reserved padding", "screenConfigPad2", "=", "buffer", ".", "getShort", "(", ")", ";", "// More reserved padding", "}", "// After parsing everything that's known, account for anything that's unknown.", "int", "bytesRead", "=", "buffer", ".", "position", "(", ")", "-", "startPosition", ";", "byte", "[", "]", "unknown", "=", "new", "byte", "[", "size", "-", "bytesRead", "]", ";", "buffer", ".", "get", "(", "unknown", ")", ";", "return", "new", "ResTable_config", "(", "size", ",", "mcc", ",", "mnc", ",", "language", ",", "region", ",", "orientation", ",", "touchscreen", ",", "density", ",", "keyboard", ",", "navigation", ",", "inputFlags", ",", "screenWidth", ",", "screenHeight", ",", "sdkVersion", ",", "minorVersion", ",", "screenLayout", ",", "uiMode", ",", "smallestScreenWidthDp", ",", "screenWidthDp", ",", "screenHeightDp", ",", "localeScript", ",", "localeVariant", ",", "screenLayout2", ",", "screenConfigPad1", ",", "screenConfigPad2", ",", "unknown", ")", ";", "}"], "docstring": "packed version of \"tl\"", "docstring_tokens": ["packed", "version", "of", "tl"]}
{"code": "screenConfigPad1 = buffer.get();", "comments": "Reserved padding", "lines": 53, "repo": "robolectric/robolectric", "path": "resources/src/main/java/org/robolectric/res/android/ResTable_config.java", "func_name": "ResTable_config.createConfig", "original_string": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "language": "java", "Allcodes": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "code_tokens": ["static", "ResTable_config", "createConfig", "(", "ByteBuffer", "buffer", ")", "{", "int", "startPosition", "=", "buffer", ".", "position", "(", ")", ";", "// The starting buffer position to calculate bytes read.", "int", "size", "=", "buffer", ".", "getInt", "(", ")", ";", "int", "mcc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "mnc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "byte", "[", "]", "language", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "language", ")", ";", "byte", "[", "]", "region", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "region", ")", ";", "int", "orientation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "touchscreen", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "density", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "keyboard", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "navigation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "inputFlags", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "buffer", ".", "get", "(", ")", ";", "// 1 byte of padding", "int", "screenWidth", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "screenHeight", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "sdkVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "minorVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "// At this point, the configuration's size needs to be taken into account as not all", "// configurations have all values.", "int", "screenLayout", "=", "0", ";", "int", "uiMode", "=", "0", ";", "int", "smallestScreenWidthDp", "=", "0", ";", "int", "screenWidthDp", "=", "0", ";", "int", "screenHeightDp", "=", "0", ";", "byte", "[", "]", "localeScript", "=", "new", "byte", "[", "4", "]", ";", "byte", "[", "]", "localeVariant", "=", "new", "byte", "[", "8", "]", ";", "byte", "screenLayout2", "=", "0", ";", "byte", "screenConfigPad1", "=", "0", ";", "short", "screenConfigPad2", "=", "0", ";", "if", "(", "size", ">=", "SCREEN_CONFIG_MIN_SIZE", ")", "{", "screenLayout", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "uiMode", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "smallestScreenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "SCREEN_DP_MIN_SIZE", ")", "{", "screenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "screenHeightDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "LOCALE_MIN_SIZE", ")", "{", "buffer", ".", "get", "(", "localeScript", ")", ";", "buffer", ".", "get", "(", "localeVariant", ")", ";", "}", "if", "(", "size", ">=", "SCREEN_CONFIG_EXTENSION_MIN_SIZE", ")", "{", "screenLayout2", "=", "(", "byte", ")", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "screenConfigPad1", "=", "buffer", ".", "get", "(", ")", ";", "// Reserved padding", "screenConfigPad2", "=", "buffer", ".", "getShort", "(", ")", ";", "// More reserved padding", "}", "// After parsing everything that's known, account for anything that's unknown.", "int", "bytesRead", "=", "buffer", ".", "position", "(", ")", "-", "startPosition", ";", "byte", "[", "]", "unknown", "=", "new", "byte", "[", "size", "-", "bytesRead", "]", ";", "buffer", ".", "get", "(", "unknown", ")", ";", "return", "new", "ResTable_config", "(", "size", ",", "mcc", ",", "mnc", ",", "language", ",", "region", ",", "orientation", ",", "touchscreen", ",", "density", ",", "keyboard", ",", "navigation", ",", "inputFlags", ",", "screenWidth", ",", "screenHeight", ",", "sdkVersion", ",", "minorVersion", ",", "screenLayout", ",", "uiMode", ",", "smallestScreenWidthDp", ",", "screenWidthDp", ",", "screenHeightDp", ",", "localeScript", ",", "localeVariant", ",", "screenLayout2", ",", "screenConfigPad1", ",", "screenConfigPad2", ",", "unknown", ")", ";", "}"], "docstring": "packed version of \"tl\"", "docstring_tokens": ["packed", "version", "of", "tl"]}
{"code": "screenConfigPad2 = buffer.getShort();", "comments": "More reserved padding", "lines": 54, "repo": "robolectric/robolectric", "path": "resources/src/main/java/org/robolectric/res/android/ResTable_config.java", "func_name": "ResTable_config.createConfig", "original_string": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "language": "java", "Allcodes": "static ResTable_config createConfig(ByteBuffer buffer) {\n    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.\n    int size = buffer.getInt();\n    int mcc = buffer.getShort() & 0xFFFF;\n    int mnc = buffer.getShort() & 0xFFFF;\n    byte[] language = new byte[2];\n    buffer.get(language);\n    byte[] region = new byte[2];\n    buffer.get(region);\n    int orientation = UnsignedBytes.toInt(buffer.get());\n    int touchscreen = UnsignedBytes.toInt(buffer.get());\n    int density = buffer.getShort() & 0xFFFF;\n    int keyboard = UnsignedBytes.toInt(buffer.get());\n    int navigation = UnsignedBytes.toInt(buffer.get());\n    int inputFlags = UnsignedBytes.toInt(buffer.get());\n    buffer.get();  // 1 byte of padding\n    int screenWidth = buffer.getShort() & 0xFFFF;\n    int screenHeight = buffer.getShort() & 0xFFFF;\n    int sdkVersion = buffer.getShort() & 0xFFFF;\n    int minorVersion = buffer.getShort() & 0xFFFF;\n\n    // At this point, the configuration's size needs to be taken into account as not all\n    // configurations have all values.\n    int screenLayout = 0;\n    int uiMode = 0;\n    int smallestScreenWidthDp = 0;\n    int screenWidthDp = 0;\n    int screenHeightDp = 0;\n    byte[] localeScript = new byte[4];\n    byte[] localeVariant = new byte[8];\n    byte screenLayout2 = 0;\n    byte screenConfigPad1 = 0;\n    short screenConfigPad2 = 0;\n\n    if (size >= SCREEN_CONFIG_MIN_SIZE) {\n      screenLayout = UnsignedBytes.toInt(buffer.get());\n      uiMode = UnsignedBytes.toInt(buffer.get());\n      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= SCREEN_DP_MIN_SIZE) {\n      screenWidthDp = buffer.getShort() & 0xFFFF;\n      screenHeightDp = buffer.getShort() & 0xFFFF;\n    }\n\n    if (size >= LOCALE_MIN_SIZE) {\n      buffer.get(localeScript);\n      buffer.get(localeVariant);\n    }\n\n    if (size >= SCREEN_CONFIG_EXTENSION_MIN_SIZE) {\n      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());\n      screenConfigPad1 = buffer.get();  // Reserved padding\n      screenConfigPad2 = buffer.getShort();  // More reserved padding\n    }\n\n    // After parsing everything that's known, account for anything that's unknown.\n    int bytesRead = buffer.position() - startPosition;\n    byte[] unknown = new byte[size - bytesRead];\n    buffer.get(unknown);\n\n    return new ResTable_config(size, mcc, mnc, language, region, orientation,\n        touchscreen, density, keyboard, navigation, inputFlags, screenWidth, screenHeight,\n        sdkVersion, minorVersion, screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n        screenHeightDp, localeScript, localeVariant, screenLayout2, screenConfigPad1, screenConfigPad2, unknown);\n  }", "code_tokens": ["static", "ResTable_config", "createConfig", "(", "ByteBuffer", "buffer", ")", "{", "int", "startPosition", "=", "buffer", ".", "position", "(", ")", ";", "// The starting buffer position to calculate bytes read.", "int", "size", "=", "buffer", ".", "getInt", "(", ")", ";", "int", "mcc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "mnc", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "byte", "[", "]", "language", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "language", ")", ";", "byte", "[", "]", "region", "=", "new", "byte", "[", "2", "]", ";", "buffer", ".", "get", "(", "region", ")", ";", "int", "orientation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "touchscreen", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "density", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "keyboard", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "navigation", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "int", "inputFlags", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "buffer", ".", "get", "(", ")", ";", "// 1 byte of padding", "int", "screenWidth", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "screenHeight", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "sdkVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "int", "minorVersion", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "// At this point, the configuration's size needs to be taken into account as not all", "// configurations have all values.", "int", "screenLayout", "=", "0", ";", "int", "uiMode", "=", "0", ";", "int", "smallestScreenWidthDp", "=", "0", ";", "int", "screenWidthDp", "=", "0", ";", "int", "screenHeightDp", "=", "0", ";", "byte", "[", "]", "localeScript", "=", "new", "byte", "[", "4", "]", ";", "byte", "[", "]", "localeVariant", "=", "new", "byte", "[", "8", "]", ";", "byte", "screenLayout2", "=", "0", ";", "byte", "screenConfigPad1", "=", "0", ";", "short", "screenConfigPad2", "=", "0", ";", "if", "(", "size", ">=", "SCREEN_CONFIG_MIN_SIZE", ")", "{", "screenLayout", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "uiMode", "=", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "smallestScreenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "SCREEN_DP_MIN_SIZE", ")", "{", "screenWidthDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "screenHeightDp", "=", "buffer", ".", "getShort", "(", ")", "&", "0xFFFF", ";", "}", "if", "(", "size", ">=", "LOCALE_MIN_SIZE", ")", "{", "buffer", ".", "get", "(", "localeScript", ")", ";", "buffer", ".", "get", "(", "localeVariant", ")", ";", "}", "if", "(", "size", ">=", "SCREEN_CONFIG_EXTENSION_MIN_SIZE", ")", "{", "screenLayout2", "=", "(", "byte", ")", "UnsignedBytes", ".", "toInt", "(", "buffer", ".", "get", "(", ")", ")", ";", "screenConfigPad1", "=", "buffer", ".", "get", "(", ")", ";", "// Reserved padding", "screenConfigPad2", "=", "buffer", ".", "getShort", "(", ")", ";", "// More reserved padding", "}", "// After parsing everything that's known, account for anything that's unknown.", "int", "bytesRead", "=", "buffer", ".", "position", "(", ")", "-", "startPosition", ";", "byte", "[", "]", "unknown", "=", "new", "byte", "[", "size", "-", "bytesRead", "]", ";", "buffer", ".", "get", "(", "unknown", ")", ";", "return", "new", "ResTable_config", "(", "size", ",", "mcc", ",", "mnc", ",", "language", ",", "region", ",", "orientation", ",", "touchscreen", ",", "density", ",", "keyboard", ",", "navigation", ",", "inputFlags", ",", "screenWidth", ",", "screenHeight", ",", "sdkVersion", ",", "minorVersion", ",", "screenLayout", ",", "uiMode", ",", "smallestScreenWidthDp", ",", "screenWidthDp", ",", "screenHeightDp", ",", "localeScript", ",", "localeVariant", ",", "screenLayout2", ",", "screenConfigPad1", ",", "screenConfigPad2", ",", "unknown", ")", ";", "}"], "docstring": "packed version of \"tl\"", "docstring_tokens": ["packed", "version", "of", "tl"]}
{"code": "instructions.remove();", "comments": "remove the method invocation", "lines": 3, "repo": "robolectric/robolectric", "path": "sandbox/src/main/java/org/robolectric/internal/bytecode/InvokeDynamicClassInstrumentor.java", "func_name": "InvokeDynamicClassInstrumentor.interceptInvokeVirtualMethodWithInvokeDynamic", "original_string": "private void interceptInvokeVirtualMethodWithInvokeDynamic(\n      ListIterator<AbstractInsnNode> instructions, MethodInsnNode targetMethod) {\n    instructions.remove();  // remove the method invocation\n\n    Type type = Type.getObjectType(targetMethod.owner);\n    String description = targetMethod.desc;\n    String owner = type.getClassName();\n\n    if (targetMethod.getOpcode() != Opcodes.INVOKESTATIC) {\n      String thisType = type.getDescriptor();\n      description = \"(\" + thisType + description.substring(1);\n    }\n\n    instructions.add(new InvokeDynamicInsnNode(targetMethod.name, description, BOOTSTRAP_INTRINSIC, owner));\n  }", "language": "java", "Allcodes": "private void interceptInvokeVirtualMethodWithInvokeDynamic(\n      ListIterator<AbstractInsnNode> instructions, MethodInsnNode targetMethod) {\n    instructions.remove();  // remove the method invocation\n\n    Type type = Type.getObjectType(targetMethod.owner);\n    String description = targetMethod.desc;\n    String owner = type.getClassName();\n\n    if (targetMethod.getOpcode() != Opcodes.INVOKESTATIC) {\n      String thisType = type.getDescriptor();\n      description = \"(\" + thisType + description.substring(1);\n    }\n\n    instructions.add(new InvokeDynamicInsnNode(targetMethod.name, description, BOOTSTRAP_INTRINSIC, owner));\n  }", "code_tokens": ["private", "void", "interceptInvokeVirtualMethodWithInvokeDynamic", "(", "ListIterator", "<", "AbstractInsnNode", ">", "instructions", ",", "MethodInsnNode", "targetMethod", ")", "{", "instructions", ".", "remove", "(", ")", ";", "// remove the method invocation", "Type", "type", "=", "Type", ".", "getObjectType", "(", "targetMethod", ".", "owner", ")", ";", "String", "description", "=", "targetMethod", ".", "desc", ";", "String", "owner", "=", "type", ".", "getClassName", "(", ")", ";", "if", "(", "targetMethod", ".", "getOpcode", "(", ")", "!=", "Opcodes", ".", "INVOKESTATIC", ")", "{", "String", "thisType", "=", "type", ".", "getDescriptor", "(", ")", ";", "description", "=", "\"(\"", "+", "thisType", "+", "description", ".", "substring", "(", "1", ")", ";", "}", "instructions", ".", "add", "(", "new", "InvokeDynamicInsnNode", "(", "targetMethod", ".", "name", ",", "description", ",", "BOOTSTRAP_INTRINSIC", ",", "owner", ")", ")", ";", "}"], "docstring": "Intercepts the method using the invokedynamic bytecode instruction available in Java 7+.\nShould be called through interceptInvokeVirtualMethod, not directly.", "docstring_tokens": ["Intercepts", "the", "method", "using", "the", "invokedynamic", "bytecode", "instruction", "available", "in", "Java", "7", "+", ".", "Should", "be", "called", "through", "interceptInvokeVirtualMethod", "not", "directly", "."]}
{"code": "info.match = Integer.MAX_VALUE;", "comments": "make sure, that this is as good match as possible.", "lines": 19, "repo": "robolectric/robolectric", "path": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java", "func_name": "ShadowPackageManager.addResolveInfoForIntent", "original_string": "@Deprecated\n  public void addResolveInfoForIntent(Intent intent, ResolveInfo info) {\n    info.isDefault = true;\n    ComponentInfo[] componentInfos =\n        new ComponentInfo[] {\n          info.activityInfo,\n          info.serviceInfo,\n          Build.VERSION.SDK_INT >= KITKAT ? info.providerInfo : null\n        };\n    for (ComponentInfo component : componentInfos) {\n      if (component != null && component.applicationInfo != null) {\n        component.applicationInfo.flags |= ApplicationInfo.FLAG_INSTALLED;\n        if (component.applicationInfo.processName == null) {\n          component.applicationInfo.processName = component.applicationInfo.packageName;\n        }\n      }\n    }\n    if (info.match == 0) {\n      info.match = Integer.MAX_VALUE; // make sure, that this is as good match as possible.\n    }\n    addResolveInfoForIntentNoDefaults(intent, info);\n  }", "language": "java", "Allcodes": "@Deprecated\n  public void addResolveInfoForIntent(Intent intent, ResolveInfo info) {\n    info.isDefault = true;\n    ComponentInfo[] componentInfos =\n        new ComponentInfo[] {\n          info.activityInfo,\n          info.serviceInfo,\n          Build.VERSION.SDK_INT >= KITKAT ? info.providerInfo : null\n        };\n    for (ComponentInfo component : componentInfos) {\n      if (component != null && component.applicationInfo != null) {\n        component.applicationInfo.flags |= ApplicationInfo.FLAG_INSTALLED;\n        if (component.applicationInfo.processName == null) {\n          component.applicationInfo.processName = component.applicationInfo.packageName;\n        }\n      }\n    }\n    if (info.match == 0) {\n      info.match = Integer.MAX_VALUE; // make sure, that this is as good match as possible.\n    }\n    addResolveInfoForIntentNoDefaults(intent, info);\n  }", "code_tokens": ["@", "Deprecated", "public", "void", "addResolveInfoForIntent", "(", "Intent", "intent", ",", "ResolveInfo", "info", ")", "{", "info", ".", "isDefault", "=", "true", ";", "ComponentInfo", "[", "]", "componentInfos", "=", "new", "ComponentInfo", "[", "]", "{", "info", ".", "activityInfo", ",", "info", ".", "serviceInfo", ",", "Build", ".", "VERSION", ".", "SDK_INT", ">=", "KITKAT", "?", "info", ".", "providerInfo", ":", "null", "}", ";", "for", "(", "ComponentInfo", "component", ":", "componentInfos", ")", "{", "if", "(", "component", "!=", "null", "&&", "component", ".", "applicationInfo", "!=", "null", ")", "{", "component", ".", "applicationInfo", ".", "flags", "|=", "ApplicationInfo", ".", "FLAG_INSTALLED", ";", "if", "(", "component", ".", "applicationInfo", ".", "processName", "==", "null", ")", "{", "component", ".", "applicationInfo", ".", "processName", "=", "component", ".", "applicationInfo", ".", "packageName", ";", "}", "}", "}", "if", "(", "info", ".", "match", "==", "0", ")", "{", "info", ".", "match", "=", "Integer", ".", "MAX_VALUE", ";", "// make sure, that this is as good match as possible.", "}", "addResolveInfoForIntentNoDefaults", "(", "intent", ",", "info", ")", ";", "}"], "docstring": "Adds extra resolve info for an intent.\n\nNote that this resolve info will have {@link ResolveInfo#isDefault} field set to {@code\ntrue} to allow its resolution for implicit intents. If this is not what you want, then please\nuse {@link #addResolveInfoForIntentNoDefaults} instead.\n\n@deprecated use {@link #addIntentFilterForComponent} instead and if the component doesn't exist\nadd it using any of {@link #installPackage}, {@link #addOrUpdateActivity}, {@link\n#addActivityIfNotPresent} or their counterparts for other types of components.", "docstring_tokens": ["Adds", "extra", "resolve", "info", "for", "an", "intent", "."]}
{"code": "final int hop = fact.getHopCount()-1;", "comments": "the hop to establish", "lines": 28, "repo": "robolectric/robolectric", "path": "shadows/httpclient/src/main/java/org/robolectric/shadows/httpclient/DefaultRequestDirector.java", "func_name": "DefaultRequestDirector.establishRoute", "original_string": "protected void establishRoute(HttpRoute route, HttpContext context)\n    throws HttpException, IOException {\n\n    HttpRouteDirector rowdy = new BasicRouteDirector();\n    int step;\n    do {\n      HttpRoute fact = managedConn.getRoute();\n      step = rowdy.nextStep(route, fact);\n\n      switch (step) {\n\n      case HttpRouteDirector.CONNECT_TARGET:\n      case HttpRouteDirector.CONNECT_PROXY:\n        managedConn.open(route, context, this.params);\n        break;\n\n      case HttpRouteDirector.TUNNEL_TARGET: {\n        boolean secure = createTunnelToTarget(route, context);\n        this.log.debug(\"Tunnel to target created.\");\n        managedConn.tunnelTarget(secure, this.params);\n      }   break;\n\n      case HttpRouteDirector.TUNNEL_PROXY: {\n        // The most simple example for this case is a proxy chain\n        // of two proxies, where P1 must be tunnelled to P2.\n        // route: Source -> P1 -> P2 -> Target (3 hops)\n        // fact:  Source -> P1 -> Target       (2 hops)\n        final int hop = fact.getHopCount()-1; // the hop to establish\n        boolean secure = createTunnelToProxy(route, hop, context);\n        this.log.debug(\"Tunnel to proxy created.\");\n        managedConn.tunnelProxy(route.getHopTarget(hop),\n                    secure, this.params);\n      }   break;\n\n\n      case HttpRouteDirector.LAYER_PROTOCOL:\n        managedConn.layerProtocol(context, this.params);\n        break;\n\n      case HttpRouteDirector.UNREACHABLE:\n        throw new IllegalStateException\n          (\"Unable to establish route.\" +\n           \"\\nplanned = \" + route +\n           \"\\ncurrent = \" + fact);\n\n      case HttpRouteDirector.COMPLETE:\n        // do nothing\n        break;\n\n      default:\n        throw new IllegalStateException\n          (\"Unknown step indicator \"+step+\" from RouteDirector.\");\n      } // switch\n\n    } while (step > HttpRouteDirector.COMPLETE);\n\n  }", "language": "java", "Allcodes": "protected void establishRoute(HttpRoute route, HttpContext context)\n    throws HttpException, IOException {\n\n    HttpRouteDirector rowdy = new BasicRouteDirector();\n    int step;\n    do {\n      HttpRoute fact = managedConn.getRoute();\n      step = rowdy.nextStep(route, fact);\n\n      switch (step) {\n\n      case HttpRouteDirector.CONNECT_TARGET:\n      case HttpRouteDirector.CONNECT_PROXY:\n        managedConn.open(route, context, this.params);\n        break;\n\n      case HttpRouteDirector.TUNNEL_TARGET: {\n        boolean secure = createTunnelToTarget(route, context);\n        this.log.debug(\"Tunnel to target created.\");\n        managedConn.tunnelTarget(secure, this.params);\n      }   break;\n\n      case HttpRouteDirector.TUNNEL_PROXY: {\n        // The most simple example for this case is a proxy chain\n        // of two proxies, where P1 must be tunnelled to P2.\n        // route: Source -> P1 -> P2 -> Target (3 hops)\n        // fact:  Source -> P1 -> Target       (2 hops)\n        final int hop = fact.getHopCount()-1; // the hop to establish\n        boolean secure = createTunnelToProxy(route, hop, context);\n        this.log.debug(\"Tunnel to proxy created.\");\n        managedConn.tunnelProxy(route.getHopTarget(hop),\n                    secure, this.params);\n      }   break;\n\n\n      case HttpRouteDirector.LAYER_PROTOCOL:\n        managedConn.layerProtocol(context, this.params);\n        break;\n\n      case HttpRouteDirector.UNREACHABLE:\n        throw new IllegalStateException\n          (\"Unable to establish route.\" +\n           \"\\nplanned = \" + route +\n           \"\\ncurrent = \" + fact);\n\n      case HttpRouteDirector.COMPLETE:\n        // do nothing\n        break;\n\n      default:\n        throw new IllegalStateException\n          (\"Unknown step indicator \"+step+\" from RouteDirector.\");\n      } // switch\n\n    } while (step > HttpRouteDirector.COMPLETE);\n\n  }", "code_tokens": ["protected", "void", "establishRoute", "(", "HttpRoute", "route", ",", "HttpContext", "context", ")", "throws", "HttpException", ",", "IOException", "{", "HttpRouteDirector", "rowdy", "=", "new", "BasicRouteDirector", "(", ")", ";", "int", "step", ";", "do", "{", "HttpRoute", "fact", "=", "managedConn", ".", "getRoute", "(", ")", ";", "step", "=", "rowdy", ".", "nextStep", "(", "route", ",", "fact", ")", ";", "switch", "(", "step", ")", "{", "case", "HttpRouteDirector", ".", "CONNECT_TARGET", ":", "case", "HttpRouteDirector", ".", "CONNECT_PROXY", ":", "managedConn", ".", "open", "(", "route", ",", "context", ",", "this", ".", "params", ")", ";", "break", ";", "case", "HttpRouteDirector", ".", "TUNNEL_TARGET", ":", "{", "boolean", "secure", "=", "createTunnelToTarget", "(", "route", ",", "context", ")", ";", "this", ".", "log", ".", "debug", "(", "\"Tunnel to target created.\"", ")", ";", "managedConn", ".", "tunnelTarget", "(", "secure", ",", "this", ".", "params", ")", ";", "}", "break", ";", "case", "HttpRouteDirector", ".", "TUNNEL_PROXY", ":", "{", "// The most simple example for this case is a proxy chain", "// of two proxies, where P1 must be tunnelled to P2.", "// route: Source -> P1 -> P2 -> Target (3 hops)", "// fact:  Source -> P1 -> Target       (2 hops)", "final", "int", "hop", "=", "fact", ".", "getHopCount", "(", ")", "-", "1", ";", "// the hop to establish", "boolean", "secure", "=", "createTunnelToProxy", "(", "route", ",", "hop", ",", "context", ")", ";", "this", ".", "log", ".", "debug", "(", "\"Tunnel to proxy created.\"", ")", ";", "managedConn", ".", "tunnelProxy", "(", "route", ".", "getHopTarget", "(", "hop", ")", ",", "secure", ",", "this", ".", "params", ")", ";", "}", "break", ";", "case", "HttpRouteDirector", ".", "LAYER_PROTOCOL", ":", "managedConn", ".", "layerProtocol", "(", "context", ",", "this", ".", "params", ")", ";", "break", ";", "case", "HttpRouteDirector", ".", "UNREACHABLE", ":", "throw", "new", "IllegalStateException", "(", "\"Unable to establish route.\"", "+", "\"\\nplanned = \"", "+", "route", "+", "\"\\ncurrent = \"", "+", "fact", ")", ";", "case", "HttpRouteDirector", ".", "COMPLETE", ":", "// do nothing", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"Unknown step indicator \"", "+", "step", "+", "\" from RouteDirector.\"", ")", ";", "}", "// switch", "}", "while", "(", "step", ">", "HttpRouteDirector", ".", "COMPLETE", ")", ";", "}"], "docstring": "Establishes the target route.\n\n@param route     the route to establish\n@param context   the context for the request execution\n\n@throws HttpException    in case of a problem\n@throws IOException      in case of an IO problem", "docstring_tokens": ["Establishes", "the", "target", "route", "."]}
{"code": "return \"java/lang/Object\";", "comments": "Handle classes that may be obfuscated", "lines": 48, "repo": "robolectric/robolectric", "path": "sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentingClassWriter.java", "func_name": "InstrumentingClassWriter.getCommonSuperClass", "original_string": "@Override\n  protected String getCommonSuperClass(final String type1, final String type2) {\n    try {\n      ClassNode info1 = typeInfo(type1);\n      ClassNode info2 = typeInfo(type2);\n      if ((info1.access & Opcodes.ACC_INTERFACE) != 0) {\n        if (typeImplements(type2, info2, type1)) {\n          return type1;\n        }\n        if ((info2.access & Opcodes.ACC_INTERFACE) != 0) {\n          if (typeImplements(type1, info1, type2)) {\n            return type2;\n          }\n        }\n        return \"java/lang/Object\";\n      }\n      if ((info2.access & Opcodes.ACC_INTERFACE) != 0) {\n        if (typeImplements(type1, info1, type2)) {\n          return type2;\n        } else {\n          return \"java/lang/Object\";\n        }\n      }\n      String b1 = typeAncestors(type1, info1);\n      String b2 = typeAncestors(type2, info2);\n      String result = \"java/lang/Object\";\n      int end1 = b1.length();\n      int end2 = b2.length();\n      while (true) {\n        int start1 = b1.lastIndexOf(';', end1 - 1);\n        int start2 = b2.lastIndexOf(';', end2 - 1);\n        if (start1 != -1 && start2 != -1\n            && end1 - start1 == end2 - start2) {\n          String p1 = b1.substring(start1 + 1, end1);\n          String p2 = b2.substring(start2 + 1, end2);\n          if (p1.equals(p2)) {\n            result = p1;\n            end1 = start1;\n            end2 = start2;\n          } else {\n            return result;\n          }\n        } else {\n          return result;\n        }\n      }\n    } catch (ClassNotFoundException e) {\n      return \"java/lang/Object\"; // Handle classes that may be obfuscated\n    }\n  }", "language": "java", "Allcodes": "@Override\n  protected String getCommonSuperClass(final String type1, final String type2) {\n    try {\n      ClassNode info1 = typeInfo(type1);\n      ClassNode info2 = typeInfo(type2);\n      if ((info1.access & Opcodes.ACC_INTERFACE) != 0) {\n        if (typeImplements(type2, info2, type1)) {\n          return type1;\n        }\n        if ((info2.access & Opcodes.ACC_INTERFACE) != 0) {\n          if (typeImplements(type1, info1, type2)) {\n            return type2;\n          }\n        }\n        return \"java/lang/Object\";\n      }\n      if ((info2.access & Opcodes.ACC_INTERFACE) != 0) {\n        if (typeImplements(type1, info1, type2)) {\n          return type2;\n        } else {\n          return \"java/lang/Object\";\n        }\n      }\n      String b1 = typeAncestors(type1, info1);\n      String b2 = typeAncestors(type2, info2);\n      String result = \"java/lang/Object\";\n      int end1 = b1.length();\n      int end2 = b2.length();\n      while (true) {\n        int start1 = b1.lastIndexOf(';', end1 - 1);\n        int start2 = b2.lastIndexOf(';', end2 - 1);\n        if (start1 != -1 && start2 != -1\n            && end1 - start1 == end2 - start2) {\n          String p1 = b1.substring(start1 + 1, end1);\n          String p2 = b2.substring(start2 + 1, end2);\n          if (p1.equals(p2)) {\n            result = p1;\n            end1 = start1;\n            end2 = start2;\n          } else {\n            return result;\n          }\n        } else {\n          return result;\n        }\n      }\n    } catch (ClassNotFoundException e) {\n      return \"java/lang/Object\"; // Handle classes that may be obfuscated\n    }\n  }", "code_tokens": ["@", "Override", "protected", "String", "getCommonSuperClass", "(", "final", "String", "type1", ",", "final", "String", "type2", ")", "{", "try", "{", "ClassNode", "info1", "=", "typeInfo", "(", "type1", ")", ";", "ClassNode", "info2", "=", "typeInfo", "(", "type2", ")", ";", "if", "(", "(", "info1", ".", "access", "&", "Opcodes", ".", "ACC_INTERFACE", ")", "!=", "0", ")", "{", "if", "(", "typeImplements", "(", "type2", ",", "info2", ",", "type1", ")", ")", "{", "return", "type1", ";", "}", "if", "(", "(", "info2", ".", "access", "&", "Opcodes", ".", "ACC_INTERFACE", ")", "!=", "0", ")", "{", "if", "(", "typeImplements", "(", "type1", ",", "info1", ",", "type2", ")", ")", "{", "return", "type2", ";", "}", "}", "return", "\"java/lang/Object\"", ";", "}", "if", "(", "(", "info2", ".", "access", "&", "Opcodes", ".", "ACC_INTERFACE", ")", "!=", "0", ")", "{", "if", "(", "typeImplements", "(", "type1", ",", "info1", ",", "type2", ")", ")", "{", "return", "type2", ";", "}", "else", "{", "return", "\"java/lang/Object\"", ";", "}", "}", "String", "b1", "=", "typeAncestors", "(", "type1", ",", "info1", ")", ";", "String", "b2", "=", "typeAncestors", "(", "type2", ",", "info2", ")", ";", "String", "result", "=", "\"java/lang/Object\"", ";", "int", "end1", "=", "b1", ".", "length", "(", ")", ";", "int", "end2", "=", "b2", ".", "length", "(", ")", ";", "while", "(", "true", ")", "{", "int", "start1", "=", "b1", ".", "lastIndexOf", "(", "'", "'", ",", "end1", "-", "1", ")", ";", "int", "start2", "=", "b2", ".", "lastIndexOf", "(", "'", "'", ",", "end2", "-", "1", ")", ";", "if", "(", "start1", "!=", "-", "1", "&&", "start2", "!=", "-", "1", "&&", "end1", "-", "start1", "==", "end2", "-", "start2", ")", "{", "String", "p1", "=", "b1", ".", "substring", "(", "start1", "+", "1", ",", "end1", ")", ";", "String", "p2", "=", "b2", ".", "substring", "(", "start2", "+", "1", ",", "end2", ")", ";", "if", "(", "p1", ".", "equals", "(", "p2", ")", ")", "{", "result", "=", "p1", ";", "end1", "=", "start1", ";", "end2", "=", "start2", ";", "}", "else", "{", "return", "result", ";", "}", "}", "else", "{", "return", "result", ";", "}", "}", "}", "catch", "(", "ClassNotFoundException", "e", ")", "{", "return", "\"java/lang/Object\"", ";", "// Handle classes that may be obfuscated", "}", "}"], "docstring": "Returns the common super type of the two given types without actually loading\nthe classes in the ClassLoader.", "docstring_tokens": ["Returns", "the", "common", "super", "type", "of", "the", "two", "given", "types", "without", "actually", "loading", "the", "classes", "in", "the", "ClassLoader", "."]}
{"code": "swap();", "comments": "same as dupX1(), pop();", "lines": 4, "repo": "nutzam/nutz", "path": "src/org/nutz/repo/org/objectweb/asm/commons/GeneratorAdapter.java", "func_name": "GeneratorAdapter.swap", "original_string": "public void swap(final Type prev, final Type type) {\n        if (type.getSize() == 1) {\n            if (prev.getSize() == 1) {\n                swap(); // same as dupX1(), pop();\n            } else {\n                dupX2();\n                pop();\n            }\n        } else {\n            if (prev.getSize() == 1) {\n                dup2X1();\n                pop2();\n            } else {\n                dup2X2();\n                pop2();\n            }\n        }\n    }", "language": "java", "Allcodes": "public void swap(final Type prev, final Type type) {\n        if (type.getSize() == 1) {\n            if (prev.getSize() == 1) {\n                swap(); // same as dupX1(), pop();\n            } else {\n                dupX2();\n                pop();\n            }\n        } else {\n            if (prev.getSize() == 1) {\n                dup2X1();\n                pop2();\n            } else {\n                dup2X2();\n                pop2();\n            }\n        }\n    }", "code_tokens": ["public", "void", "swap", "(", "final", "Type", "prev", ",", "final", "Type", "type", ")", "{", "if", "(", "type", ".", "getSize", "(", ")", "==", "1", ")", "{", "if", "(", "prev", ".", "getSize", "(", ")", "==", "1", ")", "{", "swap", "(", ")", ";", "// same as dupX1(), pop();", "}", "else", "{", "dupX2", "(", ")", ";", "pop", "(", ")", ";", "}", "}", "else", "{", "if", "(", "prev", ".", "getSize", "(", ")", "==", "1", ")", "{", "dup2X1", "(", ")", ";", "pop2", "(", ")", ";", "}", "else", "{", "dup2X2", "(", ")", ";", "pop2", "(", ")", ";", "}", "}", "}"], "docstring": "Generates the instructions to swap the top two stack values.\n\n@param prev\ntype of the top - 1 stack value.\n@param type\ntype of the top stack value.", "docstring_tokens": ["Generates", "the", "instructions", "to", "swap", "the", "top", "two", "stack", "values", "."]}
{"code": "frame[frameIndex++] = 6;", "comments": "Opcodes.UNINITIALIZED_THIS;", "lines": 8, "repo": "nutzam/nutz", "path": "src/org/nutz/repo/org/objectweb/asm/MethodWriter.java", "func_name": "MethodWriter.visitImplicitFirstFrame", "original_string": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "language": "java", "Allcodes": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "code_tokens": ["private", "void", "visitImplicitFirstFrame", "(", ")", "{", "// There can be at most descriptor.length() + 1 locals", "int", "frameIndex", "=", "startFrame", "(", "0", ",", "descriptor", ".", "length", "(", ")", "+", "1", ",", "0", ")", ";", "if", "(", "(", "access", "&", "Opcodes", ".", "ACC_STATIC", ")", "==", "0", ")", "{", "if", "(", "(", "access", "&", "ACC_CONSTRUCTOR", ")", "==", "0", ")", "{", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "cw", ".", "thisName", ")", ";", "}", "else", "{", "frame", "[", "frameIndex", "++", "]", "=", "6", ";", "// Opcodes.UNINITIALIZED_THIS;", "}", "}", "int", "i", "=", "1", ";", "loop", ":", "while", "(", "true", ")", "{", "int", "j", "=", "i", ";", "switch", "(", "descriptor", ".", "charAt", "(", "i", "++", ")", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "1", ";", "// Opcodes.INTEGER;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "2", ";", "// Opcodes.FLOAT;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "4", ";", "// Opcodes.LONG;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "3", ";", "// Opcodes.DOUBLE;", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "}", "if", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", ",", "++", "i", ")", ")", ";", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", "+", "1", ",", "i", "++", ")", ")", ";", "break", ";", "default", ":", "break", "loop", ";", "}", "}", "frame", "[", "1", "]", "=", "frameIndex", "-", "3", ";", "endFrame", "(", ")", ";", "}"], "docstring": "Visit the implicit first frame of this method.", "docstring_tokens": ["Visit", "the", "implicit", "first", "frame", "of", "this", "method", "."]}
{"code": "frame[frameIndex++] = 1;", "comments": "Opcodes.INTEGER;", "lines": 20, "repo": "nutzam/nutz", "path": "src/org/nutz/repo/org/objectweb/asm/MethodWriter.java", "func_name": "MethodWriter.visitImplicitFirstFrame", "original_string": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "language": "java", "Allcodes": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "code_tokens": ["private", "void", "visitImplicitFirstFrame", "(", ")", "{", "// There can be at most descriptor.length() + 1 locals", "int", "frameIndex", "=", "startFrame", "(", "0", ",", "descriptor", ".", "length", "(", ")", "+", "1", ",", "0", ")", ";", "if", "(", "(", "access", "&", "Opcodes", ".", "ACC_STATIC", ")", "==", "0", ")", "{", "if", "(", "(", "access", "&", "ACC_CONSTRUCTOR", ")", "==", "0", ")", "{", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "cw", ".", "thisName", ")", ";", "}", "else", "{", "frame", "[", "frameIndex", "++", "]", "=", "6", ";", "// Opcodes.UNINITIALIZED_THIS;", "}", "}", "int", "i", "=", "1", ";", "loop", ":", "while", "(", "true", ")", "{", "int", "j", "=", "i", ";", "switch", "(", "descriptor", ".", "charAt", "(", "i", "++", ")", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "1", ";", "// Opcodes.INTEGER;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "2", ";", "// Opcodes.FLOAT;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "4", ";", "// Opcodes.LONG;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "3", ";", "// Opcodes.DOUBLE;", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "}", "if", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", ",", "++", "i", ")", ")", ";", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", "+", "1", ",", "i", "++", ")", ")", ";", "break", ";", "default", ":", "break", "loop", ";", "}", "}", "frame", "[", "1", "]", "=", "frameIndex", "-", "3", ";", "endFrame", "(", ")", ";", "}"], "docstring": "Visit the implicit first frame of this method.", "docstring_tokens": ["Visit", "the", "implicit", "first", "frame", "of", "this", "method", "."]}
{"code": "frame[frameIndex++] = 2;", "comments": "Opcodes.FLOAT;", "lines": 23, "repo": "nutzam/nutz", "path": "src/org/nutz/repo/org/objectweb/asm/MethodWriter.java", "func_name": "MethodWriter.visitImplicitFirstFrame", "original_string": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "language": "java", "Allcodes": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "code_tokens": ["private", "void", "visitImplicitFirstFrame", "(", ")", "{", "// There can be at most descriptor.length() + 1 locals", "int", "frameIndex", "=", "startFrame", "(", "0", ",", "descriptor", ".", "length", "(", ")", "+", "1", ",", "0", ")", ";", "if", "(", "(", "access", "&", "Opcodes", ".", "ACC_STATIC", ")", "==", "0", ")", "{", "if", "(", "(", "access", "&", "ACC_CONSTRUCTOR", ")", "==", "0", ")", "{", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "cw", ".", "thisName", ")", ";", "}", "else", "{", "frame", "[", "frameIndex", "++", "]", "=", "6", ";", "// Opcodes.UNINITIALIZED_THIS;", "}", "}", "int", "i", "=", "1", ";", "loop", ":", "while", "(", "true", ")", "{", "int", "j", "=", "i", ";", "switch", "(", "descriptor", ".", "charAt", "(", "i", "++", ")", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "1", ";", "// Opcodes.INTEGER;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "2", ";", "// Opcodes.FLOAT;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "4", ";", "// Opcodes.LONG;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "3", ";", "// Opcodes.DOUBLE;", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "}", "if", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", ",", "++", "i", ")", ")", ";", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", "+", "1", ",", "i", "++", ")", ")", ";", "break", ";", "default", ":", "break", "loop", ";", "}", "}", "frame", "[", "1", "]", "=", "frameIndex", "-", "3", ";", "endFrame", "(", ")", ";", "}"], "docstring": "Visit the implicit first frame of this method.", "docstring_tokens": ["Visit", "the", "implicit", "first", "frame", "of", "this", "method", "."]}
{"code": "frame[frameIndex++] = 4;", "comments": "Opcodes.LONG;", "lines": 26, "repo": "nutzam/nutz", "path": "src/org/nutz/repo/org/objectweb/asm/MethodWriter.java", "func_name": "MethodWriter.visitImplicitFirstFrame", "original_string": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "language": "java", "Allcodes": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "code_tokens": ["private", "void", "visitImplicitFirstFrame", "(", ")", "{", "// There can be at most descriptor.length() + 1 locals", "int", "frameIndex", "=", "startFrame", "(", "0", ",", "descriptor", ".", "length", "(", ")", "+", "1", ",", "0", ")", ";", "if", "(", "(", "access", "&", "Opcodes", ".", "ACC_STATIC", ")", "==", "0", ")", "{", "if", "(", "(", "access", "&", "ACC_CONSTRUCTOR", ")", "==", "0", ")", "{", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "cw", ".", "thisName", ")", ";", "}", "else", "{", "frame", "[", "frameIndex", "++", "]", "=", "6", ";", "// Opcodes.UNINITIALIZED_THIS;", "}", "}", "int", "i", "=", "1", ";", "loop", ":", "while", "(", "true", ")", "{", "int", "j", "=", "i", ";", "switch", "(", "descriptor", ".", "charAt", "(", "i", "++", ")", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "1", ";", "// Opcodes.INTEGER;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "2", ";", "// Opcodes.FLOAT;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "4", ";", "// Opcodes.LONG;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "3", ";", "// Opcodes.DOUBLE;", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "}", "if", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", ",", "++", "i", ")", ")", ";", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", "+", "1", ",", "i", "++", ")", ")", ";", "break", ";", "default", ":", "break", "loop", ";", "}", "}", "frame", "[", "1", "]", "=", "frameIndex", "-", "3", ";", "endFrame", "(", ")", ";", "}"], "docstring": "Visit the implicit first frame of this method.", "docstring_tokens": ["Visit", "the", "implicit", "first", "frame", "of", "this", "method", "."]}
{"code": "frame[frameIndex++] = 3;", "comments": "Opcodes.DOUBLE;", "lines": 29, "repo": "nutzam/nutz", "path": "src/org/nutz/repo/org/objectweb/asm/MethodWriter.java", "func_name": "MethodWriter.visitImplicitFirstFrame", "original_string": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "language": "java", "Allcodes": "private void visitImplicitFirstFrame() {\n        // There can be at most descriptor.length() + 1 locals\n        int frameIndex = startFrame(0, descriptor.length() + 1, 0);\n        if ((access & Opcodes.ACC_STATIC) == 0) {\n            if ((access & ACC_CONSTRUCTOR) == 0) {\n                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);\n            } else {\n                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;\n            }\n        }\n        int i = 1;\n        loop: while (true) {\n            int j = i;\n            switch (descriptor.charAt(i++)) {\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                frame[frameIndex++] = 1; // Opcodes.INTEGER;\n                break;\n            case 'F':\n                frame[frameIndex++] = 2; // Opcodes.FLOAT;\n                break;\n            case 'J':\n                frame[frameIndex++] = 4; // Opcodes.LONG;\n                break;\n            case 'D':\n                frame[frameIndex++] = 3; // Opcodes.DOUBLE;\n                break;\n            case '[':\n                while (descriptor.charAt(i) == '[') {\n                    ++i;\n                }\n                if (descriptor.charAt(i) == 'L') {\n                    ++i;\n                    while (descriptor.charAt(i) != ';') {\n                        ++i;\n                    }\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j, ++i));\n                break;\n            case 'L':\n                while (descriptor.charAt(i) != ';') {\n                    ++i;\n                }\n                frame[frameIndex++] = Frame.OBJECT\n                        | cw.addType(descriptor.substring(j + 1, i++));\n                break;\n            default:\n                break loop;\n            }\n        }\n        frame[1] = frameIndex - 3;\n        endFrame();\n    }", "code_tokens": ["private", "void", "visitImplicitFirstFrame", "(", ")", "{", "// There can be at most descriptor.length() + 1 locals", "int", "frameIndex", "=", "startFrame", "(", "0", ",", "descriptor", ".", "length", "(", ")", "+", "1", ",", "0", ")", ";", "if", "(", "(", "access", "&", "Opcodes", ".", "ACC_STATIC", ")", "==", "0", ")", "{", "if", "(", "(", "access", "&", "ACC_CONSTRUCTOR", ")", "==", "0", ")", "{", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "cw", ".", "thisName", ")", ";", "}", "else", "{", "frame", "[", "frameIndex", "++", "]", "=", "6", ";", "// Opcodes.UNINITIALIZED_THIS;", "}", "}", "int", "i", "=", "1", ";", "loop", ":", "while", "(", "true", ")", "{", "int", "j", "=", "i", ";", "switch", "(", "descriptor", ".", "charAt", "(", "i", "++", ")", ")", "{", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "1", ";", "// Opcodes.INTEGER;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "2", ";", "// Opcodes.FLOAT;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "4", ";", "// Opcodes.LONG;", "break", ";", "case", "'", "'", ":", "frame", "[", "frameIndex", "++", "]", "=", "3", ";", "// Opcodes.DOUBLE;", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "}", "if", "(", "descriptor", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "++", "i", ";", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", ",", "++", "i", ")", ")", ";", "break", ";", "case", "'", "'", ":", "while", "(", "descriptor", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "++", "i", ";", "}", "frame", "[", "frameIndex", "++", "]", "=", "Frame", ".", "OBJECT", "|", "cw", ".", "addType", "(", "descriptor", ".", "substring", "(", "j", "+", "1", ",", "i", "++", ")", ")", ";", "break", ";", "default", ":", "break", "loop", ";", "}", "}", "frame", "[", "1", "]", "=", "frameIndex", "-", "3", ";", "endFrame", "(", ")", ";", "}"], "docstring": "Visit the implicit first frame of this method.", "docstring_tokens": ["Visit", "the", "implicit", "first", "frame", "of", "this", "method", "."]}
{"code": "int i = 1;", "comments": "index starts from 1", "lines": 3, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/statement/ExecutablePreparedStatementBase.java", "func_name": "ExecutablePreparedStatementBase.attachParams", "original_string": "protected void attachParams(List<ColumnConfig> cols, PreparedStatement stmt)\n            throws SQLException, DatabaseException {\n        int i = 1;  // index starts from 1\n        for (ColumnConfig col : cols) {\n            LOG.fine(LogType.LOG, \"Applying column parameter = \" + i + \" for column \" + col.getName());\n            applyColumnParameter(stmt, i, col);\n            i++;\n        }\n    }", "language": "java", "Allcodes": "protected void attachParams(List<ColumnConfig> cols, PreparedStatement stmt)\n            throws SQLException, DatabaseException {\n        int i = 1;  // index starts from 1\n        for (ColumnConfig col : cols) {\n            LOG.fine(LogType.LOG, \"Applying column parameter = \" + i + \" for column \" + col.getName());\n            applyColumnParameter(stmt, i, col);\n            i++;\n        }\n    }", "code_tokens": ["protected", "void", "attachParams", "(", "List", "<", "ColumnConfig", ">", "cols", ",", "PreparedStatement", "stmt", ")", "throws", "SQLException", ",", "DatabaseException", "{", "int", "i", "=", "1", ";", "// index starts from 1", "for", "(", "ColumnConfig", "col", ":", "cols", ")", "{", "LOG", ".", "fine", "(", "LogType", ".", "LOG", ",", "\"Applying column parameter = \"", "+", "i", "+", "\" for column \"", "+", "col", ".", "getName", "(", ")", ")", ";", "applyColumnParameter", "(", "stmt", ",", "i", ",", "col", ")", ";", "i", "++", ";", "}", "}"], "docstring": "Sets the list of bind variables for the execution of a DML statement\n@param cols a list of columns with their designated values\n@param stmt the PreparedStatement to which the values are to be attached\n@throws SQLException if JDBC objects to a setting (non-existent bind number, wrong column type etc.)\n@throws DatabaseException if an I/O error occurs during the read of LOB values", "docstring_tokens": ["Sets", "the", "list", "of", "bind", "variables", "for", "the", "execution", "of", "a", "DML", "statement"]}
{"code": "StringBuilder sb = new StringBuilder(nextLine.length * 2);", "comments": "This is for the worse case where all elements have to be escaped.", "lines": 7, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/csv/opencsv/CSVWriter.java", "func_name": "CSVWriter.writeNext", "original_string": "public void writeNext(String[] nextLine, boolean applyQuotesToAll) {\n\n      if (nextLine == null) {\n         return;\n      }\n\n      StringBuilder sb = new StringBuilder(nextLine.length * 2); // This is for the worse case where all elements have to be escaped.\n      for (int i = 0; i < nextLine.length; i++) {\n\n         if (i != 0) {\n            sb.append(separator);\n         }\n\n         String nextElement = nextLine[i];\n\n         if (nextElement == null) {\n            continue;\n         }\n\n         Boolean stringContainsSpecialCharacters = stringContainsSpecialCharacters(nextElement);\n\n         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {\n            sb.append(quotechar);\n         }\n\n         if (stringContainsSpecialCharacters) {\n            sb.append(processLine(nextElement));\n         } else {\n            sb.append(nextElement);\n         }\n\n         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {\n            sb.append(quotechar);\n         }\n      }\n\n      sb.append(lineEnd);\n      pw.write(sb.toString());\n   }", "language": "java", "Allcodes": "public void writeNext(String[] nextLine, boolean applyQuotesToAll) {\n\n      if (nextLine == null) {\n         return;\n      }\n\n      StringBuilder sb = new StringBuilder(nextLine.length * 2); // This is for the worse case where all elements have to be escaped.\n      for (int i = 0; i < nextLine.length; i++) {\n\n         if (i != 0) {\n            sb.append(separator);\n         }\n\n         String nextElement = nextLine[i];\n\n         if (nextElement == null) {\n            continue;\n         }\n\n         Boolean stringContainsSpecialCharacters = stringContainsSpecialCharacters(nextElement);\n\n         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {\n            sb.append(quotechar);\n         }\n\n         if (stringContainsSpecialCharacters) {\n            sb.append(processLine(nextElement));\n         } else {\n            sb.append(nextElement);\n         }\n\n         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {\n            sb.append(quotechar);\n         }\n      }\n\n      sb.append(lineEnd);\n      pw.write(sb.toString());\n   }", "code_tokens": ["public", "void", "writeNext", "(", "String", "[", "]", "nextLine", ",", "boolean", "applyQuotesToAll", ")", "{", "if", "(", "nextLine", "==", "null", ")", "{", "return", ";", "}", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "nextLine", ".", "length", "*", "2", ")", ";", "// This is for the worse case where all elements have to be escaped.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "nextLine", ".", "length", ";", "i", "++", ")", "{", "if", "(", "i", "!=", "0", ")", "{", "sb", ".", "append", "(", "separator", ")", ";", "}", "String", "nextElement", "=", "nextLine", "[", "i", "]", ";", "if", "(", "nextElement", "==", "null", ")", "{", "continue", ";", "}", "Boolean", "stringContainsSpecialCharacters", "=", "stringContainsSpecialCharacters", "(", "nextElement", ")", ";", "if", "(", "(", "applyQuotesToAll", "||", "stringContainsSpecialCharacters", ")", "&&", "(", "quotechar", "!=", "NO_QUOTE_CHARACTER", ")", ")", "{", "sb", ".", "append", "(", "quotechar", ")", ";", "}", "if", "(", "stringContainsSpecialCharacters", ")", "{", "sb", ".", "append", "(", "processLine", "(", "nextElement", ")", ")", ";", "}", "else", "{", "sb", ".", "append", "(", "nextElement", ")", ";", "}", "if", "(", "(", "applyQuotesToAll", "||", "stringContainsSpecialCharacters", ")", "&&", "(", "quotechar", "!=", "NO_QUOTE_CHARACTER", ")", ")", "{", "sb", ".", "append", "(", "quotechar", ")", ";", "}", "}", "sb", ".", "append", "(", "lineEnd", ")", ";", "pw", ".", "write", "(", "sb", ".", "toString", "(", ")", ")", ";", "}"], "docstring": "Writes the next line to the file.\n\n@param nextLine         a string array with each comma-separated element as a separate\nentry.\n@param applyQuotesToAll true if all values are to be quoted.  false applies quotes only\nto values which contain the separator, escape, quote or new line characters.", "docstring_tokens": ["Writes", "the", "next", "line", "to", "the", "file", "."]}
{"code": "StringBuilder sb = new StringBuilder(nextElement.length() * 2);", "comments": "this is for the worse case where all elements have to be escaped.", "lines": 2, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/csv/opencsv/CSVWriter.java", "func_name": "CSVWriter.processLine", "original_string": "protected StringBuilder processLine(String nextElement) {\n      StringBuilder sb = new StringBuilder(nextElement.length() * 2); // this is for the worse case where all elements have to be escaped.\n      for (int j = 0; j < nextElement.length(); j++) {\n         char nextChar = nextElement.charAt(j);\n         processCharacter(sb, nextChar);\n      }\n\n      return sb;\n   }", "language": "java", "Allcodes": "protected StringBuilder processLine(String nextElement) {\n      StringBuilder sb = new StringBuilder(nextElement.length() * 2); // this is for the worse case where all elements have to be escaped.\n      for (int j = 0; j < nextElement.length(); j++) {\n         char nextChar = nextElement.charAt(j);\n         processCharacter(sb, nextChar);\n      }\n\n      return sb;\n   }", "code_tokens": ["protected", "StringBuilder", "processLine", "(", "String", "nextElement", ")", "{", "StringBuilder", "sb", "=", "new", "StringBuilder", "(", "nextElement", ".", "length", "(", ")", "*", "2", ")", ";", "// this is for the worse case where all elements have to be escaped.", "for", "(", "int", "j", "=", "0", ";", "j", "<", "nextElement", ".", "length", "(", ")", ";", "j", "++", ")", "{", "char", "nextChar", "=", "nextElement", ".", "charAt", "(", "j", ")", ";", "processCharacter", "(", "sb", ",", "nextChar", ")", ";", "}", "return", "sb", ";", "}"], "docstring": "Processes all the characters in a line.\n@param nextElement - element to process.\n@return a StringBuilder with the elements data.", "docstring_tokens": ["Processes", "all", "the", "characters", "in", "a", "line", "."]}
{"code": "+ \"[ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$]{0,30}$\";", "comments": "following characters", "lines": 12, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/sqlgenerator/core/CreateIndexGeneratorFirebird.java", "func_name": "CreateIndexGeneratorFirebird.applyIsComputedExpressionHeuristic", "original_string": "private boolean applyIsComputedExpressionHeuristic(ColumnConfig column, Database database) {\n        String expr = column.getName();\n\n        /*\n         * https://firebirdsql.org/file/documentation/reference_manuals/fblangref25-en/html/fblangref25-structure-identifiers.html\n         * says the following about what makes a valid identifier in Firebird:\n         * - At most 31 chars\n         * - Starts with a 7-bit character\n         * - After that, letters, digits, underscores or dollar signs are valid characters\n         */\n        String regex = \"^(?i)[ABCDEFGHIJKLMNOPQRSTUVWXYZ]\" // Starting character\n                + \"[ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$]{0,30}$\"; // following characters\n        if (!expr.matches(regex))\n            return true;\n\n        /* At this point, we know that expr at least has the form of an identifier. If it is a function, it must\n         * be in the list of database functions.\n         */\n        if (database.isFunction(expr))\n            return true;\n        else\n            return false;\n    }", "language": "java", "Allcodes": "private boolean applyIsComputedExpressionHeuristic(ColumnConfig column, Database database) {\n        String expr = column.getName();\n\n        /*\n         * https://firebirdsql.org/file/documentation/reference_manuals/fblangref25-en/html/fblangref25-structure-identifiers.html\n         * says the following about what makes a valid identifier in Firebird:\n         * - At most 31 chars\n         * - Starts with a 7-bit character\n         * - After that, letters, digits, underscores or dollar signs are valid characters\n         */\n        String regex = \"^(?i)[ABCDEFGHIJKLMNOPQRSTUVWXYZ]\" // Starting character\n                + \"[ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$]{0,30}$\"; // following characters\n        if (!expr.matches(regex))\n            return true;\n\n        /* At this point, we know that expr at least has the form of an identifier. If it is a function, it must\n         * be in the list of database functions.\n         */\n        if (database.isFunction(expr))\n            return true;\n        else\n            return false;\n    }", "code_tokens": ["private", "boolean", "applyIsComputedExpressionHeuristic", "(", "ColumnConfig", "column", ",", "Database", "database", ")", "{", "String", "expr", "=", "column", ".", "getName", "(", ")", ";", "/*\n         * https://firebirdsql.org/file/documentation/reference_manuals/fblangref25-en/html/fblangref25-structure-identifiers.html\n         * says the following about what makes a valid identifier in Firebird:\n         * - At most 31 chars\n         * - Starts with a 7-bit character\n         * - After that, letters, digits, underscores or dollar signs are valid characters\n         */", "String", "regex", "=", "\"^(?i)[ABCDEFGHIJKLMNOPQRSTUVWXYZ]\"", "// Starting character", "+", "\"[ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$]{0,30}$\"", ";", "// following characters", "if", "(", "!", "expr", ".", "matches", "(", "regex", ")", ")", "return", "true", ";", "/* At this point, we know that expr at least has the form of an identifier. If it is a function, it must\n         * be in the list of database functions.\n         */", "if", "(", "database", ".", "isFunction", "(", "expr", ")", ")", "return", "true", ";", "else", "return", "false", ";", "}"], "docstring": "An imperfect heuristic to determine if an expression is more likely a column name or a computed expression.\n@return true if it is more likely an expression, false if it is more likely a column name (identifier).", "docstring_tokens": ["An", "imperfect", "heuristic", "to", "determine", "if", "an", "expression", "is", "more", "likely", "a", "column", "name", "or", "a", "computed", "expression", "."]}
{"code": "return false;", "comments": "/ assume not;", "lines": 3, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/database/core/DB2Database.java", "func_name": "DB2Database.supportsBooleanDataType", "original_string": "public boolean supportsBooleanDataType() {\n\t\tif (getConnection() == null)\n\t\t\treturn false; /// assume not;\n\t\ttry {\n\n\t\t\tfinal Integer fixPack = getDb2FixPack();\n\n\t\t\tif (fixPack == null)\n\t\t\t\tthrow new DatabaseException(\"Error getting fix pack number\");\n\n\t\t\treturn getDatabaseMajorVersion() > 11\n\t\t\t\t\t|| getDatabaseMajorVersion() == 11 && getDatabaseMinorVersion() >= 1 && fixPack.intValue() >= 1;\n\n\t\t} catch (final DatabaseException e) {\n\t\t\treturn false; // assume not\n\t\t}\n\t}", "language": "java", "Allcodes": "public boolean supportsBooleanDataType() {\n\t\tif (getConnection() == null)\n\t\t\treturn false; /// assume not;\n\t\ttry {\n\n\t\t\tfinal Integer fixPack = getDb2FixPack();\n\n\t\t\tif (fixPack == null)\n\t\t\t\tthrow new DatabaseException(\"Error getting fix pack number\");\n\n\t\t\treturn getDatabaseMajorVersion() > 11\n\t\t\t\t\t|| getDatabaseMajorVersion() == 11 && getDatabaseMinorVersion() >= 1 && fixPack.intValue() >= 1;\n\n\t\t} catch (final DatabaseException e) {\n\t\t\treturn false; // assume not\n\t\t}\n\t}", "code_tokens": ["public", "boolean", "supportsBooleanDataType", "(", ")", "{", "if", "(", "getConnection", "(", ")", "==", "null", ")", "return", "false", ";", "/// assume not;", "try", "{", "final", "Integer", "fixPack", "=", "getDb2FixPack", "(", ")", ";", "if", "(", "fixPack", "==", "null", ")", "throw", "new", "DatabaseException", "(", "\"Error getting fix pack number\"", ")", ";", "return", "getDatabaseMajorVersion", "(", ")", ">", "11", "||", "getDatabaseMajorVersion", "(", ")", "==", "11", "&&", "getDatabaseMinorVersion", "(", ")", ">=", "1", "&&", "fixPack", ".", "intValue", "(", ")", ">=", "1", ";", "}", "catch", "(", "final", "DatabaseException", "e", ")", "{", "return", "false", ";", "// assume not", "}", "}"], "docstring": "boolean data type column are allowed for versions >= 11.1.1.1\n@return", "docstring_tokens": ["boolean", "data", "type", "column", "are", "allowed", "for", "versions", ">", "=", "11", ".", "1", ".", "1", ".", "1"]}
{"code": "return false;", "comments": "assume not", "lines": 15, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/database/core/DB2Database.java", "func_name": "DB2Database.supportsBooleanDataType", "original_string": "public boolean supportsBooleanDataType() {\n\t\tif (getConnection() == null)\n\t\t\treturn false; /// assume not;\n\t\ttry {\n\n\t\t\tfinal Integer fixPack = getDb2FixPack();\n\n\t\t\tif (fixPack == null)\n\t\t\t\tthrow new DatabaseException(\"Error getting fix pack number\");\n\n\t\t\treturn getDatabaseMajorVersion() > 11\n\t\t\t\t\t|| getDatabaseMajorVersion() == 11 && getDatabaseMinorVersion() >= 1 && fixPack.intValue() >= 1;\n\n\t\t} catch (final DatabaseException e) {\n\t\t\treturn false; // assume not\n\t\t}\n\t}", "language": "java", "Allcodes": "public boolean supportsBooleanDataType() {\n\t\tif (getConnection() == null)\n\t\t\treturn false; /// assume not;\n\t\ttry {\n\n\t\t\tfinal Integer fixPack = getDb2FixPack();\n\n\t\t\tif (fixPack == null)\n\t\t\t\tthrow new DatabaseException(\"Error getting fix pack number\");\n\n\t\t\treturn getDatabaseMajorVersion() > 11\n\t\t\t\t\t|| getDatabaseMajorVersion() == 11 && getDatabaseMinorVersion() >= 1 && fixPack.intValue() >= 1;\n\n\t\t} catch (final DatabaseException e) {\n\t\t\treturn false; // assume not\n\t\t}\n\t}", "code_tokens": ["public", "boolean", "supportsBooleanDataType", "(", ")", "{", "if", "(", "getConnection", "(", ")", "==", "null", ")", "return", "false", ";", "/// assume not;", "try", "{", "final", "Integer", "fixPack", "=", "getDb2FixPack", "(", ")", ";", "if", "(", "fixPack", "==", "null", ")", "throw", "new", "DatabaseException", "(", "\"Error getting fix pack number\"", ")", ";", "return", "getDatabaseMajorVersion", "(", ")", ">", "11", "||", "getDatabaseMajorVersion", "(", ")", "==", "11", "&&", "getDatabaseMinorVersion", "(", ")", ">=", "1", "&&", "fixPack", ".", "intValue", "(", ")", ">=", "1", ";", "}", "catch", "(", "final", "DatabaseException", "e", ")", "{", "return", "false", ";", "// assume not", "}", "}"], "docstring": "boolean data type column are allowed for versions >= 11.1.1.1\n@return", "docstring_tokens": ["boolean", "data", "type", "column", "are", "allowed", "for", "versions", ">", "=", "11", ".", "1", ".", "1", ".", "1"]}
{"code": "changeLogDirectory = changeLogDirectory.trim().replace('\\\\', '/');", "comments": "convert to standard / if using absolute path on windows", "lines": 7, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/integration/ant/BaseLiquibaseTask.java", "func_name": "BaseLiquibaseTask.createResourceAccessor", "original_string": "private ResourceAccessor createResourceAccessor(ClassLoader classLoader) {\n        List<ResourceAccessor> resourceAccessors = new ArrayList<ResourceAccessor>();\n        resourceAccessors.add(new FileSystemResourceAccessor(Paths.get(\".\").toAbsolutePath().getRoot().toFile()));\n        resourceAccessors.add(new ClassLoaderResourceAccessor(classLoader));\n        String changeLogDirectory = getChangeLogDirectory();\n        if (changeLogDirectory != null) {\n          changeLogDirectory = changeLogDirectory.trim().replace('\\\\', '/');  //convert to standard / if using absolute path on windows\n          resourceAccessors.add(new FileSystemResourceAccessor(new File(changeLogDirectory)));\n        }\n        return new CompositeResourceAccessor(resourceAccessors.toArray(new ResourceAccessor[0]));\n    }", "language": "java", "Allcodes": "private ResourceAccessor createResourceAccessor(ClassLoader classLoader) {\n        List<ResourceAccessor> resourceAccessors = new ArrayList<ResourceAccessor>();\n        resourceAccessors.add(new FileSystemResourceAccessor(Paths.get(\".\").toAbsolutePath().getRoot().toFile()));\n        resourceAccessors.add(new ClassLoaderResourceAccessor(classLoader));\n        String changeLogDirectory = getChangeLogDirectory();\n        if (changeLogDirectory != null) {\n          changeLogDirectory = changeLogDirectory.trim().replace('\\\\', '/');  //convert to standard / if using absolute path on windows\n          resourceAccessors.add(new FileSystemResourceAccessor(new File(changeLogDirectory)));\n        }\n        return new CompositeResourceAccessor(resourceAccessors.toArray(new ResourceAccessor[0]));\n    }", "code_tokens": ["private", "ResourceAccessor", "createResourceAccessor", "(", "ClassLoader", "classLoader", ")", "{", "List", "<", "ResourceAccessor", ">", "resourceAccessors", "=", "new", "ArrayList", "<", "ResourceAccessor", ">", "(", ")", ";", "resourceAccessors", ".", "add", "(", "new", "FileSystemResourceAccessor", "(", "Paths", ".", "get", "(", "\".\"", ")", ".", "toAbsolutePath", "(", ")", ".", "getRoot", "(", ")", ".", "toFile", "(", ")", ")", ")", ";", "resourceAccessors", ".", "add", "(", "new", "ClassLoaderResourceAccessor", "(", "classLoader", ")", ")", ";", "String", "changeLogDirectory", "=", "getChangeLogDirectory", "(", ")", ";", "if", "(", "changeLogDirectory", "!=", "null", ")", "{", "changeLogDirectory", "=", "changeLogDirectory", ".", "trim", "(", ")", ".", "replace", "(", "'", "'", ",", "'", "'", ")", ";", "//convert to standard / if using absolute path on windows", "resourceAccessors", ".", "add", "(", "new", "FileSystemResourceAccessor", "(", "new", "File", "(", "changeLogDirectory", ")", ")", ")", ";", "}", "return", "new", "CompositeResourceAccessor", "(", "resourceAccessors", ".", "toArray", "(", "new", "ResourceAccessor", "[", "0", "]", ")", ")", ";", "}"], "docstring": "Creates a suitable ResourceAccessor for use in an Ant task..\n\n@param classLoader The ClassLoader to use in the ResourceAccessor. It is preferable that it is an AntClassLoader.\n@return A ResourceAccessor.", "docstring_tokens": ["Creates", "a", "suitable", "ResourceAccessor", "for", "use", "in", "an", "Ant", "task", ".."]}
{"code": "return getPrefix(filename);", "comments": "add end slash if necessary", "lines": 11, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/file/FilenameUtils.java", "func_name": "FilenameUtils.doGetFullPath", "original_string": "private static String doGetFullPath(String filename, boolean includeSeparator) {\n        if (filename == null) {\n            return null;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= filename.length()) {\n            if (includeSeparator) {\n                return getPrefix(filename);  // add end slash if necessary\n            } else {\n                return filename;\n            }\n        }\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return filename.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        return filename.substring(0, end);\n    }", "language": "java", "Allcodes": "private static String doGetFullPath(String filename, boolean includeSeparator) {\n        if (filename == null) {\n            return null;\n        }\n        int prefix = getPrefixLength(filename);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= filename.length()) {\n            if (includeSeparator) {\n                return getPrefix(filename);  // add end slash if necessary\n            } else {\n                return filename;\n            }\n        }\n        int index = indexOfLastSeparator(filename);\n        if (index < 0) {\n            return filename.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        return filename.substring(0, end);\n    }", "code_tokens": ["private", "static", "String", "doGetFullPath", "(", "String", "filename", ",", "boolean", "includeSeparator", ")", "{", "if", "(", "filename", "==", "null", ")", "{", "return", "null", ";", "}", "int", "prefix", "=", "getPrefixLength", "(", "filename", ")", ";", "if", "(", "prefix", "<", "0", ")", "{", "return", "null", ";", "}", "if", "(", "prefix", ">=", "filename", ".", "length", "(", ")", ")", "{", "if", "(", "includeSeparator", ")", "{", "return", "getPrefix", "(", "filename", ")", ";", "// add end slash if necessary", "}", "else", "{", "return", "filename", ";", "}", "}", "int", "index", "=", "indexOfLastSeparator", "(", "filename", ")", ";", "if", "(", "index", "<", "0", ")", "{", "return", "filename", ".", "substring", "(", "0", ",", "prefix", ")", ";", "}", "int", "end", "=", "index", "+", "(", "includeSeparator", "?", "1", ":", "0", ")", ";", "return", "filename", ".", "substring", "(", "0", ",", "end", ")", ";", "}"], "docstring": "Does the work of getting the path.\n\n@param filename  the filename\n@param includeSeparator  true to include the end separator\n@return the path", "docstring_tokens": ["Does", "the", "work", "of", "getting", "the", "path", "."]}
{"code": "descriptorMap = loadDescriptorMap();", "comments": "lazy load descriptors", "lines": 3, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/csv/opencsv/bean/HeaderColumnNameMappingStrategy.java", "func_name": "HeaderColumnNameMappingStrategy.findDescriptor", "original_string": "protected PropertyDescriptor findDescriptor(String name) throws IntrospectionException {\n      if (null == descriptorMap) {\n         descriptorMap = loadDescriptorMap(); //lazy load descriptors\n      }\n      return descriptorMap.get(name.toUpperCase().trim());\n   }", "language": "java", "Allcodes": "protected PropertyDescriptor findDescriptor(String name) throws IntrospectionException {\n      if (null == descriptorMap) {\n         descriptorMap = loadDescriptorMap(); //lazy load descriptors\n      }\n      return descriptorMap.get(name.toUpperCase().trim());\n   }", "code_tokens": ["protected", "PropertyDescriptor", "findDescriptor", "(", "String", "name", ")", "throws", "IntrospectionException", "{", "if", "(", "null", "==", "descriptorMap", ")", "{", "descriptorMap", "=", "loadDescriptorMap", "(", ")", ";", "//lazy load descriptors", "}", "return", "descriptorMap", ".", "get", "(", "name", ".", "toUpperCase", "(", ")", ".", "trim", "(", ")", ")", ";", "}"], "docstring": "Find the property descriptor for a given column.\n@param name - column name to look up.\n@return - the property descriptor for the column.\n@throws IntrospectionException - thrown on error loading the property descriptors.", "docstring_tokens": ["Find", "the", "property", "descriptor", "for", "a", "given", "column", "."]}
{"code": "fieldMap = loadFieldMap();", "comments": "lazy load fields", "lines": 3, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/csv/opencsv/bean/HeaderColumnNameMappingStrategy.java", "func_name": "HeaderColumnNameMappingStrategy.findField", "original_string": "protected BeanField findField(String name) {\n      if (null == fieldMap) {\n         fieldMap = loadFieldMap(); //lazy load fields\n      }\n      return fieldMap.get(name.toUpperCase().trim());\n   }", "language": "java", "Allcodes": "protected BeanField findField(String name) {\n      if (null == fieldMap) {\n         fieldMap = loadFieldMap(); //lazy load fields\n      }\n      return fieldMap.get(name.toUpperCase().trim());\n   }", "code_tokens": ["protected", "BeanField", "findField", "(", "String", "name", ")", "{", "if", "(", "null", "==", "fieldMap", ")", "{", "fieldMap", "=", "loadFieldMap", "(", ")", ";", "//lazy load fields", "}", "return", "fieldMap", ".", "get", "(", "name", ".", "toUpperCase", "(", ")", ".", "trim", "(", ")", ")", ";", "}"], "docstring": "Find the field for a given column.\n\n@param name - the column name to look up.\n@return - BeanField containing the field - and whether it is mandatory - for the column.", "docstring_tokens": ["Find", "the", "field", "for", "a", "given", "column", "."]}
{"code": "finalName = (String) procNameClause;", "comments": "just go with what was there", "lines": 27, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/sqlgenerator/core/CreateProcedureGenerator.java", "func_name": "CreateProcedureGenerator.addSchemaToText", "original_string": "public static String addSchemaToText(String procedureText, String schemaName, String keywordBeforeName, Database database) {\n        if (schemaName == null) {\n            return procedureText;\n        }\n        if ((StringUtil.trimToNull(schemaName) != null) && LiquibaseConfiguration.getInstance().getProperty(ChangeLogParserCofiguration.class, ChangeLogParserCofiguration.USE_PROCEDURE_SCHEMA).getValue(Boolean.class)) {\n            StringClauses parsedSql = SqlParser.parse(procedureText, true, true);\n            StringClauses.ClauseIterator clauseIterator = parsedSql.getClauseIterator();\n            Object next = \"START\";\n            while ((next != null) && !next.toString().equalsIgnoreCase(keywordBeforeName) && clauseIterator.hasNext()) {\n                if (!\"PACKAGE\".equalsIgnoreCase(keywordBeforeName) && \"PACKAGE\".equalsIgnoreCase((String) next)) {\n                    return procedureText;\n                }\n                next = clauseIterator.nextNonWhitespace();\n            }\n            if ((next != null) && clauseIterator.hasNext()) {\n                Object procNameClause = clauseIterator.nextNonWhitespace();\n                if (procNameClause instanceof String) {\n                    String[] nameParts = ((String) procNameClause).split(\"\\\\.\");\n                    String finalName;\n                    if (nameParts.length == 1) {\n                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[0];\n                    } else if (nameParts.length == 2) {\n                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[1];\n                    } else if (nameParts.length == 3) {\n                        finalName = nameParts[0] + \".\" + database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[2];\n                    } else {\n                        finalName = (String) procNameClause; //just go with what was there\n                    }\n                    clauseIterator.replace(finalName);\n                }\n                procedureText = parsedSql.toString();\n            }\n        }\n        return procedureText;\n    }", "language": "java", "Allcodes": "public static String addSchemaToText(String procedureText, String schemaName, String keywordBeforeName, Database database) {\n        if (schemaName == null) {\n            return procedureText;\n        }\n        if ((StringUtil.trimToNull(schemaName) != null) && LiquibaseConfiguration.getInstance().getProperty(ChangeLogParserCofiguration.class, ChangeLogParserCofiguration.USE_PROCEDURE_SCHEMA).getValue(Boolean.class)) {\n            StringClauses parsedSql = SqlParser.parse(procedureText, true, true);\n            StringClauses.ClauseIterator clauseIterator = parsedSql.getClauseIterator();\n            Object next = \"START\";\n            while ((next != null) && !next.toString().equalsIgnoreCase(keywordBeforeName) && clauseIterator.hasNext()) {\n                if (!\"PACKAGE\".equalsIgnoreCase(keywordBeforeName) && \"PACKAGE\".equalsIgnoreCase((String) next)) {\n                    return procedureText;\n                }\n                next = clauseIterator.nextNonWhitespace();\n            }\n            if ((next != null) && clauseIterator.hasNext()) {\n                Object procNameClause = clauseIterator.nextNonWhitespace();\n                if (procNameClause instanceof String) {\n                    String[] nameParts = ((String) procNameClause).split(\"\\\\.\");\n                    String finalName;\n                    if (nameParts.length == 1) {\n                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[0];\n                    } else if (nameParts.length == 2) {\n                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[1];\n                    } else if (nameParts.length == 3) {\n                        finalName = nameParts[0] + \".\" + database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[2];\n                    } else {\n                        finalName = (String) procNameClause; //just go with what was there\n                    }\n                    clauseIterator.replace(finalName);\n                }\n                procedureText = parsedSql.toString();\n            }\n        }\n        return procedureText;\n    }", "code_tokens": ["public", "static", "String", "addSchemaToText", "(", "String", "procedureText", ",", "String", "schemaName", ",", "String", "keywordBeforeName", ",", "Database", "database", ")", "{", "if", "(", "schemaName", "==", "null", ")", "{", "return", "procedureText", ";", "}", "if", "(", "(", "StringUtil", ".", "trimToNull", "(", "schemaName", ")", "!=", "null", ")", "&&", "LiquibaseConfiguration", ".", "getInstance", "(", ")", ".", "getProperty", "(", "ChangeLogParserCofiguration", ".", "class", ",", "ChangeLogParserCofiguration", ".", "USE_PROCEDURE_SCHEMA", ")", ".", "getValue", "(", "Boolean", ".", "class", ")", ")", "{", "StringClauses", "parsedSql", "=", "SqlParser", ".", "parse", "(", "procedureText", ",", "true", ",", "true", ")", ";", "StringClauses", ".", "ClauseIterator", "clauseIterator", "=", "parsedSql", ".", "getClauseIterator", "(", ")", ";", "Object", "next", "=", "\"START\"", ";", "while", "(", "(", "next", "!=", "null", ")", "&&", "!", "next", ".", "toString", "(", ")", ".", "equalsIgnoreCase", "(", "keywordBeforeName", ")", "&&", "clauseIterator", ".", "hasNext", "(", ")", ")", "{", "if", "(", "!", "\"PACKAGE\"", ".", "equalsIgnoreCase", "(", "keywordBeforeName", ")", "&&", "\"PACKAGE\"", ".", "equalsIgnoreCase", "(", "(", "String", ")", "next", ")", ")", "{", "return", "procedureText", ";", "}", "next", "=", "clauseIterator", ".", "nextNonWhitespace", "(", ")", ";", "}", "if", "(", "(", "next", "!=", "null", ")", "&&", "clauseIterator", ".", "hasNext", "(", ")", ")", "{", "Object", "procNameClause", "=", "clauseIterator", ".", "nextNonWhitespace", "(", ")", ";", "if", "(", "procNameClause", "instanceof", "String", ")", "{", "String", "[", "]", "nameParts", "=", "(", "(", "String", ")", "procNameClause", ")", ".", "split", "(", "\"\\\\.\"", ")", ";", "String", "finalName", ";", "if", "(", "nameParts", ".", "length", "==", "1", ")", "{", "finalName", "=", "database", ".", "escapeObjectName", "(", "schemaName", ",", "Schema", ".", "class", ")", "+", "\".\"", "+", "nameParts", "[", "0", "]", ";", "}", "else", "if", "(", "nameParts", ".", "length", "==", "2", ")", "{", "finalName", "=", "database", ".", "escapeObjectName", "(", "schemaName", ",", "Schema", ".", "class", ")", "+", "\".\"", "+", "nameParts", "[", "1", "]", ";", "}", "else", "if", "(", "nameParts", ".", "length", "==", "3", ")", "{", "finalName", "=", "nameParts", "[", "0", "]", "+", "\".\"", "+", "database", ".", "escapeObjectName", "(", "schemaName", ",", "Schema", ".", "class", ")", "+", "\".\"", "+", "nameParts", "[", "2", "]", ";", "}", "else", "{", "finalName", "=", "(", "String", ")", "procNameClause", ";", "//just go with what was there", "}", "clauseIterator", ".", "replace", "(", "finalName", ")", ";", "}", "procedureText", "=", "parsedSql", ".", "toString", "(", ")", ";", "}", "}", "return", "procedureText", ";", "}"], "docstring": "Convenience method for other classes similar to this that want to be able to modify the procedure text to add the schema", "docstring_tokens": ["Convenience", "method", "for", "other", "classes", "similar", "to", "this", "that", "want", "to", "be", "able", "to", "modify", "the", "procedure", "text", "to", "add", "the", "schema"]}
{"code": "br.reset();", "comments": "resets stream position, possible because its buffered", "lines": 8, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/csv/opencsv/CSVReader.java", "func_name": "CSVReader.isClosed", "original_string": "private boolean isClosed() {\n        if (!verifyReader) {\n            return false;\n        }\n        try {\n            br.mark(READ_AHEAD_LIMIT);\n            int nextByte = br.read();\n            br.reset(); // resets stream position, possible because its buffered\n            return nextByte == -1; // read() returns -1 at end of stream\n        } catch (IOException e) {\n            return true;\n        }\n    }", "language": "java", "Allcodes": "private boolean isClosed() {\n        if (!verifyReader) {\n            return false;\n        }\n        try {\n            br.mark(READ_AHEAD_LIMIT);\n            int nextByte = br.read();\n            br.reset(); // resets stream position, possible because its buffered\n            return nextByte == -1; // read() returns -1 at end of stream\n        } catch (IOException e) {\n            return true;\n        }\n    }", "code_tokens": ["private", "boolean", "isClosed", "(", ")", "{", "if", "(", "!", "verifyReader", ")", "{", "return", "false", ";", "}", "try", "{", "br", ".", "mark", "(", "READ_AHEAD_LIMIT", ")", ";", "int", "nextByte", "=", "br", ".", "read", "(", ")", ";", "br", ".", "reset", "(", ")", ";", "// resets stream position, possible because its buffered", "return", "nextByte", "==", "-", "1", ";", "// read() returns -1 at end of stream", "}", "catch", "(", "IOException", "e", ")", "{", "return", "true", ";", "}", "}"], "docstring": "Checks to see if the file is closed.\n@return true if the reader can no longer be read from.", "docstring_tokens": ["Checks", "to", "see", "if", "the", "file", "is", "closed", "."]}
{"code": "return nextByte == -1;", "comments": "read() returns -1 at end of stream", "lines": 9, "repo": "liquibase/liquibase", "path": "liquibase-core/src/main/java/liquibase/util/csv/opencsv/CSVReader.java", "func_name": "CSVReader.isClosed", "original_string": "private boolean isClosed() {\n        if (!verifyReader) {\n            return false;\n        }\n        try {\n            br.mark(READ_AHEAD_LIMIT);\n            int nextByte = br.read();\n            br.reset(); // resets stream position, possible because its buffered\n            return nextByte == -1; // read() returns -1 at end of stream\n        } catch (IOException e) {\n            return true;\n        }\n    }", "language": "java", "Allcodes": "private boolean isClosed() {\n        if (!verifyReader) {\n            return false;\n        }\n        try {\n            br.mark(READ_AHEAD_LIMIT);\n            int nextByte = br.read();\n            br.reset(); // resets stream position, possible because its buffered\n            return nextByte == -1; // read() returns -1 at end of stream\n        } catch (IOException e) {\n            return true;\n        }\n    }", "code_tokens": ["private", "boolean", "isClosed", "(", ")", "{", "if", "(", "!", "verifyReader", ")", "{", "return", "false", ";", "}", "try", "{", "br", ".", "mark", "(", "READ_AHEAD_LIMIT", ")", ";", "int", "nextByte", "=", "br", ".", "read", "(", ")", ";", "br", ".", "reset", "(", ")", ";", "// resets stream position, possible because its buffered", "return", "nextByte", "==", "-", "1", ";", "// read() returns -1 at end of stream", "}", "catch", "(", "IOException", "e", ")", "{", "return", "true", ";", "}", "}"], "docstring": "Checks to see if the file is closed.\n@return true if the reader can no longer be read from.", "docstring_tokens": ["Checks", "to", "see", "if", "the", "file", "is", "closed", "."]}
{"code": "String uriRegex = propValue;", "comments": "to begin with", "lines": 6, "repo": "Netflix/archaius", "path": "archaius-core/src/main/java/com/netflix/config/util/HttpVerbUriRegexPropertyValue.java", "func_name": "HttpVerbUriRegexPropertyValue.getVerbUriRegex", "original_string": "public static HttpVerbUriRegexPropertyValue getVerbUriRegex(String propValue) {\n        HttpVerbUriRegexPropertyValue returnValue = null;\n        if (propValue != null) {\n            propValue = propValue.trim();\n            int methodSeparatorIndex = propValue.indexOf(METHOD_SEPARATOR);\n            String uriRegex = propValue; // to begin with\n            Verb verb = Verb.ANY_VERB;\n            if (methodSeparatorIndex != -1) {\n                // user may have supplied a verb\n                verb = getVerb(propValue.substring(0, methodSeparatorIndex));\n                if (verb != Verb.ANY_VERB) {\n                    // update uriRegex\n                    uriRegex = propValue.substring(methodSeparatorIndex + 1);\n                }\n            }\n            returnValue = new HttpVerbUriRegexPropertyValue(verb, uriRegex);\n        }\n        return returnValue;\n    }", "language": "java", "Allcodes": "public static HttpVerbUriRegexPropertyValue getVerbUriRegex(String propValue) {\n        HttpVerbUriRegexPropertyValue returnValue = null;\n        if (propValue != null) {\n            propValue = propValue.trim();\n            int methodSeparatorIndex = propValue.indexOf(METHOD_SEPARATOR);\n            String uriRegex = propValue; // to begin with\n            Verb verb = Verb.ANY_VERB;\n            if (methodSeparatorIndex != -1) {\n                // user may have supplied a verb\n                verb = getVerb(propValue.substring(0, methodSeparatorIndex));\n                if (verb != Verb.ANY_VERB) {\n                    // update uriRegex\n                    uriRegex = propValue.substring(methodSeparatorIndex + 1);\n                }\n            }\n            returnValue = new HttpVerbUriRegexPropertyValue(verb, uriRegex);\n        }\n        return returnValue;\n    }", "code_tokens": ["public", "static", "HttpVerbUriRegexPropertyValue", "getVerbUriRegex", "(", "String", "propValue", ")", "{", "HttpVerbUriRegexPropertyValue", "returnValue", "=", "null", ";", "if", "(", "propValue", "!=", "null", ")", "{", "propValue", "=", "propValue", ".", "trim", "(", ")", ";", "int", "methodSeparatorIndex", "=", "propValue", ".", "indexOf", "(", "METHOD_SEPARATOR", ")", ";", "String", "uriRegex", "=", "propValue", ";", "// to begin with", "Verb", "verb", "=", "Verb", ".", "ANY_VERB", ";", "if", "(", "methodSeparatorIndex", "!=", "-", "1", ")", "{", "// user may have supplied a verb", "verb", "=", "getVerb", "(", "propValue", ".", "substring", "(", "0", ",", "methodSeparatorIndex", ")", ")", ";", "if", "(", "verb", "!=", "Verb", ".", "ANY_VERB", ")", "{", "// update uriRegex", "uriRegex", "=", "propValue", ".", "substring", "(", "methodSeparatorIndex", "+", "1", ")", ";", "}", "}", "returnValue", "=", "new", "HttpVerbUriRegexPropertyValue", "(", "verb", ",", "uriRegex", ")", ";", "}", "return", "returnValue", ";", "}"], "docstring": "Expects property value to be of the form &lt;uriRegex&gt; OR &lt;HTTP\nVerb name&gt;&lt;space&gt;&lt;uriRegex&gt;\n\n@param propValue\nproperty value\n@return {@link HttpVerbUriRegexPropertyValue} instance corresponding to\npropValue if propValue is not null, null otherwise", "docstring_tokens": ["Expects", "property", "value", "to", "be", "of", "the", "form", "&lt", ";", "uriRegex&gt", ";", "OR", "&lt", ";", "HTTP", "Verb", "name&gt", ";", "&lt", ";", "space&gt", ";", "&lt", ";", "uriRegex&gt", ";"]}
{"code": "return buffer.array();", "comments": "using .allocate ensures there is a backing array that can be returned", "lines": 4, "repo": "mongodb/mongo-java-driver", "path": "bson/src/main/org/bson/types/ObjectId.java", "func_name": "ObjectId.toByteArray", "original_string": "public byte[] toByteArray() {\n        ByteBuffer buffer = ByteBuffer.allocate(OBJECT_ID_LENGTH);\n        putToByteBuffer(buffer);\n        return buffer.array();  // using .allocate ensures there is a backing array that can be returned\n    }", "language": "java", "Allcodes": "public byte[] toByteArray() {\n        ByteBuffer buffer = ByteBuffer.allocate(OBJECT_ID_LENGTH);\n        putToByteBuffer(buffer);\n        return buffer.array();  // using .allocate ensures there is a backing array that can be returned\n    }", "code_tokens": ["public", "byte", "[", "]", "toByteArray", "(", ")", "{", "ByteBuffer", "buffer", "=", "ByteBuffer", ".", "allocate", "(", "OBJECT_ID_LENGTH", ")", ";", "putToByteBuffer", "(", "buffer", ")", ";", "return", "buffer", ".", "array", "(", ")", ";", "// using .allocate ensures there is a backing array that can be returned", "}"], "docstring": "Convert to a byte array.  Note that the numbers are stored in big-endian order.\n\n@return the byte array", "docstring_tokens": ["Convert", "to", "a", "byte", "array", ".", "Note", "that", "the", "numbers", "are", "stored", "in", "big", "-", "endian", "order", "."]}
{"code": "f.setPrev(this);", "comments": "relink f's prev", "lines": 8, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/ConcurrentLinkedDeque.java", "func_name": "Node.successor", "original_string": "Node<E> successor() {\n            Node<E> f = nextNonmarker();\n            for (;;) {\n                if (f == null)\n                    return null;\n                if (!f.isDeleted()) {\n                    if (f.getPrev() != this && !isDeleted())\n                        f.setPrev(this);       // relink f's prev\n                    return f;\n                }\n                Node<E> s = f.nextNonmarker();\n                if (f == getNext())\n                    casNext(f, s);             // unlink f\n                f = s;\n            }\n        }", "language": "java", "Allcodes": "Node<E> successor() {\n            Node<E> f = nextNonmarker();\n            for (;;) {\n                if (f == null)\n                    return null;\n                if (!f.isDeleted()) {\n                    if (f.getPrev() != this && !isDeleted())\n                        f.setPrev(this);       // relink f's prev\n                    return f;\n                }\n                Node<E> s = f.nextNonmarker();\n                if (f == getNext())\n                    casNext(f, s);             // unlink f\n                f = s;\n            }\n        }", "code_tokens": ["Node", "<", "E", ">", "successor", "(", ")", "{", "Node", "<", "E", ">", "f", "=", "nextNonmarker", "(", ")", ";", "for", "(", ";", ";", ")", "{", "if", "(", "f", "==", "null", ")", "return", "null", ";", "if", "(", "!", "f", ".", "isDeleted", "(", ")", ")", "{", "if", "(", "f", ".", "getPrev", "(", ")", "!=", "this", "&&", "!", "isDeleted", "(", ")", ")", "f", ".", "setPrev", "(", "this", ")", ";", "// relink f's prev", "return", "f", ";", "}", "Node", "<", "E", ">", "s", "=", "f", ".", "nextNonmarker", "(", ")", ";", "if", "(", "f", "==", "getNext", "(", ")", ")", "casNext", "(", "f", ",", "s", ")", ";", "// unlink f", "f", "=", "s", ";", "}", "}"], "docstring": "Returns the next non-deleted node, swinging next pointer\naround any encountered deleted nodes, and also patching up\nsuccessor's prev link to point back to this.  Returns\nnull if this node is trailer so has no successor.\n\n@return successor, or null if no such", "docstring_tokens": ["Returns", "the", "next", "non", "-", "deleted", "node", "swinging", "next", "pointer", "around", "any", "encountered", "deleted", "nodes", "and", "also", "patching", "up", "successor", "s", "prev", "link", "to", "point", "back", "to", "this", ".", "Returns", "null", "if", "this", "node", "is", "trailer", "so", "has", "no", "successor", "."]}
{"code": "casNext(f, s);", "comments": "unlink f", "lines": 13, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/ConcurrentLinkedDeque.java", "func_name": "Node.successor", "original_string": "Node<E> successor() {\n            Node<E> f = nextNonmarker();\n            for (;;) {\n                if (f == null)\n                    return null;\n                if (!f.isDeleted()) {\n                    if (f.getPrev() != this && !isDeleted())\n                        f.setPrev(this);       // relink f's prev\n                    return f;\n                }\n                Node<E> s = f.nextNonmarker();\n                if (f == getNext())\n                    casNext(f, s);             // unlink f\n                f = s;\n            }\n        }", "language": "java", "Allcodes": "Node<E> successor() {\n            Node<E> f = nextNonmarker();\n            for (;;) {\n                if (f == null)\n                    return null;\n                if (!f.isDeleted()) {\n                    if (f.getPrev() != this && !isDeleted())\n                        f.setPrev(this);       // relink f's prev\n                    return f;\n                }\n                Node<E> s = f.nextNonmarker();\n                if (f == getNext())\n                    casNext(f, s);             // unlink f\n                f = s;\n            }\n        }", "code_tokens": ["Node", "<", "E", ">", "successor", "(", ")", "{", "Node", "<", "E", ">", "f", "=", "nextNonmarker", "(", ")", ";", "for", "(", ";", ";", ")", "{", "if", "(", "f", "==", "null", ")", "return", "null", ";", "if", "(", "!", "f", ".", "isDeleted", "(", ")", ")", "{", "if", "(", "f", ".", "getPrev", "(", ")", "!=", "this", "&&", "!", "isDeleted", "(", ")", ")", "f", ".", "setPrev", "(", "this", ")", ";", "// relink f's prev", "return", "f", ";", "}", "Node", "<", "E", ">", "s", "=", "f", ".", "nextNonmarker", "(", ")", ";", "if", "(", "f", "==", "getNext", "(", ")", ")", "casNext", "(", "f", ",", "s", ")", ";", "// unlink f", "f", "=", "s", ";", "}", "}"], "docstring": "Returns the next non-deleted node, swinging next pointer\naround any encountered deleted nodes, and also patching up\nsuccessor's prev link to point back to this.  Returns\nnull if this node is trailer so has no successor.\n\n@return successor, or null if no such", "docstring_tokens": ["Returns", "the", "next", "non", "-", "deleted", "node", "swinging", "next", "pointer", "around", "any", "encountered", "deleted", "nodes", "and", "also", "patching", "up", "successor", "s", "prev", "link", "to", "point", "back", "to", "this", ".", "Returns", "null", "if", "this", "node", "is", "trailer", "so", "has", "no", "successor", "."]}
{"code": "f.setPrev(x);", "comments": "optimistically link", "lines": 8, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/ConcurrentLinkedDeque.java", "func_name": "Node.append", "original_string": "Node<E> append(E element) {\n            for (;;) {\n                Node<E> f = getNext();\n                if (f == null || f.isMarker())\n                    return null;\n                Node<E> x = new Node<E>(element, f, this);\n                if (casNext(f, x)) {\n                    f.setPrev(x); // optimistically link\n                    return x;\n                }\n            }\n        }", "language": "java", "Allcodes": "Node<E> append(E element) {\n            for (;;) {\n                Node<E> f = getNext();\n                if (f == null || f.isMarker())\n                    return null;\n                Node<E> x = new Node<E>(element, f, this);\n                if (casNext(f, x)) {\n                    f.setPrev(x); // optimistically link\n                    return x;\n                }\n            }\n        }", "code_tokens": ["Node", "<", "E", ">", "append", "(", "E", "element", ")", "{", "for", "(", ";", ";", ")", "{", "Node", "<", "E", ">", "f", "=", "getNext", "(", ")", ";", "if", "(", "f", "==", "null", "||", "f", ".", "isMarker", "(", ")", ")", "return", "null", ";", "Node", "<", "E", ">", "x", "=", "new", "Node", "<", "E", ">", "(", "element", ",", "f", ",", "this", ")", ";", "if", "(", "casNext", "(", "f", ",", "x", ")", ")", "{", "f", ".", "setPrev", "(", "x", ")", ";", "// optimistically link", "return", "x", ";", "}", "}", "}"], "docstring": "Tries to insert a node holding element as successor, failing\nif this node is deleted.\n\n@param element the element\n@return the new node, or null on failure", "docstring_tokens": ["Tries", "to", "insert", "a", "node", "holding", "element", "as", "successor", "failing", "if", "this", "node", "is", "deleted", "."]}
{"code": "b.successor();", "comments": "to relink b", "lines": 9, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/ConcurrentLinkedDeque.java", "func_name": "Node.replace", "original_string": "Node<E> replace(E newElement) {\n            for (;;) {\n                Node<E> b = getPrev();\n                Node<E> f = getNext();\n                if (b == null || f == null || f.isMarker())\n                    return null;\n                Node<E> x = new Node<E>(newElement, f, b);\n                if (casNext(f, new Node<E>(x))) {\n                    b.successor(); // to relink b\n                    x.successor(); // to relink f\n                    return x;\n                }\n            }\n        }", "language": "java", "Allcodes": "Node<E> replace(E newElement) {\n            for (;;) {\n                Node<E> b = getPrev();\n                Node<E> f = getNext();\n                if (b == null || f == null || f.isMarker())\n                    return null;\n                Node<E> x = new Node<E>(newElement, f, b);\n                if (casNext(f, new Node<E>(x))) {\n                    b.successor(); // to relink b\n                    x.successor(); // to relink f\n                    return x;\n                }\n            }\n        }", "code_tokens": ["Node", "<", "E", ">", "replace", "(", "E", "newElement", ")", "{", "for", "(", ";", ";", ")", "{", "Node", "<", "E", ">", "b", "=", "getPrev", "(", ")", ";", "Node", "<", "E", ">", "f", "=", "getNext", "(", ")", ";", "if", "(", "b", "==", "null", "||", "f", "==", "null", "||", "f", ".", "isMarker", "(", ")", ")", "return", "null", ";", "Node", "<", "E", ">", "x", "=", "new", "Node", "<", "E", ">", "(", "newElement", ",", "f", ",", "b", ")", ";", "if", "(", "casNext", "(", "f", ",", "new", "Node", "<", "E", ">", "(", "x", ")", ")", ")", "{", "b", ".", "successor", "(", ")", ";", "// to relink b", "x", ".", "successor", "(", ")", ";", "// to relink f", "return", "x", ";", "}", "}", "}"], "docstring": "Tries to insert a node holding element to replace this node.\nfailing if already deleted.  A currently unused proof of\nconcept that demonstrates atomic node content replacement.\n\nAlthough this implementation ensures that exactly one\nversion of this Node is alive at a given time, it fails to\nmaintain atomicity in the sense that iterators may\nencounter both the old and new versions of the element.\n\n@param newElement the new element\n@return the new node, or null on failure", "docstring_tokens": ["Tries", "to", "insert", "a", "node", "holding", "element", "to", "replace", "this", "node", ".", "failing", "if", "already", "deleted", ".", "A", "currently", "unused", "proof", "of", "concept", "that", "demonstrates", "atomic", "node", "content", "replacement", "."]}
{"code": "x.successor();", "comments": "to relink f", "lines": 10, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/ConcurrentLinkedDeque.java", "func_name": "Node.replace", "original_string": "Node<E> replace(E newElement) {\n            for (;;) {\n                Node<E> b = getPrev();\n                Node<E> f = getNext();\n                if (b == null || f == null || f.isMarker())\n                    return null;\n                Node<E> x = new Node<E>(newElement, f, b);\n                if (casNext(f, new Node<E>(x))) {\n                    b.successor(); // to relink b\n                    x.successor(); // to relink f\n                    return x;\n                }\n            }\n        }", "language": "java", "Allcodes": "Node<E> replace(E newElement) {\n            for (;;) {\n                Node<E> b = getPrev();\n                Node<E> f = getNext();\n                if (b == null || f == null || f.isMarker())\n                    return null;\n                Node<E> x = new Node<E>(newElement, f, b);\n                if (casNext(f, new Node<E>(x))) {\n                    b.successor(); // to relink b\n                    x.successor(); // to relink f\n                    return x;\n                }\n            }\n        }", "code_tokens": ["Node", "<", "E", ">", "replace", "(", "E", "newElement", ")", "{", "for", "(", ";", ";", ")", "{", "Node", "<", "E", ">", "b", "=", "getPrev", "(", ")", ";", "Node", "<", "E", ">", "f", "=", "getNext", "(", ")", ";", "if", "(", "b", "==", "null", "||", "f", "==", "null", "||", "f", ".", "isMarker", "(", ")", ")", "return", "null", ";", "Node", "<", "E", ">", "x", "=", "new", "Node", "<", "E", ">", "(", "newElement", ",", "f", ",", "b", ")", ";", "if", "(", "casNext", "(", "f", ",", "new", "Node", "<", "E", ">", "(", "x", ")", ")", ")", "{", "b", ".", "successor", "(", ")", ";", "// to relink b", "x", ".", "successor", "(", ")", ";", "// to relink f", "return", "x", ";", "}", "}", "}"], "docstring": "Tries to insert a node holding element to replace this node.\nfailing if already deleted.  A currently unused proof of\nconcept that demonstrates atomic node content replacement.\n\nAlthough this implementation ensures that exactly one\nversion of this Node is alive at a given time, it fails to\nmaintain atomicity in the sense that iterators may\nencounter both the old and new versions of the element.\n\n@param newElement the new element\n@return the new node, or null on failure", "docstring_tokens": ["Tries", "to", "insert", "a", "node", "holding", "element", "to", "replace", "this", "node", ".", "failing", "if", "already", "deleted", ".", "A", "currently", "unused", "proof", "of", "concept", "that", "demonstrates", "atomic", "node", "content", "replacement", "."]}
{"code": "bitWorkArea = (bitWorkArea << 8) + b;", "comments": "BITS_PER_BYTE", "lines": 18, "repo": "mongodb/mongo-java-driver", "path": "bson/src/main/org/bson/internal/Base64.java", "func_name": "Base64.encode", "original_string": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "language": "java", "Allcodes": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "code_tokens": ["public", "static", "String", "encode", "(", "final", "byte", "[", "]", "in", ")", "{", "int", "modulus", "=", "0", ";", "int", "bitWorkArea", "=", "0", ";", "int", "numEncodedBytes", "=", "(", "in", ".", "length", "/", "BYTES_PER_UNENCODED_BLOCK", ")", "*", "BYTES_PER_ENCODED_BLOCK", "+", "(", "(", "in", ".", "length", "%", "BYTES_PER_UNENCODED_BLOCK", "==", "0", ")", "?", "0", ":", "4", ")", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "numEncodedBytes", "]", ";", "int", "pos", "=", "0", ";", "for", "(", "int", "b", ":", "in", ")", "{", "modulus", "=", "(", "modulus", "+", "1", ")", "%", "BYTES_PER_UNENCODED_BLOCK", ";", "if", "(", "b", "<", "0", ")", "{", "b", "+=", "256", ";", "}", "bitWorkArea", "=", "(", "bitWorkArea", "<<", "8", ")", "+", "b", ";", "//  BITS_PER_BYTE", "if", "(", "0", "==", "modulus", ")", "{", "// 3 bytes = 24 bits = 4 * 6 bits to extract", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "18", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "12", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "6", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "bitWorkArea", "&", "SIX_BIT_MASK", "]", ";", "}", "}", "switch", "(", "modulus", ")", "{", "// 0-2", "case", "1", ":", "// 8 bits = 6 + 2", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "// top 6 bits", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "// remaining 2", "buffer", "[", "pos", "++", "]", "=", "PAD", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "case", "2", ":", "// 16 bits = 6 + 6 + 4", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "10", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "default", ":", "break", ";", "}", "return", "byteArrayToString", "(", "buffer", ")", ";", "}"], "docstring": "Encodes the given byte array into a Base64-encoded string.\n\n\n@param in the byte array\n@return the Base64-encoded string", "docstring_tokens": ["Encodes", "the", "given", "byte", "array", "into", "a", "Base64", "-", "encoded", "string", "."]}
{"code": "buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK];", "comments": "top 6 bits", "lines": 29, "repo": "mongodb/mongo-java-driver", "path": "bson/src/main/org/bson/internal/Base64.java", "func_name": "Base64.encode", "original_string": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "language": "java", "Allcodes": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "code_tokens": ["public", "static", "String", "encode", "(", "final", "byte", "[", "]", "in", ")", "{", "int", "modulus", "=", "0", ";", "int", "bitWorkArea", "=", "0", ";", "int", "numEncodedBytes", "=", "(", "in", ".", "length", "/", "BYTES_PER_UNENCODED_BLOCK", ")", "*", "BYTES_PER_ENCODED_BLOCK", "+", "(", "(", "in", ".", "length", "%", "BYTES_PER_UNENCODED_BLOCK", "==", "0", ")", "?", "0", ":", "4", ")", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "numEncodedBytes", "]", ";", "int", "pos", "=", "0", ";", "for", "(", "int", "b", ":", "in", ")", "{", "modulus", "=", "(", "modulus", "+", "1", ")", "%", "BYTES_PER_UNENCODED_BLOCK", ";", "if", "(", "b", "<", "0", ")", "{", "b", "+=", "256", ";", "}", "bitWorkArea", "=", "(", "bitWorkArea", "<<", "8", ")", "+", "b", ";", "//  BITS_PER_BYTE", "if", "(", "0", "==", "modulus", ")", "{", "// 3 bytes = 24 bits = 4 * 6 bits to extract", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "18", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "12", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "6", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "bitWorkArea", "&", "SIX_BIT_MASK", "]", ";", "}", "}", "switch", "(", "modulus", ")", "{", "// 0-2", "case", "1", ":", "// 8 bits = 6 + 2", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "// top 6 bits", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "// remaining 2", "buffer", "[", "pos", "++", "]", "=", "PAD", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "case", "2", ":", "// 16 bits = 6 + 6 + 4", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "10", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "default", ":", "break", ";", "}", "return", "byteArrayToString", "(", "buffer", ")", ";", "}"], "docstring": "Encodes the given byte array into a Base64-encoded string.\n\n\n@param in the byte array\n@return the Base64-encoded string", "docstring_tokens": ["Encodes", "the", "given", "byte", "array", "into", "a", "Base64", "-", "encoded", "string", "."]}
{"code": "buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK];", "comments": "remaining 2", "lines": 30, "repo": "mongodb/mongo-java-driver", "path": "bson/src/main/org/bson/internal/Base64.java", "func_name": "Base64.encode", "original_string": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "language": "java", "Allcodes": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "code_tokens": ["public", "static", "String", "encode", "(", "final", "byte", "[", "]", "in", ")", "{", "int", "modulus", "=", "0", ";", "int", "bitWorkArea", "=", "0", ";", "int", "numEncodedBytes", "=", "(", "in", ".", "length", "/", "BYTES_PER_UNENCODED_BLOCK", ")", "*", "BYTES_PER_ENCODED_BLOCK", "+", "(", "(", "in", ".", "length", "%", "BYTES_PER_UNENCODED_BLOCK", "==", "0", ")", "?", "0", ":", "4", ")", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "numEncodedBytes", "]", ";", "int", "pos", "=", "0", ";", "for", "(", "int", "b", ":", "in", ")", "{", "modulus", "=", "(", "modulus", "+", "1", ")", "%", "BYTES_PER_UNENCODED_BLOCK", ";", "if", "(", "b", "<", "0", ")", "{", "b", "+=", "256", ";", "}", "bitWorkArea", "=", "(", "bitWorkArea", "<<", "8", ")", "+", "b", ";", "//  BITS_PER_BYTE", "if", "(", "0", "==", "modulus", ")", "{", "// 3 bytes = 24 bits = 4 * 6 bits to extract", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "18", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "12", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "6", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "bitWorkArea", "&", "SIX_BIT_MASK", "]", ";", "}", "}", "switch", "(", "modulus", ")", "{", "// 0-2", "case", "1", ":", "// 8 bits = 6 + 2", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "// top 6 bits", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "// remaining 2", "buffer", "[", "pos", "++", "]", "=", "PAD", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "case", "2", ":", "// 16 bits = 6 + 6 + 4", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "10", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "default", ":", "break", ";", "}", "return", "byteArrayToString", "(", "buffer", ")", ";", "}"], "docstring": "Encodes the given byte array into a Base64-encoded string.\n\n\n@param in the byte array\n@return the Base64-encoded string", "docstring_tokens": ["Encodes", "the", "given", "byte", "array", "into", "a", "Base64", "-", "encoded", "string", "."]}
{"code": "buffer[pos] = PAD;", "comments": "Last entry no need to ++", "lines": 32, "repo": "mongodb/mongo-java-driver", "path": "bson/src/main/org/bson/internal/Base64.java", "func_name": "Base64.encode", "original_string": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "language": "java", "Allcodes": "public static String encode(final byte[] in) {\n\n        int modulus = 0;\n        int bitWorkArea = 0;\n        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK\n                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);\n\n        byte[] buffer = new byte[numEncodedBytes];\n        int pos = 0;\n\n        for (int b : in) {\n            modulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\n\n            if (b < 0) {\n                b += 256;\n            }\n\n            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n            if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];\n            }\n        }\n\n        switch (modulus) { // 0-2\n            case 1: // 8 bits = 6 + 2\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2\n                buffer[pos++] = PAD;\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n\n            case 2: // 16 bits = 6 + 6 + 4\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];\n                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];\n                buffer[pos] = PAD; // Last entry no need to ++\n                break;\n            default:\n                break;\n        }\n\n        return byteArrayToString(buffer);\n    }", "code_tokens": ["public", "static", "String", "encode", "(", "final", "byte", "[", "]", "in", ")", "{", "int", "modulus", "=", "0", ";", "int", "bitWorkArea", "=", "0", ";", "int", "numEncodedBytes", "=", "(", "in", ".", "length", "/", "BYTES_PER_UNENCODED_BLOCK", ")", "*", "BYTES_PER_ENCODED_BLOCK", "+", "(", "(", "in", ".", "length", "%", "BYTES_PER_UNENCODED_BLOCK", "==", "0", ")", "?", "0", ":", "4", ")", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "numEncodedBytes", "]", ";", "int", "pos", "=", "0", ";", "for", "(", "int", "b", ":", "in", ")", "{", "modulus", "=", "(", "modulus", "+", "1", ")", "%", "BYTES_PER_UNENCODED_BLOCK", ";", "if", "(", "b", "<", "0", ")", "{", "b", "+=", "256", ";", "}", "bitWorkArea", "=", "(", "bitWorkArea", "<<", "8", ")", "+", "b", ";", "//  BITS_PER_BYTE", "if", "(", "0", "==", "modulus", ")", "{", "// 3 bytes = 24 bits = 4 * 6 bits to extract", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "18", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "12", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "6", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "bitWorkArea", "&", "SIX_BIT_MASK", "]", ";", "}", "}", "switch", "(", "modulus", ")", "{", "// 0-2", "case", "1", ":", "// 8 bits = 6 + 2", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "// top 6 bits", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "// remaining 2", "buffer", "[", "pos", "++", "]", "=", "PAD", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "case", "2", ":", "// 16 bits = 6 + 6 + 4", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "10", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", ">>", "4", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "++", "]", "=", "ENCODE_TABLE", "[", "(", "bitWorkArea", "<<", "2", ")", "&", "SIX_BIT_MASK", "]", ";", "buffer", "[", "pos", "]", "=", "PAD", ";", "// Last entry no need to ++", "break", ";", "default", ":", "break", ";", "}", "return", "byteArrayToString", "(", "buffer", ")", ";", "}"], "docstring": "Encodes the given byte array into a Base64-encoded string.\n\n\n@param in the byte array\n@return the Base64-encoded string", "docstring_tokens": ["Encodes", "the", "given", "byte", "array", "into", "a", "Base64", "-", "encoded", "string", "."]}
{"code": "? new ReplicaSetStatus(delegate.getCluster()) : null;", "comments": "this is intended behavior in 2.x", "lines": 7, "repo": "mongodb/mongo-java-driver", "path": "driver-legacy/src/main/com/mongodb/Mongo.java", "func_name": "Mongo.getReplicaSetStatus", "original_string": "@SuppressWarnings(\"deprecation\")\n    @Deprecated\n    @Nullable\n    public ReplicaSetStatus getReplicaSetStatus() {\n        ClusterDescription clusterDescription = getClusterDescription();\n        return clusterDescription.getType() == REPLICA_SET && clusterDescription.getConnectionMode() == MULTIPLE\n               ? new ReplicaSetStatus(delegate.getCluster()) : null; // this is intended behavior in 2.x\n    }", "language": "java", "Allcodes": "@SuppressWarnings(\"deprecation\")\n    @Deprecated\n    @Nullable\n    public ReplicaSetStatus getReplicaSetStatus() {\n        ClusterDescription clusterDescription = getClusterDescription();\n        return clusterDescription.getType() == REPLICA_SET && clusterDescription.getConnectionMode() == MULTIPLE\n               ? new ReplicaSetStatus(delegate.getCluster()) : null; // this is intended behavior in 2.x\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"deprecation\"", ")", "@", "Deprecated", "@", "Nullable", "public", "ReplicaSetStatus", "getReplicaSetStatus", "(", ")", "{", "ClusterDescription", "clusterDescription", "=", "getClusterDescription", "(", ")", ";", "return", "clusterDescription", ".", "getType", "(", ")", "==", "REPLICA_SET", "&&", "clusterDescription", ".", "getConnectionMode", "(", ")", "==", "MULTIPLE", "?", "new", "ReplicaSetStatus", "(", "delegate", ".", "getCluster", "(", ")", ")", ":", "null", ";", "// this is intended behavior in 2.x", "}"], "docstring": "Get the status of the replica set cluster.\n\n@return replica set status information", "docstring_tokens": ["Get", "the", "status", "of", "the", "replica", "set", "cluster", "."]}
{"code": "bsonOutput.writeInt32(0);", "comments": "length: will set this later", "lines": 2, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/RequestMessage.java", "func_name": "RequestMessage.writeMessagePrologue", "original_string": "protected void writeMessagePrologue(final BsonOutput bsonOutput) {\n        bsonOutput.writeInt32(0); // length: will set this later\n        bsonOutput.writeInt32(id);\n        bsonOutput.writeInt32(0); // response to\n        bsonOutput.writeInt32(opCode.getValue());\n    }", "language": "java", "Allcodes": "protected void writeMessagePrologue(final BsonOutput bsonOutput) {\n        bsonOutput.writeInt32(0); // length: will set this later\n        bsonOutput.writeInt32(id);\n        bsonOutput.writeInt32(0); // response to\n        bsonOutput.writeInt32(opCode.getValue());\n    }", "code_tokens": ["protected", "void", "writeMessagePrologue", "(", "final", "BsonOutput", "bsonOutput", ")", "{", "bsonOutput", ".", "writeInt32", "(", "0", ")", ";", "// length: will set this later", "bsonOutput", ".", "writeInt32", "(", "id", ")", ";", "bsonOutput", ".", "writeInt32", "(", "0", ")", ";", "// response to", "bsonOutput", ".", "writeInt32", "(", "opCode", ".", "getValue", "(", ")", ")", ";", "}"], "docstring": "Writes the message prologue to the given output.\n\n@param bsonOutput the output", "docstring_tokens": ["Writes", "the", "message", "prologue", "to", "the", "given", "output", "."]}
{"code": "bsonOutput.writeInt32(0);", "comments": "response to", "lines": 4, "repo": "mongodb/mongo-java-driver", "path": "driver-core/src/main/com/mongodb/internal/connection/RequestMessage.java", "func_name": "RequestMessage.writeMessagePrologue", "original_string": "protected void writeMessagePrologue(final BsonOutput bsonOutput) {\n        bsonOutput.writeInt32(0); // length: will set this later\n        bsonOutput.writeInt32(id);\n        bsonOutput.writeInt32(0); // response to\n        bsonOutput.writeInt32(opCode.getValue());\n    }", "language": "java", "Allcodes": "protected void writeMessagePrologue(final BsonOutput bsonOutput) {\n        bsonOutput.writeInt32(0); // length: will set this later\n        bsonOutput.writeInt32(id);\n        bsonOutput.writeInt32(0); // response to\n        bsonOutput.writeInt32(opCode.getValue());\n    }", "code_tokens": ["protected", "void", "writeMessagePrologue", "(", "final", "BsonOutput", "bsonOutput", ")", "{", "bsonOutput", ".", "writeInt32", "(", "0", ")", ";", "// length: will set this later", "bsonOutput", ".", "writeInt32", "(", "id", ")", ";", "bsonOutput", ".", "writeInt32", "(", "0", ")", ";", "// response to", "bsonOutput", ".", "writeInt32", "(", "opCode", ".", "getValue", "(", ")", ")", ";", "}"], "docstring": "Writes the message prologue to the given output.\n\n@param bsonOutput the output", "docstring_tokens": ["Writes", "the", "message", "prologue", "to", "the", "given", "output", "."]}
{"code": "client.warmup(0L);", "comments": "This prevents backgrounding after redirection", "lines": 12, "repo": "uber/rides-android-sdk", "path": "core-android/src/main/java/com/uber/sdk/android/core/utils/CustomTabsHelper.java", "func_name": "CustomTabsHelper.openCustomTab", "original_string": "public void openCustomTab(\n            final Context context,\n            final CustomTabsIntent customTabsIntent,\n            final Uri uri,\n            CustomTabFallback fallback) {\n        final String packageName = getPackageNameToUse(context);\n\n        if (packageName != null) {\n            final CustomTabsServiceConnection connection = new CustomTabsServiceConnection() {\n                @Override\n                public void onCustomTabsServiceConnected(ComponentName componentName, CustomTabsClient client) {\n                    client.warmup(0L); // This prevents backgrounding after redirection\n\n                    customTabsIntent.intent.setPackage(packageName);\n                    customTabsIntent.intent.setData(uri);\n                    customTabsIntent.launchUrl(context, uri);\n                }\n                @Override\n                public void onServiceDisconnected(ComponentName name) {}\n            };\n            CustomTabsClient.bindCustomTabsService(context, packageName, connection);\n        } else if (fallback != null) {\n            fallback.openUri(context, uri);\n        } else {\n            Log.e(UberSdk.UBER_SDK_LOG_TAG,\n                    \"Use of openCustomTab without Customtab support or a fallback set\");\n        }\n    }", "language": "java", "Allcodes": "public void openCustomTab(\n            final Context context,\n            final CustomTabsIntent customTabsIntent,\n            final Uri uri,\n            CustomTabFallback fallback) {\n        final String packageName = getPackageNameToUse(context);\n\n        if (packageName != null) {\n            final CustomTabsServiceConnection connection = new CustomTabsServiceConnection() {\n                @Override\n                public void onCustomTabsServiceConnected(ComponentName componentName, CustomTabsClient client) {\n                    client.warmup(0L); // This prevents backgrounding after redirection\n\n                    customTabsIntent.intent.setPackage(packageName);\n                    customTabsIntent.intent.setData(uri);\n                    customTabsIntent.launchUrl(context, uri);\n                }\n                @Override\n                public void onServiceDisconnected(ComponentName name) {}\n            };\n            CustomTabsClient.bindCustomTabsService(context, packageName, connection);\n        } else if (fallback != null) {\n            fallback.openUri(context, uri);\n        } else {\n            Log.e(UberSdk.UBER_SDK_LOG_TAG,\n                    \"Use of openCustomTab without Customtab support or a fallback set\");\n        }\n    }", "code_tokens": ["public", "void", "openCustomTab", "(", "final", "Context", "context", ",", "final", "CustomTabsIntent", "customTabsIntent", ",", "final", "Uri", "uri", ",", "CustomTabFallback", "fallback", ")", "{", "final", "String", "packageName", "=", "getPackageNameToUse", "(", "context", ")", ";", "if", "(", "packageName", "!=", "null", ")", "{", "final", "CustomTabsServiceConnection", "connection", "=", "new", "CustomTabsServiceConnection", "(", ")", "{", "@", "Override", "public", "void", "onCustomTabsServiceConnected", "(", "ComponentName", "componentName", ",", "CustomTabsClient", "client", ")", "{", "client", ".", "warmup", "(", "0L", ")", ";", "// This prevents backgrounding after redirection", "customTabsIntent", ".", "intent", ".", "setPackage", "(", "packageName", ")", ";", "customTabsIntent", ".", "intent", ".", "setData", "(", "uri", ")", ";", "customTabsIntent", ".", "launchUrl", "(", "context", ",", "uri", ")", ";", "}", "@", "Override", "public", "void", "onServiceDisconnected", "(", "ComponentName", "name", ")", "{", "}", "}", ";", "CustomTabsClient", ".", "bindCustomTabsService", "(", "context", ",", "packageName", ",", "connection", ")", ";", "}", "else", "if", "(", "fallback", "!=", "null", ")", "{", "fallback", ".", "openUri", "(", "context", ",", "uri", ")", ";", "}", "else", "{", "Log", ".", "e", "(", "UberSdk", ".", "UBER_SDK_LOG_TAG", ",", "\"Use of openCustomTab without Customtab support or a fallback set\"", ")", ";", "}", "}"], "docstring": "Opens the URL on a Custom Tab if possible. Otherwise fallsback to opening it on a WebView.\n\n@param context The host context.\n@param customTabsIntent a CustomTabsIntent to be used if Custom Tabs is available.\n@param uri the Uri to be opened.\n@param fallback a CustomTabFallback to be used if Custom Tabs is not available.", "docstring_tokens": ["Opens", "the", "URL", "on", "a", "Custom", "Tab", "if", "possible", ".", "Otherwise", "fallsback", "to", "opening", "it", "on", "a", "WebView", "."]}
{"code": "return this;", "comments": "in some cases, like when using iff(), we ignore null children", "lines": 6, "repo": "tipsy/j2html", "path": "src/main/java/j2html/tags/ContainerTag.java", "func_name": "ContainerTag.with", "original_string": "public ContainerTag with(DomContent child) {\n        if (this == child) {\n            throw new RuntimeException(\"Cannot append a tag to itself.\");\n        }\n        if (child == null) {\n            return this; // in some cases, like when using iff(), we ignore null children\n        }\n        children.add(child);\n        return this;\n    }", "language": "java", "Allcodes": "public ContainerTag with(DomContent child) {\n        if (this == child) {\n            throw new RuntimeException(\"Cannot append a tag to itself.\");\n        }\n        if (child == null) {\n            return this; // in some cases, like when using iff(), we ignore null children\n        }\n        children.add(child);\n        return this;\n    }", "code_tokens": ["public", "ContainerTag", "with", "(", "DomContent", "child", ")", "{", "if", "(", "this", "==", "child", ")", "{", "throw", "new", "RuntimeException", "(", "\"Cannot append a tag to itself.\"", ")", ";", "}", "if", "(", "child", "==", "null", ")", "{", "return", "this", ";", "// in some cases, like when using iff(), we ignore null children", "}", "children", ".", "add", "(", "child", ")", ";", "return", "this", ";", "}"], "docstring": "Appends a DomContent-object to the end of this element\n\n@param child DomContent-object to be appended\n@return itself for easy chaining", "docstring_tokens": ["Appends", "a", "DomContent", "-", "object", "to", "the", "end", "of", "this", "element"]}
{"code": "attribute.setValue(value);", "comments": "update with new value", "lines": 7, "repo": "tipsy/j2html", "path": "src/main/java/j2html/tags/Tag.java", "func_name": "Tag.setAttribute", "original_string": "boolean setAttribute(String name, String value) {\n        if (value == null) {\n            return attributes.add(new Attribute(name));\n        }\n        for (Attribute attribute : attributes) {\n            if (attribute.getName().equals(name)) {\n                attribute.setValue(value); // update with new value\n                return true;\n            }\n        }\n        return attributes.add(new Attribute(name, value));\n    }", "language": "java", "Allcodes": "boolean setAttribute(String name, String value) {\n        if (value == null) {\n            return attributes.add(new Attribute(name));\n        }\n        for (Attribute attribute : attributes) {\n            if (attribute.getName().equals(name)) {\n                attribute.setValue(value); // update with new value\n                return true;\n            }\n        }\n        return attributes.add(new Attribute(name, value));\n    }", "code_tokens": ["boolean", "setAttribute", "(", "String", "name", ",", "String", "value", ")", "{", "if", "(", "value", "==", "null", ")", "{", "return", "attributes", ".", "add", "(", "new", "Attribute", "(", "name", ")", ")", ";", "}", "for", "(", "Attribute", "attribute", ":", "attributes", ")", "{", "if", "(", "attribute", ".", "getName", "(", ")", ".", "equals", "(", "name", ")", ")", "{", "attribute", ".", "setValue", "(", "value", ")", ";", "// update with new value", "return", "true", ";", "}", "}", "return", "attributes", ".", "add", "(", "new", "Attribute", "(", "name", ",", "value", ")", ")", ";", "}"], "docstring": "Sets an attribute on an element\n\n@param name  the attribute\n@param value the attribute value", "docstring_tokens": ["Sets", "an", "attribute", "on", "an", "element"]}
{"code": "cdiCamelContext.addComponent(\"camunda-bpm\", component);", "comments": "TODO: could be done by META-INF/service as well- maybe switch?", "lines": 9, "repo": "camunda-consulting/code", "path": "one-time-examples/bank-account-opening-camel/src/main/java/org/camunda/demo/camel/CamelBootStrap.java", "func_name": "CamelBootStrap.init", "original_string": "@PostConstruct\n\tpublic void init() throws Exception {\n    log.info(\"=======================\");\n    log.info(\"Adding camunda BPM Component to Camel\");\n    log.info(\"=======================\");\n\t  \n\t  CamundaBpmComponent component = new CamundaBpmComponent(processEngine);\n    component.setCamelContext(cdiCamelContext);\n    cdiCamelContext.addComponent(\"camunda-bpm\", component); // TODO: could be done by META-INF/service as well- maybe switch?\n\n    // For simplicity JMS was removed from the example - but you can easily re-add it:\n\t\t// inject the JMS connection factory into camel's JMS component\n//\t\tJmsComponent jmsComponent = cdiCamelContext.getComponent(\"jms\", JmsComponent.class);\n//\t\tjmsComponent.setConnectionFactory(queueConnectionFactory);\n\n    // Instead we exchanged the JMS component by replacing it with Camel seda component for in memory queues\n    cdiCamelContext.addComponent(\"jms\", cdiCamelContext.getComponent(\"seda\", SedaComponent.class));\n\n\t\t// add routes to camel context\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"adding OpenAccountRoute to camel context\");\n\t\tlog.info(\"=======================\");\n\t\tcdiCamelContext.addRoutes(openAccountRoute);\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"Camel Components: \" + cdiCamelContext.getComponentNames());\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"starting camel context\");\n\t\tlog.info(\"=======================\");\n\t\t// cdiCamelContext.setTracing(true);\n\t\tcdiCamelContext.start();\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"successfully created camel context and started open account route!\");\n\t\tlog.info(\"=======================\");\n\t}", "language": "java", "Allcodes": "@PostConstruct\n\tpublic void init() throws Exception {\n    log.info(\"=======================\");\n    log.info(\"Adding camunda BPM Component to Camel\");\n    log.info(\"=======================\");\n\t  \n\t  CamundaBpmComponent component = new CamundaBpmComponent(processEngine);\n    component.setCamelContext(cdiCamelContext);\n    cdiCamelContext.addComponent(\"camunda-bpm\", component); // TODO: could be done by META-INF/service as well- maybe switch?\n\n    // For simplicity JMS was removed from the example - but you can easily re-add it:\n\t\t// inject the JMS connection factory into camel's JMS component\n//\t\tJmsComponent jmsComponent = cdiCamelContext.getComponent(\"jms\", JmsComponent.class);\n//\t\tjmsComponent.setConnectionFactory(queueConnectionFactory);\n\n    // Instead we exchanged the JMS component by replacing it with Camel seda component for in memory queues\n    cdiCamelContext.addComponent(\"jms\", cdiCamelContext.getComponent(\"seda\", SedaComponent.class));\n\n\t\t// add routes to camel context\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"adding OpenAccountRoute to camel context\");\n\t\tlog.info(\"=======================\");\n\t\tcdiCamelContext.addRoutes(openAccountRoute);\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"Camel Components: \" + cdiCamelContext.getComponentNames());\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"starting camel context\");\n\t\tlog.info(\"=======================\");\n\t\t// cdiCamelContext.setTracing(true);\n\t\tcdiCamelContext.start();\n\t\tlog.info(\"=======================\");\n\t\tlog.info(\"successfully created camel context and started open account route!\");\n\t\tlog.info(\"=======================\");\n\t}", "code_tokens": ["@", "PostConstruct", "public", "void", "init", "(", ")", "throws", "Exception", "{", "log", ".", "info", "(", "\"=======================\"", ")", ";", "log", ".", "info", "(", "\"Adding camunda BPM Component to Camel\"", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "CamundaBpmComponent", "component", "=", "new", "CamundaBpmComponent", "(", "processEngine", ")", ";", "component", ".", "setCamelContext", "(", "cdiCamelContext", ")", ";", "cdiCamelContext", ".", "addComponent", "(", "\"camunda-bpm\"", ",", "component", ")", ";", "// TODO: could be done by META-INF/service as well- maybe switch?", "// For simplicity JMS was removed from the example - but you can easily re-add it:", "// inject the JMS connection factory into camel's JMS component", "//\t\tJmsComponent jmsComponent = cdiCamelContext.getComponent(\"jms\", JmsComponent.class);", "//\t\tjmsComponent.setConnectionFactory(queueConnectionFactory);", "// Instead we exchanged the JMS component by replacing it with Camel seda component for in memory queues", "cdiCamelContext", ".", "addComponent", "(", "\"jms\"", ",", "cdiCamelContext", ".", "getComponent", "(", "\"seda\"", ",", "SedaComponent", ".", "class", ")", ")", ";", "// add routes to camel context", "log", ".", "info", "(", "\"=======================\"", ")", ";", "log", ".", "info", "(", "\"adding OpenAccountRoute to camel context\"", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "cdiCamelContext", ".", "addRoutes", "(", "openAccountRoute", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "log", ".", "info", "(", "\"Camel Components: \"", "+", "cdiCamelContext", ".", "getComponentNames", "(", ")", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "log", ".", "info", "(", "\"starting camel context\"", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "// cdiCamelContext.setTracing(true);", "cdiCamelContext", ".", "start", "(", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "log", ".", "info", "(", "\"successfully created camel context and started open account route!\"", ")", ";", "log", ".", "info", "(", "\"=======================\"", ")", ";", "}"], "docstring": "private QueueConnectionFactory queueConnectionFactory;", "docstring_tokens": ["private", "QueueConnectionFactory", "queueConnectionFactory", ";"]}
{"code": "int state = NO_TOKEN_STATE;", "comments": "start in the NO_TOKEN_STATE", "lines": 6, "repo": "ninjaframework/ninja", "path": "ninja-maven-plugin/src/main/java/ninja/build/ArgumentTokenizer.java", "func_name": "ArgumentTokenizer.tokenize", "original_string": "public static List<String> tokenize(String arguments, boolean stringify) {\n    \n    LinkedList<String> argList = new LinkedList<>();\n    StringBuilder currArg = new StringBuilder();\n    boolean escaped = false;\n    int state = NO_TOKEN_STATE;  // start in the NO_TOKEN_STATE\n    int len = arguments.length();\n    \n    // Loop over each character in the string\n    for (int i = 0; i < len; i++) {\n      char c = arguments.charAt(i);\n      if (escaped) {\n        // Escaped state: just append the next character to the current arg.\n        escaped = false;\n        currArg.append(c);\n      }\n      else {\n        switch(state) {\n          case SINGLE_QUOTE_STATE:\n            if (c == '\\'') {\n            // Seen the close quote; continue this arg until whitespace is seen\n            state = NORMAL_TOKEN_STATE;\n          }\n            else {\n              currArg.append(c);\n            }\n            break;\n          case DOUBLE_QUOTE_STATE:\n            if (c == '\"') {\n            // Seen the close quote; continue this arg until whitespace is seen\n            state = NORMAL_TOKEN_STATE;\n          }\n            else if (c == '\\\\') {\n              // Look ahead, and only escape quotes or backslashes\n              i++;\n              char next = arguments.charAt(i);\n              if (next == '\"' || next == '\\\\') {\n                currArg.append(next);\n              }\n              else {\n                currArg.append(c);\n                currArg.append(next);\n              }\n            }\n            else {\n              currArg.append(c);\n            }\n            break;\n//          case NORMAL_TOKEN_STATE:\n//            if (Character.isWhitespace(c)) {\n//              // Whitespace ends the token; start a new one\n//              argList.add(currArg.toString());\n//              currArg = new StringBuffer();\n//              state = NO_TOKEN_STATE;\n//            }\n//            else if (c == '\\\\') {\n//              // Backslash in a normal token: escape the next character\n//              escaped = true;\n//            }\n//            else if (c == '\\'') {\n//              state = SINGLE_QUOTE_STATE;\n//            }\n//            else if (c == '\"') {\n//              state = DOUBLE_QUOTE_STATE;\n//            }\n//            else {\n//              currArg.append(c);\n//            }\n//            break;\n          case NO_TOKEN_STATE:\n          case NORMAL_TOKEN_STATE:\n            switch(c) {\n            case '\\\\':\n              escaped = true;\n              state = NORMAL_TOKEN_STATE;\n              break;\n            case '\\'':\n              state = SINGLE_QUOTE_STATE;\n              break;\n            case '\"':\n              state = DOUBLE_QUOTE_STATE;\n              break;\n            default:\n              if (!Character.isWhitespace(c)) {\n              currArg.append(c);\n              state = NORMAL_TOKEN_STATE;\n            }\n              else if (state == NORMAL_TOKEN_STATE) {\n                // Whitespace ends the token; start a new one\n                argList.add(currArg.toString());\n                currArg = new StringBuilder();\n                state = NO_TOKEN_STATE;\n              }\n          }\n            break;\n          default:\n            throw new IllegalStateException(\"ArgumentTokenizer state \" + state + \" is invalid!\");\n        }\n      }\n    }\n    \n    // If we're still escaped, put in the backslash\n    if (escaped) {\n      currArg.append('\\\\');\n      argList.add(currArg.toString());\n    }\n    // Close the last argument if we haven't yet\n    else if (state != NO_TOKEN_STATE) {\n      argList.add(currArg.toString());\n    }\n    // Format each argument if we've been told to stringify them\n    if (stringify) {\n      for (int i = 0; i < argList.size(); i++) {\n        argList.set(i, \"\\\"\" + _escapeQuotesAndBackslashes(argList.get(i)) + \"\\\"\");\n      }\n    }\n    return argList;\n  }", "language": "java", "Allcodes": "public static List<String> tokenize(String arguments, boolean stringify) {\n    \n    LinkedList<String> argList = new LinkedList<>();\n    StringBuilder currArg = new StringBuilder();\n    boolean escaped = false;\n    int state = NO_TOKEN_STATE;  // start in the NO_TOKEN_STATE\n    int len = arguments.length();\n    \n    // Loop over each character in the string\n    for (int i = 0; i < len; i++) {\n      char c = arguments.charAt(i);\n      if (escaped) {\n        // Escaped state: just append the next character to the current arg.\n        escaped = false;\n        currArg.append(c);\n      }\n      else {\n        switch(state) {\n          case SINGLE_QUOTE_STATE:\n            if (c == '\\'') {\n            // Seen the close quote; continue this arg until whitespace is seen\n            state = NORMAL_TOKEN_STATE;\n          }\n            else {\n              currArg.append(c);\n            }\n            break;\n          case DOUBLE_QUOTE_STATE:\n            if (c == '\"') {\n            // Seen the close quote; continue this arg until whitespace is seen\n            state = NORMAL_TOKEN_STATE;\n          }\n            else if (c == '\\\\') {\n              // Look ahead, and only escape quotes or backslashes\n              i++;\n              char next = arguments.charAt(i);\n              if (next == '\"' || next == '\\\\') {\n                currArg.append(next);\n              }\n              else {\n                currArg.append(c);\n                currArg.append(next);\n              }\n            }\n            else {\n              currArg.append(c);\n            }\n            break;\n//          case NORMAL_TOKEN_STATE:\n//            if (Character.isWhitespace(c)) {\n//              // Whitespace ends the token; start a new one\n//              argList.add(currArg.toString());\n//              currArg = new StringBuffer();\n//              state = NO_TOKEN_STATE;\n//            }\n//            else if (c == '\\\\') {\n//              // Backslash in a normal token: escape the next character\n//              escaped = true;\n//            }\n//            else if (c == '\\'') {\n//              state = SINGLE_QUOTE_STATE;\n//            }\n//            else if (c == '\"') {\n//              state = DOUBLE_QUOTE_STATE;\n//            }\n//            else {\n//              currArg.append(c);\n//            }\n//            break;\n          case NO_TOKEN_STATE:\n          case NORMAL_TOKEN_STATE:\n            switch(c) {\n            case '\\\\':\n              escaped = true;\n              state = NORMAL_TOKEN_STATE;\n              break;\n            case '\\'':\n              state = SINGLE_QUOTE_STATE;\n              break;\n            case '\"':\n              state = DOUBLE_QUOTE_STATE;\n              break;\n            default:\n              if (!Character.isWhitespace(c)) {\n              currArg.append(c);\n              state = NORMAL_TOKEN_STATE;\n            }\n              else if (state == NORMAL_TOKEN_STATE) {\n                // Whitespace ends the token; start a new one\n                argList.add(currArg.toString());\n                currArg = new StringBuilder();\n                state = NO_TOKEN_STATE;\n              }\n          }\n            break;\n          default:\n            throw new IllegalStateException(\"ArgumentTokenizer state \" + state + \" is invalid!\");\n        }\n      }\n    }\n    \n    // If we're still escaped, put in the backslash\n    if (escaped) {\n      currArg.append('\\\\');\n      argList.add(currArg.toString());\n    }\n    // Close the last argument if we haven't yet\n    else if (state != NO_TOKEN_STATE) {\n      argList.add(currArg.toString());\n    }\n    // Format each argument if we've been told to stringify them\n    if (stringify) {\n      for (int i = 0; i < argList.size(); i++) {\n        argList.set(i, \"\\\"\" + _escapeQuotesAndBackslashes(argList.get(i)) + \"\\\"\");\n      }\n    }\n    return argList;\n  }", "code_tokens": ["public", "static", "List", "<", "String", ">", "tokenize", "(", "String", "arguments", ",", "boolean", "stringify", ")", "{", "LinkedList", "<", "String", ">", "argList", "=", "new", "LinkedList", "<>", "(", ")", ";", "StringBuilder", "currArg", "=", "new", "StringBuilder", "(", ")", ";", "boolean", "escaped", "=", "false", ";", "int", "state", "=", "NO_TOKEN_STATE", ";", "// start in the NO_TOKEN_STATE", "int", "len", "=", "arguments", ".", "length", "(", ")", ";", "// Loop over each character in the string", "for", "(", "int", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "char", "c", "=", "arguments", ".", "charAt", "(", "i", ")", ";", "if", "(", "escaped", ")", "{", "// Escaped state: just append the next character to the current arg.", "escaped", "=", "false", ";", "currArg", ".", "append", "(", "c", ")", ";", "}", "else", "{", "switch", "(", "state", ")", "{", "case", "SINGLE_QUOTE_STATE", ":", "if", "(", "c", "==", "'", "'", ")", "{", "// Seen the close quote; continue this arg until whitespace is seen", "state", "=", "NORMAL_TOKEN_STATE", ";", "}", "else", "{", "currArg", ".", "append", "(", "c", ")", ";", "}", "break", ";", "case", "DOUBLE_QUOTE_STATE", ":", "if", "(", "c", "==", "'", "'", ")", "{", "// Seen the close quote; continue this arg until whitespace is seen", "state", "=", "NORMAL_TOKEN_STATE", ";", "}", "else", "if", "(", "c", "==", "'", "'", ")", "{", "// Look ahead, and only escape quotes or backslashes", "i", "++", ";", "char", "next", "=", "arguments", ".", "charAt", "(", "i", ")", ";", "if", "(", "next", "==", "'", "'", "||", "next", "==", "'", "'", ")", "{", "currArg", ".", "append", "(", "next", ")", ";", "}", "else", "{", "currArg", ".", "append", "(", "c", ")", ";", "currArg", ".", "append", "(", "next", ")", ";", "}", "}", "else", "{", "currArg", ".", "append", "(", "c", ")", ";", "}", "break", ";", "//          case NORMAL_TOKEN_STATE:", "//            if (Character.isWhitespace(c)) {", "//              // Whitespace ends the token; start a new one", "//              argList.add(currArg.toString());", "//              currArg = new StringBuffer();", "//              state = NO_TOKEN_STATE;", "//            }", "//            else if (c == '\\\\') {", "//              // Backslash in a normal token: escape the next character", "//              escaped = true;", "//            }", "//            else if (c == '\\'') {", "//              state = SINGLE_QUOTE_STATE;", "//            }", "//            else if (c == '\"') {", "//              state = DOUBLE_QUOTE_STATE;", "//            }", "//            else {", "//              currArg.append(c);", "//            }", "//            break;", "case", "NO_TOKEN_STATE", ":", "case", "NORMAL_TOKEN_STATE", ":", "switch", "(", "c", ")", "{", "case", "'", "'", ":", "escaped", "=", "true", ";", "state", "=", "NORMAL_TOKEN_STATE", ";", "break", ";", "case", "'", "'", ":", "state", "=", "SINGLE_QUOTE_STATE", ";", "break", ";", "case", "'", "'", ":", "state", "=", "DOUBLE_QUOTE_STATE", ";", "break", ";", "default", ":", "if", "(", "!", "Character", ".", "isWhitespace", "(", "c", ")", ")", "{", "currArg", ".", "append", "(", "c", ")", ";", "state", "=", "NORMAL_TOKEN_STATE", ";", "}", "else", "if", "(", "state", "==", "NORMAL_TOKEN_STATE", ")", "{", "// Whitespace ends the token; start a new one", "argList", ".", "add", "(", "currArg", ".", "toString", "(", ")", ")", ";", "currArg", "=", "new", "StringBuilder", "(", ")", ";", "state", "=", "NO_TOKEN_STATE", ";", "}", "}", "break", ";", "default", ":", "throw", "new", "IllegalStateException", "(", "\"ArgumentTokenizer state \"", "+", "state", "+", "\" is invalid!\"", ")", ";", "}", "}", "}", "// If we're still escaped, put in the backslash", "if", "(", "escaped", ")", "{", "currArg", ".", "append", "(", "'", "'", ")", ";", "argList", ".", "add", "(", "currArg", ".", "toString", "(", ")", ")", ";", "}", "// Close the last argument if we haven't yet", "else", "if", "(", "state", "!=", "NO_TOKEN_STATE", ")", "{", "argList", ".", "add", "(", "currArg", ".", "toString", "(", ")", ")", ";", "}", "// Format each argument if we've been told to stringify them", "if", "(", "stringify", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "argList", ".", "size", "(", ")", ";", "i", "++", ")", "{", "argList", ".", "set", "(", "i", ",", "\"\\\"\"", "+", "_escapeQuotesAndBackslashes", "(", "argList", ".", "get", "(", "i", ")", ")", "+", "\"\\\"\"", ")", ";", "}", "}", "return", "argList", ";", "}"], "docstring": "Tokenizes the given String into String tokens.\n@param arguments A String containing one or more command-line style arguments to be tokenized.\n@param stringify whether or not to include escape special characters\n@return A list of parsed and properly escaped arguments.", "docstring_tokens": ["Tokenizes", "the", "given", "String", "into", "String", "tokens", "."]}
{"code": "Array.set(objToFix, ref.index, objReferenced.target);", "comments": "patch array element here", "lines": 24, "repo": "jdereg/json-io", "path": "src/main/java/com/cedarsoftware/util/io/Resolver.java", "func_name": "Resolver.patchUnresolvedReferences", "original_string": "protected void patchUnresolvedReferences()\n    {\n        Iterator i = unresolvedRefs.iterator();\n        while (i.hasNext())\n        {\n            UnresolvedReference ref = (UnresolvedReference) i.next();\n            Object objToFix = ref.referencingObj.target;\n            JsonObject objReferenced = reader.getObjectsRead().get(ref.refId);\n\n            if (ref.index >= 0)\n            {    // Fix []'s and Collections containing a forward reference.\n                if (objToFix instanceof List)\n                {   // Patch up Indexable Collections\n                    List list = (List) objToFix;\n                    list.set(ref.index, objReferenced.target);\n                }\n                else if (objToFix instanceof Collection)\n                {   // Add element (since it was not indexable, add it to collection)\n                    Collection col = (Collection) objToFix;\n                    col.add(objReferenced.target);\n                }\n                else\n                {\n                    Array.set(objToFix, ref.index, objReferenced.target);        // patch array element here\n                }\n            }\n            else\n            {    // Fix field forward reference\n                Field field = MetaUtils.getField(objToFix.getClass(), ref.field);\n                if (field != null)\n                {\n                    try\n                    {\n                        field.set(objToFix, objReferenced.target);               // patch field here\n                    }\n                    catch (Exception e)\n                    {\n                        throw new JsonIoException(\"Error setting field while resolving references '\" + field.getName() + \"', @ref = \" + ref.refId, e);\n                    }\n                }\n            }\n\n            i.remove();\n        }\n    }", "language": "java", "Allcodes": "protected void patchUnresolvedReferences()\n    {\n        Iterator i = unresolvedRefs.iterator();\n        while (i.hasNext())\n        {\n            UnresolvedReference ref = (UnresolvedReference) i.next();\n            Object objToFix = ref.referencingObj.target;\n            JsonObject objReferenced = reader.getObjectsRead().get(ref.refId);\n\n            if (ref.index >= 0)\n            {    // Fix []'s and Collections containing a forward reference.\n                if (objToFix instanceof List)\n                {   // Patch up Indexable Collections\n                    List list = (List) objToFix;\n                    list.set(ref.index, objReferenced.target);\n                }\n                else if (objToFix instanceof Collection)\n                {   // Add element (since it was not indexable, add it to collection)\n                    Collection col = (Collection) objToFix;\n                    col.add(objReferenced.target);\n                }\n                else\n                {\n                    Array.set(objToFix, ref.index, objReferenced.target);        // patch array element here\n                }\n            }\n            else\n            {    // Fix field forward reference\n                Field field = MetaUtils.getField(objToFix.getClass(), ref.field);\n                if (field != null)\n                {\n                    try\n                    {\n                        field.set(objToFix, objReferenced.target);               // patch field here\n                    }\n                    catch (Exception e)\n                    {\n                        throw new JsonIoException(\"Error setting field while resolving references '\" + field.getName() + \"', @ref = \" + ref.refId, e);\n                    }\n                }\n            }\n\n            i.remove();\n        }\n    }", "code_tokens": ["protected", "void", "patchUnresolvedReferences", "(", ")", "{", "Iterator", "i", "=", "unresolvedRefs", ".", "iterator", "(", ")", ";", "while", "(", "i", ".", "hasNext", "(", ")", ")", "{", "UnresolvedReference", "ref", "=", "(", "UnresolvedReference", ")", "i", ".", "next", "(", ")", ";", "Object", "objToFix", "=", "ref", ".", "referencingObj", ".", "target", ";", "JsonObject", "objReferenced", "=", "reader", ".", "getObjectsRead", "(", ")", ".", "get", "(", "ref", ".", "refId", ")", ";", "if", "(", "ref", ".", "index", ">=", "0", ")", "{", "// Fix []'s and Collections containing a forward reference.", "if", "(", "objToFix", "instanceof", "List", ")", "{", "// Patch up Indexable Collections", "List", "list", "=", "(", "List", ")", "objToFix", ";", "list", ".", "set", "(", "ref", ".", "index", ",", "objReferenced", ".", "target", ")", ";", "}", "else", "if", "(", "objToFix", "instanceof", "Collection", ")", "{", "// Add element (since it was not indexable, add it to collection)", "Collection", "col", "=", "(", "Collection", ")", "objToFix", ";", "col", ".", "add", "(", "objReferenced", ".", "target", ")", ";", "}", "else", "{", "Array", ".", "set", "(", "objToFix", ",", "ref", ".", "index", ",", "objReferenced", ".", "target", ")", ";", "// patch array element here", "}", "}", "else", "{", "// Fix field forward reference", "Field", "field", "=", "MetaUtils", ".", "getField", "(", "objToFix", ".", "getClass", "(", ")", ",", "ref", ".", "field", ")", ";", "if", "(", "field", "!=", "null", ")", "{", "try", "{", "field", ".", "set", "(", "objToFix", ",", "objReferenced", ".", "target", ")", ";", "// patch field here", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "JsonIoException", "(", "\"Error setting field while resolving references '\"", "+", "field", ".", "getName", "(", ")", "+", "\"', @ref = \"", "+", "ref", ".", "refId", ",", "e", ")", ";", "}", "}", "}", "i", ".", "remove", "(", ")", ";", "}", "}"], "docstring": "For all fields where the value was \"@ref\":\"n\" where 'n' was the id of an object\nthat had not yet been encountered in the stream, make the final substitution.", "docstring_tokens": ["For", "all", "fields", "where", "the", "value", "was"]}
{"code": "field.set(objToFix, objReferenced.target);", "comments": "patch field here", "lines": 34, "repo": "jdereg/json-io", "path": "src/main/java/com/cedarsoftware/util/io/Resolver.java", "func_name": "Resolver.patchUnresolvedReferences", "original_string": "protected void patchUnresolvedReferences()\n    {\n        Iterator i = unresolvedRefs.iterator();\n        while (i.hasNext())\n        {\n            UnresolvedReference ref = (UnresolvedReference) i.next();\n            Object objToFix = ref.referencingObj.target;\n            JsonObject objReferenced = reader.getObjectsRead().get(ref.refId);\n\n            if (ref.index >= 0)\n            {    // Fix []'s and Collections containing a forward reference.\n                if (objToFix instanceof List)\n                {   // Patch up Indexable Collections\n                    List list = (List) objToFix;\n                    list.set(ref.index, objReferenced.target);\n                }\n                else if (objToFix instanceof Collection)\n                {   // Add element (since it was not indexable, add it to collection)\n                    Collection col = (Collection) objToFix;\n                    col.add(objReferenced.target);\n                }\n                else\n                {\n                    Array.set(objToFix, ref.index, objReferenced.target);        // patch array element here\n                }\n            }\n            else\n            {    // Fix field forward reference\n                Field field = MetaUtils.getField(objToFix.getClass(), ref.field);\n                if (field != null)\n                {\n                    try\n                    {\n                        field.set(objToFix, objReferenced.target);               // patch field here\n                    }\n                    catch (Exception e)\n                    {\n                        throw new JsonIoException(\"Error setting field while resolving references '\" + field.getName() + \"', @ref = \" + ref.refId, e);\n                    }\n                }\n            }\n\n            i.remove();\n        }\n    }", "language": "java", "Allcodes": "protected void patchUnresolvedReferences()\n    {\n        Iterator i = unresolvedRefs.iterator();\n        while (i.hasNext())\n        {\n            UnresolvedReference ref = (UnresolvedReference) i.next();\n            Object objToFix = ref.referencingObj.target;\n            JsonObject objReferenced = reader.getObjectsRead().get(ref.refId);\n\n            if (ref.index >= 0)\n            {    // Fix []'s and Collections containing a forward reference.\n                if (objToFix instanceof List)\n                {   // Patch up Indexable Collections\n                    List list = (List) objToFix;\n                    list.set(ref.index, objReferenced.target);\n                }\n                else if (objToFix instanceof Collection)\n                {   // Add element (since it was not indexable, add it to collection)\n                    Collection col = (Collection) objToFix;\n                    col.add(objReferenced.target);\n                }\n                else\n                {\n                    Array.set(objToFix, ref.index, objReferenced.target);        // patch array element here\n                }\n            }\n            else\n            {    // Fix field forward reference\n                Field field = MetaUtils.getField(objToFix.getClass(), ref.field);\n                if (field != null)\n                {\n                    try\n                    {\n                        field.set(objToFix, objReferenced.target);               // patch field here\n                    }\n                    catch (Exception e)\n                    {\n                        throw new JsonIoException(\"Error setting field while resolving references '\" + field.getName() + \"', @ref = \" + ref.refId, e);\n                    }\n                }\n            }\n\n            i.remove();\n        }\n    }", "code_tokens": ["protected", "void", "patchUnresolvedReferences", "(", ")", "{", "Iterator", "i", "=", "unresolvedRefs", ".", "iterator", "(", ")", ";", "while", "(", "i", ".", "hasNext", "(", ")", ")", "{", "UnresolvedReference", "ref", "=", "(", "UnresolvedReference", ")", "i", ".", "next", "(", ")", ";", "Object", "objToFix", "=", "ref", ".", "referencingObj", ".", "target", ";", "JsonObject", "objReferenced", "=", "reader", ".", "getObjectsRead", "(", ")", ".", "get", "(", "ref", ".", "refId", ")", ";", "if", "(", "ref", ".", "index", ">=", "0", ")", "{", "// Fix []'s and Collections containing a forward reference.", "if", "(", "objToFix", "instanceof", "List", ")", "{", "// Patch up Indexable Collections", "List", "list", "=", "(", "List", ")", "objToFix", ";", "list", ".", "set", "(", "ref", ".", "index", ",", "objReferenced", ".", "target", ")", ";", "}", "else", "if", "(", "objToFix", "instanceof", "Collection", ")", "{", "// Add element (since it was not indexable, add it to collection)", "Collection", "col", "=", "(", "Collection", ")", "objToFix", ";", "col", ".", "add", "(", "objReferenced", ".", "target", ")", ";", "}", "else", "{", "Array", ".", "set", "(", "objToFix", ",", "ref", ".", "index", ",", "objReferenced", ".", "target", ")", ";", "// patch array element here", "}", "}", "else", "{", "// Fix field forward reference", "Field", "field", "=", "MetaUtils", ".", "getField", "(", "objToFix", ".", "getClass", "(", ")", ",", "ref", ".", "field", ")", ";", "if", "(", "field", "!=", "null", ")", "{", "try", "{", "field", ".", "set", "(", "objToFix", ",", "objReferenced", ".", "target", ")", ";", "// patch field here", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "JsonIoException", "(", "\"Error setting field while resolving references '\"", "+", "field", ".", "getName", "(", ")", "+", "\"', @ref = \"", "+", "ref", ".", "refId", ",", "e", ")", ";", "}", "}", "}", "i", ".", "remove", "(", ")", ";", "}", "}"], "docstring": "For all fields where the value was \"@ref\":\"n\" where 'n' was the id of an object\nthat had not yet been encountered in the stream, make the final substitution.", "docstring_tokens": ["For", "all", "fields", "where", "the", "value", "was"]}
{"code": "jsonObj.put(fieldName, refObject);", "comments": "Update Map-of-Maps reference", "lines": 42, "repo": "jdereg/json-io", "path": "src/main/java/com/cedarsoftware/util/io/MapResolver.java", "func_name": "MapResolver.traverseFields", "original_string": "public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)\n    {\n        final Object target = jsonObj.target;\n        for (Map.Entry<String, Object> e : jsonObj.entrySet())\n        {\n            final String fieldName = e.getKey();\n            final Field field = (target != null) ? MetaUtils.getField(target.getClass(), fieldName) : null;\n            final Object rhs = e.getValue();\n\n            if (rhs == null)\n            {\n                jsonObj.put(fieldName, null);\n            }\n            else if (rhs == JsonParser.EMPTY_OBJECT)\n            {\n                jsonObj.put(fieldName, new JsonObject());\n            }\n            else if (rhs.getClass().isArray())\n            {   // RHS is an array\n                // Trace the contents of the array (so references inside the array and into the array work)\n                JsonObject<String, Object> jsonArray = new JsonObject<String, Object>();\n                jsonArray.put(\"@items\", rhs);\n                stack.addFirst(jsonArray);\n\n                // Assign the array directly to the Map key (field name)\n                jsonObj.put(fieldName, rhs);\n            }\n            else if (rhs instanceof JsonObject)\n            {\n                JsonObject<String, Object> jObj = (JsonObject) rhs;\n\n                if (field != null && MetaUtils.isLogicalPrimitive(field.getType()))\n                {\n                    jObj.put(\"value\", MetaUtils.convert(field.getType(), jObj.get(\"value\")));\n                    continue;\n                }\n                Long refId = jObj.getReferenceId();\n\n                if (refId != null)\n                {    // Correct field references\n                    JsonObject refObject = getReferencedObj(refId);\n                    jsonObj.put(fieldName, refObject);    // Update Map-of-Maps reference\n                }\n                else\n                {\n                    stack.addFirst(jObj);\n                }\n            }\n            else if (field != null)\n            {   // The code below is 'upgrading' the RHS values in the passed in JsonObject Map\n                // by using the @type class name (when specified and exists), to coerce the vanilla\n                // JSON values into the proper types defined by the class listed in @type.  This is\n                // a cool feature of json-io, that even when reading a map-of-maps JSON file, it will\n                // improve the final types of values in the maps RHS, to be of the field type that\n                // was optionally specified in @type.\n                final Class fieldType = field.getType();\n                if (MetaUtils.isPrimitive(fieldType) || BigDecimal.class.equals(fieldType) || BigInteger.class.equals(fieldType) || Date.class.equals(fieldType))\n                {\n                    jsonObj.put(fieldName, MetaUtils.convert(fieldType, rhs));\n                }\n                else if (rhs instanceof String)\n                {\n                    if (fieldType != String.class && fieldType != StringBuilder.class && fieldType != StringBuffer.class)\n                    {\n                        if (\"\".equals(((String)rhs).trim()))\n                        {   // Allow \"\" to null out a non-String field on the inbound JSON\n                            jsonObj.put(fieldName, null);\n                        }\n                    }\n                }\n            }\n        }\n        jsonObj.target = null;  // don't waste space (used for typed return, not for Map return)\n    }", "language": "java", "Allcodes": "public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)\n    {\n        final Object target = jsonObj.target;\n        for (Map.Entry<String, Object> e : jsonObj.entrySet())\n        {\n            final String fieldName = e.getKey();\n            final Field field = (target != null) ? MetaUtils.getField(target.getClass(), fieldName) : null;\n            final Object rhs = e.getValue();\n\n            if (rhs == null)\n            {\n                jsonObj.put(fieldName, null);\n            }\n            else if (rhs == JsonParser.EMPTY_OBJECT)\n            {\n                jsonObj.put(fieldName, new JsonObject());\n            }\n            else if (rhs.getClass().isArray())\n            {   // RHS is an array\n                // Trace the contents of the array (so references inside the array and into the array work)\n                JsonObject<String, Object> jsonArray = new JsonObject<String, Object>();\n                jsonArray.put(\"@items\", rhs);\n                stack.addFirst(jsonArray);\n\n                // Assign the array directly to the Map key (field name)\n                jsonObj.put(fieldName, rhs);\n            }\n            else if (rhs instanceof JsonObject)\n            {\n                JsonObject<String, Object> jObj = (JsonObject) rhs;\n\n                if (field != null && MetaUtils.isLogicalPrimitive(field.getType()))\n                {\n                    jObj.put(\"value\", MetaUtils.convert(field.getType(), jObj.get(\"value\")));\n                    continue;\n                }\n                Long refId = jObj.getReferenceId();\n\n                if (refId != null)\n                {    // Correct field references\n                    JsonObject refObject = getReferencedObj(refId);\n                    jsonObj.put(fieldName, refObject);    // Update Map-of-Maps reference\n                }\n                else\n                {\n                    stack.addFirst(jObj);\n                }\n            }\n            else if (field != null)\n            {   // The code below is 'upgrading' the RHS values in the passed in JsonObject Map\n                // by using the @type class name (when specified and exists), to coerce the vanilla\n                // JSON values into the proper types defined by the class listed in @type.  This is\n                // a cool feature of json-io, that even when reading a map-of-maps JSON file, it will\n                // improve the final types of values in the maps RHS, to be of the field type that\n                // was optionally specified in @type.\n                final Class fieldType = field.getType();\n                if (MetaUtils.isPrimitive(fieldType) || BigDecimal.class.equals(fieldType) || BigInteger.class.equals(fieldType) || Date.class.equals(fieldType))\n                {\n                    jsonObj.put(fieldName, MetaUtils.convert(fieldType, rhs));\n                }\n                else if (rhs instanceof String)\n                {\n                    if (fieldType != String.class && fieldType != StringBuilder.class && fieldType != StringBuffer.class)\n                    {\n                        if (\"\".equals(((String)rhs).trim()))\n                        {   // Allow \"\" to null out a non-String field on the inbound JSON\n                            jsonObj.put(fieldName, null);\n                        }\n                    }\n                }\n            }\n        }\n        jsonObj.target = null;  // don't waste space (used for typed return, not for Map return)\n    }", "code_tokens": ["public", "void", "traverseFields", "(", "final", "Deque", "<", "JsonObject", "<", "String", ",", "Object", ">", ">", "stack", ",", "final", "JsonObject", "<", "String", ",", "Object", ">", "jsonObj", ")", "{", "final", "Object", "target", "=", "jsonObj", ".", "target", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "e", ":", "jsonObj", ".", "entrySet", "(", ")", ")", "{", "final", "String", "fieldName", "=", "e", ".", "getKey", "(", ")", ";", "final", "Field", "field", "=", "(", "target", "!=", "null", ")", "?", "MetaUtils", ".", "getField", "(", "target", ".", "getClass", "(", ")", ",", "fieldName", ")", ":", "null", ";", "final", "Object", "rhs", "=", "e", ".", "getValue", "(", ")", ";", "if", "(", "rhs", "==", "null", ")", "{", "jsonObj", ".", "put", "(", "fieldName", ",", "null", ")", ";", "}", "else", "if", "(", "rhs", "==", "JsonParser", ".", "EMPTY_OBJECT", ")", "{", "jsonObj", ".", "put", "(", "fieldName", ",", "new", "JsonObject", "(", ")", ")", ";", "}", "else", "if", "(", "rhs", ".", "getClass", "(", ")", ".", "isArray", "(", ")", ")", "{", "// RHS is an array", "// Trace the contents of the array (so references inside the array and into the array work)", "JsonObject", "<", "String", ",", "Object", ">", "jsonArray", "=", "new", "JsonObject", "<", "String", ",", "Object", ">", "(", ")", ";", "jsonArray", ".", "put", "(", "\"@items\"", ",", "rhs", ")", ";", "stack", ".", "addFirst", "(", "jsonArray", ")", ";", "// Assign the array directly to the Map key (field name)", "jsonObj", ".", "put", "(", "fieldName", ",", "rhs", ")", ";", "}", "else", "if", "(", "rhs", "instanceof", "JsonObject", ")", "{", "JsonObject", "<", "String", ",", "Object", ">", "jObj", "=", "(", "JsonObject", ")", "rhs", ";", "if", "(", "field", "!=", "null", "&&", "MetaUtils", ".", "isLogicalPrimitive", "(", "field", ".", "getType", "(", ")", ")", ")", "{", "jObj", ".", "put", "(", "\"value\"", ",", "MetaUtils", ".", "convert", "(", "field", ".", "getType", "(", ")", ",", "jObj", ".", "get", "(", "\"value\"", ")", ")", ")", ";", "continue", ";", "}", "Long", "refId", "=", "jObj", ".", "getReferenceId", "(", ")", ";", "if", "(", "refId", "!=", "null", ")", "{", "// Correct field references", "JsonObject", "refObject", "=", "getReferencedObj", "(", "refId", ")", ";", "jsonObj", ".", "put", "(", "fieldName", ",", "refObject", ")", ";", "// Update Map-of-Maps reference", "}", "else", "{", "stack", ".", "addFirst", "(", "jObj", ")", ";", "}", "}", "else", "if", "(", "field", "!=", "null", ")", "{", "// The code below is 'upgrading' the RHS values in the passed in JsonObject Map", "// by using the @type class name (when specified and exists), to coerce the vanilla", "// JSON values into the proper types defined by the class listed in @type.  This is", "// a cool feature of json-io, that even when reading a map-of-maps JSON file, it will", "// improve the final types of values in the maps RHS, to be of the field type that", "// was optionally specified in @type.", "final", "Class", "fieldType", "=", "field", ".", "getType", "(", ")", ";", "if", "(", "MetaUtils", ".", "isPrimitive", "(", "fieldType", ")", "||", "BigDecimal", ".", "class", ".", "equals", "(", "fieldType", ")", "||", "BigInteger", ".", "class", ".", "equals", "(", "fieldType", ")", "||", "Date", ".", "class", ".", "equals", "(", "fieldType", ")", ")", "{", "jsonObj", ".", "put", "(", "fieldName", ",", "MetaUtils", ".", "convert", "(", "fieldType", ",", "rhs", ")", ")", ";", "}", "else", "if", "(", "rhs", "instanceof", "String", ")", "{", "if", "(", "fieldType", "!=", "String", ".", "class", "&&", "fieldType", "!=", "StringBuilder", ".", "class", "&&", "fieldType", "!=", "StringBuffer", ".", "class", ")", "{", "if", "(", "\"\"", ".", "equals", "(", "(", "(", "String", ")", "rhs", ")", ".", "trim", "(", ")", ")", ")", "{", "// Allow \"\" to null out a non-String field on the inbound JSON", "jsonObj", ".", "put", "(", "fieldName", ",", "null", ")", ";", "}", "}", "}", "}", "}", "jsonObj", ".", "target", "=", "null", ";", "// don't waste space (used for typed return, not for Map return)", "}"], "docstring": "Walk the JsonObject fields and perform necessary substitutions so that all references matched up.\nThis code patches @ref and @id pairings up, in the 'Map of Map' mode.  Where the JSON may contain\nan @id of an object which can have more than one @ref to it, this code will make sure that each\n@ref (value side of the Map associated to a given field name) will be pointer to the appropriate Map\ninstance.\n@param stack   Stack (Deque) used for graph traversal.\n@param jsonObj a Map-of-Map representation of the current object being examined (containing all fields).", "docstring_tokens": ["Walk", "the", "JsonObject", "fields", "and", "perform", "necessary", "substitutions", "so", "that", "all", "references", "matched", "up", ".", "This", "code", "patches"]}
{"code": "jsonObj.target = null;", "comments": "don't waste space (used for typed return, not for Map return)", "lines": 73, "repo": "jdereg/json-io", "path": "src/main/java/com/cedarsoftware/util/io/MapResolver.java", "func_name": "MapResolver.traverseFields", "original_string": "public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)\n    {\n        final Object target = jsonObj.target;\n        for (Map.Entry<String, Object> e : jsonObj.entrySet())\n        {\n            final String fieldName = e.getKey();\n            final Field field = (target != null) ? MetaUtils.getField(target.getClass(), fieldName) : null;\n            final Object rhs = e.getValue();\n\n            if (rhs == null)\n            {\n                jsonObj.put(fieldName, null);\n            }\n            else if (rhs == JsonParser.EMPTY_OBJECT)\n            {\n                jsonObj.put(fieldName, new JsonObject());\n            }\n            else if (rhs.getClass().isArray())\n            {   // RHS is an array\n                // Trace the contents of the array (so references inside the array and into the array work)\n                JsonObject<String, Object> jsonArray = new JsonObject<String, Object>();\n                jsonArray.put(\"@items\", rhs);\n                stack.addFirst(jsonArray);\n\n                // Assign the array directly to the Map key (field name)\n                jsonObj.put(fieldName, rhs);\n            }\n            else if (rhs instanceof JsonObject)\n            {\n                JsonObject<String, Object> jObj = (JsonObject) rhs;\n\n                if (field != null && MetaUtils.isLogicalPrimitive(field.getType()))\n                {\n                    jObj.put(\"value\", MetaUtils.convert(field.getType(), jObj.get(\"value\")));\n                    continue;\n                }\n                Long refId = jObj.getReferenceId();\n\n                if (refId != null)\n                {    // Correct field references\n                    JsonObject refObject = getReferencedObj(refId);\n                    jsonObj.put(fieldName, refObject);    // Update Map-of-Maps reference\n                }\n                else\n                {\n                    stack.addFirst(jObj);\n                }\n            }\n            else if (field != null)\n            {   // The code below is 'upgrading' the RHS values in the passed in JsonObject Map\n                // by using the @type class name (when specified and exists), to coerce the vanilla\n                // JSON values into the proper types defined by the class listed in @type.  This is\n                // a cool feature of json-io, that even when reading a map-of-maps JSON file, it will\n                // improve the final types of values in the maps RHS, to be of the field type that\n                // was optionally specified in @type.\n                final Class fieldType = field.getType();\n                if (MetaUtils.isPrimitive(fieldType) || BigDecimal.class.equals(fieldType) || BigInteger.class.equals(fieldType) || Date.class.equals(fieldType))\n                {\n                    jsonObj.put(fieldName, MetaUtils.convert(fieldType, rhs));\n                }\n                else if (rhs instanceof String)\n                {\n                    if (fieldType != String.class && fieldType != StringBuilder.class && fieldType != StringBuffer.class)\n                    {\n                        if (\"\".equals(((String)rhs).trim()))\n                        {   // Allow \"\" to null out a non-String field on the inbound JSON\n                            jsonObj.put(fieldName, null);\n                        }\n                    }\n                }\n            }\n        }\n        jsonObj.target = null;  // don't waste space (used for typed return, not for Map return)\n    }", "language": "java", "Allcodes": "public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)\n    {\n        final Object target = jsonObj.target;\n        for (Map.Entry<String, Object> e : jsonObj.entrySet())\n        {\n            final String fieldName = e.getKey();\n            final Field field = (target != null) ? MetaUtils.getField(target.getClass(), fieldName) : null;\n            final Object rhs = e.getValue();\n\n            if (rhs == null)\n            {\n                jsonObj.put(fieldName, null);\n            }\n            else if (rhs == JsonParser.EMPTY_OBJECT)\n            {\n                jsonObj.put(fieldName, new JsonObject());\n            }\n            else if (rhs.getClass().isArray())\n            {   // RHS is an array\n                // Trace the contents of the array (so references inside the array and into the array work)\n                JsonObject<String, Object> jsonArray = new JsonObject<String, Object>();\n                jsonArray.put(\"@items\", rhs);\n                stack.addFirst(jsonArray);\n\n                // Assign the array directly to the Map key (field name)\n                jsonObj.put(fieldName, rhs);\n            }\n            else if (rhs instanceof JsonObject)\n            {\n                JsonObject<String, Object> jObj = (JsonObject) rhs;\n\n                if (field != null && MetaUtils.isLogicalPrimitive(field.getType()))\n                {\n                    jObj.put(\"value\", MetaUtils.convert(field.getType(), jObj.get(\"value\")));\n                    continue;\n                }\n                Long refId = jObj.getReferenceId();\n\n                if (refId != null)\n                {    // Correct field references\n                    JsonObject refObject = getReferencedObj(refId);\n                    jsonObj.put(fieldName, refObject);    // Update Map-of-Maps reference\n                }\n                else\n                {\n                    stack.addFirst(jObj);\n                }\n            }\n            else if (field != null)\n            {   // The code below is 'upgrading' the RHS values in the passed in JsonObject Map\n                // by using the @type class name (when specified and exists), to coerce the vanilla\n                // JSON values into the proper types defined by the class listed in @type.  This is\n                // a cool feature of json-io, that even when reading a map-of-maps JSON file, it will\n                // improve the final types of values in the maps RHS, to be of the field type that\n                // was optionally specified in @type.\n                final Class fieldType = field.getType();\n                if (MetaUtils.isPrimitive(fieldType) || BigDecimal.class.equals(fieldType) || BigInteger.class.equals(fieldType) || Date.class.equals(fieldType))\n                {\n                    jsonObj.put(fieldName, MetaUtils.convert(fieldType, rhs));\n                }\n                else if (rhs instanceof String)\n                {\n                    if (fieldType != String.class && fieldType != StringBuilder.class && fieldType != StringBuffer.class)\n                    {\n                        if (\"\".equals(((String)rhs).trim()))\n                        {   // Allow \"\" to null out a non-String field on the inbound JSON\n                            jsonObj.put(fieldName, null);\n                        }\n                    }\n                }\n            }\n        }\n        jsonObj.target = null;  // don't waste space (used for typed return, not for Map return)\n    }", "code_tokens": ["public", "void", "traverseFields", "(", "final", "Deque", "<", "JsonObject", "<", "String", ",", "Object", ">", ">", "stack", ",", "final", "JsonObject", "<", "String", ",", "Object", ">", "jsonObj", ")", "{", "final", "Object", "target", "=", "jsonObj", ".", "target", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "e", ":", "jsonObj", ".", "entrySet", "(", ")", ")", "{", "final", "String", "fieldName", "=", "e", ".", "getKey", "(", ")", ";", "final", "Field", "field", "=", "(", "target", "!=", "null", ")", "?", "MetaUtils", ".", "getField", "(", "target", ".", "getClass", "(", ")", ",", "fieldName", ")", ":", "null", ";", "final", "Object", "rhs", "=", "e", ".", "getValue", "(", ")", ";", "if", "(", "rhs", "==", "null", ")", "{", "jsonObj", ".", "put", "(", "fieldName", ",", "null", ")", ";", "}", "else", "if", "(", "rhs", "==", "JsonParser", ".", "EMPTY_OBJECT", ")", "{", "jsonObj", ".", "put", "(", "fieldName", ",", "new", "JsonObject", "(", ")", ")", ";", "}", "else", "if", "(", "rhs", ".", "getClass", "(", ")", ".", "isArray", "(", ")", ")", "{", "// RHS is an array", "// Trace the contents of the array (so references inside the array and into the array work)", "JsonObject", "<", "String", ",", "Object", ">", "jsonArray", "=", "new", "JsonObject", "<", "String", ",", "Object", ">", "(", ")", ";", "jsonArray", ".", "put", "(", "\"@items\"", ",", "rhs", ")", ";", "stack", ".", "addFirst", "(", "jsonArray", ")", ";", "// Assign the array directly to the Map key (field name)", "jsonObj", ".", "put", "(", "fieldName", ",", "rhs", ")", ";", "}", "else", "if", "(", "rhs", "instanceof", "JsonObject", ")", "{", "JsonObject", "<", "String", ",", "Object", ">", "jObj", "=", "(", "JsonObject", ")", "rhs", ";", "if", "(", "field", "!=", "null", "&&", "MetaUtils", ".", "isLogicalPrimitive", "(", "field", ".", "getType", "(", ")", ")", ")", "{", "jObj", ".", "put", "(", "\"value\"", ",", "MetaUtils", ".", "convert", "(", "field", ".", "getType", "(", ")", ",", "jObj", ".", "get", "(", "\"value\"", ")", ")", ")", ";", "continue", ";", "}", "Long", "refId", "=", "jObj", ".", "getReferenceId", "(", ")", ";", "if", "(", "refId", "!=", "null", ")", "{", "// Correct field references", "JsonObject", "refObject", "=", "getReferencedObj", "(", "refId", ")", ";", "jsonObj", ".", "put", "(", "fieldName", ",", "refObject", ")", ";", "// Update Map-of-Maps reference", "}", "else", "{", "stack", ".", "addFirst", "(", "jObj", ")", ";", "}", "}", "else", "if", "(", "field", "!=", "null", ")", "{", "// The code below is 'upgrading' the RHS values in the passed in JsonObject Map", "// by using the @type class name (when specified and exists), to coerce the vanilla", "// JSON values into the proper types defined by the class listed in @type.  This is", "// a cool feature of json-io, that even when reading a map-of-maps JSON file, it will", "// improve the final types of values in the maps RHS, to be of the field type that", "// was optionally specified in @type.", "final", "Class", "fieldType", "=", "field", ".", "getType", "(", ")", ";", "if", "(", "MetaUtils", ".", "isPrimitive", "(", "fieldType", ")", "||", "BigDecimal", ".", "class", ".", "equals", "(", "fieldType", ")", "||", "BigInteger", ".", "class", ".", "equals", "(", "fieldType", ")", "||", "Date", ".", "class", ".", "equals", "(", "fieldType", ")", ")", "{", "jsonObj", ".", "put", "(", "fieldName", ",", "MetaUtils", ".", "convert", "(", "fieldType", ",", "rhs", ")", ")", ";", "}", "else", "if", "(", "rhs", "instanceof", "String", ")", "{", "if", "(", "fieldType", "!=", "String", ".", "class", "&&", "fieldType", "!=", "StringBuilder", ".", "class", "&&", "fieldType", "!=", "StringBuffer", ".", "class", ")", "{", "if", "(", "\"\"", ".", "equals", "(", "(", "(", "String", ")", "rhs", ")", ".", "trim", "(", ")", ")", ")", "{", "// Allow \"\" to null out a non-String field on the inbound JSON", "jsonObj", ".", "put", "(", "fieldName", ",", "null", ")", ";", "}", "}", "}", "}", "}", "jsonObj", ".", "target", "=", "null", ";", "// don't waste space (used for typed return, not for Map return)", "}"], "docstring": "Walk the JsonObject fields and perform necessary substitutions so that all references matched up.\nThis code patches @ref and @id pairings up, in the 'Map of Map' mode.  Where the JSON may contain\nan @id of an object which can have more than one @ref to it, this code will make sure that each\n@ref (value side of the Map associated to a given field name) will be pointer to the appropriate Map\ninstance.\n@param stack   Stack (Deque) used for graph traversal.\n@param jsonObj a Map-of-Map representation of the current object being examined (containing all fields).", "docstring_tokens": ["Walk", "the", "JsonObject", "fields", "and", "perform", "necessary", "substitutions", "so", "that", "all", "references", "matched", "up", ".", "This", "code", "patches"]}
{"code": "writer.print( \" 1>/dev/null 2>&1 &\" );", "comments": "redirect outputs and run as background task", "lines": 23, "repo": "simpligility/android-maven-plugin", "path": "src/main/java/com/simpligility/maven/plugins/android/AbstractEmulatorMojo.java", "func_name": "AbstractEmulatorMojo.writeEmulatorStartScriptUnix", "original_string": "private String writeEmulatorStartScriptUnix() throws MojoExecutionException\n    {\n        String filename = SCRIPT_FOLDER + \"/android-maven-plugin-emulator-start.sh\";\n\n        File sh;\n        sh = new File( \"/bin/bash\" );\n        if ( !sh.exists() )\n        {\n            sh = new File( \"/usr/bin/bash\" );\n        }\n        if ( !sh.exists() )\n        {\n            sh = new File( \"/bin/sh\" );\n        }\n\n        File file = new File( filename );\n        PrintWriter writer = null;\n        try\n        {\n            writer = new PrintWriter( new FileWriter( file ) );\n            writer.println( \"#!\" + sh.getAbsolutePath() );\n            writer.print( assembleStartCommandLine() );\n            writer.print( \" 1>/dev/null 2>&1 &\" ); // redirect outputs and run as background task\n        }\n        catch ( IOException e )\n        {\n            getLog().error( \"Failure writing file \" + filename );\n        }\n        finally\n        {\n            if ( writer != null )\n            {\n                writer.flush();\n                writer.close();\n            }\n        }\n        file.setExecutable( true );\n        return filename;\n    }", "language": "java", "Allcodes": "private String writeEmulatorStartScriptUnix() throws MojoExecutionException\n    {\n        String filename = SCRIPT_FOLDER + \"/android-maven-plugin-emulator-start.sh\";\n\n        File sh;\n        sh = new File( \"/bin/bash\" );\n        if ( !sh.exists() )\n        {\n            sh = new File( \"/usr/bin/bash\" );\n        }\n        if ( !sh.exists() )\n        {\n            sh = new File( \"/bin/sh\" );\n        }\n\n        File file = new File( filename );\n        PrintWriter writer = null;\n        try\n        {\n            writer = new PrintWriter( new FileWriter( file ) );\n            writer.println( \"#!\" + sh.getAbsolutePath() );\n            writer.print( assembleStartCommandLine() );\n            writer.print( \" 1>/dev/null 2>&1 &\" ); // redirect outputs and run as background task\n        }\n        catch ( IOException e )\n        {\n            getLog().error( \"Failure writing file \" + filename );\n        }\n        finally\n        {\n            if ( writer != null )\n            {\n                writer.flush();\n                writer.close();\n            }\n        }\n        file.setExecutable( true );\n        return filename;\n    }", "code_tokens": ["private", "String", "writeEmulatorStartScriptUnix", "(", ")", "throws", "MojoExecutionException", "{", "String", "filename", "=", "SCRIPT_FOLDER", "+", "\"/android-maven-plugin-emulator-start.sh\"", ";", "File", "sh", ";", "sh", "=", "new", "File", "(", "\"/bin/bash\"", ")", ";", "if", "(", "!", "sh", ".", "exists", "(", ")", ")", "{", "sh", "=", "new", "File", "(", "\"/usr/bin/bash\"", ")", ";", "}", "if", "(", "!", "sh", ".", "exists", "(", ")", ")", "{", "sh", "=", "new", "File", "(", "\"/bin/sh\"", ")", ";", "}", "File", "file", "=", "new", "File", "(", "filename", ")", ";", "PrintWriter", "writer", "=", "null", ";", "try", "{", "writer", "=", "new", "PrintWriter", "(", "new", "FileWriter", "(", "file", ")", ")", ";", "writer", ".", "println", "(", "\"#!\"", "+", "sh", ".", "getAbsolutePath", "(", ")", ")", ";", "writer", ".", "print", "(", "assembleStartCommandLine", "(", ")", ")", ";", "writer", ".", "print", "(", "\" 1>/dev/null 2>&1 &\"", ")", ";", "// redirect outputs and run as background task", "}", "catch", "(", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "error", "(", "\"Failure writing file \"", "+", "filename", ")", ";", "}", "finally", "{", "if", "(", "writer", "!=", "null", ")", "{", "writer", ".", "flush", "(", ")", ";", "writer", ".", "close", "(", ")", ";", "}", "}", "file", ".", "setExecutable", "(", "true", ")", ";", "return", "filename", ";", "}"], "docstring": "Writes the script to start the emulator in the background for unix based environments.\n\n@return absolute path name of start script\n@throws IOException\n@throws MojoExecutionException", "docstring_tokens": ["Writes", "the", "script", "to", "start", "the", "emulator", "in", "the", "background", "for", "unix", "based", "environments", "."]}
{"code": "final AtomicBoolean result = new AtomicBoolean( true );", "comments": "if no devices are present, it counts as successful", "lines": 4, "repo": "simpligility/android-maven-plugin", "path": "src/main/java/com/simpligility/maven/plugins/android/AbstractAndroidMojo.java", "func_name": "AbstractAndroidMojo.undeployApk", "original_string": "protected boolean undeployApk( final String packageName ) throws MojoExecutionException, MojoFailureException\n    {\n\n        final AtomicBoolean result = new AtomicBoolean( true ); // if no devices are present, it counts as successful\n\n        doWithDevices( new DeviceCallback()\n        {\n            public void doWithDevice( final IDevice device ) throws MojoExecutionException\n            {\n                String deviceLogLinePrefix = DeviceHelper.getDeviceLogLinePrefix( device );\n                try\n                {\n                    device.uninstallPackage( packageName );\n                    getLog().info( deviceLogLinePrefix + \"Successfully uninstalled \" + packageName );\n                    getLog().debug( \" from \" + DeviceHelper.getDescriptiveName( device ) );\n                    result.set( true );\n                }\n                catch ( InstallException e )\n                {\n                    result.set( false );\n                    throw new MojoExecutionException( deviceLogLinePrefix + \"Uninstall of \" + packageName\n                            + \" failed.\", e );\n                }\n            }\n        } );\n\n        return result.get();\n    }", "language": "java", "Allcodes": "protected boolean undeployApk( final String packageName ) throws MojoExecutionException, MojoFailureException\n    {\n\n        final AtomicBoolean result = new AtomicBoolean( true ); // if no devices are present, it counts as successful\n\n        doWithDevices( new DeviceCallback()\n        {\n            public void doWithDevice( final IDevice device ) throws MojoExecutionException\n            {\n                String deviceLogLinePrefix = DeviceHelper.getDeviceLogLinePrefix( device );\n                try\n                {\n                    device.uninstallPackage( packageName );\n                    getLog().info( deviceLogLinePrefix + \"Successfully uninstalled \" + packageName );\n                    getLog().debug( \" from \" + DeviceHelper.getDescriptiveName( device ) );\n                    result.set( true );\n                }\n                catch ( InstallException e )\n                {\n                    result.set( false );\n                    throw new MojoExecutionException( deviceLogLinePrefix + \"Uninstall of \" + packageName\n                            + \" failed.\", e );\n                }\n            }\n        } );\n\n        return result.get();\n    }", "code_tokens": ["protected", "boolean", "undeployApk", "(", "final", "String", "packageName", ")", "throws", "MojoExecutionException", ",", "MojoFailureException", "{", "final", "AtomicBoolean", "result", "=", "new", "AtomicBoolean", "(", "true", ")", ";", "// if no devices are present, it counts as successful", "doWithDevices", "(", "new", "DeviceCallback", "(", ")", "{", "public", "void", "doWithDevice", "(", "final", "IDevice", "device", ")", "throws", "MojoExecutionException", "{", "String", "deviceLogLinePrefix", "=", "DeviceHelper", ".", "getDeviceLogLinePrefix", "(", "device", ")", ";", "try", "{", "device", ".", "uninstallPackage", "(", "packageName", ")", ";", "getLog", "(", ")", ".", "info", "(", "deviceLogLinePrefix", "+", "\"Successfully uninstalled \"", "+", "packageName", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\" from \"", "+", "DeviceHelper", ".", "getDescriptiveName", "(", "device", ")", ")", ";", "result", ".", "set", "(", "true", ")", ";", "}", "catch", "(", "InstallException", "e", ")", "{", "result", ".", "set", "(", "false", ")", ";", "throw", "new", "MojoExecutionException", "(", "deviceLogLinePrefix", "+", "\"Uninstall of \"", "+", "packageName", "+", "\" failed.\"", ",", "e", ")", ";", "}", "}", "}", ")", ";", "return", "result", ".", "get", "(", ")", ";", "}"], "docstring": "Undeploys an apk, specified by package name, from a connected emulator\nor usb device. Also deletes the application's data and cache\ndirectories on the device.\n\n@param packageName the package name to undeploy.\n@return <code>true</code> if successfully undeployed, <code>false</code> otherwise.", "docstring_tokens": ["Undeploys", "an", "apk", "specified", "by", "package", "name", "from", "a", "connected", "emulator", "or", "usb", "device", ".", "Also", "deletes", "the", "application", "s", "data", "and", "cache", "directories", "on", "the", "device", "."]}
{"code": "parameters.add( \"-f\" );", "comments": "force overwriting existing output file", "lines": 42, "repo": "simpligility/android-maven-plugin", "path": "src/main/java/com/simpligility/maven/plugins/android/standalonemojos/ZipalignMojo.java", "func_name": "ZipalignMojo.execute", "original_string": "public void execute() throws MojoExecutionException, MojoFailureException\n    {\n\n        // If we're not on a supported packaging with just skip (Issue 87)\n        // http://code.google.com/p/maven-android-plugin/issues/detail?id=87\n        if ( ! SUPPORTED_PACKAGING_TYPES.contains( project.getPackaging() ) )\n        {\n            getLog().info( \"Skipping zipalign on \" + project.getPackaging() );\n            return;\n        }\n\n        ConfigHandler configHandler = new ConfigHandler( this, this.session, this.execution );\n        configHandler.parseConfiguration();\n\n        parsedInputApk = FilenameUtils.separatorsToSystem( parsedInputApk );\n        parsedOutputApk = FilenameUtils.separatorsToSystem( parsedOutputApk );\n\n        getLog().debug( \"skip:\" + parsedSkip );\n        getLog().debug( \"verbose:\" + parsedVerbose );\n        getLog().debug( \"inputApk:\" + parsedInputApk );\n        getLog().debug( \"outputApk:\" + parsedOutputApk );\n        getLog().debug( \"classifier:\" + parsedClassifier );\n\n        if ( parsedSkip )\n        {\n            getLog().info( \"Skipping zipalign\" );\n        }\n        else\n        {\n            boolean outputToSameFile = sameOutputAsInput();\n\n            CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();\n            executor.setLogger( this.getLog() );\n\n            String command = getAndroidSdk().getZipalignPath();\n\n            List<String> parameters = new ArrayList<String>();\n            if ( parsedVerbose )\n            {\n                parameters.add( \"-v\" );\n            }\n            parameters.add( \"-f\" ); // force overwriting existing output file\n            parameters.add( \"4\" ); // byte alignment has to be 4!\n            parameters.add( parsedInputApk );\n            String outputApk = outputToSameFile ? getTemporaryOutputApkFilename() : parsedOutputApk;\n            parameters.add( outputApk );\n\n            try\n            {\n                getLog().info( \"Running command: \" + command );\n                getLog().info( \"with parameters: \" + parameters );\n                executor.setCaptureStdOut( true );\n                executor.executeCommand( command, parameters );\n\n                if ( FileUtils.fileExists( outputApk ) )\n                {\n                    if ( outputToSameFile )\n                    {\n                        // No needs to attach zipaligned apk to artifacts\n                        try\n                        {\n                            FileUtils.rename( new File( outputApk ),  new File( parsedInputApk ) );\n                        }\n                        catch ( IOException e )\n                        {\n                            getLog().error( \"Failed to replace original apk with aligned \"\n                                    + getFullPathWithName( outputApk ), e );\n                        }\n                    }\n                    else\n                    {\n                        // Attach the resulting artifact (Issue 88)\n                        // http://code.google.com/p/maven-android-plugin/issues/detail?id=88\n                        projectHelper.attachArtifact( project, APK, parsedClassifier, new File( outputApk ) );\n                        getLog().info( \"Attach \" + getFullPathWithName( outputApk )  + \" as '\"\n                                + parsedClassifier + \"' to the project\" );\n                    }\n                }\n                else\n                {\n                    getLog().error( \"Cannot attach \" + getFullPathWithName( outputApk ) + \" to the project\"\n                            + \" - The file does not exist\" );\n                }\n            }\n            catch ( ExecutionException e )\n            {\n                throw new MojoExecutionException( \"\", e );\n            }\n        }\n    }", "language": "java", "Allcodes": "public void execute() throws MojoExecutionException, MojoFailureException\n    {\n\n        // If we're not on a supported packaging with just skip (Issue 87)\n        // http://code.google.com/p/maven-android-plugin/issues/detail?id=87\n        if ( ! SUPPORTED_PACKAGING_TYPES.contains( project.getPackaging() ) )\n        {\n            getLog().info( \"Skipping zipalign on \" + project.getPackaging() );\n            return;\n        }\n\n        ConfigHandler configHandler = new ConfigHandler( this, this.session, this.execution );\n        configHandler.parseConfiguration();\n\n        parsedInputApk = FilenameUtils.separatorsToSystem( parsedInputApk );\n        parsedOutputApk = FilenameUtils.separatorsToSystem( parsedOutputApk );\n\n        getLog().debug( \"skip:\" + parsedSkip );\n        getLog().debug( \"verbose:\" + parsedVerbose );\n        getLog().debug( \"inputApk:\" + parsedInputApk );\n        getLog().debug( \"outputApk:\" + parsedOutputApk );\n        getLog().debug( \"classifier:\" + parsedClassifier );\n\n        if ( parsedSkip )\n        {\n            getLog().info( \"Skipping zipalign\" );\n        }\n        else\n        {\n            boolean outputToSameFile = sameOutputAsInput();\n\n            CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();\n            executor.setLogger( this.getLog() );\n\n            String command = getAndroidSdk().getZipalignPath();\n\n            List<String> parameters = new ArrayList<String>();\n            if ( parsedVerbose )\n            {\n                parameters.add( \"-v\" );\n            }\n            parameters.add( \"-f\" ); // force overwriting existing output file\n            parameters.add( \"4\" ); // byte alignment has to be 4!\n            parameters.add( parsedInputApk );\n            String outputApk = outputToSameFile ? getTemporaryOutputApkFilename() : parsedOutputApk;\n            parameters.add( outputApk );\n\n            try\n            {\n                getLog().info( \"Running command: \" + command );\n                getLog().info( \"with parameters: \" + parameters );\n                executor.setCaptureStdOut( true );\n                executor.executeCommand( command, parameters );\n\n                if ( FileUtils.fileExists( outputApk ) )\n                {\n                    if ( outputToSameFile )\n                    {\n                        // No needs to attach zipaligned apk to artifacts\n                        try\n                        {\n                            FileUtils.rename( new File( outputApk ),  new File( parsedInputApk ) );\n                        }\n                        catch ( IOException e )\n                        {\n                            getLog().error( \"Failed to replace original apk with aligned \"\n                                    + getFullPathWithName( outputApk ), e );\n                        }\n                    }\n                    else\n                    {\n                        // Attach the resulting artifact (Issue 88)\n                        // http://code.google.com/p/maven-android-plugin/issues/detail?id=88\n                        projectHelper.attachArtifact( project, APK, parsedClassifier, new File( outputApk ) );\n                        getLog().info( \"Attach \" + getFullPathWithName( outputApk )  + \" as '\"\n                                + parsedClassifier + \"' to the project\" );\n                    }\n                }\n                else\n                {\n                    getLog().error( \"Cannot attach \" + getFullPathWithName( outputApk ) + \" to the project\"\n                            + \" - The file does not exist\" );\n                }\n            }\n            catch ( ExecutionException e )\n            {\n                throw new MojoExecutionException( \"\", e );\n            }\n        }\n    }", "code_tokens": ["public", "void", "execute", "(", ")", "throws", "MojoExecutionException", ",", "MojoFailureException", "{", "// If we're not on a supported packaging with just skip (Issue 87)", "// http://code.google.com/p/maven-android-plugin/issues/detail?id=87", "if", "(", "!", "SUPPORTED_PACKAGING_TYPES", ".", "contains", "(", "project", ".", "getPackaging", "(", ")", ")", ")", "{", "getLog", "(", ")", ".", "info", "(", "\"Skipping zipalign on \"", "+", "project", ".", "getPackaging", "(", ")", ")", ";", "return", ";", "}", "ConfigHandler", "configHandler", "=", "new", "ConfigHandler", "(", "this", ",", "this", ".", "session", ",", "this", ".", "execution", ")", ";", "configHandler", ".", "parseConfiguration", "(", ")", ";", "parsedInputApk", "=", "FilenameUtils", ".", "separatorsToSystem", "(", "parsedInputApk", ")", ";", "parsedOutputApk", "=", "FilenameUtils", ".", "separatorsToSystem", "(", "parsedOutputApk", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"skip:\"", "+", "parsedSkip", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"verbose:\"", "+", "parsedVerbose", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"inputApk:\"", "+", "parsedInputApk", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"outputApk:\"", "+", "parsedOutputApk", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"classifier:\"", "+", "parsedClassifier", ")", ";", "if", "(", "parsedSkip", ")", "{", "getLog", "(", ")", ".", "info", "(", "\"Skipping zipalign\"", ")", ";", "}", "else", "{", "boolean", "outputToSameFile", "=", "sameOutputAsInput", "(", ")", ";", "CommandExecutor", "executor", "=", "CommandExecutor", ".", "Factory", ".", "createDefaultCommmandExecutor", "(", ")", ";", "executor", ".", "setLogger", "(", "this", ".", "getLog", "(", ")", ")", ";", "String", "command", "=", "getAndroidSdk", "(", ")", ".", "getZipalignPath", "(", ")", ";", "List", "<", "String", ">", "parameters", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "if", "(", "parsedVerbose", ")", "{", "parameters", ".", "add", "(", "\"-v\"", ")", ";", "}", "parameters", ".", "add", "(", "\"-f\"", ")", ";", "// force overwriting existing output file", "parameters", ".", "add", "(", "\"4\"", ")", ";", "// byte alignment has to be 4!", "parameters", ".", "add", "(", "parsedInputApk", ")", ";", "String", "outputApk", "=", "outputToSameFile", "?", "getTemporaryOutputApkFilename", "(", ")", ":", "parsedOutputApk", ";", "parameters", ".", "add", "(", "outputApk", ")", ";", "try", "{", "getLog", "(", ")", ".", "info", "(", "\"Running command: \"", "+", "command", ")", ";", "getLog", "(", ")", ".", "info", "(", "\"with parameters: \"", "+", "parameters", ")", ";", "executor", ".", "setCaptureStdOut", "(", "true", ")", ";", "executor", ".", "executeCommand", "(", "command", ",", "parameters", ")", ";", "if", "(", "FileUtils", ".", "fileExists", "(", "outputApk", ")", ")", "{", "if", "(", "outputToSameFile", ")", "{", "// No needs to attach zipaligned apk to artifacts", "try", "{", "FileUtils", ".", "rename", "(", "new", "File", "(", "outputApk", ")", ",", "new", "File", "(", "parsedInputApk", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "error", "(", "\"Failed to replace original apk with aligned \"", "+", "getFullPathWithName", "(", "outputApk", ")", ",", "e", ")", ";", "}", "}", "else", "{", "// Attach the resulting artifact (Issue 88)", "// http://code.google.com/p/maven-android-plugin/issues/detail?id=88", "projectHelper", ".", "attachArtifact", "(", "project", ",", "APK", ",", "parsedClassifier", ",", "new", "File", "(", "outputApk", ")", ")", ";", "getLog", "(", ")", ".", "info", "(", "\"Attach \"", "+", "getFullPathWithName", "(", "outputApk", ")", "+", "\" as '\"", "+", "parsedClassifier", "+", "\"' to the project\"", ")", ";", "}", "}", "else", "{", "getLog", "(", ")", ".", "error", "(", "\"Cannot attach \"", "+", "getFullPathWithName", "(", "outputApk", ")", "+", "\" to the project\"", "+", "\" - The file does not exist\"", ")", ";", "}", "}", "catch", "(", "ExecutionException", "e", ")", "{", "throw", "new", "MojoExecutionException", "(", "\"\"", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Execute the mojo by parsing the confign and actually doing the zipalign.\n\n@throws MojoExecutionException", "docstring_tokens": ["Execute", "the", "mojo", "by", "parsing", "the", "confign", "and", "actually", "doing", "the", "zipalign", "."]}
{"code": "parameters.add( \"4\" );", "comments": "byte alignment has to be 4!", "lines": 43, "repo": "simpligility/android-maven-plugin", "path": "src/main/java/com/simpligility/maven/plugins/android/standalonemojos/ZipalignMojo.java", "func_name": "ZipalignMojo.execute", "original_string": "public void execute() throws MojoExecutionException, MojoFailureException\n    {\n\n        // If we're not on a supported packaging with just skip (Issue 87)\n        // http://code.google.com/p/maven-android-plugin/issues/detail?id=87\n        if ( ! SUPPORTED_PACKAGING_TYPES.contains( project.getPackaging() ) )\n        {\n            getLog().info( \"Skipping zipalign on \" + project.getPackaging() );\n            return;\n        }\n\n        ConfigHandler configHandler = new ConfigHandler( this, this.session, this.execution );\n        configHandler.parseConfiguration();\n\n        parsedInputApk = FilenameUtils.separatorsToSystem( parsedInputApk );\n        parsedOutputApk = FilenameUtils.separatorsToSystem( parsedOutputApk );\n\n        getLog().debug( \"skip:\" + parsedSkip );\n        getLog().debug( \"verbose:\" + parsedVerbose );\n        getLog().debug( \"inputApk:\" + parsedInputApk );\n        getLog().debug( \"outputApk:\" + parsedOutputApk );\n        getLog().debug( \"classifier:\" + parsedClassifier );\n\n        if ( parsedSkip )\n        {\n            getLog().info( \"Skipping zipalign\" );\n        }\n        else\n        {\n            boolean outputToSameFile = sameOutputAsInput();\n\n            CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();\n            executor.setLogger( this.getLog() );\n\n            String command = getAndroidSdk().getZipalignPath();\n\n            List<String> parameters = new ArrayList<String>();\n            if ( parsedVerbose )\n            {\n                parameters.add( \"-v\" );\n            }\n            parameters.add( \"-f\" ); // force overwriting existing output file\n            parameters.add( \"4\" ); // byte alignment has to be 4!\n            parameters.add( parsedInputApk );\n            String outputApk = outputToSameFile ? getTemporaryOutputApkFilename() : parsedOutputApk;\n            parameters.add( outputApk );\n\n            try\n            {\n                getLog().info( \"Running command: \" + command );\n                getLog().info( \"with parameters: \" + parameters );\n                executor.setCaptureStdOut( true );\n                executor.executeCommand( command, parameters );\n\n                if ( FileUtils.fileExists( outputApk ) )\n                {\n                    if ( outputToSameFile )\n                    {\n                        // No needs to attach zipaligned apk to artifacts\n                        try\n                        {\n                            FileUtils.rename( new File( outputApk ),  new File( parsedInputApk ) );\n                        }\n                        catch ( IOException e )\n                        {\n                            getLog().error( \"Failed to replace original apk with aligned \"\n                                    + getFullPathWithName( outputApk ), e );\n                        }\n                    }\n                    else\n                    {\n                        // Attach the resulting artifact (Issue 88)\n                        // http://code.google.com/p/maven-android-plugin/issues/detail?id=88\n                        projectHelper.attachArtifact( project, APK, parsedClassifier, new File( outputApk ) );\n                        getLog().info( \"Attach \" + getFullPathWithName( outputApk )  + \" as '\"\n                                + parsedClassifier + \"' to the project\" );\n                    }\n                }\n                else\n                {\n                    getLog().error( \"Cannot attach \" + getFullPathWithName( outputApk ) + \" to the project\"\n                            + \" - The file does not exist\" );\n                }\n            }\n            catch ( ExecutionException e )\n            {\n                throw new MojoExecutionException( \"\", e );\n            }\n        }\n    }", "language": "java", "Allcodes": "public void execute() throws MojoExecutionException, MojoFailureException\n    {\n\n        // If we're not on a supported packaging with just skip (Issue 87)\n        // http://code.google.com/p/maven-android-plugin/issues/detail?id=87\n        if ( ! SUPPORTED_PACKAGING_TYPES.contains( project.getPackaging() ) )\n        {\n            getLog().info( \"Skipping zipalign on \" + project.getPackaging() );\n            return;\n        }\n\n        ConfigHandler configHandler = new ConfigHandler( this, this.session, this.execution );\n        configHandler.parseConfiguration();\n\n        parsedInputApk = FilenameUtils.separatorsToSystem( parsedInputApk );\n        parsedOutputApk = FilenameUtils.separatorsToSystem( parsedOutputApk );\n\n        getLog().debug( \"skip:\" + parsedSkip );\n        getLog().debug( \"verbose:\" + parsedVerbose );\n        getLog().debug( \"inputApk:\" + parsedInputApk );\n        getLog().debug( \"outputApk:\" + parsedOutputApk );\n        getLog().debug( \"classifier:\" + parsedClassifier );\n\n        if ( parsedSkip )\n        {\n            getLog().info( \"Skipping zipalign\" );\n        }\n        else\n        {\n            boolean outputToSameFile = sameOutputAsInput();\n\n            CommandExecutor executor = CommandExecutor.Factory.createDefaultCommmandExecutor();\n            executor.setLogger( this.getLog() );\n\n            String command = getAndroidSdk().getZipalignPath();\n\n            List<String> parameters = new ArrayList<String>();\n            if ( parsedVerbose )\n            {\n                parameters.add( \"-v\" );\n            }\n            parameters.add( \"-f\" ); // force overwriting existing output file\n            parameters.add( \"4\" ); // byte alignment has to be 4!\n            parameters.add( parsedInputApk );\n            String outputApk = outputToSameFile ? getTemporaryOutputApkFilename() : parsedOutputApk;\n            parameters.add( outputApk );\n\n            try\n            {\n                getLog().info( \"Running command: \" + command );\n                getLog().info( \"with parameters: \" + parameters );\n                executor.setCaptureStdOut( true );\n                executor.executeCommand( command, parameters );\n\n                if ( FileUtils.fileExists( outputApk ) )\n                {\n                    if ( outputToSameFile )\n                    {\n                        // No needs to attach zipaligned apk to artifacts\n                        try\n                        {\n                            FileUtils.rename( new File( outputApk ),  new File( parsedInputApk ) );\n                        }\n                        catch ( IOException e )\n                        {\n                            getLog().error( \"Failed to replace original apk with aligned \"\n                                    + getFullPathWithName( outputApk ), e );\n                        }\n                    }\n                    else\n                    {\n                        // Attach the resulting artifact (Issue 88)\n                        // http://code.google.com/p/maven-android-plugin/issues/detail?id=88\n                        projectHelper.attachArtifact( project, APK, parsedClassifier, new File( outputApk ) );\n                        getLog().info( \"Attach \" + getFullPathWithName( outputApk )  + \" as '\"\n                                + parsedClassifier + \"' to the project\" );\n                    }\n                }\n                else\n                {\n                    getLog().error( \"Cannot attach \" + getFullPathWithName( outputApk ) + \" to the project\"\n                            + \" - The file does not exist\" );\n                }\n            }\n            catch ( ExecutionException e )\n            {\n                throw new MojoExecutionException( \"\", e );\n            }\n        }\n    }", "code_tokens": ["public", "void", "execute", "(", ")", "throws", "MojoExecutionException", ",", "MojoFailureException", "{", "// If we're not on a supported packaging with just skip (Issue 87)", "// http://code.google.com/p/maven-android-plugin/issues/detail?id=87", "if", "(", "!", "SUPPORTED_PACKAGING_TYPES", ".", "contains", "(", "project", ".", "getPackaging", "(", ")", ")", ")", "{", "getLog", "(", ")", ".", "info", "(", "\"Skipping zipalign on \"", "+", "project", ".", "getPackaging", "(", ")", ")", ";", "return", ";", "}", "ConfigHandler", "configHandler", "=", "new", "ConfigHandler", "(", "this", ",", "this", ".", "session", ",", "this", ".", "execution", ")", ";", "configHandler", ".", "parseConfiguration", "(", ")", ";", "parsedInputApk", "=", "FilenameUtils", ".", "separatorsToSystem", "(", "parsedInputApk", ")", ";", "parsedOutputApk", "=", "FilenameUtils", ".", "separatorsToSystem", "(", "parsedOutputApk", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"skip:\"", "+", "parsedSkip", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"verbose:\"", "+", "parsedVerbose", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"inputApk:\"", "+", "parsedInputApk", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"outputApk:\"", "+", "parsedOutputApk", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"classifier:\"", "+", "parsedClassifier", ")", ";", "if", "(", "parsedSkip", ")", "{", "getLog", "(", ")", ".", "info", "(", "\"Skipping zipalign\"", ")", ";", "}", "else", "{", "boolean", "outputToSameFile", "=", "sameOutputAsInput", "(", ")", ";", "CommandExecutor", "executor", "=", "CommandExecutor", ".", "Factory", ".", "createDefaultCommmandExecutor", "(", ")", ";", "executor", ".", "setLogger", "(", "this", ".", "getLog", "(", ")", ")", ";", "String", "command", "=", "getAndroidSdk", "(", ")", ".", "getZipalignPath", "(", ")", ";", "List", "<", "String", ">", "parameters", "=", "new", "ArrayList", "<", "String", ">", "(", ")", ";", "if", "(", "parsedVerbose", ")", "{", "parameters", ".", "add", "(", "\"-v\"", ")", ";", "}", "parameters", ".", "add", "(", "\"-f\"", ")", ";", "// force overwriting existing output file", "parameters", ".", "add", "(", "\"4\"", ")", ";", "// byte alignment has to be 4!", "parameters", ".", "add", "(", "parsedInputApk", ")", ";", "String", "outputApk", "=", "outputToSameFile", "?", "getTemporaryOutputApkFilename", "(", ")", ":", "parsedOutputApk", ";", "parameters", ".", "add", "(", "outputApk", ")", ";", "try", "{", "getLog", "(", ")", ".", "info", "(", "\"Running command: \"", "+", "command", ")", ";", "getLog", "(", ")", ".", "info", "(", "\"with parameters: \"", "+", "parameters", ")", ";", "executor", ".", "setCaptureStdOut", "(", "true", ")", ";", "executor", ".", "executeCommand", "(", "command", ",", "parameters", ")", ";", "if", "(", "FileUtils", ".", "fileExists", "(", "outputApk", ")", ")", "{", "if", "(", "outputToSameFile", ")", "{", "// No needs to attach zipaligned apk to artifacts", "try", "{", "FileUtils", ".", "rename", "(", "new", "File", "(", "outputApk", ")", ",", "new", "File", "(", "parsedInputApk", ")", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "getLog", "(", ")", ".", "error", "(", "\"Failed to replace original apk with aligned \"", "+", "getFullPathWithName", "(", "outputApk", ")", ",", "e", ")", ";", "}", "}", "else", "{", "// Attach the resulting artifact (Issue 88)", "// http://code.google.com/p/maven-android-plugin/issues/detail?id=88", "projectHelper", ".", "attachArtifact", "(", "project", ",", "APK", ",", "parsedClassifier", ",", "new", "File", "(", "outputApk", ")", ")", ";", "getLog", "(", ")", ".", "info", "(", "\"Attach \"", "+", "getFullPathWithName", "(", "outputApk", ")", "+", "\" as '\"", "+", "parsedClassifier", "+", "\"' to the project\"", ")", ";", "}", "}", "else", "{", "getLog", "(", ")", ".", "error", "(", "\"Cannot attach \"", "+", "getFullPathWithName", "(", "outputApk", ")", "+", "\" to the project\"", "+", "\" - The file does not exist\"", ")", ";", "}", "}", "catch", "(", "ExecutionException", "e", ")", "{", "throw", "new", "MojoExecutionException", "(", "\"\"", ",", "e", ")", ";", "}", "}", "}"], "docstring": "Execute the mojo by parsing the confign and actually doing the zipalign.\n\n@throws MojoExecutionException", "docstring_tokens": ["Execute", "the", "mojo", "by", "parsing", "the", "confign", "and", "actually", "doing", "the", "zipalign", "."]}
{"code": "threshold = (newCapacity >> 1) + (newCapacity >> 2);", "comments": "3/4 capacity", "lines": 5, "repo": "liaohuqiu/cube-sdk", "path": "core/src/in/srain/cube/set/hash/SimpleHashSet.java", "func_name": "SimpleHashSet.makeTable", "original_string": "private SimpleHashSetEntry<T>[] makeTable(int newCapacity) {\n        @SuppressWarnings(\"unchecked\")\n        SimpleHashSetEntry<T>[] newTable = (SimpleHashSetEntry<T>[]) new SimpleHashSetEntry[newCapacity];\n        mTable = newTable;\n        threshold = (newCapacity >> 1) + (newCapacity >> 2); // 3/4 capacity\n        return newTable;\n    }", "language": "java", "Allcodes": "private SimpleHashSetEntry<T>[] makeTable(int newCapacity) {\n        @SuppressWarnings(\"unchecked\")\n        SimpleHashSetEntry<T>[] newTable = (SimpleHashSetEntry<T>[]) new SimpleHashSetEntry[newCapacity];\n        mTable = newTable;\n        threshold = (newCapacity >> 1) + (newCapacity >> 2); // 3/4 capacity\n        return newTable;\n    }", "code_tokens": ["private", "SimpleHashSetEntry", "<", "T", ">", "[", "]", "makeTable", "(", "int", "newCapacity", ")", "{", "@", "SuppressWarnings", "(", "\"unchecked\"", ")", "SimpleHashSetEntry", "<", "T", ">", "[", "]", "newTable", "=", "(", "SimpleHashSetEntry", "<", "T", ">", "[", "]", ")", "new", "SimpleHashSetEntry", "[", "newCapacity", "]", ";", "mTable", "=", "newTable", ";", "threshold", "=", "(", "newCapacity", ">>", "1", ")", "+", "(", "newCapacity", ">>", "2", ")", ";", "// 3/4 capacity", "return", "newTable", ";", "}"], "docstring": "Allocate a table of the given capacity and set the threshold accordingly.\n\n@param newCapacity must be a power of two", "docstring_tokens": ["Allocate", "a", "table", "of", "the", "given", "capacity", "and", "set", "the", "threshold", "accordingly", "."]}
{"code": "this.hints.put(SVGHints.KEY_ELEMENT_ID, null);", "comments": "clear it", "lines": 4, "repo": "jfree/jfreesvg", "path": "src/main/java/org/jfree/graphics2d/svg/SVGGraphics2D.java", "func_name": "SVGGraphics2D.appendOptionalElementIDFromHint", "original_string": "private void appendOptionalElementIDFromHint(StringBuilder sb) {\n        String elementID = (String) this.hints.get(SVGHints.KEY_ELEMENT_ID);\n        if (elementID != null) {\n            this.hints.put(SVGHints.KEY_ELEMENT_ID, null); // clear it\n            if (this.elementIDs.contains(elementID)) {\n                throw new IllegalStateException(\"The element id \" \n                        + elementID + \" is already used.\");\n            } else {\n                this.elementIDs.add(elementID);\n            }\n            this.sb.append(\"id=\\\"\").append(elementID).append(\"\\\" \");\n        }\n    }", "language": "java", "Allcodes": "private void appendOptionalElementIDFromHint(StringBuilder sb) {\n        String elementID = (String) this.hints.get(SVGHints.KEY_ELEMENT_ID);\n        if (elementID != null) {\n            this.hints.put(SVGHints.KEY_ELEMENT_ID, null); // clear it\n            if (this.elementIDs.contains(elementID)) {\n                throw new IllegalStateException(\"The element id \" \n                        + elementID + \" is already used.\");\n            } else {\n                this.elementIDs.add(elementID);\n            }\n            this.sb.append(\"id=\\\"\").append(elementID).append(\"\\\" \");\n        }\n    }", "code_tokens": ["private", "void", "appendOptionalElementIDFromHint", "(", "StringBuilder", "sb", ")", "{", "String", "elementID", "=", "(", "String", ")", "this", ".", "hints", ".", "get", "(", "SVGHints", ".", "KEY_ELEMENT_ID", ")", ";", "if", "(", "elementID", "!=", "null", ")", "{", "this", ".", "hints", ".", "put", "(", "SVGHints", ".", "KEY_ELEMENT_ID", ",", "null", ")", ";", "// clear it", "if", "(", "this", ".", "elementIDs", ".", "contains", "(", "elementID", ")", ")", "{", "throw", "new", "IllegalStateException", "(", "\"The element id \"", "+", "elementID", "+", "\" is already used.\"", ")", ";", "}", "else", "{", "this", ".", "elementIDs", ".", "add", "(", "elementID", ")", ";", "}", "this", ".", "sb", ".", "append", "(", "\"id=\\\"\"", ")", ".", "append", "(", "elementID", ")", ".", "append", "(", "\"\\\" \"", ")", ";", "}", "}"], "docstring": "A utility method that appends an optional element id if one is\nspecified via the rendering hints.\n\n@param sb  the string builder ({@code null} not permitted).", "docstring_tokens": ["A", "utility", "method", "that", "appends", "an", "optional", "element", "id", "if", "one", "is", "specified", "via", "the", "rendering", "hints", "."]}
{"code": "httpRequestHolderList.remove(httpRequestHolder);", "comments": "Not very fast if you a lot of outstanding requests", "lines": 29, "repo": "advantageous/qbit", "path": "qbit/core/src/main/java/io/advantageous/qbit/proxy/ProxyServiceImpl.java", "func_name": "ProxyServiceImpl.trackTimeouts", "original_string": "private void trackTimeouts() {\n        new ArrayList<>(httpRequestHolderList).forEach(httpRequestHolder -> {\n\n            /* If it is handled then remove it from the list. */\n            if (httpRequestHolder.request.isHandled()) {\n                httpRequestHolderList.remove(httpRequestHolder);\n                return;\n            }\n\n            /* Get the duration that this request has been around. */\n            final long duration = time - httpRequestHolder.startTime;\n\n            /* See if the duration is greater than the timeout time. */\n            if (duration > timeOutIntervalMS) {\n\n                /* If we timed out, mark the request as handled, and then notify the client that the\n                backend timed out.\n                 */\n                httpRequestHolder.request.handled();\n\n                /* Tell client that the backend timed out. */\n                httpRequestHolder.request.getReceiver().timeoutWithMessage(String.format(\"\\\"TIMEOUT %s %s %s\\\"\",\n                        httpRequestHolder.request.address(),\n                        httpRequestHolder.request.getRemoteAddress(),\n                        httpRequestHolder.startTime\n                ));\n\n                /* If we timed out then remove this from the list. */\n                httpRequestHolderList.remove(httpRequestHolder); //Not very fast if you a lot of outstanding requests\n            }\n        });\n    }", "language": "java", "Allcodes": "private void trackTimeouts() {\n        new ArrayList<>(httpRequestHolderList).forEach(httpRequestHolder -> {\n\n            /* If it is handled then remove it from the list. */\n            if (httpRequestHolder.request.isHandled()) {\n                httpRequestHolderList.remove(httpRequestHolder);\n                return;\n            }\n\n            /* Get the duration that this request has been around. */\n            final long duration = time - httpRequestHolder.startTime;\n\n            /* See if the duration is greater than the timeout time. */\n            if (duration > timeOutIntervalMS) {\n\n                /* If we timed out, mark the request as handled, and then notify the client that the\n                backend timed out.\n                 */\n                httpRequestHolder.request.handled();\n\n                /* Tell client that the backend timed out. */\n                httpRequestHolder.request.getReceiver().timeoutWithMessage(String.format(\"\\\"TIMEOUT %s %s %s\\\"\",\n                        httpRequestHolder.request.address(),\n                        httpRequestHolder.request.getRemoteAddress(),\n                        httpRequestHolder.startTime\n                ));\n\n                /* If we timed out then remove this from the list. */\n                httpRequestHolderList.remove(httpRequestHolder); //Not very fast if you a lot of outstanding requests\n            }\n        });\n    }", "code_tokens": ["private", "void", "trackTimeouts", "(", ")", "{", "new", "ArrayList", "<>", "(", "httpRequestHolderList", ")", ".", "forEach", "(", "httpRequestHolder", "->", "{", "/* If it is handled then remove it from the list. */", "if", "(", "httpRequestHolder", ".", "request", ".", "isHandled", "(", ")", ")", "{", "httpRequestHolderList", ".", "remove", "(", "httpRequestHolder", ")", ";", "return", ";", "}", "/* Get the duration that this request has been around. */", "final", "long", "duration", "=", "time", "-", "httpRequestHolder", ".", "startTime", ";", "/* See if the duration is greater than the timeout time. */", "if", "(", "duration", ">", "timeOutIntervalMS", ")", "{", "/* If we timed out, mark the request as handled, and then notify the client that the\n                backend timed out.\n                 */", "httpRequestHolder", ".", "request", ".", "handled", "(", ")", ";", "/* Tell client that the backend timed out. */", "httpRequestHolder", ".", "request", ".", "getReceiver", "(", ")", ".", "timeoutWithMessage", "(", "String", ".", "format", "(", "\"\\\"TIMEOUT %s %s %s\\\"\"", ",", "httpRequestHolder", ".", "request", ".", "address", "(", ")", ",", "httpRequestHolder", ".", "request", ".", "getRemoteAddress", "(", ")", ",", "httpRequestHolder", ".", "startTime", ")", ")", ";", "/* If we timed out then remove this from the list. */", "httpRequestHolderList", ".", "remove", "(", "httpRequestHolder", ")", ";", "//Not very fast if you a lot of outstanding requests", "}", "}", ")", ";", "}"], "docstring": "Tracks timeouts periodically if timeout tracking is enabled.", "docstring_tokens": ["Tracks", "timeouts", "periodically", "if", "timeout", "tracking", "is", "enabled", "."]}
{"code": "doCall(item);", "comments": "Do call calls forwardEvent but does not flush. Only when the queue is empty do we flush.", "lines": 14, "repo": "advantageous/qbit", "path": "qbit/core/src/main/java/io/advantageous/qbit/service/impl/ServiceBundleImpl.java", "func_name": "ServiceBundleImpl.startUpCallQueue", "original_string": "public ServiceBundle startUpCallQueue() {\n        methodQueue.startListener(new ReceiveQueueListener<MethodCall<Object>>() {\n\n            long time;\n\n            long lastTimeAutoFlush;\n\n            /**\n             * When we receive a method call, we call doCall.\n             * @param item item\n             */\n            @Override\n            public void receive(MethodCall<Object> item) {\n                doCall(item); //Do call calls forwardEvent but does not flush. Only when the queue is empty do we flush.\n            }\n\n            /**\n             * If the queue is empty, then go ahead, and flush to each client all incoming requests every 50 milliseconds.\n             */\n            @Override\n            public void empty() {\n                time = timer.now();\n                if (time > (lastTimeAutoFlush + 50)) {\n\n                    //noinspection Convert2streamapi\n                    for (SendQueue<MethodCall<Object>> sendQueue : sendQueues) {\n                        sendQueue.flushSends();\n                    }\n                    lastTimeAutoFlush = time;\n                }\n            }\n\n        });\n\n        return this;\n    }", "language": "java", "Allcodes": "public ServiceBundle startUpCallQueue() {\n        methodQueue.startListener(new ReceiveQueueListener<MethodCall<Object>>() {\n\n            long time;\n\n            long lastTimeAutoFlush;\n\n            /**\n             * When we receive a method call, we call doCall.\n             * @param item item\n             */\n            @Override\n            public void receive(MethodCall<Object> item) {\n                doCall(item); //Do call calls forwardEvent but does not flush. Only when the queue is empty do we flush.\n            }\n\n            /**\n             * If the queue is empty, then go ahead, and flush to each client all incoming requests every 50 milliseconds.\n             */\n            @Override\n            public void empty() {\n                time = timer.now();\n                if (time > (lastTimeAutoFlush + 50)) {\n\n                    //noinspection Convert2streamapi\n                    for (SendQueue<MethodCall<Object>> sendQueue : sendQueues) {\n                        sendQueue.flushSends();\n                    }\n                    lastTimeAutoFlush = time;\n                }\n            }\n\n        });\n\n        return this;\n    }", "code_tokens": ["public", "ServiceBundle", "startUpCallQueue", "(", ")", "{", "methodQueue", ".", "startListener", "(", "new", "ReceiveQueueListener", "<", "MethodCall", "<", "Object", ">", ">", "(", ")", "{", "long", "time", ";", "long", "lastTimeAutoFlush", ";", "/**\n             * When we receive a method call, we call doCall.\n             * @param item item\n             */", "@", "Override", "public", "void", "receive", "(", "MethodCall", "<", "Object", ">", "item", ")", "{", "doCall", "(", "item", ")", ";", "//Do call calls forwardEvent but does not flush. Only when the queue is empty do we flush.", "}", "/**\n             * If the queue is empty, then go ahead, and flush to each client all incoming requests every 50 milliseconds.\n             */", "@", "Override", "public", "void", "empty", "(", ")", "{", "time", "=", "timer", ".", "now", "(", ")", ";", "if", "(", "time", ">", "(", "lastTimeAutoFlush", "+", "50", ")", ")", "{", "//noinspection Convert2streamapi", "for", "(", "SendQueue", "<", "MethodCall", "<", "Object", ">", ">", "sendQueue", ":", "sendQueues", ")", "{", "sendQueue", ".", "flushSends", "(", ")", ";", "}", "lastTimeAutoFlush", "=", "time", ";", "}", "}", "}", ")", ";", "return", "this", ";", "}"], "docstring": "Start the client bundle.", "docstring_tokens": ["Start", "the", "client", "bundle", "."]}
{"code": "Sys.sleep(10_000);", "comments": "primary is down so slow it down so we don't flow the system with updates of service pools.", "lines": 21, "repo": "advantageous/qbit", "path": "qbit/core/src/main/java/io/advantageous/qbit/service/discovery/impl/ServiceDiscoveryImpl.java", "func_name": "ServiceDiscoveryImpl.doFailOverHealthServicesLoad", "original_string": "private void doFailOverHealthServicesLoad(final String serviceNameToFetch, Exception ex) {\n\n        /* If there is a backup provider, load from there. */\n        if (backupProvider != null) {\n\n            if (debug) logger.debug(\"ServiceDiscoveryImpl::loadHealthyServices \" +\n                    \"Error while loading healthy\" +\n                    \" services for \" + serviceNameToFetch, ex);\n\n            final List<EndpointDefinition> healthyServices = backupProvider.loadServices(serviceNameToFetch);\n            populateServiceMap(serviceNameToFetch, healthyServices);\n            serviceNamesBeingLoaded.remove(serviceNameToFetch);\n\n        } else {\n\n            logger.error(\"ServiceDiscoveryImpl::loadHealthyServices \" +\n                    \"Error while loading healthy\" +\n                    \" services for \" + serviceNameToFetch, ex);\n        }\n\n        Sys.sleep(10_000); //primary is down so slow it down so we don't flow the system with updates of service pools.\n\n    }", "language": "java", "Allcodes": "private void doFailOverHealthServicesLoad(final String serviceNameToFetch, Exception ex) {\n\n        /* If there is a backup provider, load from there. */\n        if (backupProvider != null) {\n\n            if (debug) logger.debug(\"ServiceDiscoveryImpl::loadHealthyServices \" +\n                    \"Error while loading healthy\" +\n                    \" services for \" + serviceNameToFetch, ex);\n\n            final List<EndpointDefinition> healthyServices = backupProvider.loadServices(serviceNameToFetch);\n            populateServiceMap(serviceNameToFetch, healthyServices);\n            serviceNamesBeingLoaded.remove(serviceNameToFetch);\n\n        } else {\n\n            logger.error(\"ServiceDiscoveryImpl::loadHealthyServices \" +\n                    \"Error while loading healthy\" +\n                    \" services for \" + serviceNameToFetch, ex);\n        }\n\n        Sys.sleep(10_000); //primary is down so slow it down so we don't flow the system with updates of service pools.\n\n    }", "code_tokens": ["private", "void", "doFailOverHealthServicesLoad", "(", "final", "String", "serviceNameToFetch", ",", "Exception", "ex", ")", "{", "/* If there is a backup provider, load from there. */", "if", "(", "backupProvider", "!=", "null", ")", "{", "if", "(", "debug", ")", "logger", ".", "debug", "(", "\"ServiceDiscoveryImpl::loadHealthyServices \"", "+", "\"Error while loading healthy\"", "+", "\" services for \"", "+", "serviceNameToFetch", ",", "ex", ")", ";", "final", "List", "<", "EndpointDefinition", ">", "healthyServices", "=", "backupProvider", ".", "loadServices", "(", "serviceNameToFetch", ")", ";", "populateServiceMap", "(", "serviceNameToFetch", ",", "healthyServices", ")", ";", "serviceNamesBeingLoaded", ".", "remove", "(", "serviceNameToFetch", ")", ";", "}", "else", "{", "logger", ".", "error", "(", "\"ServiceDiscoveryImpl::loadHealthyServices \"", "+", "\"Error while loading healthy\"", "+", "\" services for \"", "+", "serviceNameToFetch", ",", "ex", ")", ";", "}", "Sys", ".", "sleep", "(", "10_000", ")", ";", "//primary is down so slow it down so we don't flow the system with updates of service pools.", "}"], "docstring": "If the primary load failed, we could have a backup provider registered.\n\n@param serviceNameToFetch service pool to fetch\n@param ex", "docstring_tokens": ["If", "the", "primary", "load", "failed", "we", "could", "have", "a", "backup", "provider", "registered", "."]}
{"code": "++_inputPtr;", "comments": "Leading zero to be skipped", "lines": 17, "repo": "bazaarvoice/rison", "path": "src/main/java/com/bazaarvoice/jackson/rison/RisonParser.java", "func_name": "RisonParser._verifyNoLeadingZeroes", "original_string": "private char _verifyNoLeadingZeroes()\n            throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }", "language": "java", "Allcodes": "private char _verifyNoLeadingZeroes()\n            throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }", "code_tokens": ["private", "char", "_verifyNoLeadingZeroes", "(", ")", "throws", "IOException", ",", "JsonParseException", "{", "// Ok to have plain \"0\"", "if", "(", "_inputPtr", ">=", "_inputEnd", "&&", "!", "loadMore", "(", ")", ")", "{", "return", "'", "'", ";", "}", "char", "ch", "=", "_inputBuffer", "[", "_inputPtr", "]", ";", "// if not followed by a number (probably '.'); return zero as is, to be included", "if", "(", "ch", "<", "'", "'", "||", "ch", ">", "'", "'", ")", "{", "return", "'", "'", ";", "}", "if", "(", "!", "isEnabled", "(", "JsonParser", ".", "Feature", ".", "ALLOW_NUMERIC_LEADING_ZEROS", ")", ")", "{", "reportInvalidNumber", "(", "\"Leading zeroes not allowed\"", ")", ";", "}", "// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)", "++", "_inputPtr", ";", "// Leading zero to be skipped", "if", "(", "ch", "==", "INT_0", ")", "{", "while", "(", "_inputPtr", "<", "_inputEnd", "||", "loadMore", "(", ")", ")", "{", "ch", "=", "_inputBuffer", "[", "_inputPtr", "]", ";", "if", "(", "ch", "<", "'", "'", "||", "ch", ">", "'", "'", ")", "{", "// followed by non-number; retain one zero", "return", "'", "'", ";", "}", "++", "_inputPtr", ";", "// skip previous zero", "if", "(", "ch", "!=", "'", "'", ")", "{", "// followed by other number; return", "break", ";", "}", "}", "}", "return", "ch", ";", "}"], "docstring": "Method called when we have seen one zero, and want to ensure\nit is not followed by another", "docstring_tokens": ["Method", "called", "when", "we", "have", "seen", "one", "zero", "and", "want", "to", "ensure", "it", "is", "not", "followed", "by", "another"]}
{"code": "++_inputPtr;", "comments": "skip previous zero", "lines": 24, "repo": "bazaarvoice/rison", "path": "src/main/java/com/bazaarvoice/jackson/rison/RisonParser.java", "func_name": "RisonParser._verifyNoLeadingZeroes", "original_string": "private char _verifyNoLeadingZeroes()\n            throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }", "language": "java", "Allcodes": "private char _verifyNoLeadingZeroes()\n            throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }", "code_tokens": ["private", "char", "_verifyNoLeadingZeroes", "(", ")", "throws", "IOException", ",", "JsonParseException", "{", "// Ok to have plain \"0\"", "if", "(", "_inputPtr", ">=", "_inputEnd", "&&", "!", "loadMore", "(", ")", ")", "{", "return", "'", "'", ";", "}", "char", "ch", "=", "_inputBuffer", "[", "_inputPtr", "]", ";", "// if not followed by a number (probably '.'); return zero as is, to be included", "if", "(", "ch", "<", "'", "'", "||", "ch", ">", "'", "'", ")", "{", "return", "'", "'", ";", "}", "if", "(", "!", "isEnabled", "(", "JsonParser", ".", "Feature", ".", "ALLOW_NUMERIC_LEADING_ZEROS", ")", ")", "{", "reportInvalidNumber", "(", "\"Leading zeroes not allowed\"", ")", ";", "}", "// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)", "++", "_inputPtr", ";", "// Leading zero to be skipped", "if", "(", "ch", "==", "INT_0", ")", "{", "while", "(", "_inputPtr", "<", "_inputEnd", "||", "loadMore", "(", ")", ")", "{", "ch", "=", "_inputBuffer", "[", "_inputPtr", "]", ";", "if", "(", "ch", "<", "'", "'", "||", "ch", ">", "'", "'", ")", "{", "// followed by non-number; retain one zero", "return", "'", "'", ";", "}", "++", "_inputPtr", ";", "// skip previous zero", "if", "(", "ch", "!=", "'", "'", ")", "{", "// followed by other number; return", "break", ";", "}", "}", "}", "return", "ch", ";", "}"], "docstring": "Method called when we have seen one zero, and want to ensure\nit is not followed by another", "docstring_tokens": ["Method", "called", "when", "we", "have", "seen", "one", "zero", "and", "want", "to", "ensure", "it", "is", "not", "followed", "by", "another"]}
{"code": "int start = _inputPtr-1;", "comments": "-1 to bring back first char", "lines": 17, "repo": "bazaarvoice/rison", "path": "src/main/java/com/bazaarvoice/jackson/rison/RisonParser.java", "func_name": "RisonParser._parseUnquotedFieldName", "original_string": "protected String _parseUnquotedFieldName(int i)\n            throws IOException, JsonParseException\n    {\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk = IdentifierUtils.isIdStartLenient(i);\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or single-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = 0;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (!IdentifierUtils.isIdCharLenient(ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * 31) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _parseUnquotedFieldName2(start, hash);\n    }", "language": "java", "Allcodes": "protected String _parseUnquotedFieldName(int i)\n            throws IOException, JsonParseException\n    {\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk = IdentifierUtils.isIdStartLenient(i);\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or single-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = 0;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (!IdentifierUtils.isIdCharLenient(ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * 31) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _parseUnquotedFieldName2(start, hash);\n    }", "code_tokens": ["protected", "String", "_parseUnquotedFieldName", "(", "int", "i", ")", "throws", "IOException", ",", "JsonParseException", "{", "// Also: first char must be a valid name char, but NOT be number", "boolean", "firstOk", "=", "IdentifierUtils", ".", "isIdStartLenient", "(", "i", ")", ";", "if", "(", "!", "firstOk", ")", "{", "_reportUnexpectedChar", "(", "i", ",", "\"was expecting either valid name character (for unquoted name) or single-quote (for quoted) to start field name\"", ")", ";", "}", "int", "ptr", "=", "_inputPtr", ";", "int", "hash", "=", "0", ";", "final", "int", "inputLen", "=", "_inputEnd", ";", "if", "(", "ptr", "<", "inputLen", ")", "{", "do", "{", "int", "ch", "=", "_inputBuffer", "[", "ptr", "]", ";", "if", "(", "!", "IdentifierUtils", ".", "isIdCharLenient", "(", "ch", ")", ")", "{", "int", "start", "=", "_inputPtr", "-", "1", ";", "// -1 to bring back first char", "_inputPtr", "=", "ptr", ";", "return", "_symbols", ".", "findSymbol", "(", "_inputBuffer", ",", "start", ",", "ptr", "-", "start", ",", "hash", ")", ";", "}", "hash", "=", "(", "hash", "*", "31", ")", "+", "ch", ";", "++", "ptr", ";", "}", "while", "(", "ptr", "<", "inputLen", ")", ";", "}", "int", "start", "=", "_inputPtr", "-", "1", ";", "_inputPtr", "=", "ptr", ";", "return", "_parseUnquotedFieldName2", "(", "start", ",", "hash", ")", ";", "}"], "docstring": "Method called when we see non-white space character other\nthan double quote, when expecting a field name.\nIn standard mode will just throw an expection; but\nin non-standard modes may be able to parse name.", "docstring_tokens": ["Method", "called", "when", "we", "see", "non", "-", "white", "space", "character", "other", "than", "double", "quote", "when", "expecting", "a", "field", "name", ".", "In", "standard", "mode", "will", "just", "throw", "an", "expection", ";", "but", "in", "non", "-", "standard", "modes", "may", "be", "able", "to", "parse", "name", "."]}
{"code": "len += offset;", "comments": "-> len marks the end from now on", "lines": 8, "repo": "bazaarvoice/rison", "path": "src/main/java/com/bazaarvoice/jackson/rison/RisonGenerator.java", "func_name": "RisonGenerator._writeString", "original_string": "private void _writeString(char[] text, int offset, int len)\n            throws IOException, JsonGenerationException\n    {\n        /* Let's just find longest spans of non-escapable\n        * content, and for each see if it makes sense\n        * to copy them, or write through\n        */\n        len += offset; // -> len marks the end from now on\n        while (offset < len) {\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c == '!' || c == '\\'') {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape('!', c);\n        }\n    }", "language": "java", "Allcodes": "private void _writeString(char[] text, int offset, int len)\n            throws IOException, JsonGenerationException\n    {\n        /* Let's just find longest spans of non-escapable\n        * content, and for each see if it makes sense\n        * to copy them, or write through\n        */\n        len += offset; // -> len marks the end from now on\n        while (offset < len) {\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c == '!' || c == '\\'') {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape('!', c);\n        }\n    }", "code_tokens": ["private", "void", "_writeString", "(", "char", "[", "]", "text", ",", "int", "offset", ",", "int", "len", ")", "throws", "IOException", ",", "JsonGenerationException", "{", "/* Let's just find longest spans of non-escapable\n        * content, and for each see if it makes sense\n        * to copy them, or write through\n        */", "len", "+=", "offset", ";", "// -> len marks the end from now on", "while", "(", "offset", "<", "len", ")", "{", "int", "start", "=", "offset", ";", "while", "(", "true", ")", "{", "char", "c", "=", "text", "[", "offset", "]", ";", "if", "(", "c", "==", "'", "'", "||", "c", "==", "'", "'", ")", "{", "break", ";", "}", "if", "(", "++", "offset", ">=", "len", ")", "{", "break", ";", "}", "}", "// Short span? Better just copy it to buffer first:", "int", "newAmount", "=", "offset", "-", "start", ";", "if", "(", "newAmount", "<", "SHORT_WRITE", ")", "{", "// Note: let's reserve room for escaped char (up to 6 chars)", "if", "(", "(", "_outputTail", "+", "newAmount", ")", ">", "_outputEnd", ")", "{", "_flushBuffer", "(", ")", ";", "}", "if", "(", "newAmount", ">", "0", ")", "{", "System", ".", "arraycopy", "(", "text", ",", "start", ",", "_outputBuffer", ",", "_outputTail", ",", "newAmount", ")", ";", "_outputTail", "+=", "newAmount", ";", "}", "}", "else", "{", "// Nope: better just write through", "_flushBuffer", "(", ")", ";", "_writer", ".", "write", "(", "text", ",", "start", ",", "newAmount", ")", ";", "}", "// Was this the end?", "if", "(", "offset", ">=", "len", ")", "{", "// yup", "break", ";", "}", "// Nope, need to escape the char.", "char", "c", "=", "text", "[", "offset", "++", "]", ";", "_appendCharacterEscape", "(", "'", "'", ",", "c", ")", ";", "}", "}"], "docstring": "This method called when the string content is already in\na char buffer, and need not be copied for processing.", "docstring_tokens": ["This", "method", "called", "when", "the", "string", "content", "is", "already", "in", "a", "char", "buffer", "and", "need", "not", "be", "copied", "for", "processing", "."]}
{"code": "message = null;", "comments": "so that message and messageBytes don't go out of", "lines": 9, "repo": "twitter/elephant-bird", "path": "core/src/main/java/com/twitter/elephantbird/mapreduce/io/BinaryWritable.java", "func_name": "BinaryWritable.serialize", "original_string": "private byte[] serialize() {\n    if (messageBytes == null && message != null) {\n      checkConverter();\n      messageBytes = converter.toBytes(message);\n      if (messageBytes == null) {\n        // should we throw an IOException instead?\n        LOG.warn(\"Could not serialize \" + message.getClass());\n      } else {\n        message = null; // so that message and messageBytes don't go out of\n                        // sync.\n      }\n    }\n    return messageBytes;\n  }", "language": "java", "Allcodes": "private byte[] serialize() {\n    if (messageBytes == null && message != null) {\n      checkConverter();\n      messageBytes = converter.toBytes(message);\n      if (messageBytes == null) {\n        // should we throw an IOException instead?\n        LOG.warn(\"Could not serialize \" + message.getClass());\n      } else {\n        message = null; // so that message and messageBytes don't go out of\n                        // sync.\n      }\n    }\n    return messageBytes;\n  }", "code_tokens": ["private", "byte", "[", "]", "serialize", "(", ")", "{", "if", "(", "messageBytes", "==", "null", "&&", "message", "!=", "null", ")", "{", "checkConverter", "(", ")", ";", "messageBytes", "=", "converter", ".", "toBytes", "(", "message", ")", ";", "if", "(", "messageBytes", "==", "null", ")", "{", "// should we throw an IOException instead?", "LOG", ".", "warn", "(", "\"Could not serialize \"", "+", "message", ".", "getClass", "(", ")", ")", ";", "}", "else", "{", "message", "=", "null", ";", "// so that message and messageBytes don't go out of", "// sync.", "}", "}", "return", "messageBytes", ";", "}"], "docstring": "Converts the message to raw bytes, and caches the converted value.\n@return converted value, which may be null in case of null message or error.", "docstring_tokens": ["Converts", "the", "message", "to", "raw", "bytes", "and", "caches", "the", "converted", "value", "."]}
{"code": "final Decimal maxRange = Decimal.valueOf(\"0.03\");", "comments": "3.0%", "lines": 2, "repo": "mdeverdelhan/ta4j-origins", "path": "ta4j-examples/src/main/java/ta4jexamples/bots/TradingBotOnMovingTimeSeries.java", "func_name": "TradingBotOnMovingTimeSeries.generateRandomTick", "original_string": "private static Tick generateRandomTick() {\r\n        final Decimal maxRange = Decimal.valueOf(\"0.03\"); // 3.0%\r\n        Decimal openPrice = LAST_TICK_CLOSE_PRICE;\r\n        Decimal minPrice = openPrice.minus(openPrice.multipliedBy(maxRange.multipliedBy(Decimal.valueOf(Math.random()))));\r\n        Decimal maxPrice = openPrice.plus(openPrice.multipliedBy(maxRange.multipliedBy(Decimal.valueOf(Math.random()))));\r\n        Decimal closePrice = randDecimal(minPrice, maxPrice);\r\n        LAST_TICK_CLOSE_PRICE = closePrice;\r\n        return new BaseTick(ZonedDateTime.now(), openPrice, maxPrice, minPrice, closePrice, Decimal.ONE);\r\n    }", "language": "java", "Allcodes": "private static Tick generateRandomTick() {\r\n        final Decimal maxRange = Decimal.valueOf(\"0.03\"); // 3.0%\r\n        Decimal openPrice = LAST_TICK_CLOSE_PRICE;\r\n        Decimal minPrice = openPrice.minus(openPrice.multipliedBy(maxRange.multipliedBy(Decimal.valueOf(Math.random()))));\r\n        Decimal maxPrice = openPrice.plus(openPrice.multipliedBy(maxRange.multipliedBy(Decimal.valueOf(Math.random()))));\r\n        Decimal closePrice = randDecimal(minPrice, maxPrice);\r\n        LAST_TICK_CLOSE_PRICE = closePrice;\r\n        return new BaseTick(ZonedDateTime.now(), openPrice, maxPrice, minPrice, closePrice, Decimal.ONE);\r\n    }", "code_tokens": ["private", "static", "Tick", "generateRandomTick", "(", ")", "{", "final", "Decimal", "maxRange", "=", "Decimal", ".", "valueOf", "(", "\"0.03\"", ")", ";", "// 3.0%\r", "Decimal", "openPrice", "=", "LAST_TICK_CLOSE_PRICE", ";", "Decimal", "minPrice", "=", "openPrice", ".", "minus", "(", "openPrice", ".", "multipliedBy", "(", "maxRange", ".", "multipliedBy", "(", "Decimal", ".", "valueOf", "(", "Math", ".", "random", "(", ")", ")", ")", ")", ")", ";", "Decimal", "maxPrice", "=", "openPrice", ".", "plus", "(", "openPrice", ".", "multipliedBy", "(", "maxRange", ".", "multipliedBy", "(", "Decimal", ".", "valueOf", "(", "Math", ".", "random", "(", ")", ")", ")", ")", ")", ";", "Decimal", "closePrice", "=", "randDecimal", "(", "minPrice", ",", "maxPrice", ")", ";", "LAST_TICK_CLOSE_PRICE", "=", "closePrice", ";", "return", "new", "BaseTick", "(", "ZonedDateTime", ".", "now", "(", ")", ",", "openPrice", ",", "maxPrice", ",", "minPrice", ",", "closePrice", ",", "Decimal", ".", "ONE", ")", ";", "}"], "docstring": "Generates a random tick.\n@return a random tick", "docstring_tokens": ["Generates", "a", "random", "tick", "."]}
{"code": "LocalTime tripBeginTime = LocalTime.ofSecondOfDay(firstStopTime.departure_time % 86399);", "comments": "convert 24hr+ seconds to 0 - 86399", "lines": 6, "repo": "conveyal/gtfs-lib", "path": "src/main/java/com/conveyal/gtfs/stats/PatternStats.java", "func_name": "PatternStats.getAverageSpeedForTrips", "original_string": "public double getAverageSpeedForTrips (Collection<Trip> trips, LocalTime from, LocalTime to) {\n        TDoubleList speeds = new TDoubleArrayList();\n\n        for (Trip trip : trips) {\n            StopTime firstStopTime = feed.stop_times.ceilingEntry(Fun.t2(trip.trip_id, null)).getValue();\n            LocalTime tripBeginTime = LocalTime.ofSecondOfDay(firstStopTime.departure_time % 86399); // convert 24hr+ seconds to 0 - 86399\n\n            // skip trip if begin time is before or after specified time period\n            if (tripBeginTime.isAfter(to) || tripBeginTime.isBefore(from)) {\n                continue;\n            }\n            // TODO: swap straight lines for actual geometry?\n            double speed = feed.getTripSpeed(trip.trip_id, true);\n\n            if (!Double.isNaN(speed)) {\n                speeds.add(speed);\n            }\n        }\n\n        if (speeds.isEmpty()) return -1;\n\n        return speeds.sum() / speeds.size();\n    }", "language": "java", "Allcodes": "public double getAverageSpeedForTrips (Collection<Trip> trips, LocalTime from, LocalTime to) {\n        TDoubleList speeds = new TDoubleArrayList();\n\n        for (Trip trip : trips) {\n            StopTime firstStopTime = feed.stop_times.ceilingEntry(Fun.t2(trip.trip_id, null)).getValue();\n            LocalTime tripBeginTime = LocalTime.ofSecondOfDay(firstStopTime.departure_time % 86399); // convert 24hr+ seconds to 0 - 86399\n\n            // skip trip if begin time is before or after specified time period\n            if (tripBeginTime.isAfter(to) || tripBeginTime.isBefore(from)) {\n                continue;\n            }\n            // TODO: swap straight lines for actual geometry?\n            double speed = feed.getTripSpeed(trip.trip_id, true);\n\n            if (!Double.isNaN(speed)) {\n                speeds.add(speed);\n            }\n        }\n\n        if (speeds.isEmpty()) return -1;\n\n        return speeds.sum() / speeds.size();\n    }", "code_tokens": ["public", "double", "getAverageSpeedForTrips", "(", "Collection", "<", "Trip", ">", "trips", ",", "LocalTime", "from", ",", "LocalTime", "to", ")", "{", "TDoubleList", "speeds", "=", "new", "TDoubleArrayList", "(", ")", ";", "for", "(", "Trip", "trip", ":", "trips", ")", "{", "StopTime", "firstStopTime", "=", "feed", ".", "stop_times", ".", "ceilingEntry", "(", "Fun", ".", "t2", "(", "trip", ".", "trip_id", ",", "null", ")", ")", ".", "getValue", "(", ")", ";", "LocalTime", "tripBeginTime", "=", "LocalTime", ".", "ofSecondOfDay", "(", "firstStopTime", ".", "departure_time", "%", "86399", ")", ";", "// convert 24hr+ seconds to 0 - 86399", "// skip trip if begin time is before or after specified time period", "if", "(", "tripBeginTime", ".", "isAfter", "(", "to", ")", "||", "tripBeginTime", ".", "isBefore", "(", "from", ")", ")", "{", "continue", ";", "}", "// TODO: swap straight lines for actual geometry?", "double", "speed", "=", "feed", ".", "getTripSpeed", "(", "trip", ".", "trip_id", ",", "true", ")", ";", "if", "(", "!", "Double", ".", "isNaN", "(", "speed", ")", ")", "{", "speeds", ".", "add", "(", "speed", ")", ";", "}", "}", "if", "(", "speeds", ".", "isEmpty", "(", ")", ")", "return", "-", "1", ";", "return", "speeds", ".", "sum", "(", ")", "/", "speeds", ".", "size", "(", ")", ";", "}"], "docstring": "Get average speed for set of trips that begin within the time window in meters per second.\n@param trips\n@param from\n@param to\n@return avg. speed (meters per second)", "docstring_tokens": ["Get", "average", "speed", "for", "set", "of", "trips", "that", "begin", "within", "the", "time", "window", "in", "meters", "per", "second", "."]}
{"code": "return distance / time;", "comments": "meters per second", "lines": 16, "repo": "conveyal/gtfs-lib", "path": "src/main/java/com/conveyal/gtfs/GTFSFeed.java", "func_name": "GTFSFeed.getTripSpeed", "original_string": "public double getTripSpeed (String trip_id, boolean straightLine) {\n\n        StopTime firstStopTime = this.stop_times.ceilingEntry(Fun.t2(trip_id, null)).getValue();\n        StopTime lastStopTime = this.stop_times.floorEntry(Fun.t2(trip_id, Fun.HI)).getValue();\n\n        // ensure that stopTime returned matches trip id (i.e., that the trip has stoptimes)\n        if (!firstStopTime.trip_id.equals(trip_id) || !lastStopTime.trip_id.equals(trip_id)) {\n            return Double.NaN;\n        }\n\n        double distance = getTripDistance(trip_id, straightLine);\n\n        // trip time (in seconds)\n        int time = lastStopTime.arrival_time - firstStopTime.departure_time;\n\n        return distance / time; // meters per second\n    }", "language": "java", "Allcodes": "public double getTripSpeed (String trip_id, boolean straightLine) {\n\n        StopTime firstStopTime = this.stop_times.ceilingEntry(Fun.t2(trip_id, null)).getValue();\n        StopTime lastStopTime = this.stop_times.floorEntry(Fun.t2(trip_id, Fun.HI)).getValue();\n\n        // ensure that stopTime returned matches trip id (i.e., that the trip has stoptimes)\n        if (!firstStopTime.trip_id.equals(trip_id) || !lastStopTime.trip_id.equals(trip_id)) {\n            return Double.NaN;\n        }\n\n        double distance = getTripDistance(trip_id, straightLine);\n\n        // trip time (in seconds)\n        int time = lastStopTime.arrival_time - firstStopTime.departure_time;\n\n        return distance / time; // meters per second\n    }", "code_tokens": ["public", "double", "getTripSpeed", "(", "String", "trip_id", ",", "boolean", "straightLine", ")", "{", "StopTime", "firstStopTime", "=", "this", ".", "stop_times", ".", "ceilingEntry", "(", "Fun", ".", "t2", "(", "trip_id", ",", "null", ")", ")", ".", "getValue", "(", ")", ";", "StopTime", "lastStopTime", "=", "this", ".", "stop_times", ".", "floorEntry", "(", "Fun", ".", "t2", "(", "trip_id", ",", "Fun", ".", "HI", ")", ")", ".", "getValue", "(", ")", ";", "// ensure that stopTime returned matches trip id (i.e., that the trip has stoptimes)", "if", "(", "!", "firstStopTime", ".", "trip_id", ".", "equals", "(", "trip_id", ")", "||", "!", "lastStopTime", ".", "trip_id", ".", "equals", "(", "trip_id", ")", ")", "{", "return", "Double", ".", "NaN", ";", "}", "double", "distance", "=", "getTripDistance", "(", "trip_id", ",", "straightLine", ")", ";", "// trip time (in seconds)", "int", "time", "=", "lastStopTime", ".", "arrival_time", "-", "firstStopTime", ".", "departure_time", ";", "return", "distance", "/", "time", ";", "// meters per second", "}"], "docstring": "Get trip speed in meters per second.", "docstring_tokens": ["Get", "trip", "speed", "in", "meters", "per", "second", "."]}
{"code": "mHandler.sendMessageDelayed(m, 1000L);", "comments": "uncolour in 1 second.", "lines": 4, "repo": "evant/JobSchedulerCompat", "path": "app/src/main/java/me/tatarka/support/job/sample/MainActivity.java", "func_name": "MainActivity.onReceivedStartJob", "original_string": "public void onReceivedStartJob(JobParameters params) {\n        mShowStartView.setBackgroundColor(startJobColor);\n        Message m = Message.obtain(mHandler, MSG_UNCOLOUR_START);\n        mHandler.sendMessageDelayed(m, 1000L); // uncolour in 1 second.\n        mParamsTextView.setText(\"Executing: \" + params.getJobId() + \" \" + params.getExtras());\n    }", "language": "java", "Allcodes": "public void onReceivedStartJob(JobParameters params) {\n        mShowStartView.setBackgroundColor(startJobColor);\n        Message m = Message.obtain(mHandler, MSG_UNCOLOUR_START);\n        mHandler.sendMessageDelayed(m, 1000L); // uncolour in 1 second.\n        mParamsTextView.setText(\"Executing: \" + params.getJobId() + \" \" + params.getExtras());\n    }", "code_tokens": ["public", "void", "onReceivedStartJob", "(", "JobParameters", "params", ")", "{", "mShowStartView", ".", "setBackgroundColor", "(", "startJobColor", ")", ";", "Message", "m", "=", "Message", ".", "obtain", "(", "mHandler", ",", "MSG_UNCOLOUR_START", ")", ";", "mHandler", ".", "sendMessageDelayed", "(", "m", ",", "1000L", ")", ";", "// uncolour in 1 second.", "mParamsTextView", ".", "setText", "(", "\"Executing: \"", "+", "params", ".", "getJobId", "(", ")", "+", "\" \"", "+", "params", ".", "getExtras", "(", ")", ")", ";", "}"], "docstring": "Receives callback from the service when a job has landed on the app. Colours the UI and post\na message to uncolour it after a second.", "docstring_tokens": ["Receives", "callback", "from", "the", "service", "when", "a", "job", "has", "landed", "on", "the", "app", ".", "Colours", "the", "UI", "and", "post", "a", "message", "to", "uncolour", "it", "after", "a", "second", "."]}
{"code": "formatter.format(\"%%%02X\", (int) c);", "comments": "TODO", "lines": 46, "repo": "ocpsoft/rewrite", "path": "config-proxy/src/main/java/org/ocpsoft/rewrite/servlet/config/proxy/ProxyServlet.java", "func_name": "ProxyServlet.encodeUriQuery", "original_string": "protected static CharSequence encodeUriQuery(CharSequence in)\n   {\n      /*\n       * Note that I can't simply use URI.java to encode because it will escape pre-existing escaped things. TODO:\n       * replace/compare to with Rewrite Encoding\n       */\n      StringBuilder outBuf = null;\n      Formatter formatter = null;\n      for (int i = 0; i < in.length(); i++)\n      {\n         char c = in.charAt(i);\n         boolean escape = true;\n         if (c < 128)\n         {\n            if (asciiQueryChars.get(c))\n            {\n               escape = false;\n            }\n         }\n         else if (!Character.isISOControl(c) && !Character.isSpaceChar(c))\n         {\n            /*\n             * not-ascii\n             */\n            escape = false;\n         }\n         if (!escape)\n         {\n            if (outBuf != null)\n               outBuf.append(c);\n         }\n         else\n         {\n            /*\n             * escape\n             */\n            if (outBuf == null)\n            {\n               outBuf = new StringBuilder(in.length() + 5 * 3);\n               outBuf.append(in, 0, i);\n               formatter = new Formatter(outBuf);\n            }\n            /*\n             * leading %, 0 padded, width 2, capital hex\n             */\n            formatter.format(\"%%%02X\", (int) c);// TODO\n         }\n      }\n      return outBuf != null ? outBuf : in;\n   }", "language": "java", "Allcodes": "protected static CharSequence encodeUriQuery(CharSequence in)\n   {\n      /*\n       * Note that I can't simply use URI.java to encode because it will escape pre-existing escaped things. TODO:\n       * replace/compare to with Rewrite Encoding\n       */\n      StringBuilder outBuf = null;\n      Formatter formatter = null;\n      for (int i = 0; i < in.length(); i++)\n      {\n         char c = in.charAt(i);\n         boolean escape = true;\n         if (c < 128)\n         {\n            if (asciiQueryChars.get(c))\n            {\n               escape = false;\n            }\n         }\n         else if (!Character.isISOControl(c) && !Character.isSpaceChar(c))\n         {\n            /*\n             * not-ascii\n             */\n            escape = false;\n         }\n         if (!escape)\n         {\n            if (outBuf != null)\n               outBuf.append(c);\n         }\n         else\n         {\n            /*\n             * escape\n             */\n            if (outBuf == null)\n            {\n               outBuf = new StringBuilder(in.length() + 5 * 3);\n               outBuf.append(in, 0, i);\n               formatter = new Formatter(outBuf);\n            }\n            /*\n             * leading %, 0 padded, width 2, capital hex\n             */\n            formatter.format(\"%%%02X\", (int) c);// TODO\n         }\n      }\n      return outBuf != null ? outBuf : in;\n   }", "code_tokens": ["protected", "static", "CharSequence", "encodeUriQuery", "(", "CharSequence", "in", ")", "{", "/*\n       * Note that I can't simply use URI.java to encode because it will escape pre-existing escaped things. TODO:\n       * replace/compare to with Rewrite Encoding\n       */", "StringBuilder", "outBuf", "=", "null", ";", "Formatter", "formatter", "=", "null", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "in", ".", "length", "(", ")", ";", "i", "++", ")", "{", "char", "c", "=", "in", ".", "charAt", "(", "i", ")", ";", "boolean", "escape", "=", "true", ";", "if", "(", "c", "<", "128", ")", "{", "if", "(", "asciiQueryChars", ".", "get", "(", "c", ")", ")", "{", "escape", "=", "false", ";", "}", "}", "else", "if", "(", "!", "Character", ".", "isISOControl", "(", "c", ")", "&&", "!", "Character", ".", "isSpaceChar", "(", "c", ")", ")", "{", "/*\n             * not-ascii\n             */", "escape", "=", "false", ";", "}", "if", "(", "!", "escape", ")", "{", "if", "(", "outBuf", "!=", "null", ")", "outBuf", ".", "append", "(", "c", ")", ";", "}", "else", "{", "/*\n             * escape\n             */", "if", "(", "outBuf", "==", "null", ")", "{", "outBuf", "=", "new", "StringBuilder", "(", "in", ".", "length", "(", ")", "+", "5", "*", "3", ")", ";", "outBuf", ".", "append", "(", "in", ",", "0", ",", "i", ")", ";", "formatter", "=", "new", "Formatter", "(", "outBuf", ")", ";", "}", "/*\n             * leading %, 0 padded, width 2, capital hex\n             */", "formatter", ".", "format", "(", "\"%%%02X\"", ",", "(", "int", ")", "c", ")", ";", "// TODO", "}", "}", "return", "outBuf", "!=", "null", "?", "outBuf", ":", "in", ";", "}"], "docstring": "Encodes characters in the query or fragment part of the URI.\n\n<p>\nUnfortunately, an incoming URI sometimes has characters disallowed by the spec. HttpClient insists that the\noutgoing proxied request has a valid URI because it uses Java's {@link URI}. To be more forgiving, we must escape\nthe problematic characters. See the URI class for the spec.\n\n@param in example: name=value&foo=bar#fragment", "docstring_tokens": ["Encodes", "characters", "in", "the", "query", "or", "fragment", "part", "of", "the", "URI", "."]}
{"code": "empty[0] = 80;", "comments": "P", "lines": 15, "repo": "sonatype/plexus-archiver", "path": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipArchiver.java", "func_name": "AbstractZipArchiver.createEmptyZip", "original_string": "@SuppressWarnings({\"JavaDoc\"})\n    protected boolean createEmptyZip( File zipFile )\n        throws ArchiverException\n    {\n        // In this case using java.util.zip will not work\n        // because it does not permit a zero-entry archive.\n        // Must create it manually.\n        getLogger().info( \"Note: creating empty \" + archiveType + \" archive \" + zipFile );\n        OutputStream os = null;\n        try\n        {\n            os = new FileOutputStream( zipFile );\n            // Cf. PKZIP specification.\n            byte[] empty = new byte[22];\n            empty[0] = 80; // P\n            empty[1] = 75; // K\n            empty[2] = 5;\n            empty[3] = 6;\n            // remainder zeros\n            os.write( empty );\n        }\n        catch ( IOException ioe )\n        {\n            throw new ArchiverException( \"Could not create empty ZIP archive \" + \"(\" + ioe.getMessage() + \")\", ioe );\n        }\n        finally\n        {\n            IOUtil.close( os );\n        }\n        return true;\n    }", "language": "java", "Allcodes": "@SuppressWarnings({\"JavaDoc\"})\n    protected boolean createEmptyZip( File zipFile )\n        throws ArchiverException\n    {\n        // In this case using java.util.zip will not work\n        // because it does not permit a zero-entry archive.\n        // Must create it manually.\n        getLogger().info( \"Note: creating empty \" + archiveType + \" archive \" + zipFile );\n        OutputStream os = null;\n        try\n        {\n            os = new FileOutputStream( zipFile );\n            // Cf. PKZIP specification.\n            byte[] empty = new byte[22];\n            empty[0] = 80; // P\n            empty[1] = 75; // K\n            empty[2] = 5;\n            empty[3] = 6;\n            // remainder zeros\n            os.write( empty );\n        }\n        catch ( IOException ioe )\n        {\n            throw new ArchiverException( \"Could not create empty ZIP archive \" + \"(\" + ioe.getMessage() + \")\", ioe );\n        }\n        finally\n        {\n            IOUtil.close( os );\n        }\n        return true;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "{", "\"JavaDoc\"", "}", ")", "protected", "boolean", "createEmptyZip", "(", "File", "zipFile", ")", "throws", "ArchiverException", "{", "// In this case using java.util.zip will not work", "// because it does not permit a zero-entry archive.", "// Must create it manually.", "getLogger", "(", ")", ".", "info", "(", "\"Note: creating empty \"", "+", "archiveType", "+", "\" archive \"", "+", "zipFile", ")", ";", "OutputStream", "os", "=", "null", ";", "try", "{", "os", "=", "new", "FileOutputStream", "(", "zipFile", ")", ";", "// Cf. PKZIP specification.", "byte", "[", "]", "empty", "=", "new", "byte", "[", "22", "]", ";", "empty", "[", "0", "]", "=", "80", ";", "// P", "empty", "[", "1", "]", "=", "75", ";", "// K", "empty", "[", "2", "]", "=", "5", ";", "empty", "[", "3", "]", "=", "6", ";", "// remainder zeros", "os", ".", "write", "(", "empty", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "ArchiverException", "(", "\"Could not create empty ZIP archive \"", "+", "\"(\"", "+", "ioe", ".", "getMessage", "(", ")", "+", "\")\"", ",", "ioe", ")", ";", "}", "finally", "{", "IOUtil", ".", "close", "(", "os", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Create an empty zip file\n\n@param zipFile The file\n@return true for historic reasons", "docstring_tokens": ["Create", "an", "empty", "zip", "file"]}
{"code": "empty[1] = 75;", "comments": "K", "lines": 16, "repo": "sonatype/plexus-archiver", "path": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipArchiver.java", "func_name": "AbstractZipArchiver.createEmptyZip", "original_string": "@SuppressWarnings({\"JavaDoc\"})\n    protected boolean createEmptyZip( File zipFile )\n        throws ArchiverException\n    {\n        // In this case using java.util.zip will not work\n        // because it does not permit a zero-entry archive.\n        // Must create it manually.\n        getLogger().info( \"Note: creating empty \" + archiveType + \" archive \" + zipFile );\n        OutputStream os = null;\n        try\n        {\n            os = new FileOutputStream( zipFile );\n            // Cf. PKZIP specification.\n            byte[] empty = new byte[22];\n            empty[0] = 80; // P\n            empty[1] = 75; // K\n            empty[2] = 5;\n            empty[3] = 6;\n            // remainder zeros\n            os.write( empty );\n        }\n        catch ( IOException ioe )\n        {\n            throw new ArchiverException( \"Could not create empty ZIP archive \" + \"(\" + ioe.getMessage() + \")\", ioe );\n        }\n        finally\n        {\n            IOUtil.close( os );\n        }\n        return true;\n    }", "language": "java", "Allcodes": "@SuppressWarnings({\"JavaDoc\"})\n    protected boolean createEmptyZip( File zipFile )\n        throws ArchiverException\n    {\n        // In this case using java.util.zip will not work\n        // because it does not permit a zero-entry archive.\n        // Must create it manually.\n        getLogger().info( \"Note: creating empty \" + archiveType + \" archive \" + zipFile );\n        OutputStream os = null;\n        try\n        {\n            os = new FileOutputStream( zipFile );\n            // Cf. PKZIP specification.\n            byte[] empty = new byte[22];\n            empty[0] = 80; // P\n            empty[1] = 75; // K\n            empty[2] = 5;\n            empty[3] = 6;\n            // remainder zeros\n            os.write( empty );\n        }\n        catch ( IOException ioe )\n        {\n            throw new ArchiverException( \"Could not create empty ZIP archive \" + \"(\" + ioe.getMessage() + \")\", ioe );\n        }\n        finally\n        {\n            IOUtil.close( os );\n        }\n        return true;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "{", "\"JavaDoc\"", "}", ")", "protected", "boolean", "createEmptyZip", "(", "File", "zipFile", ")", "throws", "ArchiverException", "{", "// In this case using java.util.zip will not work", "// because it does not permit a zero-entry archive.", "// Must create it manually.", "getLogger", "(", ")", ".", "info", "(", "\"Note: creating empty \"", "+", "archiveType", "+", "\" archive \"", "+", "zipFile", ")", ";", "OutputStream", "os", "=", "null", ";", "try", "{", "os", "=", "new", "FileOutputStream", "(", "zipFile", ")", ";", "// Cf. PKZIP specification.", "byte", "[", "]", "empty", "=", "new", "byte", "[", "22", "]", ";", "empty", "[", "0", "]", "=", "80", ";", "// P", "empty", "[", "1", "]", "=", "75", ";", "// K", "empty", "[", "2", "]", "=", "5", ";", "empty", "[", "3", "]", "=", "6", ";", "// remainder zeros", "os", ".", "write", "(", "empty", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "throw", "new", "ArchiverException", "(", "\"Could not create empty ZIP archive \"", "+", "\"(\"", "+", "ioe", ".", "getMessage", "(", ")", "+", "\")\"", ",", "ioe", ")", ";", "}", "finally", "{", "IOUtil", ".", "close", "(", "os", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Create an empty zip file\n\n@param zipFile The file\n@return true for historic reasons", "docstring_tokens": ["Create", "an", "empty", "zip", "file"]}
{"code": "newUrl = kojiUtils.formatStorageUrl( config.getStorageRootUrl(), buildInfo );", "comments": "volume is involved", "lines": 32, "repo": "Commonjava/indy", "path": "addons/koji/common/src/main/java/org/commonjava/indy/koji/data/KojiRepairManager.java", "func_name": "KojiRepairManager.doRepair", "original_string": "private KojiRepairResult.RepairResult doRepair( String packageType, RemoteRepository repository,\n                                                    KojiBuildInfo buildInfo, String user, boolean isDryRun )\n                    throws KojiRepairException\n    {\n        StoreKey storeKey;\n        if ( repository != null )\n        {\n            storeKey = repository.getKey();\n        }\n        else\n        {\n            String name = kojiUtils.getRepositoryName( buildInfo );\n            storeKey = new StoreKey( packageType, StoreType.remote, name );\n            try\n            {\n                repository = (RemoteRepository) storeManager.getArtifactStore( storeKey );\n            }\n            catch ( IndyDataException e )\n            {\n                throw new KojiRepairException( \"Cannot get store: %s. Reason: %s\", e, storeKey,\n                                               e.getMessage() );\n            }\n        }\n\n        KojiRepairResult.RepairResult repairResult = new KojiRepairResult.RepairResult( storeKey );\n\n        String url = repository.getUrl();\n\n        String newUrl;\n        try\n        {\n            newUrl = kojiUtils.formatStorageUrl( config.getStorageRootUrl(), buildInfo ); // volume is involved\n        }\n        catch ( MalformedURLException e )\n        {\n            throw new KojiRepairException( \"Failed to format storage Url: %s. Reason: %s\", e, storeKey,\n                                           e.getMessage() );\n        }\n\n        boolean changed = !url.equals( newUrl );\n        if ( changed )\n        {\n            repairResult.withPropertyChange( \"url\", url, newUrl );\n\n            if ( !isDryRun )\n            {\n                ChangeSummary changeSummary = new ChangeSummary( user,\n                                                                 \"Repair \" + storeKey + \" url with volume: \" + buildInfo\n                                                                                 .getVolumeName() );\n                repository.setUrl( newUrl );\n                repository.setMetadata( METADATA_KOJI_BUILD_ID, Integer.toString( buildInfo.getId() ) );\n                boolean fireEvents = false;\n                boolean skipIfExists = false;\n                try\n                {\n                    storeManager.storeArtifactStore( repository, changeSummary, skipIfExists, fireEvents, new EventMetadata() );\n                }\n                catch ( IndyDataException e )\n                {\n                    throw new KojiRepairException( \"Failed to repair store: %s. Reason: %s\", e, storeKey, e.getMessage() );\n                }\n            }\n        }\n        return repairResult;\n    }", "language": "java", "Allcodes": "private KojiRepairResult.RepairResult doRepair( String packageType, RemoteRepository repository,\n                                                    KojiBuildInfo buildInfo, String user, boolean isDryRun )\n                    throws KojiRepairException\n    {\n        StoreKey storeKey;\n        if ( repository != null )\n        {\n            storeKey = repository.getKey();\n        }\n        else\n        {\n            String name = kojiUtils.getRepositoryName( buildInfo );\n            storeKey = new StoreKey( packageType, StoreType.remote, name );\n            try\n            {\n                repository = (RemoteRepository) storeManager.getArtifactStore( storeKey );\n            }\n            catch ( IndyDataException e )\n            {\n                throw new KojiRepairException( \"Cannot get store: %s. Reason: %s\", e, storeKey,\n                                               e.getMessage() );\n            }\n        }\n\n        KojiRepairResult.RepairResult repairResult = new KojiRepairResult.RepairResult( storeKey );\n\n        String url = repository.getUrl();\n\n        String newUrl;\n        try\n        {\n            newUrl = kojiUtils.formatStorageUrl( config.getStorageRootUrl(), buildInfo ); // volume is involved\n        }\n        catch ( MalformedURLException e )\n        {\n            throw new KojiRepairException( \"Failed to format storage Url: %s. Reason: %s\", e, storeKey,\n                                           e.getMessage() );\n        }\n\n        boolean changed = !url.equals( newUrl );\n        if ( changed )\n        {\n            repairResult.withPropertyChange( \"url\", url, newUrl );\n\n            if ( !isDryRun )\n            {\n                ChangeSummary changeSummary = new ChangeSummary( user,\n                                                                 \"Repair \" + storeKey + \" url with volume: \" + buildInfo\n                                                                                 .getVolumeName() );\n                repository.setUrl( newUrl );\n                repository.setMetadata( METADATA_KOJI_BUILD_ID, Integer.toString( buildInfo.getId() ) );\n                boolean fireEvents = false;\n                boolean skipIfExists = false;\n                try\n                {\n                    storeManager.storeArtifactStore( repository, changeSummary, skipIfExists, fireEvents, new EventMetadata() );\n                }\n                catch ( IndyDataException e )\n                {\n                    throw new KojiRepairException( \"Failed to repair store: %s. Reason: %s\", e, storeKey, e.getMessage() );\n                }\n            }\n        }\n        return repairResult;\n    }", "code_tokens": ["private", "KojiRepairResult", ".", "RepairResult", "doRepair", "(", "String", "packageType", ",", "RemoteRepository", "repository", ",", "KojiBuildInfo", "buildInfo", ",", "String", "user", ",", "boolean", "isDryRun", ")", "throws", "KojiRepairException", "{", "StoreKey", "storeKey", ";", "if", "(", "repository", "!=", "null", ")", "{", "storeKey", "=", "repository", ".", "getKey", "(", ")", ";", "}", "else", "{", "String", "name", "=", "kojiUtils", ".", "getRepositoryName", "(", "buildInfo", ")", ";", "storeKey", "=", "new", "StoreKey", "(", "packageType", ",", "StoreType", ".", "remote", ",", "name", ")", ";", "try", "{", "repository", "=", "(", "RemoteRepository", ")", "storeManager", ".", "getArtifactStore", "(", "storeKey", ")", ";", "}", "catch", "(", "IndyDataException", "e", ")", "{", "throw", "new", "KojiRepairException", "(", "\"Cannot get store: %s. Reason: %s\"", ",", "e", ",", "storeKey", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "KojiRepairResult", ".", "RepairResult", "repairResult", "=", "new", "KojiRepairResult", ".", "RepairResult", "(", "storeKey", ")", ";", "String", "url", "=", "repository", ".", "getUrl", "(", ")", ";", "String", "newUrl", ";", "try", "{", "newUrl", "=", "kojiUtils", ".", "formatStorageUrl", "(", "config", ".", "getStorageRootUrl", "(", ")", ",", "buildInfo", ")", ";", "// volume is involved", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "throw", "new", "KojiRepairException", "(", "\"Failed to format storage Url: %s. Reason: %s\"", ",", "e", ",", "storeKey", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "boolean", "changed", "=", "!", "url", ".", "equals", "(", "newUrl", ")", ";", "if", "(", "changed", ")", "{", "repairResult", ".", "withPropertyChange", "(", "\"url\"", ",", "url", ",", "newUrl", ")", ";", "if", "(", "!", "isDryRun", ")", "{", "ChangeSummary", "changeSummary", "=", "new", "ChangeSummary", "(", "user", ",", "\"Repair \"", "+", "storeKey", "+", "\" url with volume: \"", "+", "buildInfo", ".", "getVolumeName", "(", ")", ")", ";", "repository", ".", "setUrl", "(", "newUrl", ")", ";", "repository", ".", "setMetadata", "(", "METADATA_KOJI_BUILD_ID", ",", "Integer", ".", "toString", "(", "buildInfo", ".", "getId", "(", ")", ")", ")", ";", "boolean", "fireEvents", "=", "false", ";", "boolean", "skipIfExists", "=", "false", ";", "try", "{", "storeManager", ".", "storeArtifactStore", "(", "repository", ",", "changeSummary", ",", "skipIfExists", ",", "fireEvents", ",", "new", "EventMetadata", "(", ")", ")", ";", "}", "catch", "(", "IndyDataException", "e", ")", "{", "throw", "new", "KojiRepairException", "(", "\"Failed to repair store: %s. Reason: %s\"", ",", "e", ",", "storeKey", ",", "e", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", "return", "repairResult", ";", "}"], "docstring": "Repair one remote repository.\n@param packageType\n@param repository repository to be repaired. If null, the repository name will be retrieved according to\nthe buildInfo and the naming format in koji.conf.\n@param buildInfo koji build which this repository proxies\n@param user the user does the repair\n@param isDryRun\n@return\n@throws KojiRepairException", "docstring_tokens": ["Repair", "one", "remote", "repository", "."]}
{"code": "return true;", "comments": "yes, there is at least one deadbolt action remaining", "lines": 4, "repo": "schaloner/deadbolt-2-java", "path": "code/app/be/objectify/deadbolt/java/actions/AbstractDeadboltAction.java", "func_name": "AbstractDeadboltAction.deadboltActionLeftInActionChain", "original_string": "private static boolean deadboltActionLeftInActionChain(final Action<?> action) {\n        if(action != null) {\n            if(action.delegate instanceof AbstractDeadboltAction) {\n                return true; // yes, there is at least one deadbolt action remaining\n            }\n            // action.delegate wasn't a deadbolt action, let's check the next one in the chain\n            return deadboltActionLeftInActionChain(action.delegate);\n        }\n        return false;\n    }", "language": "java", "Allcodes": "private static boolean deadboltActionLeftInActionChain(final Action<?> action) {\n        if(action != null) {\n            if(action.delegate instanceof AbstractDeadboltAction) {\n                return true; // yes, there is at least one deadbolt action remaining\n            }\n            // action.delegate wasn't a deadbolt action, let's check the next one in the chain\n            return deadboltActionLeftInActionChain(action.delegate);\n        }\n        return false;\n    }", "code_tokens": ["private", "static", "boolean", "deadboltActionLeftInActionChain", "(", "final", "Action", "<", "?", ">", "action", ")", "{", "if", "(", "action", "!=", "null", ")", "{", "if", "(", "action", ".", "delegate", "instanceof", "AbstractDeadboltAction", ")", "{", "return", "true", ";", "// yes, there is at least one deadbolt action remaining", "}", "// action.delegate wasn't a deadbolt action, let's check the next one in the chain", "return", "deadboltActionLeftInActionChain", "(", "action", ".", "delegate", ")", ";", "}", "return", "false", ";", "}"], "docstring": "Recursive method to determine if there is another deadbolt action further down the action chain", "docstring_tokens": ["Recursive", "method", "to", "determine", "if", "there", "is", "another", "deadbolt", "action", "further", "down", "the", "action", "chain"]}
{"code": "wsNotifier.sendMessage(repositoryCreationResultRest);", "comments": "TODO test me!", "lines": 55, "repo": "project-ncl/pnc", "path": "rest/src/main/java/org/jboss/pnc/rest/endpoint/BpmEndpoint.java", "func_name": "BpmEndpoint.onRCCreationSuccess", "original_string": "private void onRCCreationSuccess(BpmNotificationRest notification, BuildConfigurationRest buildConfigurationRest) {\n        LOG.debug(\"Received BPM event RC_CREATION_SUCCESS: \" + notification);\n\n        BpmStringMapNotificationRest repositoryCreationTaskResult = (BpmStringMapNotificationRest) notification;\n\n        int repositoryConfigurationId = -1;\n        int buildConfigurationSavedId = -1;\n        try {\n            repositoryConfigurationId = Integer.valueOf(repositoryCreationTaskResult.getData().get(\"repositoryConfigurationId\"));\n        } catch (NumberFormatException ex) {\n            String errorMessage = \"Receive notification about successful BC creation '\" + repositoryCreationTaskResult\n                    + \"' but the ID of the newly created RC '\" + repositoryCreationTaskResult.getData()\n                    .get(\"repositoryConfigurationId\")\n                    + \"' is not a number. It should be present under 'repositoryConfigurationId' key.\";\n\n            LOG.error(errorMessage, ex);\n            sendErrorMessage(repositoryConfigurationId, buildConfigurationSavedId, errorMessage);\n            return;\n        }\n\n        RepositoryConfiguration repositoryConfiguration = repositoryConfigurationRepository.queryById(repositoryConfigurationId);\n        if (repositoryConfiguration == null) {\n            String errorMessage = \"Repository Configuration was not found in database.\";\n            LOG.error(errorMessage);\n            sendErrorMessage(repositoryConfigurationId, buildConfigurationSavedId, errorMessage);\n            return;\n        }\n\n        if (buildConfigurationRest != null) { //TODO test me\n            BuildConfiguration buildConfiguration = buildConfigurationRest.toDBEntityBuilder()\n                    .repositoryConfiguration(repositoryConfiguration)\n                    .build();\n            BuildConfiguration buildConfigurationSaved = buildConfigurationRepository.save(buildConfiguration);\n            buildConfigurationSavedId = buildConfigurationSaved.getId();\n\n            Set<Integer> bcSetIds = buildConfigurationRest.getBuildConfigurationSetIds();\n            try {\n                if (bcSetIds != null) {\n                    addBuildConfigurationToSet(buildConfigurationSaved, bcSetIds);\n                }\n            } catch (Exception e) {\n                LOG.error(e.getMessage());\n                sendErrorMessage(repositoryConfigurationId, buildConfigurationSavedId, e.getMessage());\n                return;\n            }\n        }\n\n        RepositoryCreationResultRest repositoryCreationResultRest\n                = new RepositoryCreationResultRest(\n                        repositoryConfigurationId,\n                        buildConfigurationSavedId,\n                        RepositoryCreationResultRest.EventType.RC_CREATION_SUCCESS,\n                        null);\n\n        wsNotifier.sendMessage(repositoryCreationResultRest); //TODO test me!\n    }", "language": "java", "Allcodes": "private void onRCCreationSuccess(BpmNotificationRest notification, BuildConfigurationRest buildConfigurationRest) {\n        LOG.debug(\"Received BPM event RC_CREATION_SUCCESS: \" + notification);\n\n        BpmStringMapNotificationRest repositoryCreationTaskResult = (BpmStringMapNotificationRest) notification;\n\n        int repositoryConfigurationId = -1;\n        int buildConfigurationSavedId = -1;\n        try {\n            repositoryConfigurationId = Integer.valueOf(repositoryCreationTaskResult.getData().get(\"repositoryConfigurationId\"));\n        } catch (NumberFormatException ex) {\n            String errorMessage = \"Receive notification about successful BC creation '\" + repositoryCreationTaskResult\n                    + \"' but the ID of the newly created RC '\" + repositoryCreationTaskResult.getData()\n                    .get(\"repositoryConfigurationId\")\n                    + \"' is not a number. It should be present under 'repositoryConfigurationId' key.\";\n\n            LOG.error(errorMessage, ex);\n            sendErrorMessage(repositoryConfigurationId, buildConfigurationSavedId, errorMessage);\n            return;\n        }\n\n        RepositoryConfiguration repositoryConfiguration = repositoryConfigurationRepository.queryById(repositoryConfigurationId);\n        if (repositoryConfiguration == null) {\n            String errorMessage = \"Repository Configuration was not found in database.\";\n            LOG.error(errorMessage);\n            sendErrorMessage(repositoryConfigurationId, buildConfigurationSavedId, errorMessage);\n            return;\n        }\n\n        if (buildConfigurationRest != null) { //TODO test me\n            BuildConfiguration buildConfiguration = buildConfigurationRest.toDBEntityBuilder()\n                    .repositoryConfiguration(repositoryConfiguration)\n                    .build();\n            BuildConfiguration buildConfigurationSaved = buildConfigurationRepository.save(buildConfiguration);\n            buildConfigurationSavedId = buildConfigurationSaved.getId();\n\n            Set<Integer> bcSetIds = buildConfigurationRest.getBuildConfigurationSetIds();\n            try {\n                if (bcSetIds != null) {\n                    addBuildConfigurationToSet(buildConfigurationSaved, bcSetIds);\n                }\n            } catch (Exception e) {\n                LOG.error(e.getMessage());\n                sendErrorMessage(repositoryConfigurationId, buildConfigurationSavedId, e.getMessage());\n                return;\n            }\n        }\n\n        RepositoryCreationResultRest repositoryCreationResultRest\n                = new RepositoryCreationResultRest(\n                        repositoryConfigurationId,\n                        buildConfigurationSavedId,\n                        RepositoryCreationResultRest.EventType.RC_CREATION_SUCCESS,\n                        null);\n\n        wsNotifier.sendMessage(repositoryCreationResultRest); //TODO test me!\n    }", "code_tokens": ["private", "void", "onRCCreationSuccess", "(", "BpmNotificationRest", "notification", ",", "BuildConfigurationRest", "buildConfigurationRest", ")", "{", "LOG", ".", "debug", "(", "\"Received BPM event RC_CREATION_SUCCESS: \"", "+", "notification", ")", ";", "BpmStringMapNotificationRest", "repositoryCreationTaskResult", "=", "(", "BpmStringMapNotificationRest", ")", "notification", ";", "int", "repositoryConfigurationId", "=", "-", "1", ";", "int", "buildConfigurationSavedId", "=", "-", "1", ";", "try", "{", "repositoryConfigurationId", "=", "Integer", ".", "valueOf", "(", "repositoryCreationTaskResult", ".", "getData", "(", ")", ".", "get", "(", "\"repositoryConfigurationId\"", ")", ")", ";", "}", "catch", "(", "NumberFormatException", "ex", ")", "{", "String", "errorMessage", "=", "\"Receive notification about successful BC creation '\"", "+", "repositoryCreationTaskResult", "+", "\"' but the ID of the newly created RC '\"", "+", "repositoryCreationTaskResult", ".", "getData", "(", ")", ".", "get", "(", "\"repositoryConfigurationId\"", ")", "+", "\"' is not a number. It should be present under 'repositoryConfigurationId' key.\"", ";", "LOG", ".", "error", "(", "errorMessage", ",", "ex", ")", ";", "sendErrorMessage", "(", "repositoryConfigurationId", ",", "buildConfigurationSavedId", ",", "errorMessage", ")", ";", "return", ";", "}", "RepositoryConfiguration", "repositoryConfiguration", "=", "repositoryConfigurationRepository", ".", "queryById", "(", "repositoryConfigurationId", ")", ";", "if", "(", "repositoryConfiguration", "==", "null", ")", "{", "String", "errorMessage", "=", "\"Repository Configuration was not found in database.\"", ";", "LOG", ".", "error", "(", "errorMessage", ")", ";", "sendErrorMessage", "(", "repositoryConfigurationId", ",", "buildConfigurationSavedId", ",", "errorMessage", ")", ";", "return", ";", "}", "if", "(", "buildConfigurationRest", "!=", "null", ")", "{", "//TODO test me", "BuildConfiguration", "buildConfiguration", "=", "buildConfigurationRest", ".", "toDBEntityBuilder", "(", ")", ".", "repositoryConfiguration", "(", "repositoryConfiguration", ")", ".", "build", "(", ")", ";", "BuildConfiguration", "buildConfigurationSaved", "=", "buildConfigurationRepository", ".", "save", "(", "buildConfiguration", ")", ";", "buildConfigurationSavedId", "=", "buildConfigurationSaved", ".", "getId", "(", ")", ";", "Set", "<", "Integer", ">", "bcSetIds", "=", "buildConfigurationRest", ".", "getBuildConfigurationSetIds", "(", ")", ";", "try", "{", "if", "(", "bcSetIds", "!=", "null", ")", "{", "addBuildConfigurationToSet", "(", "buildConfigurationSaved", ",", "bcSetIds", ")", ";", "}", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "error", "(", "e", ".", "getMessage", "(", ")", ")", ";", "sendErrorMessage", "(", "repositoryConfigurationId", ",", "buildConfigurationSavedId", ",", "e", ".", "getMessage", "(", ")", ")", ";", "return", ";", "}", "}", "RepositoryCreationResultRest", "repositoryCreationResultRest", "=", "new", "RepositoryCreationResultRest", "(", "repositoryConfigurationId", ",", "buildConfigurationSavedId", ",", "RepositoryCreationResultRest", ".", "EventType", ".", "RC_CREATION_SUCCESS", ",", "null", ")", ";", "wsNotifier", ".", "sendMessage", "(", "repositoryCreationResultRest", ")", ";", "//TODO test me!", "}"], "docstring": "Given the successful BC creation, add the BC into the BC sets. This solution has been\nselected because if this was done in BPM process there would have to be a foreach cycle and\nat least two REST requests for each BC Set ID. The process would become too complicated.\nNotification listeners are ideal for these kind of operations.", "docstring_tokens": ["Given", "the", "successful", "BC", "creation", "add", "the", "BC", "into", "the", "BC", "sets", ".", "This", "solution", "has", "been", "selected", "because", "if", "this", "was", "done", "in", "BPM", "process", "there", "would", "have", "to", "be", "a", "foreach", "cycle", "and", "at", "least", "two", "REST", "requests", "for", "each", "BC", "Set", "ID", ".", "The", "process", "would", "become", "too", "complicated", ".", "Notification", "listeners", "are", "ideal", "for", "these", "kind", "of", "operations", "."]}
{"code": "len = 6;", "comments": "unicode escapes are six digits long,", "lines": 43, "repo": "Whiley/WhileyCompilerCollection", "path": "src/main/java/wycc/cfg/ConfigFileParser.java", "func_name": "ConfigFileParser.parseString", "original_string": "protected String parseString(String v) {\n\t\t/*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */\n\t\tv = v.substring(1, v.length() - 1);\n\n\t\tStringBuffer result = new StringBuffer();\n\t\t// Second, step through the string and replace escaped characters\n\t\tfor (int i = 0; i < v.length(); i++) {\n\t\t\tif (v.charAt(i) == '\\\\') {\n\t\t\t\tif (v.length() <= i + 1) {\n\t\t\t\t\tthrow new RuntimeException(\"unexpected end-of-string\");\n\t\t\t\t} else {\n\t\t\t\t\tchar replace = 0;\n\t\t\t\t\tint len = 2;\n\t\t\t\t\tswitch (v.charAt(i + 1)) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\treplace = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\treplace = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\treplace = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treplace = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\treplace = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\treplace = '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\treplace = '\\'';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\treplace = '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tlen = 6; // unicode escapes are six digits long,\n\t\t\t\t\t\t// including \"slash u\"\n\t\t\t\t\t\tString unicode = v.substring(i + 2, i + 6);\n\t\t\t\t\t\treplace = (char) Integer.parseInt(unicode, 16); // unicode\n\t\t\t\t\t\ti = i + 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException(\"unknown escape character\");\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.append(replace);\n\t\t\t\t\ti = i + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = result.append(v.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}", "language": "java", "Allcodes": "protected String parseString(String v) {\n\t\t/*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */\n\t\tv = v.substring(1, v.length() - 1);\n\n\t\tStringBuffer result = new StringBuffer();\n\t\t// Second, step through the string and replace escaped characters\n\t\tfor (int i = 0; i < v.length(); i++) {\n\t\t\tif (v.charAt(i) == '\\\\') {\n\t\t\t\tif (v.length() <= i + 1) {\n\t\t\t\t\tthrow new RuntimeException(\"unexpected end-of-string\");\n\t\t\t\t} else {\n\t\t\t\t\tchar replace = 0;\n\t\t\t\t\tint len = 2;\n\t\t\t\t\tswitch (v.charAt(i + 1)) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\treplace = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\treplace = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\treplace = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treplace = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\treplace = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\treplace = '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\treplace = '\\'';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\treplace = '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tlen = 6; // unicode escapes are six digits long,\n\t\t\t\t\t\t// including \"slash u\"\n\t\t\t\t\t\tString unicode = v.substring(i + 2, i + 6);\n\t\t\t\t\t\treplace = (char) Integer.parseInt(unicode, 16); // unicode\n\t\t\t\t\t\ti = i + 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException(\"unknown escape character\");\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.append(replace);\n\t\t\t\t\ti = i + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = result.append(v.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}", "code_tokens": ["protected", "String", "parseString", "(", "String", "v", ")", "{", "/*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */", "v", "=", "v", ".", "substring", "(", "1", ",", "v", ".", "length", "(", ")", "-", "1", ")", ";", "StringBuffer", "result", "=", "new", "StringBuffer", "(", ")", ";", "// Second, step through the string and replace escaped characters", "for", "(", "int", "i", "=", "0", ";", "i", "<", "v", ".", "length", "(", ")", ";", "i", "++", ")", "{", "if", "(", "v", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "if", "(", "v", ".", "length", "(", ")", "<=", "i", "+", "1", ")", "{", "throw", "new", "RuntimeException", "(", "\"unexpected end-of-string\"", ")", ";", "}", "else", "{", "char", "replace", "=", "0", ";", "int", "len", "=", "2", ";", "switch", "(", "v", ".", "charAt", "(", "i", "+", "1", ")", ")", "{", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "len", "=", "6", ";", "// unicode escapes are six digits long,", "// including \"slash u\"", "String", "unicode", "=", "v", ".", "substring", "(", "i", "+", "2", ",", "i", "+", "6", ")", ";", "replace", "=", "(", "char", ")", "Integer", ".", "parseInt", "(", "unicode", ",", "16", ")", ";", "// unicode", "i", "=", "i", "+", "5", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"unknown escape character\"", ")", ";", "}", "result", "=", "result", ".", "append", "(", "replace", ")", ";", "i", "=", "i", "+", "1", ";", "}", "}", "else", "{", "result", "=", "result", ".", "append", "(", "v", ".", "charAt", "(", "i", ")", ")", ";", "}", "}", "return", "result", ".", "toString", "(", ")", ";", "}"], "docstring": "Parse a string constant whilst interpreting all escape characters.\n\n@param v\n@return", "docstring_tokens": ["Parse", "a", "string", "constant", "whilst", "interpreting", "all", "escape", "characters", "."]}
{"code": "replace = (char) Integer.parseInt(unicode, 16);", "comments": "unicode", "lines": 46, "repo": "Whiley/WhileyCompilerCollection", "path": "src/main/java/wycc/cfg/ConfigFileParser.java", "func_name": "ConfigFileParser.parseString", "original_string": "protected String parseString(String v) {\n\t\t/*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */\n\t\tv = v.substring(1, v.length() - 1);\n\n\t\tStringBuffer result = new StringBuffer();\n\t\t// Second, step through the string and replace escaped characters\n\t\tfor (int i = 0; i < v.length(); i++) {\n\t\t\tif (v.charAt(i) == '\\\\') {\n\t\t\t\tif (v.length() <= i + 1) {\n\t\t\t\t\tthrow new RuntimeException(\"unexpected end-of-string\");\n\t\t\t\t} else {\n\t\t\t\t\tchar replace = 0;\n\t\t\t\t\tint len = 2;\n\t\t\t\t\tswitch (v.charAt(i + 1)) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\treplace = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\treplace = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\treplace = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treplace = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\treplace = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\treplace = '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\treplace = '\\'';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\treplace = '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tlen = 6; // unicode escapes are six digits long,\n\t\t\t\t\t\t// including \"slash u\"\n\t\t\t\t\t\tString unicode = v.substring(i + 2, i + 6);\n\t\t\t\t\t\treplace = (char) Integer.parseInt(unicode, 16); // unicode\n\t\t\t\t\t\ti = i + 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException(\"unknown escape character\");\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.append(replace);\n\t\t\t\t\ti = i + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = result.append(v.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}", "language": "java", "Allcodes": "protected String parseString(String v) {\n\t\t/*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */\n\t\tv = v.substring(1, v.length() - 1);\n\n\t\tStringBuffer result = new StringBuffer();\n\t\t// Second, step through the string and replace escaped characters\n\t\tfor (int i = 0; i < v.length(); i++) {\n\t\t\tif (v.charAt(i) == '\\\\') {\n\t\t\t\tif (v.length() <= i + 1) {\n\t\t\t\t\tthrow new RuntimeException(\"unexpected end-of-string\");\n\t\t\t\t} else {\n\t\t\t\t\tchar replace = 0;\n\t\t\t\t\tint len = 2;\n\t\t\t\t\tswitch (v.charAt(i + 1)) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\treplace = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\treplace = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\treplace = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treplace = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\treplace = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\treplace = '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\treplace = '\\'';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\treplace = '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tlen = 6; // unicode escapes are six digits long,\n\t\t\t\t\t\t// including \"slash u\"\n\t\t\t\t\t\tString unicode = v.substring(i + 2, i + 6);\n\t\t\t\t\t\treplace = (char) Integer.parseInt(unicode, 16); // unicode\n\t\t\t\t\t\ti = i + 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException(\"unknown escape character\");\n\t\t\t\t\t}\n\t\t\t\t\tresult = result.append(replace);\n\t\t\t\t\ti = i + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = result.append(v.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}", "code_tokens": ["protected", "String", "parseString", "(", "String", "v", ")", "{", "/*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */", "v", "=", "v", ".", "substring", "(", "1", ",", "v", ".", "length", "(", ")", "-", "1", ")", ";", "StringBuffer", "result", "=", "new", "StringBuffer", "(", ")", ";", "// Second, step through the string and replace escaped characters", "for", "(", "int", "i", "=", "0", ";", "i", "<", "v", ".", "length", "(", ")", ";", "i", "++", ")", "{", "if", "(", "v", ".", "charAt", "(", "i", ")", "==", "'", "'", ")", "{", "if", "(", "v", ".", "length", "(", ")", "<=", "i", "+", "1", ")", "{", "throw", "new", "RuntimeException", "(", "\"unexpected end-of-string\"", ")", ";", "}", "else", "{", "char", "replace", "=", "0", ";", "int", "len", "=", "2", ";", "switch", "(", "v", ".", "charAt", "(", "i", "+", "1", ")", ")", "{", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "replace", "=", "'", "'", ";", "break", ";", "case", "'", "'", ":", "len", "=", "6", ";", "// unicode escapes are six digits long,", "// including \"slash u\"", "String", "unicode", "=", "v", ".", "substring", "(", "i", "+", "2", ",", "i", "+", "6", ")", ";", "replace", "=", "(", "char", ")", "Integer", ".", "parseInt", "(", "unicode", ",", "16", ")", ";", "// unicode", "i", "=", "i", "+", "5", ";", "break", ";", "default", ":", "throw", "new", "RuntimeException", "(", "\"unknown escape character\"", ")", ";", "}", "result", "=", "result", ".", "append", "(", "replace", ")", ";", "i", "=", "i", "+", "1", ";", "}", "}", "else", "{", "result", "=", "result", ".", "append", "(", "v", ".", "charAt", "(", "i", ")", ")", ";", "}", "}", "return", "result", ".", "toString", "(", ")", ";", "}"], "docstring": "Parse a string constant whilst interpreting all escape characters.\n\n@param v\n@return", "docstring_tokens": ["Parse", "a", "string", "constant", "whilst", "interpreting", "all", "escape", "characters", "."]}
{"code": "break;", "comments": "restart rule application loop", "lines": 14, "repo": "Whiley/WhileyCompilerCollection", "path": "src/main/java/wybs/io/AbstractLexer.java", "func_name": "AbstractLexer.scan", "original_string": "public List<Token> scan() throws Error {\n\t\tArrayList<Token> tokens = new ArrayList<>();\n\t\tint pos = 0;\n\t\twhile (pos < input.length()) {\n\t\t\tint start = pos;\n\t\t\tfor (int i = 0; i != rules.length; ++i) {\n\t\t\t\tRule rule = rules[i];\n\t\t\t\tint left = input.length() - pos;\n\t\t\t\tif (left >= rule.lookahead()) {\n\t\t\t\t\tToken t = rule.match(input, pos);\n\t\t\t\t\tif (t != null) {\n\t\t\t\t\t\ttokens.add(t);\n\t\t\t\t\t\tpos = pos + t.text.length();\n\t\t\t\t\t\tbreak; // restart rule application loop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos == start) {\n\t\t\t\tthrow new Error(\"unrecognised token encountered (\" + input.charAt(pos) + \")\",pos);\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}", "language": "java", "Allcodes": "public List<Token> scan() throws Error {\n\t\tArrayList<Token> tokens = new ArrayList<>();\n\t\tint pos = 0;\n\t\twhile (pos < input.length()) {\n\t\t\tint start = pos;\n\t\t\tfor (int i = 0; i != rules.length; ++i) {\n\t\t\t\tRule rule = rules[i];\n\t\t\t\tint left = input.length() - pos;\n\t\t\t\tif (left >= rule.lookahead()) {\n\t\t\t\t\tToken t = rule.match(input, pos);\n\t\t\t\t\tif (t != null) {\n\t\t\t\t\t\ttokens.add(t);\n\t\t\t\t\t\tpos = pos + t.text.length();\n\t\t\t\t\t\tbreak; // restart rule application loop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos == start) {\n\t\t\t\tthrow new Error(\"unrecognised token encountered (\" + input.charAt(pos) + \")\",pos);\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}", "code_tokens": ["public", "List", "<", "Token", ">", "scan", "(", ")", "throws", "Error", "{", "ArrayList", "<", "Token", ">", "tokens", "=", "new", "ArrayList", "<>", "(", ")", ";", "int", "pos", "=", "0", ";", "while", "(", "pos", "<", "input", ".", "length", "(", ")", ")", "{", "int", "start", "=", "pos", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "rules", ".", "length", ";", "++", "i", ")", "{", "Rule", "rule", "=", "rules", "[", "i", "]", ";", "int", "left", "=", "input", ".", "length", "(", ")", "-", "pos", ";", "if", "(", "left", ">=", "rule", ".", "lookahead", "(", ")", ")", "{", "Token", "t", "=", "rule", ".", "match", "(", "input", ",", "pos", ")", ";", "if", "(", "t", "!=", "null", ")", "{", "tokens", ".", "add", "(", "t", ")", ";", "pos", "=", "pos", "+", "t", ".", "text", ".", "length", "(", ")", ";", "break", ";", "// restart rule application loop", "}", "}", "}", "if", "(", "pos", "==", "start", ")", "{", "throw", "new", "Error", "(", "\"unrecognised token encountered (\"", "+", "input", ".", "charAt", "(", "pos", ")", "+", "\")\"", ",", "pos", ")", ";", "}", "}", "return", "tokens", ";", "}"], "docstring": "Scan the given input stream and produce a list of tokens, or an error.\n\n@return", "docstring_tokens": ["Scan", "the", "given", "input", "stream", "and", "produce", "a", "list", "of", "tokens", "or", "an", "error", "."]}
{"code": "iter.remove();", "comments": "remove option from args list", "lines": 21, "repo": "Whiley/WhileyCompilerCollection", "path": "src/main/java/wycc/util/OptArg.java", "func_name": "OptArg.parseOptions", "original_string": "public static Map<String,Object> parseOptions(List<String> args, OptArg... options) {\r\n\t\tHashMap<String,Object> result = new HashMap<>();\r\n\t\tHashMap<String,OptArg> optmap = new HashMap<>();\r\n\r\n\t\tfor(OptArg opt : options) {\r\n\t\t\tif(opt.defaultValue != null) {\r\n\t\t\t\tresult.put(opt.option, opt.defaultValue);\r\n\t\t\t}\r\n\t\t\toptmap.put(opt.option, opt);\r\n\t\t\toptmap.put(opt.shortForm, opt);\r\n\t\t}\r\n\r\n\t\tIterator<String> iter = args.iterator();\r\n\t\twhile(iter.hasNext()) {\r\n\t\t\tString arg = iter.next();\r\n\t\t\tif (arg.startsWith(\"-\")) {\r\n\t\t\t\targ = arg.substring(1,arg.length());\r\n\t\t\t\tOptArg opt = optmap.get(arg);\r\n\t\t\t\tif(opt != null) {\r\n\t\t\t\t\t// matched\r\n\t\t\t\t\titer.remove(); // remove option from args list\r\n\t\t\t\t\tKind k = opt.argument;\r\n\t\t\t\t\tif(k != null) {\r\n\t\t\t\t\t\tString param = iter.next();\r\n\t\t\t\t\t\titer.remove();\r\n\t\t\t\t\t\tk.process(opt.option,param,result);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult.put(opt.option,null);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new RuntimeException(\"unknown command-line option: -\" + arg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}", "language": "java", "Allcodes": "public static Map<String,Object> parseOptions(List<String> args, OptArg... options) {\r\n\t\tHashMap<String,Object> result = new HashMap<>();\r\n\t\tHashMap<String,OptArg> optmap = new HashMap<>();\r\n\r\n\t\tfor(OptArg opt : options) {\r\n\t\t\tif(opt.defaultValue != null) {\r\n\t\t\t\tresult.put(opt.option, opt.defaultValue);\r\n\t\t\t}\r\n\t\t\toptmap.put(opt.option, opt);\r\n\t\t\toptmap.put(opt.shortForm, opt);\r\n\t\t}\r\n\r\n\t\tIterator<String> iter = args.iterator();\r\n\t\twhile(iter.hasNext()) {\r\n\t\t\tString arg = iter.next();\r\n\t\t\tif (arg.startsWith(\"-\")) {\r\n\t\t\t\targ = arg.substring(1,arg.length());\r\n\t\t\t\tOptArg opt = optmap.get(arg);\r\n\t\t\t\tif(opt != null) {\r\n\t\t\t\t\t// matched\r\n\t\t\t\t\titer.remove(); // remove option from args list\r\n\t\t\t\t\tKind k = opt.argument;\r\n\t\t\t\t\tif(k != null) {\r\n\t\t\t\t\t\tString param = iter.next();\r\n\t\t\t\t\t\titer.remove();\r\n\t\t\t\t\t\tk.process(opt.option,param,result);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult.put(opt.option,null);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new RuntimeException(\"unknown command-line option: -\" + arg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}", "code_tokens": ["public", "static", "Map", "<", "String", ",", "Object", ">", "parseOptions", "(", "List", "<", "String", ">", "args", ",", "OptArg", "...", "options", ")", "{", "HashMap", "<", "String", ",", "Object", ">", "result", "=", "new", "HashMap", "<>", "(", ")", ";", "HashMap", "<", "String", ",", "OptArg", ">", "optmap", "=", "new", "HashMap", "<>", "(", ")", ";", "for", "(", "OptArg", "opt", ":", "options", ")", "{", "if", "(", "opt", ".", "defaultValue", "!=", "null", ")", "{", "result", ".", "put", "(", "opt", ".", "option", ",", "opt", ".", "defaultValue", ")", ";", "}", "optmap", ".", "put", "(", "opt", ".", "option", ",", "opt", ")", ";", "optmap", ".", "put", "(", "opt", ".", "shortForm", ",", "opt", ")", ";", "}", "Iterator", "<", "String", ">", "iter", "=", "args", ".", "iterator", "(", ")", ";", "while", "(", "iter", ".", "hasNext", "(", ")", ")", "{", "String", "arg", "=", "iter", ".", "next", "(", ")", ";", "if", "(", "arg", ".", "startsWith", "(", "\"-\"", ")", ")", "{", "arg", "=", "arg", ".", "substring", "(", "1", ",", "arg", ".", "length", "(", ")", ")", ";", "OptArg", "opt", "=", "optmap", ".", "get", "(", "arg", ")", ";", "if", "(", "opt", "!=", "null", ")", "{", "// matched\r", "iter", ".", "remove", "(", ")", ";", "// remove option from args list\r", "Kind", "k", "=", "opt", ".", "argument", ";", "if", "(", "k", "!=", "null", ")", "{", "String", "param", "=", "iter", ".", "next", "(", ")", ";", "iter", ".", "remove", "(", ")", ";", "k", ".", "process", "(", "opt", ".", "option", ",", "param", ",", "result", ")", ";", "}", "else", "{", "result", ".", "put", "(", "opt", ".", "option", ",", "null", ")", ";", "}", "}", "else", "{", "throw", "new", "RuntimeException", "(", "\"unknown command-line option: -\"", "+", "arg", ")", ";", "}", "}", "}", "return", "result", ";", "}"], "docstring": "Parse options from the list of arguments, removing those which are\nrecognised. Anything which is not recognised is left as is.\n\n@param args\n--- the list of argument strings. This is modified by removing\nthose which are processed.\n@param options\n--- the list of OptArg defining which options should be\nprocessed\n@throws --- a <code>RuntimeException</code> if an unrecognised option is\nencountered (that is, a token starting with '-')..", "docstring_tokens": ["Parse", "options", "from", "the", "list", "of", "arguments", "removing", "those", "which", "are", "recognised", ".", "Anything", "which", "is", "not", "recognised", "is", "left", "as", "is", "."]}
{"code": "running_offset = -1;", "comments": "no +1 on first entry", "lines": 3, "repo": "plume-lib/bcel-util", "path": "src/main/java/org/plumelib/bcelutil/StackMapUtils.java", "func_name": "StackMapUtils.find_stack_map_equal", "original_string": "protected final StackMapEntry find_stack_map_equal(int offset) {\n\n    running_offset = -1; // no +1 on first entry\n    for (int i = 0; i < stack_map_table.length; i++) {\n      running_offset = stack_map_table[i].getByteCodeOffset() + running_offset + 1;\n\n      if (running_offset > offset) {\n        throw new RuntimeException(\"Invalid StackMap offset 1\");\n      }\n\n      if (running_offset == offset) {\n        return stack_map_table[i];\n      }\n      // try next map entry\n    }\n\n    // no offset matched\n    throw new RuntimeException(\"Invalid StackMap offset 2\");\n  }", "language": "java", "Allcodes": "protected final StackMapEntry find_stack_map_equal(int offset) {\n\n    running_offset = -1; // no +1 on first entry\n    for (int i = 0; i < stack_map_table.length; i++) {\n      running_offset = stack_map_table[i].getByteCodeOffset() + running_offset + 1;\n\n      if (running_offset > offset) {\n        throw new RuntimeException(\"Invalid StackMap offset 1\");\n      }\n\n      if (running_offset == offset) {\n        return stack_map_table[i];\n      }\n      // try next map entry\n    }\n\n    // no offset matched\n    throw new RuntimeException(\"Invalid StackMap offset 2\");\n  }", "code_tokens": ["protected", "final", "StackMapEntry", "find_stack_map_equal", "(", "int", "offset", ")", "{", "running_offset", "=", "-", "1", ";", "// no +1 on first entry", "for", "(", "int", "i", "=", "0", ";", "i", "<", "stack_map_table", ".", "length", ";", "i", "++", ")", "{", "running_offset", "=", "stack_map_table", "[", "i", "]", ".", "getByteCodeOffset", "(", ")", "+", "running_offset", "+", "1", ";", "if", "(", "running_offset", ">", "offset", ")", "{", "throw", "new", "RuntimeException", "(", "\"Invalid StackMap offset 1\"", ")", ";", "}", "if", "(", "running_offset", "==", "offset", ")", "{", "return", "stack_map_table", "[", "i", "]", ";", "}", "// try next map entry", "}", "// no offset matched", "throw", "new", "RuntimeException", "(", "\"Invalid StackMap offset 2\"", ")", ";", "}"], "docstring": "Find the StackMap entry whose offset matches the input argument. Also sets running_offset.\n\n@param offset byte code offset\n@return the corresponding StackMapEntry", "docstring_tokens": ["Find", "the", "StackMap", "entry", "whose", "offset", "matches", "the", "input", "argument", ".", "Also", "sets", "running_offset", "."]}
{"code": "mgen.toString();", "comments": "ensure it can be formatted without exceptions", "lines": 8, "repo": "plume-lib/bcel-util", "path": "src/main/java/org/plumelib/bcelutil/BcelUtil.java", "func_name": "BcelUtil.checkMgen", "original_string": "public static void checkMgen(MethodGen mgen) {\n\n    if (skipChecks) {\n      return;\n    }\n\n    try {\n      mgen.toString(); // ensure it can be formatted without exceptions\n      mgen.getLineNumberTable(mgen.getConstantPool());\n\n      InstructionList ilist = mgen.getInstructionList();\n      if (ilist == null || ilist.getStart() == null) {\n        return;\n      }\n      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n      for (CodeExceptionGen gen : exceptionHandlers) {\n        assert ilist.contains(gen.getStartPC())\n            : \"exception handler \"\n                + gen\n                + \" has been forgotten in \"\n                + mgen.getClassName()\n                + \".\"\n                + mgen.getName();\n      }\n      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n      nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n      Error e =\n          new Error(\n              String.format(\n                  \"failure while checking method %s.%s%n\", mgen.getClassName(), mgen.getName()),\n              t);\n      e.printStackTrace();\n      throw e;\n    }\n  }", "language": "java", "Allcodes": "public static void checkMgen(MethodGen mgen) {\n\n    if (skipChecks) {\n      return;\n    }\n\n    try {\n      mgen.toString(); // ensure it can be formatted without exceptions\n      mgen.getLineNumberTable(mgen.getConstantPool());\n\n      InstructionList ilist = mgen.getInstructionList();\n      if (ilist == null || ilist.getStart() == null) {\n        return;\n      }\n      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n      for (CodeExceptionGen gen : exceptionHandlers) {\n        assert ilist.contains(gen.getStartPC())\n            : \"exception handler \"\n                + gen\n                + \" has been forgotten in \"\n                + mgen.getClassName()\n                + \".\"\n                + mgen.getName();\n      }\n      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n      nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n      Error e =\n          new Error(\n              String.format(\n                  \"failure while checking method %s.%s%n\", mgen.getClassName(), mgen.getName()),\n              t);\n      e.printStackTrace();\n      throw e;\n    }\n  }", "code_tokens": ["public", "static", "void", "checkMgen", "(", "MethodGen", "mgen", ")", "{", "if", "(", "skipChecks", ")", "{", "return", ";", "}", "try", "{", "mgen", ".", "toString", "(", ")", ";", "// ensure it can be formatted without exceptions", "mgen", ".", "getLineNumberTable", "(", "mgen", ".", "getConstantPool", "(", ")", ")", ";", "InstructionList", "ilist", "=", "mgen", ".", "getInstructionList", "(", ")", ";", "if", "(", "ilist", "==", "null", "||", "ilist", ".", "getStart", "(", ")", "==", "null", ")", "{", "return", ";", "}", "CodeExceptionGen", "[", "]", "exceptionHandlers", "=", "mgen", ".", "getExceptionHandlers", "(", ")", ";", "for", "(", "CodeExceptionGen", "gen", ":", "exceptionHandlers", ")", "{", "assert", "ilist", ".", "contains", "(", "gen", ".", "getStartPC", "(", ")", ")", ":", "\"exception handler \"", "+", "gen", "+", "\" has been forgotten in \"", "+", "mgen", ".", "getClassName", "(", ")", "+", "\".\"", "+", "mgen", ".", "getName", "(", ")", ";", "}", "MethodGen", "nmg", "=", "new", "MethodGen", "(", "mgen", ".", "getMethod", "(", ")", ",", "mgen", ".", "getClassName", "(", ")", ",", "mgen", ".", "getConstantPool", "(", ")", ")", ";", "nmg", ".", "getLineNumberTable", "(", "mgen", ".", "getConstantPool", "(", ")", ")", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "Error", "e", "=", "new", "Error", "(", "String", ".", "format", "(", "\"failure while checking method %s.%s%n\"", ",", "mgen", ".", "getClassName", "(", ")", ",", "mgen", ".", "getName", "(", ")", ")", ",", "t", ")", ";", "e", ".", "printStackTrace", "(", ")", ";", "throw", "e", ";", "}", "}"], "docstring": "Checks the specified method for consistency.\n\n<p>Does nothing if {@link #skipChecks} is false.\n\n@param mgen the class to check", "docstring_tokens": ["Checks", "the", "specified", "method", "for", "consistency", "."]}
{"code": "return \"\";", "comments": "Default package", "lines": 6, "repo": "sockeqwe/ParcelablePlease", "path": "processor/src/main/java/com/hannesdorfmann/parcelableplease/processor/util/TypeUtils.java", "func_name": "TypeUtils.getPackageName", "original_string": "public static String getPackageName(Elements elementUtils, TypeElement type) throws IOException {\n    PackageElement pkg = elementUtils.getPackageOf(type);\n    if (!pkg.isUnnamed()) {\n      return pkg.getQualifiedName().toString();\n    } else {\n      return \"\"; // Default package\n    }\n  }", "language": "java", "Allcodes": "public static String getPackageName(Elements elementUtils, TypeElement type) throws IOException {\n    PackageElement pkg = elementUtils.getPackageOf(type);\n    if (!pkg.isUnnamed()) {\n      return pkg.getQualifiedName().toString();\n    } else {\n      return \"\"; // Default package\n    }\n  }", "code_tokens": ["public", "static", "String", "getPackageName", "(", "Elements", "elementUtils", ",", "TypeElement", "type", ")", "throws", "IOException", "{", "PackageElement", "pkg", "=", "elementUtils", ".", "getPackageOf", "(", "type", ")", ";", "if", "(", "!", "pkg", ".", "isUnnamed", "(", ")", ")", "{", "return", "pkg", ".", "getQualifiedName", "(", ")", ".", "toString", "(", ")", ";", "}", "else", "{", "return", "\"\"", ";", "// Default package", "}", "}"], "docstring": "Get the Package name\n\n@throws IOException", "docstring_tokens": ["Get", "the", "Package", "name"]}
{"code": "connector = (JNDIConnector) session.getLogin().getConnector();", "comments": "possible CCE", "lines": 11, "repo": "javydreamercsw/validation-manager", "path": "VM-Core/src/main/java/com/validation/manager/core/server/JPAEclipseLinkSessionCustomizer.java", "func_name": "JPAEclipseLinkSessionCustomizer.customize", "original_string": "@Override\n    public void customize(Session session) throws Exception {\n        JNDIConnector connector;\n        // Initialize session customizer\n        DataSource dataSource;\n        try {\n            Context context = new InitialContext();\n            if (null == context) {\n                throw new VMException(\"Context is null\");\n            }\n            connector = (JNDIConnector) session.getLogin().getConnector(); // possible CCE\n            // Lookup this new dataSource\n            dataSource = (DataSource) context.lookup(JNDI_DATASOURCE_NAME);\n            connector.setDataSource(dataSource);\n            // Change from COMPOSITE_NAME_LOOKUP to STRING_LOOKUP\n            // Note: if both jta and non-jta elements exist this will only change the first one - and may still result in the COMPOSITE_NAME_LOOKUP being set\n            // Make sure only jta-data-source is in persistence.xml with no non-jta-data-source property set\n            connector.setLookupType(JNDIConnector.STRING_LOOKUP);\n\n            // if you are specifying both JTA and non-JTA in your persistence.xml then set both connectors to be safe\n            JNDIConnector writeConnector\n                    = (JNDIConnector) session.getLogin().getConnector();\n            writeConnector.setLookupType(JNDIConnector.STRING_LOOKUP);\n            JNDIConnector readConnector\n                    = (JNDIConnector) ((DatabaseLogin) ((ServerSession) session)\n                            .getReadConnectionPool().getLogin()).getConnector();\n            readConnector.setLookupType(JNDIConnector.STRING_LOOKUP);\n\n            // Set the new connection on the session\n            session.getLogin().setConnector(connector);\n        }\n        catch (Exception e) {\n            LOG.log(Level.SEVERE, JNDI_DATASOURCE_NAME, e);\n        }\n    }", "language": "java", "Allcodes": "@Override\n    public void customize(Session session) throws Exception {\n        JNDIConnector connector;\n        // Initialize session customizer\n        DataSource dataSource;\n        try {\n            Context context = new InitialContext();\n            if (null == context) {\n                throw new VMException(\"Context is null\");\n            }\n            connector = (JNDIConnector) session.getLogin().getConnector(); // possible CCE\n            // Lookup this new dataSource\n            dataSource = (DataSource) context.lookup(JNDI_DATASOURCE_NAME);\n            connector.setDataSource(dataSource);\n            // Change from COMPOSITE_NAME_LOOKUP to STRING_LOOKUP\n            // Note: if both jta and non-jta elements exist this will only change the first one - and may still result in the COMPOSITE_NAME_LOOKUP being set\n            // Make sure only jta-data-source is in persistence.xml with no non-jta-data-source property set\n            connector.setLookupType(JNDIConnector.STRING_LOOKUP);\n\n            // if you are specifying both JTA and non-JTA in your persistence.xml then set both connectors to be safe\n            JNDIConnector writeConnector\n                    = (JNDIConnector) session.getLogin().getConnector();\n            writeConnector.setLookupType(JNDIConnector.STRING_LOOKUP);\n            JNDIConnector readConnector\n                    = (JNDIConnector) ((DatabaseLogin) ((ServerSession) session)\n                            .getReadConnectionPool().getLogin()).getConnector();\n            readConnector.setLookupType(JNDIConnector.STRING_LOOKUP);\n\n            // Set the new connection on the session\n            session.getLogin().setConnector(connector);\n        }\n        catch (Exception e) {\n            LOG.log(Level.SEVERE, JNDI_DATASOURCE_NAME, e);\n        }\n    }", "code_tokens": ["@", "Override", "public", "void", "customize", "(", "Session", "session", ")", "throws", "Exception", "{", "JNDIConnector", "connector", ";", "// Initialize session customizer", "DataSource", "dataSource", ";", "try", "{", "Context", "context", "=", "new", "InitialContext", "(", ")", ";", "if", "(", "null", "==", "context", ")", "{", "throw", "new", "VMException", "(", "\"Context is null\"", ")", ";", "}", "connector", "=", "(", "JNDIConnector", ")", "session", ".", "getLogin", "(", ")", ".", "getConnector", "(", ")", ";", "// possible CCE", "// Lookup this new dataSource", "dataSource", "=", "(", "DataSource", ")", "context", ".", "lookup", "(", "JNDI_DATASOURCE_NAME", ")", ";", "connector", ".", "setDataSource", "(", "dataSource", ")", ";", "// Change from COMPOSITE_NAME_LOOKUP to STRING_LOOKUP", "// Note: if both jta and non-jta elements exist this will only change the first one - and may still result in the COMPOSITE_NAME_LOOKUP being set", "// Make sure only jta-data-source is in persistence.xml with no non-jta-data-source property set", "connector", ".", "setLookupType", "(", "JNDIConnector", ".", "STRING_LOOKUP", ")", ";", "// if you are specifying both JTA and non-JTA in your persistence.xml then set both connectors to be safe", "JNDIConnector", "writeConnector", "=", "(", "JNDIConnector", ")", "session", ".", "getLogin", "(", ")", ".", "getConnector", "(", ")", ";", "writeConnector", ".", "setLookupType", "(", "JNDIConnector", ".", "STRING_LOOKUP", ")", ";", "JNDIConnector", "readConnector", "=", "(", "JNDIConnector", ")", "(", "(", "DatabaseLogin", ")", "(", "(", "ServerSession", ")", "session", ")", ".", "getReadConnectionPool", "(", ")", ".", "getLogin", "(", ")", ")", ".", "getConnector", "(", ")", ";", "readConnector", ".", "setLookupType", "(", "JNDIConnector", ".", "STRING_LOOKUP", ")", ";", "// Set the new connection on the session", "session", ".", "getLogin", "(", ")", ".", "setConnector", "(", "connector", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "JNDI_DATASOURCE_NAME", ",", "e", ")", ";", "}", "}"], "docstring": "Get a dataSource connection and set it on the session with\nlookupType=STRING_LOOKUP\n\n@param session Session\n@throws java.lang.Exception If an error occurs.", "docstring_tokens": ["Get", "a", "dataSource", "connection", "and", "set", "it", "on", "the", "session", "with", "lookupType", "=", "STRING_LOOKUP"]}
{"code": "FileOutputStream fos;", "comments": "Output stream to write to", "lines": 4, "repo": "javydreamercsw/validation-manager", "path": "Validation-Manager-Web/src/main/java/net/sourceforge/javydreamercsw/validation/manager/web/importer/FileUploader.java", "func_name": "FileUploader.receiveUpload", "original_string": "@Override\n    public OutputStream receiveUpload(String filename,\n            String MIMEType) {\n        FileOutputStream fos; // Output stream to write to\n        try {\n            file = File.createTempFile(\"upload\",\n                    filename.substring(filename.lastIndexOf('.')));\n            // Open the file for writing.\n            fos = new FileOutputStream(getFile());\n        } catch (FileNotFoundException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        } catch (IOException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        }\n        return fos; // Return the output stream to write to\n    }", "language": "java", "Allcodes": "@Override\n    public OutputStream receiveUpload(String filename,\n            String MIMEType) {\n        FileOutputStream fos; // Output stream to write to\n        try {\n            file = File.createTempFile(\"upload\",\n                    filename.substring(filename.lastIndexOf('.')));\n            // Open the file for writing.\n            fos = new FileOutputStream(getFile());\n        } catch (FileNotFoundException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        } catch (IOException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        }\n        return fos; // Return the output stream to write to\n    }", "code_tokens": ["@", "Override", "public", "OutputStream", "receiveUpload", "(", "String", "filename", ",", "String", "MIMEType", ")", "{", "FileOutputStream", "fos", ";", "// Output stream to write to", "try", "{", "file", "=", "File", ".", "createTempFile", "(", "\"upload\"", ",", "filename", ".", "substring", "(", "filename", ".", "lastIndexOf", "(", "'", "'", ")", ")", ")", ";", "// Open the file for writing.", "fos", "=", "new", "FileOutputStream", "(", "getFile", "(", ")", ")", ";", "}", "catch", "(", "FileNotFoundException", "ex", ")", "{", "// Error while opening the file. Not reported here.", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "null", ",", "ex", ")", ";", "return", "null", ";", "}", "catch", "(", "IOException", "ex", ")", "{", "// Error while opening the file. Not reported here.", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "null", ",", "ex", ")", ";", "return", "null", ";", "}", "return", "fos", ";", "// Return the output stream to write to", "}"], "docstring": "Callback method to begin receiving the upload.", "docstring_tokens": ["Callback", "method", "to", "begin", "receiving", "the", "upload", "."]}
{"code": "return fos;", "comments": "Return the output stream to write to", "lines": 19, "repo": "javydreamercsw/validation-manager", "path": "Validation-Manager-Web/src/main/java/net/sourceforge/javydreamercsw/validation/manager/web/importer/FileUploader.java", "func_name": "FileUploader.receiveUpload", "original_string": "@Override\n    public OutputStream receiveUpload(String filename,\n            String MIMEType) {\n        FileOutputStream fos; // Output stream to write to\n        try {\n            file = File.createTempFile(\"upload\",\n                    filename.substring(filename.lastIndexOf('.')));\n            // Open the file for writing.\n            fos = new FileOutputStream(getFile());\n        } catch (FileNotFoundException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        } catch (IOException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        }\n        return fos; // Return the output stream to write to\n    }", "language": "java", "Allcodes": "@Override\n    public OutputStream receiveUpload(String filename,\n            String MIMEType) {\n        FileOutputStream fos; // Output stream to write to\n        try {\n            file = File.createTempFile(\"upload\",\n                    filename.substring(filename.lastIndexOf('.')));\n            // Open the file for writing.\n            fos = new FileOutputStream(getFile());\n        } catch (FileNotFoundException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        } catch (IOException ex) {\n            // Error while opening the file. Not reported here.\n            LOG.log(Level.SEVERE, null, ex);\n            return null;\n        }\n        return fos; // Return the output stream to write to\n    }", "code_tokens": ["@", "Override", "public", "OutputStream", "receiveUpload", "(", "String", "filename", ",", "String", "MIMEType", ")", "{", "FileOutputStream", "fos", ";", "// Output stream to write to", "try", "{", "file", "=", "File", ".", "createTempFile", "(", "\"upload\"", ",", "filename", ".", "substring", "(", "filename", ".", "lastIndexOf", "(", "'", "'", ")", ")", ")", ";", "// Open the file for writing.", "fos", "=", "new", "FileOutputStream", "(", "getFile", "(", ")", ")", ";", "}", "catch", "(", "FileNotFoundException", "ex", ")", "{", "// Error while opening the file. Not reported here.", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "null", ",", "ex", ")", ";", "return", "null", ";", "}", "catch", "(", "IOException", "ex", ")", "{", "// Error while opening the file. Not reported here.", "LOG", ".", "log", "(", "Level", ".", "SEVERE", ",", "null", ",", "ex", ")", ";", "return", "null", ";", "}", "return", "fos", ";", "// Return the output stream to write to", "}"], "docstring": "Callback method to begin receiving the upload.", "docstring_tokens": ["Callback", "method", "to", "begin", "receiving", "the", "upload", "."]}
{"code": "add = false;", "comments": "already in the list", "lines": 14, "repo": "deib-polimi/SPF2", "path": "sPFWFDMid/src/main/java/it/polimi/spf/wfd/ServiceList.java", "func_name": "ServiceList.addServiceIfNotPresent", "original_string": "public void addServiceIfNotPresent(WiFiP2pService service) {\n        WfdLog.d(TAG, \"addServiceIfNotPresent BEGIN, with size = \" + serviceList.size());\n\n        if (service == null) {\n            WfdLog.e(TAG, \"Service is null, returning...\");\n            return;\n        }\n\n        boolean add = true;\n        for (WiFiP2pService element : serviceList) {\n            if (element != null\n                    && element.getDevice().equals(service.getDevice())\n                    && element.getInstanceName().equals(service.getInstanceName())) {\n                add = false; //already in the list\n            }\n        }\n\n        if (add) {\n            serviceList.add(service);\n        }\n\n        WfdLog.d(TAG, \"addServiceIfNotPresent END, with size = \" + serviceList.size());\n    }", "language": "java", "Allcodes": "public void addServiceIfNotPresent(WiFiP2pService service) {\n        WfdLog.d(TAG, \"addServiceIfNotPresent BEGIN, with size = \" + serviceList.size());\n\n        if (service == null) {\n            WfdLog.e(TAG, \"Service is null, returning...\");\n            return;\n        }\n\n        boolean add = true;\n        for (WiFiP2pService element : serviceList) {\n            if (element != null\n                    && element.getDevice().equals(service.getDevice())\n                    && element.getInstanceName().equals(service.getInstanceName())) {\n                add = false; //already in the list\n            }\n        }\n\n        if (add) {\n            serviceList.add(service);\n        }\n\n        WfdLog.d(TAG, \"addServiceIfNotPresent END, with size = \" + serviceList.size());\n    }", "code_tokens": ["public", "void", "addServiceIfNotPresent", "(", "WiFiP2pService", "service", ")", "{", "WfdLog", ".", "d", "(", "TAG", ",", "\"addServiceIfNotPresent BEGIN, with size = \"", "+", "serviceList", ".", "size", "(", ")", ")", ";", "if", "(", "service", "==", "null", ")", "{", "WfdLog", ".", "e", "(", "TAG", ",", "\"Service is null, returning...\"", ")", ";", "return", ";", "}", "boolean", "add", "=", "true", ";", "for", "(", "WiFiP2pService", "element", ":", "serviceList", ")", "{", "if", "(", "element", "!=", "null", "&&", "element", ".", "getDevice", "(", ")", ".", "equals", "(", "service", ".", "getDevice", "(", ")", ")", "&&", "element", ".", "getInstanceName", "(", ")", ".", "equals", "(", "service", ".", "getInstanceName", "(", ")", ")", ")", "{", "add", "=", "false", ";", "//already in the list", "}", "}", "if", "(", "add", ")", "{", "serviceList", ".", "add", "(", "service", ")", ";", "}", "WfdLog", ".", "d", "(", "TAG", ",", "\"addServiceIfNotPresent END, with size = \"", "+", "serviceList", ".", "size", "(", ")", ")", ";", "}"], "docstring": "Method to add a service inside the list in a secure way.\nThe service is added only if isn't already inside the list.\n\n@param service {@link WiFiP2pService} to add.", "docstring_tokens": ["Method", "to", "add", "a", "service", "inside", "the", "list", "in", "a", "secure", "way", ".", "The", "service", "is", "added", "only", "if", "isn", "t", "already", "inside", "the", "list", "."]}
{"code": "SPF.get().notifyProximityStatus(false);", "comments": "false because it's starting", "lines": 13, "repo": "deib-polimi/SPF2", "path": "sPFFramework/src/main/java/it/polimi/spf/framework/local/SPFService.java", "func_name": "SPFService.onStartCommand", "original_string": "@Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (intent == null) {\n            return START_STICKY;\n        }\n\n        String action = intent.getAction();\n\n        if (ACTION_START_FOREGROUND.equals(action)) {\n            if (!SPF.get().isConnected()) {\n                SPF.get().connect();\n            }\n            SPF.get().notifyProximityStatus(false); //false because it's starting\n\n            startInForeground();\n            Log.d(TAG, \"Started in foreground\");\n        } else if (ACTION_STOP_FOREGROUND.equals(action)) {\n\n            //notify to the middleware that i killed the proximity service\n            SPF.get().notifyProximityStatus(true); //true because it's killing\n\n            stopForeground(true);\n            mIsStartedForeground = false;\n            Log.d(TAG, \"Foreground stopped\");\n        }\n\n        return START_STICKY;\n    }", "language": "java", "Allcodes": "@Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (intent == null) {\n            return START_STICKY;\n        }\n\n        String action = intent.getAction();\n\n        if (ACTION_START_FOREGROUND.equals(action)) {\n            if (!SPF.get().isConnected()) {\n                SPF.get().connect();\n            }\n            SPF.get().notifyProximityStatus(false); //false because it's starting\n\n            startInForeground();\n            Log.d(TAG, \"Started in foreground\");\n        } else if (ACTION_STOP_FOREGROUND.equals(action)) {\n\n            //notify to the middleware that i killed the proximity service\n            SPF.get().notifyProximityStatus(true); //true because it's killing\n\n            stopForeground(true);\n            mIsStartedForeground = false;\n            Log.d(TAG, \"Foreground stopped\");\n        }\n\n        return START_STICKY;\n    }", "code_tokens": ["@", "Override", "public", "int", "onStartCommand", "(", "Intent", "intent", ",", "int", "flags", ",", "int", "startId", ")", "{", "if", "(", "intent", "==", "null", ")", "{", "return", "START_STICKY", ";", "}", "String", "action", "=", "intent", ".", "getAction", "(", ")", ";", "if", "(", "ACTION_START_FOREGROUND", ".", "equals", "(", "action", ")", ")", "{", "if", "(", "!", "SPF", ".", "get", "(", ")", ".", "isConnected", "(", ")", ")", "{", "SPF", ".", "get", "(", ")", ".", "connect", "(", ")", ";", "}", "SPF", ".", "get", "(", ")", ".", "notifyProximityStatus", "(", "false", ")", ";", "//false because it's starting", "startInForeground", "(", ")", ";", "Log", ".", "d", "(", "TAG", ",", "\"Started in foreground\"", ")", ";", "}", "else", "if", "(", "ACTION_STOP_FOREGROUND", ".", "equals", "(", "action", ")", ")", "{", "//notify to the middleware that i killed the proximity service", "SPF", ".", "get", "(", ")", ".", "notifyProximityStatus", "(", "true", ")", ";", "//true because it's killing", "stopForeground", "(", "true", ")", ";", "mIsStartedForeground", "=", "false", ";", "Log", ".", "d", "(", "TAG", ",", "\"Foreground stopped\"", ")", ";", "}", "return", "START_STICKY", ";", "}"], "docstring": "Triggered by the front end to keep spf service active in foreground", "docstring_tokens": ["Triggered", "by", "the", "front", "end", "to", "keep", "spf", "service", "active", "in", "foreground"]}
{"code": "SPF.get().notifyProximityStatus(true);", "comments": "true because it's killing", "lines": 20, "repo": "deib-polimi/SPF2", "path": "sPFFramework/src/main/java/it/polimi/spf/framework/local/SPFService.java", "func_name": "SPFService.onStartCommand", "original_string": "@Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (intent == null) {\n            return START_STICKY;\n        }\n\n        String action = intent.getAction();\n\n        if (ACTION_START_FOREGROUND.equals(action)) {\n            if (!SPF.get().isConnected()) {\n                SPF.get().connect();\n            }\n            SPF.get().notifyProximityStatus(false); //false because it's starting\n\n            startInForeground();\n            Log.d(TAG, \"Started in foreground\");\n        } else if (ACTION_STOP_FOREGROUND.equals(action)) {\n\n            //notify to the middleware that i killed the proximity service\n            SPF.get().notifyProximityStatus(true); //true because it's killing\n\n            stopForeground(true);\n            mIsStartedForeground = false;\n            Log.d(TAG, \"Foreground stopped\");\n        }\n\n        return START_STICKY;\n    }", "language": "java", "Allcodes": "@Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        if (intent == null) {\n            return START_STICKY;\n        }\n\n        String action = intent.getAction();\n\n        if (ACTION_START_FOREGROUND.equals(action)) {\n            if (!SPF.get().isConnected()) {\n                SPF.get().connect();\n            }\n            SPF.get().notifyProximityStatus(false); //false because it's starting\n\n            startInForeground();\n            Log.d(TAG, \"Started in foreground\");\n        } else if (ACTION_STOP_FOREGROUND.equals(action)) {\n\n            //notify to the middleware that i killed the proximity service\n            SPF.get().notifyProximityStatus(true); //true because it's killing\n\n            stopForeground(true);\n            mIsStartedForeground = false;\n            Log.d(TAG, \"Foreground stopped\");\n        }\n\n        return START_STICKY;\n    }", "code_tokens": ["@", "Override", "public", "int", "onStartCommand", "(", "Intent", "intent", ",", "int", "flags", ",", "int", "startId", ")", "{", "if", "(", "intent", "==", "null", ")", "{", "return", "START_STICKY", ";", "}", "String", "action", "=", "intent", ".", "getAction", "(", ")", ";", "if", "(", "ACTION_START_FOREGROUND", ".", "equals", "(", "action", ")", ")", "{", "if", "(", "!", "SPF", ".", "get", "(", ")", ".", "isConnected", "(", ")", ")", "{", "SPF", ".", "get", "(", ")", ".", "connect", "(", ")", ";", "}", "SPF", ".", "get", "(", ")", ".", "notifyProximityStatus", "(", "false", ")", ";", "//false because it's starting", "startInForeground", "(", ")", ";", "Log", ".", "d", "(", "TAG", ",", "\"Started in foreground\"", ")", ";", "}", "else", "if", "(", "ACTION_STOP_FOREGROUND", ".", "equals", "(", "action", ")", ")", "{", "//notify to the middleware that i killed the proximity service", "SPF", ".", "get", "(", ")", ".", "notifyProximityStatus", "(", "true", ")", ";", "//true because it's killing", "stopForeground", "(", "true", ")", ";", "mIsStartedForeground", "=", "false", ";", "Log", ".", "d", "(", "TAG", ",", "\"Foreground stopped\"", ")", ";", "}", "return", "START_STICKY", ";", "}"], "docstring": "Triggered by the front end to keep spf service active in foreground", "docstring_tokens": ["Triggered", "by", "the", "front", "end", "to", "keep", "spf", "service", "active", "in", "foreground"]}
{"code": "true));", "comments": "important: sets true to get detailed message when this method fails", "lines": 25, "repo": "deib-polimi/SPF2", "path": "sPFWFDMid/src/main/java/it/polimi/spf/wfd/WifiDirectMiddleware.java", "func_name": "WifiDirectMiddleware.startRegistration", "original_string": "private void startRegistration() {\n        //  Create a string map containing information about your service.\n        Map<String, String> mRecordMap = new HashMap<>();\n        mRecordMap.put(Configuration.PORT, Integer.toString(mPort));\n        mRecordMap.put(Configuration.IDENTIFIER, myIdentifier);\n\n        // Service information.  Pass it an instance name, service type\n        // Configuration.SERVICE_REG_TYPE , and the map containing\n        // information other devices will want once they connect to this one.\n        WifiP2pDnsSdServiceInfo mInfo = WifiP2pDnsSdServiceInfo.newInstance(\n                Configuration.SERVICE_INSTANCE + myIdentifier,\n                Configuration.SERVICE_REG_TYPE, mRecordMap);\n\n        // Add the local service, sending the service info, network channel,\n        // and listener that will be used to indicate success or failure of\n        // the request.\n        mManager.addLocalService(mChannel, mInfo,\n                new CustomizableActionListener(\n                        this.mContext,\n                        TAG,\n                        \"Added Local Service\",\n                        null,\n                        \"Failed to add a service\",\n                        \"Failed to add a service\",\n                        true)); //important: sets true to get detailed message when this method fails\n\n    }", "language": "java", "Allcodes": "private void startRegistration() {\n        //  Create a string map containing information about your service.\n        Map<String, String> mRecordMap = new HashMap<>();\n        mRecordMap.put(Configuration.PORT, Integer.toString(mPort));\n        mRecordMap.put(Configuration.IDENTIFIER, myIdentifier);\n\n        // Service information.  Pass it an instance name, service type\n        // Configuration.SERVICE_REG_TYPE , and the map containing\n        // information other devices will want once they connect to this one.\n        WifiP2pDnsSdServiceInfo mInfo = WifiP2pDnsSdServiceInfo.newInstance(\n                Configuration.SERVICE_INSTANCE + myIdentifier,\n                Configuration.SERVICE_REG_TYPE, mRecordMap);\n\n        // Add the local service, sending the service info, network channel,\n        // and listener that will be used to indicate success or failure of\n        // the request.\n        mManager.addLocalService(mChannel, mInfo,\n                new CustomizableActionListener(\n                        this.mContext,\n                        TAG,\n                        \"Added Local Service\",\n                        null,\n                        \"Failed to add a service\",\n                        \"Failed to add a service\",\n                        true)); //important: sets true to get detailed message when this method fails\n\n    }", "code_tokens": ["private", "void", "startRegistration", "(", ")", "{", "//  Create a string map containing information about your service.", "Map", "<", "String", ",", "String", ">", "mRecordMap", "=", "new", "HashMap", "<>", "(", ")", ";", "mRecordMap", ".", "put", "(", "Configuration", ".", "PORT", ",", "Integer", ".", "toString", "(", "mPort", ")", ")", ";", "mRecordMap", ".", "put", "(", "Configuration", ".", "IDENTIFIER", ",", "myIdentifier", ")", ";", "// Service information.  Pass it an instance name, service type", "// Configuration.SERVICE_REG_TYPE , and the map containing", "// information other devices will want once they connect to this one.", "WifiP2pDnsSdServiceInfo", "mInfo", "=", "WifiP2pDnsSdServiceInfo", ".", "newInstance", "(", "Configuration", ".", "SERVICE_INSTANCE", "+", "myIdentifier", ",", "Configuration", ".", "SERVICE_REG_TYPE", ",", "mRecordMap", ")", ";", "// Add the local service, sending the service info, network channel,", "// and listener that will be used to indicate success or failure of", "// the request.", "mManager", ".", "addLocalService", "(", "mChannel", ",", "mInfo", ",", "new", "CustomizableActionListener", "(", "this", ".", "mContext", ",", "TAG", ",", "\"Added Local Service\"", ",", "null", ",", "\"Failed to add a service\"", ",", "\"Failed to add a service\"", ",", "true", ")", ")", ";", "//important: sets true to get detailed message when this method fails", "}"], "docstring": "Registers a local service.", "docstring_tokens": ["Registers", "a", "local", "service", "."]}
{"code": "return null;", "comments": "TODO handle insertion error", "lines": 13, "repo": "deib-polimi/SPF2", "path": "sPFFramework/src/main/java/it/polimi/spf/framework/security/ApplicationRegistry.java", "func_name": "ApplicationRegistry.registerApplication", "original_string": "public String registerApplication(AppDescriptor descriptor, SPFPersona persona) {\n\t\tString token = mTokenGenerator.generateAccessToken();\n\n\t\tContentValues cv = new ContentValues();\n\t\tcv.put(Contract.COLUMN_APP_NAME, descriptor.getAppName());\n\t\tcv.put(Contract.COLUMN_ACCESS_TOKEN, token);\n\t\tcv.put(Contract.COLUMN_APP_IDENTIFIER, descriptor.getAppIdentifier());\n\t\tcv.put(Contract.COLUMN_PERMISSION_CODE, descriptor.getPermissionCode());\n\t\tcv.put(Contract.COLUMN_PERSONA, persona.getIdentifier());\n\n\t\tSQLiteDatabase db = mRegistryTable.getWritableDatabase();\n\t\tif (db.insert(Contract.TABLE_NAME, null, cv) == -1) {\n\t\t\treturn null; // TODO handle insertion error\n\t\t}\n\n\t\treturn token;\n\t}", "language": "java", "Allcodes": "public String registerApplication(AppDescriptor descriptor, SPFPersona persona) {\n\t\tString token = mTokenGenerator.generateAccessToken();\n\n\t\tContentValues cv = new ContentValues();\n\t\tcv.put(Contract.COLUMN_APP_NAME, descriptor.getAppName());\n\t\tcv.put(Contract.COLUMN_ACCESS_TOKEN, token);\n\t\tcv.put(Contract.COLUMN_APP_IDENTIFIER, descriptor.getAppIdentifier());\n\t\tcv.put(Contract.COLUMN_PERMISSION_CODE, descriptor.getPermissionCode());\n\t\tcv.put(Contract.COLUMN_PERSONA, persona.getIdentifier());\n\n\t\tSQLiteDatabase db = mRegistryTable.getWritableDatabase();\n\t\tif (db.insert(Contract.TABLE_NAME, null, cv) == -1) {\n\t\t\treturn null; // TODO handle insertion error\n\t\t}\n\n\t\treturn token;\n\t}", "code_tokens": ["public", "String", "registerApplication", "(", "AppDescriptor", "descriptor", ",", "SPFPersona", "persona", ")", "{", "String", "token", "=", "mTokenGenerator", ".", "generateAccessToken", "(", ")", ";", "ContentValues", "cv", "=", "new", "ContentValues", "(", ")", ";", "cv", ".", "put", "(", "Contract", ".", "COLUMN_APP_NAME", ",", "descriptor", ".", "getAppName", "(", ")", ")", ";", "cv", ".", "put", "(", "Contract", ".", "COLUMN_ACCESS_TOKEN", ",", "token", ")", ";", "cv", ".", "put", "(", "Contract", ".", "COLUMN_APP_IDENTIFIER", ",", "descriptor", ".", "getAppIdentifier", "(", ")", ")", ";", "cv", ".", "put", "(", "Contract", ".", "COLUMN_PERMISSION_CODE", ",", "descriptor", ".", "getPermissionCode", "(", ")", ")", ";", "cv", ".", "put", "(", "Contract", ".", "COLUMN_PERSONA", ",", "persona", ".", "getIdentifier", "(", ")", ")", ";", "SQLiteDatabase", "db", "=", "mRegistryTable", ".", "getWritableDatabase", "(", ")", ";", "if", "(", "db", ".", "insert", "(", "Contract", ".", "TABLE_NAME", ",", "null", ",", "cv", ")", "==", "-", "1", ")", "{", "return", "null", ";", "// TODO handle insertion error", "}", "return", "token", ";", "}"], "docstring": "Low level method to register applications. It will not validate the\ndescriptor given as parameter.\n\n@param descriptor\n@param persona\n@return - the token to give back.", "docstring_tokens": ["Low", "level", "method", "to", "register", "applications", ".", "It", "will", "not", "validate", "the", "descriptor", "given", "as", "parameter", "."]}
{"code": "Entity newEntity = new Entity();", "comments": "This would be your new entity", "lines": 18, "repo": "socialize/socialize-sdk-android", "path": "demo/src/com/socialize/demo/snippets/ActionBarReload.java", "func_name": "ActionBarReload.reload", "original_string": "void reload() {\n//begin-snippet-1\n\n// The in the Activity which renders the ActionBar\nEntity entity = Entity.newInstance(\"http://getsocialize.com\", \"Socialize\");\n\n// Setup a listener to retain a reference\nMyActionBarListener listener = new MyActionBarListener();\n\n// Use the listener when you show the action bar\n// The \"this\" argument refers to the current Activity\nActionBarUtils.showActionBar(this, R.layout.actionbar, entity, null, listener);\n\n// Later (After the action bar has loaded!), you can reference the view to refresh\nActionBarView view = listener.getActionBarView();\n\nif (view != null) {\n\tEntity newEntity = new Entity(); // This would be your new entity\n\tview.setEntity(newEntity);\n\tview.refresh();\n}\t\n\t\t\n//end-snippet-1\n\t}", "language": "java", "Allcodes": "void reload() {\n//begin-snippet-1\n\n// The in the Activity which renders the ActionBar\nEntity entity = Entity.newInstance(\"http://getsocialize.com\", \"Socialize\");\n\n// Setup a listener to retain a reference\nMyActionBarListener listener = new MyActionBarListener();\n\n// Use the listener when you show the action bar\n// The \"this\" argument refers to the current Activity\nActionBarUtils.showActionBar(this, R.layout.actionbar, entity, null, listener);\n\n// Later (After the action bar has loaded!), you can reference the view to refresh\nActionBarView view = listener.getActionBarView();\n\nif (view != null) {\n\tEntity newEntity = new Entity(); // This would be your new entity\n\tview.setEntity(newEntity);\n\tview.refresh();\n}\t\n\t\t\n//end-snippet-1\n\t}", "code_tokens": ["void", "reload", "(", ")", "{", "//begin-snippet-1", "// The in the Activity which renders the ActionBar", "Entity", "entity", "=", "Entity", ".", "newInstance", "(", "\"http://getsocialize.com\"", ",", "\"Socialize\"", ")", ";", "// Setup a listener to retain a reference", "MyActionBarListener", "listener", "=", "new", "MyActionBarListener", "(", ")", ";", "// Use the listener when you show the action bar", "// The \"this\" argument refers to the current Activity", "ActionBarUtils", ".", "showActionBar", "(", "this", ",", "R", ".", "layout", ".", "actionbar", ",", "entity", ",", "null", ",", "listener", ")", ";", "// Later (After the action bar has loaded!), you can reference the view to refresh", "ActionBarView", "view", "=", "listener", ".", "getActionBarView", "(", ")", ";", "if", "(", "view", "!=", "null", ")", "{", "Entity", "newEntity", "=", "new", "Entity", "(", ")", ";", "// This would be your new entity", "view", ".", "setEntity", "(", "newEntity", ")", ";", "view", ".", "refresh", "(", ")", ";", "}", "//end-snippet-1", "}"], "docstring": "end-snippet-0", "docstring_tokens": ["end", "-", "snippet", "-", "0"]}
{"code": "int lenDiv3 = (len + 2) / 3;", "comments": "ceil(len / 3)", "lines": 3, "repo": "socialize/socialize-sdk-android", "path": "sdk/src/com/socialize/util/Base64Utils.java", "func_name": "Base64Utils.encode", "original_string": "public byte[] encode(byte[] source, int off, int len, byte[] alphabet,\n      int maxLineLength) {\n    int lenDiv3 = (len + 2) / 3; // ceil(len / 3)\n    int len43 = lenDiv3 * 4;\n    byte[] outBuff = new byte[len43 // Main 4:3\n        + (len43 / maxLineLength)]; // New lines\n\n    int d = 0;\n    int e = 0;\n    int len2 = len - 2;\n    int lineLength = 0;\n    for (; d < len2; d += 3, e += 4) {\n\n      // The following block of code is the same as\n      // encode3to4( source, d + off, 3, outBuff, e, alphabet );\n      // but inlined for faster encoding (~20% improvement)\n      int inBuff =\n          ((source[d + off] << 24) >>> 8)\n              | ((source[d + 1 + off] << 24) >>> 16)\n              | ((source[d + 2 + off] << 24) >>> 24);\n      outBuff[e] = alphabet[(inBuff >>> 18)];\n      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];\n      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];\n      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n        lineLength = 0;\n      } // end if: end of line\n    } // end for: each piece of array\n\n    if (d < len) {\n      encode3to4(source, d + off, len - d, outBuff, e, alphabet);\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        // Add a last newline\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n      }\n      e += 4;\n    }\n\n    assert (e == outBuff.length);\n    return outBuff;\n  }", "language": "java", "Allcodes": "public byte[] encode(byte[] source, int off, int len, byte[] alphabet,\n      int maxLineLength) {\n    int lenDiv3 = (len + 2) / 3; // ceil(len / 3)\n    int len43 = lenDiv3 * 4;\n    byte[] outBuff = new byte[len43 // Main 4:3\n        + (len43 / maxLineLength)]; // New lines\n\n    int d = 0;\n    int e = 0;\n    int len2 = len - 2;\n    int lineLength = 0;\n    for (; d < len2; d += 3, e += 4) {\n\n      // The following block of code is the same as\n      // encode3to4( source, d + off, 3, outBuff, e, alphabet );\n      // but inlined for faster encoding (~20% improvement)\n      int inBuff =\n          ((source[d + off] << 24) >>> 8)\n              | ((source[d + 1 + off] << 24) >>> 16)\n              | ((source[d + 2 + off] << 24) >>> 24);\n      outBuff[e] = alphabet[(inBuff >>> 18)];\n      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];\n      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];\n      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n        lineLength = 0;\n      } // end if: end of line\n    } // end for: each piece of array\n\n    if (d < len) {\n      encode3to4(source, d + off, len - d, outBuff, e, alphabet);\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        // Add a last newline\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n      }\n      e += 4;\n    }\n\n    assert (e == outBuff.length);\n    return outBuff;\n  }", "code_tokens": ["public", "byte", "[", "]", "encode", "(", "byte", "[", "]", "source", ",", "int", "off", ",", "int", "len", ",", "byte", "[", "]", "alphabet", ",", "int", "maxLineLength", ")", "{", "int", "lenDiv3", "=", "(", "len", "+", "2", ")", "/", "3", ";", "// ceil(len / 3)", "int", "len43", "=", "lenDiv3", "*", "4", ";", "byte", "[", "]", "outBuff", "=", "new", "byte", "[", "len43", "// Main 4:3", "+", "(", "len43", "/", "maxLineLength", ")", "]", ";", "// New lines", "int", "d", "=", "0", ";", "int", "e", "=", "0", ";", "int", "len2", "=", "len", "-", "2", ";", "int", "lineLength", "=", "0", ";", "for", "(", ";", "d", "<", "len2", ";", "d", "+=", "3", ",", "e", "+=", "4", ")", "{", "// The following block of code is the same as", "// encode3to4( source, d + off, 3, outBuff, e, alphabet );", "// but inlined for faster encoding (~20% improvement)", "int", "inBuff", "=", "(", "(", "source", "[", "d", "+", "off", "]", "<<", "24", ")", ">>>", "8", ")", "|", "(", "(", "source", "[", "d", "+", "1", "+", "off", "]", "<<", "24", ")", ">>>", "16", ")", "|", "(", "(", "source", "[", "d", "+", "2", "+", "off", "]", "<<", "24", ")", ">>>", "24", ")", ";", "outBuff", "[", "e", "]", "=", "alphabet", "[", "(", "inBuff", ">>>", "18", ")", "]", ";", "outBuff", "[", "e", "+", "1", "]", "=", "alphabet", "[", "(", "inBuff", ">>>", "12", ")", "&", "0x3f", "]", ";", "outBuff", "[", "e", "+", "2", "]", "=", "alphabet", "[", "(", "inBuff", ">>>", "6", ")", "&", "0x3f", "]", ";", "outBuff", "[", "e", "+", "3", "]", "=", "alphabet", "[", "(", "inBuff", ")", "&", "0x3f", "]", ";", "lineLength", "+=", "4", ";", "if", "(", "lineLength", "==", "maxLineLength", ")", "{", "outBuff", "[", "e", "+", "4", "]", "=", "NEW_LINE", ";", "e", "++", ";", "lineLength", "=", "0", ";", "}", "// end if: end of line", "}", "// end for: each piece of array", "if", "(", "d", "<", "len", ")", "{", "encode3to4", "(", "source", ",", "d", "+", "off", ",", "len", "-", "d", ",", "outBuff", ",", "e", ",", "alphabet", ")", ";", "lineLength", "+=", "4", ";", "if", "(", "lineLength", "==", "maxLineLength", ")", "{", "// Add a last newline", "outBuff", "[", "e", "+", "4", "]", "=", "NEW_LINE", ";", "e", "++", ";", "}", "e", "+=", "4", ";", "}", "assert", "(", "e", "==", "outBuff", ".", "length", ")", ";", "return", "outBuff", ";", "}"], "docstring": "Encodes a byte array into Base64 notation.\n\n@param source The data to convert\n@param off Offset in array where conversion should begin\n@param len Length of data to convert\n@param alphabet is the encoding alphabet\n@param maxLineLength maximum length of one line.\n@return the BASE64-encoded byte array", "docstring_tokens": ["Encodes", "a", "byte", "array", "into", "Base64", "notation", "."]}
{"code": "+ (len43 / maxLineLength)];", "comments": "New lines", "lines": 6, "repo": "socialize/socialize-sdk-android", "path": "sdk/src/com/socialize/util/Base64Utils.java", "func_name": "Base64Utils.encode", "original_string": "public byte[] encode(byte[] source, int off, int len, byte[] alphabet,\n      int maxLineLength) {\n    int lenDiv3 = (len + 2) / 3; // ceil(len / 3)\n    int len43 = lenDiv3 * 4;\n    byte[] outBuff = new byte[len43 // Main 4:3\n        + (len43 / maxLineLength)]; // New lines\n\n    int d = 0;\n    int e = 0;\n    int len2 = len - 2;\n    int lineLength = 0;\n    for (; d < len2; d += 3, e += 4) {\n\n      // The following block of code is the same as\n      // encode3to4( source, d + off, 3, outBuff, e, alphabet );\n      // but inlined for faster encoding (~20% improvement)\n      int inBuff =\n          ((source[d + off] << 24) >>> 8)\n              | ((source[d + 1 + off] << 24) >>> 16)\n              | ((source[d + 2 + off] << 24) >>> 24);\n      outBuff[e] = alphabet[(inBuff >>> 18)];\n      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];\n      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];\n      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n        lineLength = 0;\n      } // end if: end of line\n    } // end for: each piece of array\n\n    if (d < len) {\n      encode3to4(source, d + off, len - d, outBuff, e, alphabet);\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        // Add a last newline\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n      }\n      e += 4;\n    }\n\n    assert (e == outBuff.length);\n    return outBuff;\n  }", "language": "java", "Allcodes": "public byte[] encode(byte[] source, int off, int len, byte[] alphabet,\n      int maxLineLength) {\n    int lenDiv3 = (len + 2) / 3; // ceil(len / 3)\n    int len43 = lenDiv3 * 4;\n    byte[] outBuff = new byte[len43 // Main 4:3\n        + (len43 / maxLineLength)]; // New lines\n\n    int d = 0;\n    int e = 0;\n    int len2 = len - 2;\n    int lineLength = 0;\n    for (; d < len2; d += 3, e += 4) {\n\n      // The following block of code is the same as\n      // encode3to4( source, d + off, 3, outBuff, e, alphabet );\n      // but inlined for faster encoding (~20% improvement)\n      int inBuff =\n          ((source[d + off] << 24) >>> 8)\n              | ((source[d + 1 + off] << 24) >>> 16)\n              | ((source[d + 2 + off] << 24) >>> 24);\n      outBuff[e] = alphabet[(inBuff >>> 18)];\n      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];\n      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];\n      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n        lineLength = 0;\n      } // end if: end of line\n    } // end for: each piece of array\n\n    if (d < len) {\n      encode3to4(source, d + off, len - d, outBuff, e, alphabet);\n\n      lineLength += 4;\n      if (lineLength == maxLineLength) {\n        // Add a last newline\n        outBuff[e + 4] = NEW_LINE;\n        e++;\n      }\n      e += 4;\n    }\n\n    assert (e == outBuff.length);\n    return outBuff;\n  }", "code_tokens": ["public", "byte", "[", "]", "encode", "(", "byte", "[", "]", "source", ",", "int", "off", ",", "int", "len", ",", "byte", "[", "]", "alphabet", ",", "int", "maxLineLength", ")", "{", "int", "lenDiv3", "=", "(", "len", "+", "2", ")", "/", "3", ";", "// ceil(len / 3)", "int", "len43", "=", "lenDiv3", "*", "4", ";", "byte", "[", "]", "outBuff", "=", "new", "byte", "[", "len43", "// Main 4:3", "+", "(", "len43", "/", "maxLineLength", ")", "]", ";", "// New lines", "int", "d", "=", "0", ";", "int", "e", "=", "0", ";", "int", "len2", "=", "len", "-", "2", ";", "int", "lineLength", "=", "0", ";", "for", "(", ";", "d", "<", "len2", ";", "d", "+=", "3", ",", "e", "+=", "4", ")", "{", "// The following block of code is the same as", "// encode3to4( source, d + off, 3, outBuff, e, alphabet );", "// but inlined for faster encoding (~20% improvement)", "int", "inBuff", "=", "(", "(", "source", "[", "d", "+", "off", "]", "<<", "24", ")", ">>>", "8", ")", "|", "(", "(", "source", "[", "d", "+", "1", "+", "off", "]", "<<", "24", ")", ">>>", "16", ")", "|", "(", "(", "source", "[", "d", "+", "2", "+", "off", "]", "<<", "24", ")", ">>>", "24", ")", ";", "outBuff", "[", "e", "]", "=", "alphabet", "[", "(", "inBuff", ">>>", "18", ")", "]", ";", "outBuff", "[", "e", "+", "1", "]", "=", "alphabet", "[", "(", "inBuff", ">>>", "12", ")", "&", "0x3f", "]", ";", "outBuff", "[", "e", "+", "2", "]", "=", "alphabet", "[", "(", "inBuff", ">>>", "6", ")", "&", "0x3f", "]", ";", "outBuff", "[", "e", "+", "3", "]", "=", "alphabet", "[", "(", "inBuff", ")", "&", "0x3f", "]", ";", "lineLength", "+=", "4", ";", "if", "(", "lineLength", "==", "maxLineLength", ")", "{", "outBuff", "[", "e", "+", "4", "]", "=", "NEW_LINE", ";", "e", "++", ";", "lineLength", "=", "0", ";", "}", "// end if: end of line", "}", "// end for: each piece of array", "if", "(", "d", "<", "len", ")", "{", "encode3to4", "(", "source", ",", "d", "+", "off", ",", "len", "-", "d", ",", "outBuff", ",", "e", ",", "alphabet", ")", ";", "lineLength", "+=", "4", ";", "if", "(", "lineLength", "==", "maxLineLength", ")", "{", "// Add a last newline", "outBuff", "[", "e", "+", "4", "]", "=", "NEW_LINE", ";", "e", "++", ";", "}", "e", "+=", "4", ";", "}", "assert", "(", "e", "==", "outBuff", ".", "length", ")", ";", "return", "outBuff", ";", "}"], "docstring": "Encodes a byte array into Base64 notation.\n\n@param source The data to convert\n@param off Offset in array where conversion should begin\n@param len Length of data to convert\n@param alphabet is the encoding alphabet\n@param maxLineLength maximum length of one line.\n@return the BASE64-encoded byte array", "docstring_tokens": ["Encodes", "a", "byte", "array", "into", "Base64", "notation", "."]}
{"code": "byte[] outBuff = new byte[2 + len34];", "comments": "Upper limit on size of output", "lines": 4, "repo": "socialize/socialize-sdk-android", "path": "sdk/src/com/socialize/util/Base64Utils.java", "func_name": "Base64Utils.decode", "original_string": "public byte[] decode(byte[] source, int off, int len, byte[] decodabet)\n      throws Base64DecoderException {\n    int len34 = len * 3 / 4;\n    byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n    int outBuffPosn = 0;\n\n    byte[] b4 = new byte[4];\n    int b4Posn = 0;\n    int i = 0;\n    byte sbiCrop = 0;\n    byte sbiDecode = 0;\n    for (i = 0; i < len; i++) {\n      sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits\n      sbiDecode = decodabet[sbiCrop];\n\n      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n        if (sbiDecode >= EQUALS_SIGN_ENC) {\n          // An equals sign (for padding) must not occur at position 0 or 1\n          // and must be the last byte[s] in the encoded value\n          if (sbiCrop == EQUALS_SIGN) {\n            int bytesLeft = len - i;\n            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\n            if (b4Posn == 0 || b4Posn == 1) {\n              throw new Base64DecoderException(\n                  \"invalid padding byte '=' at byte offset \" + i);\n            } else if ((b4Posn == 3 && bytesLeft > 2)\n                || (b4Posn == 4 && bytesLeft > 1)) {\n              throw new Base64DecoderException(\n                  \"padding byte '=' falsely signals end of encoded value \"\n                      + \"at offset \" + i);\n            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\n              throw new Base64DecoderException(\n                  \"encoded value has invalid trailing byte\");\n            }\n            break;\n          }\n\n          b4[b4Posn++] = sbiCrop;\n          if (b4Posn == 4) {\n            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n            b4Posn = 0;\n          }\n        }\n      } else {\n        throw new Base64DecoderException(\"Bad Base64 input character at \" + i\n            + \": \" + source[i + off] + \"(decimal)\");\n      }\n    }\n\n    // Because web safe encoding allows non padding base64 encodes, we\n    // need to pad the rest of the b4 buffer with equal signs when\n    // b4Posn != 0.  There can be at most 2 equal signs at the end of\n    // four characters, so the b4 buffer must have two or three\n    // characters.  This also catches the case where the input is\n    // padded with EQUALS_SIGN\n    if (b4Posn != 0) {\n      if (b4Posn == 1) {\n        throw new Base64DecoderException(\"single trailing character at offset \"\n            + (len - 1));\n      }\n      b4[b4Posn++] = EQUALS_SIGN;\n      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n    }\n\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n  }", "language": "java", "Allcodes": "public byte[] decode(byte[] source, int off, int len, byte[] decodabet)\n      throws Base64DecoderException {\n    int len34 = len * 3 / 4;\n    byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n    int outBuffPosn = 0;\n\n    byte[] b4 = new byte[4];\n    int b4Posn = 0;\n    int i = 0;\n    byte sbiCrop = 0;\n    byte sbiDecode = 0;\n    for (i = 0; i < len; i++) {\n      sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits\n      sbiDecode = decodabet[sbiCrop];\n\n      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n        if (sbiDecode >= EQUALS_SIGN_ENC) {\n          // An equals sign (for padding) must not occur at position 0 or 1\n          // and must be the last byte[s] in the encoded value\n          if (sbiCrop == EQUALS_SIGN) {\n            int bytesLeft = len - i;\n            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\n            if (b4Posn == 0 || b4Posn == 1) {\n              throw new Base64DecoderException(\n                  \"invalid padding byte '=' at byte offset \" + i);\n            } else if ((b4Posn == 3 && bytesLeft > 2)\n                || (b4Posn == 4 && bytesLeft > 1)) {\n              throw new Base64DecoderException(\n                  \"padding byte '=' falsely signals end of encoded value \"\n                      + \"at offset \" + i);\n            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\n              throw new Base64DecoderException(\n                  \"encoded value has invalid trailing byte\");\n            }\n            break;\n          }\n\n          b4[b4Posn++] = sbiCrop;\n          if (b4Posn == 4) {\n            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n            b4Posn = 0;\n          }\n        }\n      } else {\n        throw new Base64DecoderException(\"Bad Base64 input character at \" + i\n            + \": \" + source[i + off] + \"(decimal)\");\n      }\n    }\n\n    // Because web safe encoding allows non padding base64 encodes, we\n    // need to pad the rest of the b4 buffer with equal signs when\n    // b4Posn != 0.  There can be at most 2 equal signs at the end of\n    // four characters, so the b4 buffer must have two or three\n    // characters.  This also catches the case where the input is\n    // padded with EQUALS_SIGN\n    if (b4Posn != 0) {\n      if (b4Posn == 1) {\n        throw new Base64DecoderException(\"single trailing character at offset \"\n            + (len - 1));\n      }\n      b4[b4Posn++] = EQUALS_SIGN;\n      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n    }\n\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n  }", "code_tokens": ["public", "byte", "[", "]", "decode", "(", "byte", "[", "]", "source", ",", "int", "off", ",", "int", "len", ",", "byte", "[", "]", "decodabet", ")", "throws", "Base64DecoderException", "{", "int", "len34", "=", "len", "*", "3", "/", "4", ";", "byte", "[", "]", "outBuff", "=", "new", "byte", "[", "2", "+", "len34", "]", ";", "// Upper limit on size of output", "int", "outBuffPosn", "=", "0", ";", "byte", "[", "]", "b4", "=", "new", "byte", "[", "4", "]", ";", "int", "b4Posn", "=", "0", ";", "int", "i", "=", "0", ";", "byte", "sbiCrop", "=", "0", ";", "byte", "sbiDecode", "=", "0", ";", "for", "(", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "sbiCrop", "=", "(", "byte", ")", "(", "source", "[", "i", "+", "off", "]", "&", "0x7f", ")", ";", "// Only the low seven bits", "sbiDecode", "=", "decodabet", "[", "sbiCrop", "]", ";", "if", "(", "sbiDecode", ">=", "WHITE_SPACE_ENC", ")", "{", "// White space Equals sign or better", "if", "(", "sbiDecode", ">=", "EQUALS_SIGN_ENC", ")", "{", "// An equals sign (for padding) must not occur at position 0 or 1", "// and must be the last byte[s] in the encoded value", "if", "(", "sbiCrop", "==", "EQUALS_SIGN", ")", "{", "int", "bytesLeft", "=", "len", "-", "i", ";", "byte", "lastByte", "=", "(", "byte", ")", "(", "source", "[", "len", "-", "1", "+", "off", "]", "&", "0x7f", ")", ";", "if", "(", "b4Posn", "==", "0", "||", "b4Posn", "==", "1", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"invalid padding byte '=' at byte offset \"", "+", "i", ")", ";", "}", "else", "if", "(", "(", "b4Posn", "==", "3", "&&", "bytesLeft", ">", "2", ")", "||", "(", "b4Posn", "==", "4", "&&", "bytesLeft", ">", "1", ")", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"padding byte '=' falsely signals end of encoded value \"", "+", "\"at offset \"", "+", "i", ")", ";", "}", "else", "if", "(", "lastByte", "!=", "EQUALS_SIGN", "&&", "lastByte", "!=", "NEW_LINE", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"encoded value has invalid trailing byte\"", ")", ";", "}", "break", ";", "}", "b4", "[", "b4Posn", "++", "]", "=", "sbiCrop", ";", "if", "(", "b4Posn", "==", "4", ")", "{", "outBuffPosn", "+=", "decode4to3", "(", "b4", ",", "0", ",", "outBuff", ",", "outBuffPosn", ",", "decodabet", ")", ";", "b4Posn", "=", "0", ";", "}", "}", "}", "else", "{", "throw", "new", "Base64DecoderException", "(", "\"Bad Base64 input character at \"", "+", "i", "+", "\": \"", "+", "source", "[", "i", "+", "off", "]", "+", "\"(decimal)\"", ")", ";", "}", "}", "// Because web safe encoding allows non padding base64 encodes, we", "// need to pad the rest of the b4 buffer with equal signs when", "// b4Posn != 0.  There can be at most 2 equal signs at the end of", "// four characters, so the b4 buffer must have two or three", "// characters.  This also catches the case where the input is", "// padded with EQUALS_SIGN", "if", "(", "b4Posn", "!=", "0", ")", "{", "if", "(", "b4Posn", "==", "1", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"single trailing character at offset \"", "+", "(", "len", "-", "1", ")", ")", ";", "}", "b4", "[", "b4Posn", "++", "]", "=", "EQUALS_SIGN", ";", "outBuffPosn", "+=", "decode4to3", "(", "b4", ",", "0", ",", "outBuff", ",", "outBuffPosn", ",", "decodabet", ")", ";", "}", "byte", "[", "]", "out", "=", "new", "byte", "[", "outBuffPosn", "]", ";", "System", ".", "arraycopy", "(", "outBuff", ",", "0", ",", "out", ",", "0", ",", "outBuffPosn", ")", ";", "return", "out", ";", "}"], "docstring": "Decodes Base64 content using the supplied decodabet and returns\nthe decoded byte array.\n\n@param source    The Base64 encoded data\n@param off       The offset of where to begin decoding\n@param len       The length of characters to decode\n@param decodabet the decodabet for decoding Base64 content\n@return decoded data", "docstring_tokens": ["Decodes", "Base64", "content", "using", "the", "supplied", "decodabet", "and", "returns", "the", "decoded", "byte", "array", "."]}
{"code": "sbiCrop = (byte) (source[i + off] & 0x7f);", "comments": "Only the low seven bits", "lines": 13, "repo": "socialize/socialize-sdk-android", "path": "sdk/src/com/socialize/util/Base64Utils.java", "func_name": "Base64Utils.decode", "original_string": "public byte[] decode(byte[] source, int off, int len, byte[] decodabet)\n      throws Base64DecoderException {\n    int len34 = len * 3 / 4;\n    byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n    int outBuffPosn = 0;\n\n    byte[] b4 = new byte[4];\n    int b4Posn = 0;\n    int i = 0;\n    byte sbiCrop = 0;\n    byte sbiDecode = 0;\n    for (i = 0; i < len; i++) {\n      sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits\n      sbiDecode = decodabet[sbiCrop];\n\n      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n        if (sbiDecode >= EQUALS_SIGN_ENC) {\n          // An equals sign (for padding) must not occur at position 0 or 1\n          // and must be the last byte[s] in the encoded value\n          if (sbiCrop == EQUALS_SIGN) {\n            int bytesLeft = len - i;\n            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\n            if (b4Posn == 0 || b4Posn == 1) {\n              throw new Base64DecoderException(\n                  \"invalid padding byte '=' at byte offset \" + i);\n            } else if ((b4Posn == 3 && bytesLeft > 2)\n                || (b4Posn == 4 && bytesLeft > 1)) {\n              throw new Base64DecoderException(\n                  \"padding byte '=' falsely signals end of encoded value \"\n                      + \"at offset \" + i);\n            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\n              throw new Base64DecoderException(\n                  \"encoded value has invalid trailing byte\");\n            }\n            break;\n          }\n\n          b4[b4Posn++] = sbiCrop;\n          if (b4Posn == 4) {\n            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n            b4Posn = 0;\n          }\n        }\n      } else {\n        throw new Base64DecoderException(\"Bad Base64 input character at \" + i\n            + \": \" + source[i + off] + \"(decimal)\");\n      }\n    }\n\n    // Because web safe encoding allows non padding base64 encodes, we\n    // need to pad the rest of the b4 buffer with equal signs when\n    // b4Posn != 0.  There can be at most 2 equal signs at the end of\n    // four characters, so the b4 buffer must have two or three\n    // characters.  This also catches the case where the input is\n    // padded with EQUALS_SIGN\n    if (b4Posn != 0) {\n      if (b4Posn == 1) {\n        throw new Base64DecoderException(\"single trailing character at offset \"\n            + (len - 1));\n      }\n      b4[b4Posn++] = EQUALS_SIGN;\n      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n    }\n\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n  }", "language": "java", "Allcodes": "public byte[] decode(byte[] source, int off, int len, byte[] decodabet)\n      throws Base64DecoderException {\n    int len34 = len * 3 / 4;\n    byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n    int outBuffPosn = 0;\n\n    byte[] b4 = new byte[4];\n    int b4Posn = 0;\n    int i = 0;\n    byte sbiCrop = 0;\n    byte sbiDecode = 0;\n    for (i = 0; i < len; i++) {\n      sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits\n      sbiDecode = decodabet[sbiCrop];\n\n      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n        if (sbiDecode >= EQUALS_SIGN_ENC) {\n          // An equals sign (for padding) must not occur at position 0 or 1\n          // and must be the last byte[s] in the encoded value\n          if (sbiCrop == EQUALS_SIGN) {\n            int bytesLeft = len - i;\n            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\n            if (b4Posn == 0 || b4Posn == 1) {\n              throw new Base64DecoderException(\n                  \"invalid padding byte '=' at byte offset \" + i);\n            } else if ((b4Posn == 3 && bytesLeft > 2)\n                || (b4Posn == 4 && bytesLeft > 1)) {\n              throw new Base64DecoderException(\n                  \"padding byte '=' falsely signals end of encoded value \"\n                      + \"at offset \" + i);\n            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\n              throw new Base64DecoderException(\n                  \"encoded value has invalid trailing byte\");\n            }\n            break;\n          }\n\n          b4[b4Posn++] = sbiCrop;\n          if (b4Posn == 4) {\n            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n            b4Posn = 0;\n          }\n        }\n      } else {\n        throw new Base64DecoderException(\"Bad Base64 input character at \" + i\n            + \": \" + source[i + off] + \"(decimal)\");\n      }\n    }\n\n    // Because web safe encoding allows non padding base64 encodes, we\n    // need to pad the rest of the b4 buffer with equal signs when\n    // b4Posn != 0.  There can be at most 2 equal signs at the end of\n    // four characters, so the b4 buffer must have two or three\n    // characters.  This also catches the case where the input is\n    // padded with EQUALS_SIGN\n    if (b4Posn != 0) {\n      if (b4Posn == 1) {\n        throw new Base64DecoderException(\"single trailing character at offset \"\n            + (len - 1));\n      }\n      b4[b4Posn++] = EQUALS_SIGN;\n      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\n    }\n\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n  }", "code_tokens": ["public", "byte", "[", "]", "decode", "(", "byte", "[", "]", "source", ",", "int", "off", ",", "int", "len", ",", "byte", "[", "]", "decodabet", ")", "throws", "Base64DecoderException", "{", "int", "len34", "=", "len", "*", "3", "/", "4", ";", "byte", "[", "]", "outBuff", "=", "new", "byte", "[", "2", "+", "len34", "]", ";", "// Upper limit on size of output", "int", "outBuffPosn", "=", "0", ";", "byte", "[", "]", "b4", "=", "new", "byte", "[", "4", "]", ";", "int", "b4Posn", "=", "0", ";", "int", "i", "=", "0", ";", "byte", "sbiCrop", "=", "0", ";", "byte", "sbiDecode", "=", "0", ";", "for", "(", "i", "=", "0", ";", "i", "<", "len", ";", "i", "++", ")", "{", "sbiCrop", "=", "(", "byte", ")", "(", "source", "[", "i", "+", "off", "]", "&", "0x7f", ")", ";", "// Only the low seven bits", "sbiDecode", "=", "decodabet", "[", "sbiCrop", "]", ";", "if", "(", "sbiDecode", ">=", "WHITE_SPACE_ENC", ")", "{", "// White space Equals sign or better", "if", "(", "sbiDecode", ">=", "EQUALS_SIGN_ENC", ")", "{", "// An equals sign (for padding) must not occur at position 0 or 1", "// and must be the last byte[s] in the encoded value", "if", "(", "sbiCrop", "==", "EQUALS_SIGN", ")", "{", "int", "bytesLeft", "=", "len", "-", "i", ";", "byte", "lastByte", "=", "(", "byte", ")", "(", "source", "[", "len", "-", "1", "+", "off", "]", "&", "0x7f", ")", ";", "if", "(", "b4Posn", "==", "0", "||", "b4Posn", "==", "1", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"invalid padding byte '=' at byte offset \"", "+", "i", ")", ";", "}", "else", "if", "(", "(", "b4Posn", "==", "3", "&&", "bytesLeft", ">", "2", ")", "||", "(", "b4Posn", "==", "4", "&&", "bytesLeft", ">", "1", ")", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"padding byte '=' falsely signals end of encoded value \"", "+", "\"at offset \"", "+", "i", ")", ";", "}", "else", "if", "(", "lastByte", "!=", "EQUALS_SIGN", "&&", "lastByte", "!=", "NEW_LINE", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"encoded value has invalid trailing byte\"", ")", ";", "}", "break", ";", "}", "b4", "[", "b4Posn", "++", "]", "=", "sbiCrop", ";", "if", "(", "b4Posn", "==", "4", ")", "{", "outBuffPosn", "+=", "decode4to3", "(", "b4", ",", "0", ",", "outBuff", ",", "outBuffPosn", ",", "decodabet", ")", ";", "b4Posn", "=", "0", ";", "}", "}", "}", "else", "{", "throw", "new", "Base64DecoderException", "(", "\"Bad Base64 input character at \"", "+", "i", "+", "\": \"", "+", "source", "[", "i", "+", "off", "]", "+", "\"(decimal)\"", ")", ";", "}", "}", "// Because web safe encoding allows non padding base64 encodes, we", "// need to pad the rest of the b4 buffer with equal signs when", "// b4Posn != 0.  There can be at most 2 equal signs at the end of", "// four characters, so the b4 buffer must have two or three", "// characters.  This also catches the case where the input is", "// padded with EQUALS_SIGN", "if", "(", "b4Posn", "!=", "0", ")", "{", "if", "(", "b4Posn", "==", "1", ")", "{", "throw", "new", "Base64DecoderException", "(", "\"single trailing character at offset \"", "+", "(", "len", "-", "1", ")", ")", ";", "}", "b4", "[", "b4Posn", "++", "]", "=", "EQUALS_SIGN", ";", "outBuffPosn", "+=", "decode4to3", "(", "b4", ",", "0", ",", "outBuff", ",", "outBuffPosn", ",", "decodabet", ")", ";", "}", "byte", "[", "]", "out", "=", "new", "byte", "[", "outBuffPosn", "]", ";", "System", ".", "arraycopy", "(", "outBuff", ",", "0", ",", "out", ",", "0", ",", "outBuffPosn", ")", ";", "return", "out", ";", "}"], "docstring": "Decodes Base64 content using the supplied decodabet and returns\nthe decoded byte array.\n\n@param source    The Base64 encoded data\n@param off       The offset of where to begin decoding\n@param len       The length of characters to decode\n@param decodabet the decodabet for decoding Base64 content\n@return decoded data", "docstring_tokens": ["Decodes", "Base64", "content", "using", "the", "supplied", "decodabet", "and", "returns", "the", "decoded", "byte", "array", "."]}
{"code": "return name;", "comments": "no tags in this name", "lines": 8, "repo": "sps/metrics-opentsdb", "path": "src/main/java/com/github/sps/metrics/opentsdb/OpenTsdbMetric.java", "func_name": "OpenTsdbMetric.fixEncodedTagsInNameAfterPrefix", "original_string": "public static String fixEncodedTagsInNameAfterPrefix(final String name) {\n        if (name == null)\n            return name;\n\n        int tagStart = name.indexOf(\"TAG(\");\n\n        if (tagStart == -1)\n            return name; // no tags in this name\n\n        if (tagStart == 0)\n            return name; // tag string is already correct\n\n        // extract the \"TAG(...)\" string from the middle of the name and put it at the front.\n        int tagEnd = name.lastIndexOf(')');\n        if (tagEnd == -1) {\n            throw new IllegalArgumentException(\"Tag definition missing closing parenthesis for metric '\" + name + \"'\");\n        }\n\n        String tagString = name.substring(tagStart, tagEnd+1);\n        return tagString + name.substring(0, tagStart) + name.substring(tagEnd+1);\n    }", "language": "java", "Allcodes": "public static String fixEncodedTagsInNameAfterPrefix(final String name) {\n        if (name == null)\n            return name;\n\n        int tagStart = name.indexOf(\"TAG(\");\n\n        if (tagStart == -1)\n            return name; // no tags in this name\n\n        if (tagStart == 0)\n            return name; // tag string is already correct\n\n        // extract the \"TAG(...)\" string from the middle of the name and put it at the front.\n        int tagEnd = name.lastIndexOf(')');\n        if (tagEnd == -1) {\n            throw new IllegalArgumentException(\"Tag definition missing closing parenthesis for metric '\" + name + \"'\");\n        }\n\n        String tagString = name.substring(tagStart, tagEnd+1);\n        return tagString + name.substring(0, tagStart) + name.substring(tagEnd+1);\n    }", "code_tokens": ["public", "static", "String", "fixEncodedTagsInNameAfterPrefix", "(", "final", "String", "name", ")", "{", "if", "(", "name", "==", "null", ")", "return", "name", ";", "int", "tagStart", "=", "name", ".", "indexOf", "(", "\"TAG(\"", ")", ";", "if", "(", "tagStart", "==", "-", "1", ")", "return", "name", ";", "// no tags in this name", "if", "(", "tagStart", "==", "0", ")", "return", "name", ";", "// tag string is already correct", "// extract the \"TAG(...)\" string from the middle of the name and put it at the front.", "int", "tagEnd", "=", "name", ".", "lastIndexOf", "(", "'", "'", ")", ";", "if", "(", "tagEnd", "==", "-", "1", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Tag definition missing closing parenthesis for metric '\"", "+", "name", "+", "\"'\"", ")", ";", "}", "String", "tagString", "=", "name", ".", "substring", "(", "tagStart", ",", "tagEnd", "+", "1", ")", ";", "return", "tagString", "+", "name", ".", "substring", "(", "0", ",", "tagStart", ")", "+", "name", ".", "substring", "(", "tagEnd", "+", "1", ")", ";", "}"], "docstring": "Call this function whenever a potentially tag-encoded name is prefixed.\n\n@param name a metric name with encoded tag strings that has been prefixed.\n@return a fixed metric name", "docstring_tokens": ["Call", "this", "function", "whenever", "a", "potentially", "tag", "-", "encoded", "name", "is", "prefixed", "."]}
{"code": "return name;", "comments": "tag string is already correct", "lines": 11, "repo": "sps/metrics-opentsdb", "path": "src/main/java/com/github/sps/metrics/opentsdb/OpenTsdbMetric.java", "func_name": "OpenTsdbMetric.fixEncodedTagsInNameAfterPrefix", "original_string": "public static String fixEncodedTagsInNameAfterPrefix(final String name) {\n        if (name == null)\n            return name;\n\n        int tagStart = name.indexOf(\"TAG(\");\n\n        if (tagStart == -1)\n            return name; // no tags in this name\n\n        if (tagStart == 0)\n            return name; // tag string is already correct\n\n        // extract the \"TAG(...)\" string from the middle of the name and put it at the front.\n        int tagEnd = name.lastIndexOf(')');\n        if (tagEnd == -1) {\n            throw new IllegalArgumentException(\"Tag definition missing closing parenthesis for metric '\" + name + \"'\");\n        }\n\n        String tagString = name.substring(tagStart, tagEnd+1);\n        return tagString + name.substring(0, tagStart) + name.substring(tagEnd+1);\n    }", "language": "java", "Allcodes": "public static String fixEncodedTagsInNameAfterPrefix(final String name) {\n        if (name == null)\n            return name;\n\n        int tagStart = name.indexOf(\"TAG(\");\n\n        if (tagStart == -1)\n            return name; // no tags in this name\n\n        if (tagStart == 0)\n            return name; // tag string is already correct\n\n        // extract the \"TAG(...)\" string from the middle of the name and put it at the front.\n        int tagEnd = name.lastIndexOf(')');\n        if (tagEnd == -1) {\n            throw new IllegalArgumentException(\"Tag definition missing closing parenthesis for metric '\" + name + \"'\");\n        }\n\n        String tagString = name.substring(tagStart, tagEnd+1);\n        return tagString + name.substring(0, tagStart) + name.substring(tagEnd+1);\n    }", "code_tokens": ["public", "static", "String", "fixEncodedTagsInNameAfterPrefix", "(", "final", "String", "name", ")", "{", "if", "(", "name", "==", "null", ")", "return", "name", ";", "int", "tagStart", "=", "name", ".", "indexOf", "(", "\"TAG(\"", ")", ";", "if", "(", "tagStart", "==", "-", "1", ")", "return", "name", ";", "// no tags in this name", "if", "(", "tagStart", "==", "0", ")", "return", "name", ";", "// tag string is already correct", "// extract the \"TAG(...)\" string from the middle of the name and put it at the front.", "int", "tagEnd", "=", "name", ".", "lastIndexOf", "(", "'", "'", ")", ";", "if", "(", "tagEnd", "==", "-", "1", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Tag definition missing closing parenthesis for metric '\"", "+", "name", "+", "\"'\"", ")", ";", "}", "String", "tagString", "=", "name", ".", "substring", "(", "tagStart", ",", "tagEnd", "+", "1", ")", ";", "return", "tagString", "+", "name", ".", "substring", "(", "0", ",", "tagStart", ")", "+", "name", ".", "substring", "(", "tagEnd", "+", "1", ")", ";", "}"], "docstring": "Call this function whenever a potentially tag-encoded name is prefixed.\n\n@param name a metric name with encoded tag strings that has been prefixed.\n@return a fixed metric name", "docstring_tokens": ["Call", "this", "function", "whenever", "a", "potentially", "tag", "-", "encoded", "name", "is", "prefixed", "."]}
{"code": "return ch(characters[0]);", "comments": "optimize one-char strings", "lines": 6, "repo": "fge/grappa", "path": "src/main/java/com/github/fge/grappa/parsers/BaseParser.java", "func_name": "BaseParser.string", "original_string": "@Cached\n    @DontLabel\n    public Rule string(final char... characters)\n    {\n        if (characters.length == 1)\n            return ch(characters[0]); // optimize one-char strings\n        return new StringMatcher(new String(characters));\n    }", "language": "java", "Allcodes": "@Cached\n    @DontLabel\n    public Rule string(final char... characters)\n    {\n        if (characters.length == 1)\n            return ch(characters[0]); // optimize one-char strings\n        return new StringMatcher(new String(characters));\n    }", "code_tokens": ["@", "Cached", "@", "DontLabel", "public", "Rule", "string", "(", "final", "char", "...", "characters", ")", "{", "if", "(", "characters", ".", "length", "==", "1", ")", "return", "ch", "(", "characters", "[", "0", "]", ")", ";", "// optimize one-char strings", "return", "new", "StringMatcher", "(", "new", "String", "(", "characters", ")", ")", ";", "}"], "docstring": "Match a given set of characters as a string literal\n\n@param characters the characters of the string to match\n@return a rule", "docstring_tokens": ["Match", "a", "given", "set", "of", "characters", "as", "a", "string", "literal"]}
{"code": "Pattern p = Pattern.compile(\"   (.*):(.*):\" + dependencyType + \":(.*):(.*)\");", "comments": "keep only selected type (projlib or jar or bw-ear) dependencies", "lines": 12, "repo": "fastconnect/tibco-bwmaven", "path": "bw-maven-plugin/src/main/java/fr/fastconnect/factory/tibco/bw/maven/AbstractBWMojo.java", "func_name": "AbstractBWMojo.readDependenciesFromFile", "original_string": "protected List<Dependency> readDependenciesFromFile(String resolvedFileName, String dependencyType) throws IOException {\n\t\tList<Dependency> dependencies = new ArrayList<Dependency>();\n\n\t\tFile resolvedFile = new File(resolvedFileName);\n\t\tif (!resolvedFile.exists()) {\n\t\t\treturn dependencies;\n\t\t}\n\n\t\tFileInputStream fstream = new FileInputStream(resolvedFile);\n\t\tDataInputStream ds = new DataInputStream(fstream);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(ds));\n\t\tPattern p = Pattern.compile(\"   (.*):(.*):\" + dependencyType + \":(.*):(.*)\"); // keep only selected type (projlib or jar or bw-ear) dependencies\n\t\tString strLine;\n\t\twhile ((strLine = br.readLine()) != null) {\n\t\t\tMatcher m = p.matcher(strLine);\n\t\t\tif (m.matches()) {\n\t\t\t\tgetLog().debug(m.group(0));\n\n\t\t\t\tString groupId = m.group(1);\n\t\t\t\tString artifactId = m.group(2);\n\t\t\t\tString version = m.group(3);\n\t\t\t\tString scope = m.group(4);\n\n\t\t\t\t// create the dependency\n\t\t\t\tDependency dependency = new Dependency();\n\t\t\t\tdependency.setGroupId(groupId);\n\t\t\t\tdependency.setArtifactId(artifactId);\n\t\t\t\tdependency.setVersion(version);\n\t\t\t\tdependency.setType(dependencyType);\n\t\t\t\tdependency.setScope(scope);\n\n\t\t\t\tdependencies.add(dependency);\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\n\t\treturn dependencies;\n\t}", "language": "java", "Allcodes": "protected List<Dependency> readDependenciesFromFile(String resolvedFileName, String dependencyType) throws IOException {\n\t\tList<Dependency> dependencies = new ArrayList<Dependency>();\n\n\t\tFile resolvedFile = new File(resolvedFileName);\n\t\tif (!resolvedFile.exists()) {\n\t\t\treturn dependencies;\n\t\t}\n\n\t\tFileInputStream fstream = new FileInputStream(resolvedFile);\n\t\tDataInputStream ds = new DataInputStream(fstream);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(ds));\n\t\tPattern p = Pattern.compile(\"   (.*):(.*):\" + dependencyType + \":(.*):(.*)\"); // keep only selected type (projlib or jar or bw-ear) dependencies\n\t\tString strLine;\n\t\twhile ((strLine = br.readLine()) != null) {\n\t\t\tMatcher m = p.matcher(strLine);\n\t\t\tif (m.matches()) {\n\t\t\t\tgetLog().debug(m.group(0));\n\n\t\t\t\tString groupId = m.group(1);\n\t\t\t\tString artifactId = m.group(2);\n\t\t\t\tString version = m.group(3);\n\t\t\t\tString scope = m.group(4);\n\n\t\t\t\t// create the dependency\n\t\t\t\tDependency dependency = new Dependency();\n\t\t\t\tdependency.setGroupId(groupId);\n\t\t\t\tdependency.setArtifactId(artifactId);\n\t\t\t\tdependency.setVersion(version);\n\t\t\t\tdependency.setType(dependencyType);\n\t\t\t\tdependency.setScope(scope);\n\n\t\t\t\tdependencies.add(dependency);\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\n\t\treturn dependencies;\n\t}", "code_tokens": ["protected", "List", "<", "Dependency", ">", "readDependenciesFromFile", "(", "String", "resolvedFileName", ",", "String", "dependencyType", ")", "throws", "IOException", "{", "List", "<", "Dependency", ">", "dependencies", "=", "new", "ArrayList", "<", "Dependency", ">", "(", ")", ";", "File", "resolvedFile", "=", "new", "File", "(", "resolvedFileName", ")", ";", "if", "(", "!", "resolvedFile", ".", "exists", "(", ")", ")", "{", "return", "dependencies", ";", "}", "FileInputStream", "fstream", "=", "new", "FileInputStream", "(", "resolvedFile", ")", ";", "DataInputStream", "ds", "=", "new", "DataInputStream", "(", "fstream", ")", ";", "BufferedReader", "br", "=", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "ds", ")", ")", ";", "Pattern", "p", "=", "Pattern", ".", "compile", "(", "\"   (.*):(.*):\"", "+", "dependencyType", "+", "\":(.*):(.*)\"", ")", ";", "// keep only selected type (projlib or jar or bw-ear) dependencies", "String", "strLine", ";", "while", "(", "(", "strLine", "=", "br", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "Matcher", "m", "=", "p", ".", "matcher", "(", "strLine", ")", ";", "if", "(", "m", ".", "matches", "(", ")", ")", "{", "getLog", "(", ")", ".", "debug", "(", "m", ".", "group", "(", "0", ")", ")", ";", "String", "groupId", "=", "m", ".", "group", "(", "1", ")", ";", "String", "artifactId", "=", "m", ".", "group", "(", "2", ")", ";", "String", "version", "=", "m", ".", "group", "(", "3", ")", ";", "String", "scope", "=", "m", ".", "group", "(", "4", ")", ";", "// create the dependency", "Dependency", "dependency", "=", "new", "Dependency", "(", ")", ";", "dependency", ".", "setGroupId", "(", "groupId", ")", ";", "dependency", ".", "setArtifactId", "(", "artifactId", ")", ";", "dependency", ".", "setVersion", "(", "version", ")", ";", "dependency", ".", "setType", "(", "dependencyType", ")", ";", "dependency", ".", "setScope", "(", "scope", ")", ";", "dependencies", ".", "add", "(", "dependency", ")", ";", "}", "}", "br", ".", "close", "(", ")", ";", "return", "dependencies", ";", "}"], "docstring": "This will read the dependencies from the 'resolved' file found in the\nbuild directory. This file was created earlier in the build by the\n'resolve-bw-dependencies' execution of the 'process-resources' phase.\n\n@return The list of dependencies of type {@link dependencyType}\n@throws IOException", "docstring_tokens": ["This", "will", "read", "the", "dependencies", "from", "the", "resolved", "file", "found", "in", "the", "build", "directory", ".", "This", "file", "was", "created", "earlier", "in", "the", "build", "by", "the", "resolve", "-", "bw", "-", "dependencies", "execution", "of", "the", "process", "-", "resources", "phase", "."]}
{"code": "return;", "comments": "avoid duplicates", "lines": 5, "repo": "fastconnect/tibco-bwmaven", "path": "bw-maven-plugin/src/main/java/fr/fastconnect/factory/tibco/bw/maven/compile/UpdateAliasesLibsMojo.java", "func_name": "UpdateAliasesLibsMojo.addAlias", "original_string": "private void addAlias(ArrayList<HashMap<String,Object>> list, String aliasName) {\n\t\tfor (HashMap<String, Object> h : list) {\n\t\t\tString name = (String) h.get(\"name\");\n\t\t\tif (name != null && name.equals(aliasName)) {\n\t\t\t\treturn; // avoid duplicates\n\t\t\t}\n\t\t}\n\t\tHashMap<String, Object> h = new HashMap<String, Object>();\n\t\th.put(\"isClasspathFile\", Boolean.TRUE);\n\t\th.put(\"name\", aliasName);\n\t\th.put(\"includeInDeployment\", Boolean.TRUE);\n\n\t\tlist.add(h);\n\t}", "language": "java", "Allcodes": "private void addAlias(ArrayList<HashMap<String,Object>> list, String aliasName) {\n\t\tfor (HashMap<String, Object> h : list) {\n\t\t\tString name = (String) h.get(\"name\");\n\t\t\tif (name != null && name.equals(aliasName)) {\n\t\t\t\treturn; // avoid duplicates\n\t\t\t}\n\t\t}\n\t\tHashMap<String, Object> h = new HashMap<String, Object>();\n\t\th.put(\"isClasspathFile\", Boolean.TRUE);\n\t\th.put(\"name\", aliasName);\n\t\th.put(\"includeInDeployment\", Boolean.TRUE);\n\n\t\tlist.add(h);\n\t}", "code_tokens": ["private", "void", "addAlias", "(", "ArrayList", "<", "HashMap", "<", "String", ",", "Object", ">", ">", "list", ",", "String", "aliasName", ")", "{", "for", "(", "HashMap", "<", "String", ",", "Object", ">", "h", ":", "list", ")", "{", "String", "name", "=", "(", "String", ")", "h", ".", "get", "(", "\"name\"", ")", ";", "if", "(", "name", "!=", "null", "&&", "name", ".", "equals", "(", "aliasName", ")", ")", "{", "return", ";", "// avoid duplicates", "}", "}", "HashMap", "<", "String", ",", "Object", ">", "h", "=", "new", "HashMap", "<", "String", ",", "Object", ">", "(", ")", ";", "h", ".", "put", "(", "\"isClasspathFile\"", ",", "Boolean", ".", "TRUE", ")", ";", "h", ".", "put", "(", "\"name\"", ",", "aliasName", ")", ";", "h", ".", "put", "(", "\"includeInDeployment\"", ",", "Boolean", ".", "TRUE", ")", ";", "list", ".", "add", "(", "h", ")", ";", "}"], "docstring": "This method add an alias in the object used internally by TIBCO\nBusinessWorks.\n\n@param list, an object used internally by TIBCO BusinessWorks.\n@param aliasName, the name of the alias as normalized b\n{@link AbstractBWMojo}.", "docstring_tokens": ["This", "method", "add", "an", "alias", "in", "the", "object", "used", "internally", "by", "TIBCO", "BusinessWorks", "."]}
{"code": "return null;", "comments": "should never happen", "lines": 22, "repo": "ricksbrown/cowsay", "path": "src/main/java/com/github/ricksbrown/cowsay/Cowloader.java", "func_name": "Cowloader.load", "original_string": "public static String load(final String cowfileSpec) {\n\t\tString effectiveCowfileSpec = (cowfileSpec != null) ? cowfileSpec.trim() : DEFAULT_COW;\n\t\tif (effectiveCowfileSpec.length() > 0) {\n\t\t\tif (!effectiveCowfileSpec.endsWith(COWFILE_EXT)) {\n\t\t\t\teffectiveCowfileSpec += COWFILE_EXT;\n\t\t\t}\n\t\t\tInputStream cowInputStream;\n\t\t\tif (effectiveCowfileSpec.indexOf(File.separatorChar) >= 0) {\n\t\t\t\tcowInputStream = getCowFromPath(effectiveCowfileSpec);\n\t\t\t} else {\n\t\t\t\tcowInputStream = getCowFromCowPath(effectiveCowfileSpec);\n\t\t\t}\n\t\t\tif (cowInputStream == null) {\n\t\t\t\t// Maybe there should be a verbose mode where we log this sort of error instead of silently failing?\n\t\t\t\tcowInputStream = getCowFromResources(DEFAULT_COW + COWFILE_EXT);\n\t\t\t}\n\t\t\tif (cowInputStream != null) {\n\t\t\t\tString cow = cowInputStreamToString(cowInputStream);\n\t\t\t\treturn cow;\n\t\t\t}\n\t\t}\n\t\treturn null;  // should never happen\n\t}", "language": "java", "Allcodes": "public static String load(final String cowfileSpec) {\n\t\tString effectiveCowfileSpec = (cowfileSpec != null) ? cowfileSpec.trim() : DEFAULT_COW;\n\t\tif (effectiveCowfileSpec.length() > 0) {\n\t\t\tif (!effectiveCowfileSpec.endsWith(COWFILE_EXT)) {\n\t\t\t\teffectiveCowfileSpec += COWFILE_EXT;\n\t\t\t}\n\t\t\tInputStream cowInputStream;\n\t\t\tif (effectiveCowfileSpec.indexOf(File.separatorChar) >= 0) {\n\t\t\t\tcowInputStream = getCowFromPath(effectiveCowfileSpec);\n\t\t\t} else {\n\t\t\t\tcowInputStream = getCowFromCowPath(effectiveCowfileSpec);\n\t\t\t}\n\t\t\tif (cowInputStream == null) {\n\t\t\t\t// Maybe there should be a verbose mode where we log this sort of error instead of silently failing?\n\t\t\t\tcowInputStream = getCowFromResources(DEFAULT_COW + COWFILE_EXT);\n\t\t\t}\n\t\t\tif (cowInputStream != null) {\n\t\t\t\tString cow = cowInputStreamToString(cowInputStream);\n\t\t\t\treturn cow;\n\t\t\t}\n\t\t}\n\t\treturn null;  // should never happen\n\t}", "code_tokens": ["public", "static", "String", "load", "(", "final", "String", "cowfileSpec", ")", "{", "String", "effectiveCowfileSpec", "=", "(", "cowfileSpec", "!=", "null", ")", "?", "cowfileSpec", ".", "trim", "(", ")", ":", "DEFAULT_COW", ";", "if", "(", "effectiveCowfileSpec", ".", "length", "(", ")", ">", "0", ")", "{", "if", "(", "!", "effectiveCowfileSpec", ".", "endsWith", "(", "COWFILE_EXT", ")", ")", "{", "effectiveCowfileSpec", "+=", "COWFILE_EXT", ";", "}", "InputStream", "cowInputStream", ";", "if", "(", "effectiveCowfileSpec", ".", "indexOf", "(", "File", ".", "separatorChar", ")", ">=", "0", ")", "{", "cowInputStream", "=", "getCowFromPath", "(", "effectiveCowfileSpec", ")", ";", "}", "else", "{", "cowInputStream", "=", "getCowFromCowPath", "(", "effectiveCowfileSpec", ")", ";", "}", "if", "(", "cowInputStream", "==", "null", ")", "{", "// Maybe there should be a verbose mode where we log this sort of error instead of silently failing?", "cowInputStream", "=", "getCowFromResources", "(", "DEFAULT_COW", "+", "COWFILE_EXT", ")", ";", "}", "if", "(", "cowInputStream", "!=", "null", ")", "{", "String", "cow", "=", "cowInputStreamToString", "(", "cowInputStream", ")", ";", "return", "cow", ";", "}", "}", "return", "null", ";", "// should never happen", "}"], "docstring": "Call this with the provided cowfileSpec - that is the value passed to `-f` on the commandline.\n\n@param cowfileSpec If cowfileSpec contains a filepath separator it is interpreted as relative to CWD\notherwise the COWPATH will be searched. If not found on the COWPATH we will search for a bundled cowfile.\n@return The content of the specified cowfile (or default cowfile if cowfileSpec is null or empty).", "docstring_tokens": ["Call", "this", "with", "the", "provided", "cowfileSpec", "-", "that", "is", "the", "value", "passed", "to", "-", "f", "on", "the", "commandline", "."]}
{"code": "String cwd = System.getProperty(\"user.dir\");", "comments": "TODO is this really CWD?", "lines": 2, "repo": "ricksbrown/cowsay", "path": "src/main/java/com/github/ricksbrown/cowsay/Cowloader.java", "func_name": "Cowloader.getCowFromPath", "original_string": "private static InputStream getCowFromPath(final String path) {\n\t\tString cwd = System.getProperty(\"user.dir\");  // TODO is this really CWD?\n\t\tif (cwd != null) {\n\t\t\tFile cowfile = new File(cwd, path);\n\t\t\tif (isCowfile(cowfile)) {\n\t\t\t\treturn cowfileToCowInputStream(cowfile);\n\t\t\t}\n\t\t}\n\t\t// maybe it's an absolute path?\n\t\tFile cowfile = new File(path);\n\t\tif (isCowfile(cowfile)) {\n\t\t\treturn cowfileToCowInputStream(cowfile);\n\t\t}\n\t\treturn null;\n\t}", "language": "java", "Allcodes": "private static InputStream getCowFromPath(final String path) {\n\t\tString cwd = System.getProperty(\"user.dir\");  // TODO is this really CWD?\n\t\tif (cwd != null) {\n\t\t\tFile cowfile = new File(cwd, path);\n\t\t\tif (isCowfile(cowfile)) {\n\t\t\t\treturn cowfileToCowInputStream(cowfile);\n\t\t\t}\n\t\t}\n\t\t// maybe it's an absolute path?\n\t\tFile cowfile = new File(path);\n\t\tif (isCowfile(cowfile)) {\n\t\t\treturn cowfileToCowInputStream(cowfile);\n\t\t}\n\t\treturn null;\n\t}", "code_tokens": ["private", "static", "InputStream", "getCowFromPath", "(", "final", "String", "path", ")", "{", "String", "cwd", "=", "System", ".", "getProperty", "(", "\"user.dir\"", ")", ";", "// TODO is this really CWD?", "if", "(", "cwd", "!=", "null", ")", "{", "File", "cowfile", "=", "new", "File", "(", "cwd", ",", "path", ")", ";", "if", "(", "isCowfile", "(", "cowfile", ")", ")", "{", "return", "cowfileToCowInputStream", "(", "cowfile", ")", ";", "}", "}", "// maybe it's an absolute path?", "File", "cowfile", "=", "new", "File", "(", "path", ")", ";", "if", "(", "isCowfile", "(", "cowfile", ")", ")", "{", "return", "cowfileToCowInputStream", "(", "cowfile", ")", ";", "}", "return", "null", ";", "}"], "docstring": "In the case that the cowfileSpec is a filesystem path call this method to attempt to load the cowfile.\nIt will attempt to load the cowfile relative to CWD and if that fails it will try as an absolute path.\n@param path A path to a cowfile either relative to CWD or an absolute path.\n@return An InputStream to the cowfile if it exists.", "docstring_tokens": ["In", "the", "case", "that", "the", "cowfileSpec", "is", "a", "filesystem", "path", "call", "this", "method", "to", "attempt", "to", "load", "the", "cowfile", ".", "It", "will", "attempt", "to", "load", "the", "cowfile", "relative", "to", "CWD", "and", "if", "that", "fails", "it", "will", "try", "as", "an", "absolute", "path", "."]}
{"code": "300L);", "comments": "give InputMethodManager some time to recognise that the View is focused", "lines": 3, "repo": "pushbit/sprockets-android", "path": "sprockets/src/main/java/net/sf/sprockets/view/inputmethod/InputMethods.java", "func_name": "InputMethods.show", "original_string": "public static void show(View view) {\n        view.postDelayed(() -> Managers.inputMethod(view.getContext()).showSoftInput(view, 0),\n                300L); // give InputMethodManager some time to recognise that the View is focused\n    }", "language": "java", "Allcodes": "public static void show(View view) {\n        view.postDelayed(() -> Managers.inputMethod(view.getContext()).showSoftInput(view, 0),\n                300L); // give InputMethodManager some time to recognise that the View is focused\n    }", "code_tokens": ["public", "static", "void", "show", "(", "View", "view", ")", "{", "view", ".", "postDelayed", "(", "(", ")", "->", "Managers", ".", "inputMethod", "(", "view", ".", "getContext", "(", ")", ")", ".", "showSoftInput", "(", "view", ",", "0", ")", ",", "300L", ")", ";", "// give InputMethodManager some time to recognise that the View is focused", "}"], "docstring": "Show the current input method for the focused View which can receive input.", "docstring_tokens": ["Show", "the", "current", "input", "method", "for", "the", "focused", "View", "which", "can", "receive", "input", "."]}
{"code": "req.fit().centerCrop();", "comments": "view width/height isn't available yet", "lines": 7, "repo": "pushbit/sprockets-android", "path": "sprockets/src/main/java/net/sf/sprockets/databinding/BindingAdapters.java", "func_name": "BindingAdapters.load", "original_string": "@BindingAdapter(value = {\"sprockets_placeholder\", \"sprockets_load\", \"sprockets_resize\",\n            \"sprockets_transform\"}, requireAll = false)\n    public static void load(ImageView view, Drawable placeholder, Uri load, boolean resize,\n                            String transform) {\n        RequestCreator req = Picasso.with(view.getContext()).load(load).placeholder(placeholder);\n        if (resize) {\n            req.fit().centerCrop(); // view width/height isn't available yet\n        }\n        if (TextUtils.equals(transform, \"circle\")) {\n            req.transform(Transformations.circle());\n        }\n        req.into(view);\n    }", "language": "java", "Allcodes": "@BindingAdapter(value = {\"sprockets_placeholder\", \"sprockets_load\", \"sprockets_resize\",\n            \"sprockets_transform\"}, requireAll = false)\n    public static void load(ImageView view, Drawable placeholder, Uri load, boolean resize,\n                            String transform) {\n        RequestCreator req = Picasso.with(view.getContext()).load(load).placeholder(placeholder);\n        if (resize) {\n            req.fit().centerCrop(); // view width/height isn't available yet\n        }\n        if (TextUtils.equals(transform, \"circle\")) {\n            req.transform(Transformations.circle());\n        }\n        req.into(view);\n    }", "code_tokens": ["@", "BindingAdapter", "(", "value", "=", "{", "\"sprockets_placeholder\"", ",", "\"sprockets_load\"", ",", "\"sprockets_resize\"", ",", "\"sprockets_transform\"", "}", ",", "requireAll", "=", "false", ")", "public", "static", "void", "load", "(", "ImageView", "view", ",", "Drawable", "placeholder", ",", "Uri", "load", ",", "boolean", "resize", ",", "String", "transform", ")", "{", "RequestCreator", "req", "=", "Picasso", ".", "with", "(", "view", ".", "getContext", "(", ")", ")", ".", "load", "(", "load", ")", ".", "placeholder", "(", "placeholder", ")", ";", "if", "(", "resize", ")", "{", "req", ".", "fit", "(", ")", ".", "centerCrop", "(", ")", ";", "// view width/height isn't available yet", "}", "if", "(", "TextUtils", ".", "equals", "(", "transform", ",", "\"circle\"", ")", ")", "{", "req", ".", "transform", "(", "Transformations", ".", "circle", "(", ")", ")", ";", "}", "req", ".", "into", "(", "view", ")", ";", "}"], "docstring": "Set a placeholder before loading an image, optionally resizing and transforming it. All\nattributes are optional.\n\n@param transform can be \"circle\"", "docstring_tokens": ["Set", "a", "placeholder", "before", "loading", "an", "image", "optionally", "resizing", "and", "transforming", "it", ".", "All", "attributes", "are", "optional", "."]}
{"code": "return 1;", "comments": "assuming LinearLayoutManager", "lines": 9, "repo": "pushbit/sprockets-android", "path": "sprockets/src/main/java/net/sf/sprockets/widget/LayoutManagers.java", "func_name": "LayoutManagers.getSpanCount", "original_string": "public static int getSpanCount(RecyclerView view) {\n        LayoutManager layout = view.getLayoutManager();\n        if (layout != null) {\n            if (layout instanceof GridLayoutManager) {\n                return ((GridLayoutManager) layout).getSpanCount();\n            } else if (layout instanceof StaggeredGridLayoutManager) {\n                return ((StaggeredGridLayoutManager) layout).getSpanCount();\n            }\n            return 1; // assuming LinearLayoutManager\n        }\n        return 0;\n    }", "language": "java", "Allcodes": "public static int getSpanCount(RecyclerView view) {\n        LayoutManager layout = view.getLayoutManager();\n        if (layout != null) {\n            if (layout instanceof GridLayoutManager) {\n                return ((GridLayoutManager) layout).getSpanCount();\n            } else if (layout instanceof StaggeredGridLayoutManager) {\n                return ((StaggeredGridLayoutManager) layout).getSpanCount();\n            }\n            return 1; // assuming LinearLayoutManager\n        }\n        return 0;\n    }", "code_tokens": ["public", "static", "int", "getSpanCount", "(", "RecyclerView", "view", ")", "{", "LayoutManager", "layout", "=", "view", ".", "getLayoutManager", "(", ")", ";", "if", "(", "layout", "!=", "null", ")", "{", "if", "(", "layout", "instanceof", "GridLayoutManager", ")", "{", "return", "(", "(", "GridLayoutManager", ")", "layout", ")", ".", "getSpanCount", "(", ")", ";", "}", "else", "if", "(", "layout", "instanceof", "StaggeredGridLayoutManager", ")", "{", "return", "(", "(", "StaggeredGridLayoutManager", ")", "layout", ")", ".", "getSpanCount", "(", ")", ";", "}", "return", "1", ";", "// assuming LinearLayoutManager", "}", "return", "0", ";", "}"], "docstring": "Get the number of spans laid out by the RecyclerView's LayoutManager.\n\n@return 0 if the RecyclerView doesn't have a LayoutManager", "docstring_tokens": ["Get", "the", "number", "of", "spans", "laid", "out", "by", "the", "RecyclerView", "s", "LayoutManager", "."]}
{"code": "mDrawable = drawable;", "comments": "don't save until now so above is repeated until measured", "lines": 8, "repo": "pushbit/sprockets-android", "path": "sprockets/src/main/java/net/sf/sprockets/view/TranslateImagePageChangeListener.java", "func_name": "TranslateImagePageChangeListener.checkDrawable", "original_string": "private void checkDrawable() {\n        Drawable drawable = mView.getDrawable();\n        if (mDrawable != drawable) {\n            /* get the latest View size and ensure that it's been measured */\n            mViewWidth = mView.getWidth();\n            mViewHeight = mView.getHeight();\n            if (mViewWidth > 0 && mViewHeight > 0) {\n                mDrawable = drawable; // don't save until now so above is repeated until measured\n                if (mDrawable != null) {\n                    mDrawableWidth = mDrawable.getIntrinsicWidth();\n                    mDrawableHeight = mDrawable.getIntrinsicHeight();\n                    if (mDrawableWidth > 0 && mDrawableHeight > 0) { // e.g. colors don't have size\n                        float widthRatio = (float) mViewWidth / mDrawableWidth;\n                        float heightRatio = (float) mViewHeight / mDrawableHeight;\n                        mScale = widthRatio > heightRatio ? widthRatio : heightRatio;\n                    } else { // nothing to scale, ensure matrix is skipped\n                        mScale = 0.0f;\n                    }\n                }\n            } else { // don't update matrix until View is measured\n                mScale = 0.0f;\n            }\n            reset();\n        }\n    }", "language": "java", "Allcodes": "private void checkDrawable() {\n        Drawable drawable = mView.getDrawable();\n        if (mDrawable != drawable) {\n            /* get the latest View size and ensure that it's been measured */\n            mViewWidth = mView.getWidth();\n            mViewHeight = mView.getHeight();\n            if (mViewWidth > 0 && mViewHeight > 0) {\n                mDrawable = drawable; // don't save until now so above is repeated until measured\n                if (mDrawable != null) {\n                    mDrawableWidth = mDrawable.getIntrinsicWidth();\n                    mDrawableHeight = mDrawable.getIntrinsicHeight();\n                    if (mDrawableWidth > 0 && mDrawableHeight > 0) { // e.g. colors don't have size\n                        float widthRatio = (float) mViewWidth / mDrawableWidth;\n                        float heightRatio = (float) mViewHeight / mDrawableHeight;\n                        mScale = widthRatio > heightRatio ? widthRatio : heightRatio;\n                    } else { // nothing to scale, ensure matrix is skipped\n                        mScale = 0.0f;\n                    }\n                }\n            } else { // don't update matrix until View is measured\n                mScale = 0.0f;\n            }\n            reset();\n        }\n    }", "code_tokens": ["private", "void", "checkDrawable", "(", ")", "{", "Drawable", "drawable", "=", "mView", ".", "getDrawable", "(", ")", ";", "if", "(", "mDrawable", "!=", "drawable", ")", "{", "/* get the latest View size and ensure that it's been measured */", "mViewWidth", "=", "mView", ".", "getWidth", "(", ")", ";", "mViewHeight", "=", "mView", ".", "getHeight", "(", ")", ";", "if", "(", "mViewWidth", ">", "0", "&&", "mViewHeight", ">", "0", ")", "{", "mDrawable", "=", "drawable", ";", "// don't save until now so above is repeated until measured", "if", "(", "mDrawable", "!=", "null", ")", "{", "mDrawableWidth", "=", "mDrawable", ".", "getIntrinsicWidth", "(", ")", ";", "mDrawableHeight", "=", "mDrawable", ".", "getIntrinsicHeight", "(", ")", ";", "if", "(", "mDrawableWidth", ">", "0", "&&", "mDrawableHeight", ">", "0", ")", "{", "// e.g. colors don't have size", "float", "widthRatio", "=", "(", "float", ")", "mViewWidth", "/", "mDrawableWidth", ";", "float", "heightRatio", "=", "(", "float", ")", "mViewHeight", "/", "mDrawableHeight", ";", "mScale", "=", "widthRatio", ">", "heightRatio", "?", "widthRatio", ":", "heightRatio", ";", "}", "else", "{", "// nothing to scale, ensure matrix is skipped", "mScale", "=", "0.0f", ";", "}", "}", "}", "else", "{", "// don't update matrix until View is measured", "mScale", "=", "0.0f", ";", "}", "reset", "(", ")", ";", "}", "}"], "docstring": "Check if the ImageView has a new Drawable and calculate the new scaling if it does.", "docstring_tokens": ["Check", "if", "the", "ImageView", "has", "a", "new", "Drawable", "and", "calculate", "the", "new", "scaling", "if", "it", "does", "."]}
{"code": "Stack<Diff> equalities = new Stack<Diff>();", "comments": "Stack of equalities.", "lines": 6, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.diff_cleanupEfficiency", "original_string": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "language": "java", "Allcodes": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "code_tokens": ["public", "void", "diff_cleanupEfficiency", "(", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", ";", "}", "boolean", "changes", "=", "false", ";", "Stack", "<", "Diff", ">", "equalities", "=", "new", "Stack", "<", "Diff", ">", "(", ")", ";", "// Stack of equalities.", "String", "lastequality", "=", "null", ";", "// Always equal to equalities.lastElement().text", "ListIterator", "<", "Diff", ">", "pointer", "=", "diffs", ".", "listIterator", "(", ")", ";", "// Is there an insertion operation before the last equality.", "boolean", "pre_ins", "=", "false", ";", "// Is there a deletion operation before the last equality.", "boolean", "pre_del", "=", "false", ";", "// Is there an insertion operation after the last equality.", "boolean", "post_ins", "=", "false", ";", "// Is there a deletion operation after the last equality.", "boolean", "post_del", "=", "false", ";", "Diff", "thisDiff", "=", "pointer", ".", "next", "(", ")", ";", "Diff", "safeDiff", "=", "thisDiff", ";", "// The last Diff that is known to be unsplitable.", "while", "(", "thisDiff", "!=", "null", ")", "{", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "EQUAL", ")", "{", "// Equality found.", "if", "(", "thisDiff", ".", "text", ".", "length", "(", ")", "<", "Diff_EditCost", "&&", "(", "post_ins", "||", "post_del", ")", ")", "{", "// Candidate found.", "equalities", ".", "push", "(", "thisDiff", ")", ";", "pre_ins", "=", "post_ins", ";", "pre_del", "=", "post_del", ";", "lastequality", "=", "thisDiff", ".", "text", ";", "}", "else", "{", "// Not a candidate, and can never become one.", "equalities", ".", "clear", "(", ")", ";", "lastequality", "=", "null", ";", "safeDiff", "=", "thisDiff", ";", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "else", "{", "// An insertion or deletion.", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "DELETE", ")", "{", "post_del", "=", "true", ";", "}", "else", "{", "post_ins", "=", "true", ";", "}", "/*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */", "if", "(", "lastequality", "!=", "null", "&&", "(", "(", "pre_ins", "&&", "pre_del", "&&", "post_ins", "&&", "post_del", ")", "||", "(", "(", "lastequality", ".", "length", "(", ")", "<", "Diff_EditCost", "/", "2", ")", "&&", "(", "(", "pre_ins", "?", "1", ":", "0", ")", "+", "(", "pre_del", "?", "1", ":", "0", ")", "+", "(", "post_ins", "?", "1", ":", "0", ")", "+", "(", "post_del", "?", "1", ":", "0", ")", ")", "==", "3", ")", ")", ")", "{", "//System.out.println(\"Splitting: '\" + lastequality + \"'\");", "// Walk back to offending equality.", "while", "(", "thisDiff", "!=", "equalities", ".", "lastElement", "(", ")", ")", "{", "thisDiff", "=", "pointer", ".", "previous", "(", ")", ";", "}", "pointer", ".", "next", "(", ")", ";", "// Replace equality with a delete.", "pointer", ".", "set", "(", "new", "Diff", "(", "Operation", ".", "DELETE", ",", "lastequality", ")", ")", ";", "// Insert a corresponding an insert.", "pointer", ".", "add", "(", "thisDiff", "=", "new", "Diff", "(", "Operation", ".", "INSERT", ",", "lastequality", ")", ")", ";", "equalities", ".", "pop", "(", ")", ";", "// Throw away the equality we just deleted.", "lastequality", "=", "null", ";", "if", "(", "pre_ins", "&&", "pre_del", ")", "{", "// No changes made which could affect previous entry, keep going.", "post_ins", "=", "post_del", "=", "true", ";", "equalities", ".", "clear", "(", ")", ";", "safeDiff", "=", "thisDiff", ";", "}", "else", "{", "if", "(", "!", "equalities", ".", "empty", "(", ")", ")", "{", "// Throw away the previous equality (it needs to be reevaluated).", "equalities", ".", "pop", "(", ")", ";", "}", "if", "(", "equalities", ".", "empty", "(", ")", ")", "{", "// There are no previous questionable equalities,", "// walk back to the last known safe diff.", "thisDiff", "=", "safeDiff", ";", "}", "else", "{", "// There is an equality we can fall back to.", "thisDiff", "=", "equalities", ".", "lastElement", "(", ")", ";", "}", "while", "(", "thisDiff", "!=", "pointer", ".", "previous", "(", ")", ")", "{", "// Intentionally empty loop.", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "changes", "=", "true", ";", "}", "}", "thisDiff", "=", "pointer", ".", "hasNext", "(", ")", "?", "pointer", ".", "next", "(", ")", ":", "null", ";", "}", "if", "(", "changes", ")", "{", "diff_cleanupMerge", "(", "diffs", ")", ";", "}", "}"], "docstring": "Reduce the number of edits by eliminating operationally trivial equalities.\n@param diffs LinkedList of Diff objects.", "docstring_tokens": ["Reduce", "the", "number", "of", "edits", "by", "eliminating", "operationally", "trivial", "equalities", "."]}
{"code": "String lastequality = null;", "comments": "Always equal to equalities.lastElement().text", "lines": 7, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.diff_cleanupEfficiency", "original_string": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "language": "java", "Allcodes": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "code_tokens": ["public", "void", "diff_cleanupEfficiency", "(", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", ";", "}", "boolean", "changes", "=", "false", ";", "Stack", "<", "Diff", ">", "equalities", "=", "new", "Stack", "<", "Diff", ">", "(", ")", ";", "// Stack of equalities.", "String", "lastequality", "=", "null", ";", "// Always equal to equalities.lastElement().text", "ListIterator", "<", "Diff", ">", "pointer", "=", "diffs", ".", "listIterator", "(", ")", ";", "// Is there an insertion operation before the last equality.", "boolean", "pre_ins", "=", "false", ";", "// Is there a deletion operation before the last equality.", "boolean", "pre_del", "=", "false", ";", "// Is there an insertion operation after the last equality.", "boolean", "post_ins", "=", "false", ";", "// Is there a deletion operation after the last equality.", "boolean", "post_del", "=", "false", ";", "Diff", "thisDiff", "=", "pointer", ".", "next", "(", ")", ";", "Diff", "safeDiff", "=", "thisDiff", ";", "// The last Diff that is known to be unsplitable.", "while", "(", "thisDiff", "!=", "null", ")", "{", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "EQUAL", ")", "{", "// Equality found.", "if", "(", "thisDiff", ".", "text", ".", "length", "(", ")", "<", "Diff_EditCost", "&&", "(", "post_ins", "||", "post_del", ")", ")", "{", "// Candidate found.", "equalities", ".", "push", "(", "thisDiff", ")", ";", "pre_ins", "=", "post_ins", ";", "pre_del", "=", "post_del", ";", "lastequality", "=", "thisDiff", ".", "text", ";", "}", "else", "{", "// Not a candidate, and can never become one.", "equalities", ".", "clear", "(", ")", ";", "lastequality", "=", "null", ";", "safeDiff", "=", "thisDiff", ";", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "else", "{", "// An insertion or deletion.", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "DELETE", ")", "{", "post_del", "=", "true", ";", "}", "else", "{", "post_ins", "=", "true", ";", "}", "/*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */", "if", "(", "lastequality", "!=", "null", "&&", "(", "(", "pre_ins", "&&", "pre_del", "&&", "post_ins", "&&", "post_del", ")", "||", "(", "(", "lastequality", ".", "length", "(", ")", "<", "Diff_EditCost", "/", "2", ")", "&&", "(", "(", "pre_ins", "?", "1", ":", "0", ")", "+", "(", "pre_del", "?", "1", ":", "0", ")", "+", "(", "post_ins", "?", "1", ":", "0", ")", "+", "(", "post_del", "?", "1", ":", "0", ")", ")", "==", "3", ")", ")", ")", "{", "//System.out.println(\"Splitting: '\" + lastequality + \"'\");", "// Walk back to offending equality.", "while", "(", "thisDiff", "!=", "equalities", ".", "lastElement", "(", ")", ")", "{", "thisDiff", "=", "pointer", ".", "previous", "(", ")", ";", "}", "pointer", ".", "next", "(", ")", ";", "// Replace equality with a delete.", "pointer", ".", "set", "(", "new", "Diff", "(", "Operation", ".", "DELETE", ",", "lastequality", ")", ")", ";", "// Insert a corresponding an insert.", "pointer", ".", "add", "(", "thisDiff", "=", "new", "Diff", "(", "Operation", ".", "INSERT", ",", "lastequality", ")", ")", ";", "equalities", ".", "pop", "(", ")", ";", "// Throw away the equality we just deleted.", "lastequality", "=", "null", ";", "if", "(", "pre_ins", "&&", "pre_del", ")", "{", "// No changes made which could affect previous entry, keep going.", "post_ins", "=", "post_del", "=", "true", ";", "equalities", ".", "clear", "(", ")", ";", "safeDiff", "=", "thisDiff", ";", "}", "else", "{", "if", "(", "!", "equalities", ".", "empty", "(", ")", ")", "{", "// Throw away the previous equality (it needs to be reevaluated).", "equalities", ".", "pop", "(", ")", ";", "}", "if", "(", "equalities", ".", "empty", "(", ")", ")", "{", "// There are no previous questionable equalities,", "// walk back to the last known safe diff.", "thisDiff", "=", "safeDiff", ";", "}", "else", "{", "// There is an equality we can fall back to.", "thisDiff", "=", "equalities", ".", "lastElement", "(", ")", ";", "}", "while", "(", "thisDiff", "!=", "pointer", ".", "previous", "(", ")", ")", "{", "// Intentionally empty loop.", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "changes", "=", "true", ";", "}", "}", "thisDiff", "=", "pointer", ".", "hasNext", "(", ")", "?", "pointer", ".", "next", "(", ")", ":", "null", ";", "}", "if", "(", "changes", ")", "{", "diff_cleanupMerge", "(", "diffs", ")", ";", "}", "}"], "docstring": "Reduce the number of edits by eliminating operationally trivial equalities.\n@param diffs LinkedList of Diff objects.", "docstring_tokens": ["Reduce", "the", "number", "of", "edits", "by", "eliminating", "operationally", "trivial", "equalities", "."]}
{"code": "Diff safeDiff = thisDiff;", "comments": "The last Diff that is known to be unsplitable.", "lines": 18, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.diff_cleanupEfficiency", "original_string": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "language": "java", "Allcodes": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "code_tokens": ["public", "void", "diff_cleanupEfficiency", "(", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", ";", "}", "boolean", "changes", "=", "false", ";", "Stack", "<", "Diff", ">", "equalities", "=", "new", "Stack", "<", "Diff", ">", "(", ")", ";", "// Stack of equalities.", "String", "lastequality", "=", "null", ";", "// Always equal to equalities.lastElement().text", "ListIterator", "<", "Diff", ">", "pointer", "=", "diffs", ".", "listIterator", "(", ")", ";", "// Is there an insertion operation before the last equality.", "boolean", "pre_ins", "=", "false", ";", "// Is there a deletion operation before the last equality.", "boolean", "pre_del", "=", "false", ";", "// Is there an insertion operation after the last equality.", "boolean", "post_ins", "=", "false", ";", "// Is there a deletion operation after the last equality.", "boolean", "post_del", "=", "false", ";", "Diff", "thisDiff", "=", "pointer", ".", "next", "(", ")", ";", "Diff", "safeDiff", "=", "thisDiff", ";", "// The last Diff that is known to be unsplitable.", "while", "(", "thisDiff", "!=", "null", ")", "{", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "EQUAL", ")", "{", "// Equality found.", "if", "(", "thisDiff", ".", "text", ".", "length", "(", ")", "<", "Diff_EditCost", "&&", "(", "post_ins", "||", "post_del", ")", ")", "{", "// Candidate found.", "equalities", ".", "push", "(", "thisDiff", ")", ";", "pre_ins", "=", "post_ins", ";", "pre_del", "=", "post_del", ";", "lastequality", "=", "thisDiff", ".", "text", ";", "}", "else", "{", "// Not a candidate, and can never become one.", "equalities", ".", "clear", "(", ")", ";", "lastequality", "=", "null", ";", "safeDiff", "=", "thisDiff", ";", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "else", "{", "// An insertion or deletion.", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "DELETE", ")", "{", "post_del", "=", "true", ";", "}", "else", "{", "post_ins", "=", "true", ";", "}", "/*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */", "if", "(", "lastequality", "!=", "null", "&&", "(", "(", "pre_ins", "&&", "pre_del", "&&", "post_ins", "&&", "post_del", ")", "||", "(", "(", "lastequality", ".", "length", "(", ")", "<", "Diff_EditCost", "/", "2", ")", "&&", "(", "(", "pre_ins", "?", "1", ":", "0", ")", "+", "(", "pre_del", "?", "1", ":", "0", ")", "+", "(", "post_ins", "?", "1", ":", "0", ")", "+", "(", "post_del", "?", "1", ":", "0", ")", ")", "==", "3", ")", ")", ")", "{", "//System.out.println(\"Splitting: '\" + lastequality + \"'\");", "// Walk back to offending equality.", "while", "(", "thisDiff", "!=", "equalities", ".", "lastElement", "(", ")", ")", "{", "thisDiff", "=", "pointer", ".", "previous", "(", ")", ";", "}", "pointer", ".", "next", "(", ")", ";", "// Replace equality with a delete.", "pointer", ".", "set", "(", "new", "Diff", "(", "Operation", ".", "DELETE", ",", "lastequality", ")", ")", ";", "// Insert a corresponding an insert.", "pointer", ".", "add", "(", "thisDiff", "=", "new", "Diff", "(", "Operation", ".", "INSERT", ",", "lastequality", ")", ")", ";", "equalities", ".", "pop", "(", ")", ";", "// Throw away the equality we just deleted.", "lastequality", "=", "null", ";", "if", "(", "pre_ins", "&&", "pre_del", ")", "{", "// No changes made which could affect previous entry, keep going.", "post_ins", "=", "post_del", "=", "true", ";", "equalities", ".", "clear", "(", ")", ";", "safeDiff", "=", "thisDiff", ";", "}", "else", "{", "if", "(", "!", "equalities", ".", "empty", "(", ")", ")", "{", "// Throw away the previous equality (it needs to be reevaluated).", "equalities", ".", "pop", "(", ")", ";", "}", "if", "(", "equalities", ".", "empty", "(", ")", ")", "{", "// There are no previous questionable equalities,", "// walk back to the last known safe diff.", "thisDiff", "=", "safeDiff", ";", "}", "else", "{", "// There is an equality we can fall back to.", "thisDiff", "=", "equalities", ".", "lastElement", "(", ")", ";", "}", "while", "(", "thisDiff", "!=", "pointer", ".", "previous", "(", ")", ")", "{", "// Intentionally empty loop.", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "changes", "=", "true", ";", "}", "}", "thisDiff", "=", "pointer", ".", "hasNext", "(", ")", "?", "pointer", ".", "next", "(", ")", ":", "null", ";", "}", "if", "(", "changes", ")", "{", "diff_cleanupMerge", "(", "diffs", ")", ";", "}", "}"], "docstring": "Reduce the number of edits by eliminating operationally trivial equalities.\n@param diffs LinkedList of Diff objects.", "docstring_tokens": ["Reduce", "the", "number", "of", "edits", "by", "eliminating", "operationally", "trivial", "equalities", "."]}
{"code": "equalities.pop();", "comments": "Throw away the equality we just deleted.", "lines": 67, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.diff_cleanupEfficiency", "original_string": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "language": "java", "Allcodes": "public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {\n    if (diffs.isEmpty()) {\n      return;\n    }\n    boolean changes = false;\n    Stack<Diff> equalities = new Stack<Diff>();  // Stack of equalities.\n    String lastequality = null; // Always equal to equalities.lastElement().text\n    ListIterator<Diff> pointer = diffs.listIterator();\n    // Is there an insertion operation before the last equality.\n    boolean pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    boolean pre_del = false;\n    // Is there an insertion operation after the last equality.\n    boolean post_ins = false;\n    // Is there a deletion operation after the last equality.\n    boolean post_del = false;\n    Diff thisDiff = pointer.next();\n    Diff safeDiff = thisDiff;  // The last Diff that is known to be unsplitable.\n    while (thisDiff != null) {\n      if (thisDiff.operation == Operation.EQUAL) {\n        // Equality found.\n        if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\n          // Candidate found.\n          equalities.push(thisDiff);\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = thisDiff.text;\n        } else {\n          // Not a candidate, and can never become one.\n          equalities.clear();\n          lastequality = null;\n          safeDiff = thisDiff;\n        }\n        post_ins = post_del = false;\n      } else {\n        // An insertion or deletion.\n        if (thisDiff.operation == Operation.DELETE) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality != null\n            && ((pre_ins && pre_del && post_ins && post_del)\n                || ((lastequality.length() < Diff_EditCost / 2)\n                    && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0)\n                        + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\n          //System.out.println(\"Splitting: '\" + lastequality + \"'\");\n          // Walk back to offending equality.\n          while (thisDiff != equalities.lastElement()) {\n            thisDiff = pointer.previous();\n          }\n          pointer.next();\n\n          // Replace equality with a delete.\n          pointer.set(new Diff(Operation.DELETE, lastequality));\n          // Insert a corresponding an insert.\n          pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\n\n          equalities.pop();  // Throw away the equality we just deleted.\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalities.clear();\n            safeDiff = thisDiff;\n          } else {\n            if (!equalities.empty()) {\n              // Throw away the previous equality (it needs to be reevaluated).\n              equalities.pop();\n            }\n            if (equalities.empty()) {\n              // There are no previous questionable equalities,\n              // walk back to the last known safe diff.\n              thisDiff = safeDiff;\n            } else {\n              // There is an equality we can fall back to.\n              thisDiff = equalities.lastElement();\n            }\n            while (thisDiff != pointer.previous()) {\n              // Intentionally empty loop.\n            }\n            post_ins = post_del = false;\n          }\n\n          changes = true;\n        }\n      }\n      thisDiff = pointer.hasNext() ? pointer.next() : null;\n    }\n\n    if (changes) {\n      diff_cleanupMerge(diffs);\n    }\n  }", "code_tokens": ["public", "void", "diff_cleanupEfficiency", "(", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", ";", "}", "boolean", "changes", "=", "false", ";", "Stack", "<", "Diff", ">", "equalities", "=", "new", "Stack", "<", "Diff", ">", "(", ")", ";", "// Stack of equalities.", "String", "lastequality", "=", "null", ";", "// Always equal to equalities.lastElement().text", "ListIterator", "<", "Diff", ">", "pointer", "=", "diffs", ".", "listIterator", "(", ")", ";", "// Is there an insertion operation before the last equality.", "boolean", "pre_ins", "=", "false", ";", "// Is there a deletion operation before the last equality.", "boolean", "pre_del", "=", "false", ";", "// Is there an insertion operation after the last equality.", "boolean", "post_ins", "=", "false", ";", "// Is there a deletion operation after the last equality.", "boolean", "post_del", "=", "false", ";", "Diff", "thisDiff", "=", "pointer", ".", "next", "(", ")", ";", "Diff", "safeDiff", "=", "thisDiff", ";", "// The last Diff that is known to be unsplitable.", "while", "(", "thisDiff", "!=", "null", ")", "{", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "EQUAL", ")", "{", "// Equality found.", "if", "(", "thisDiff", ".", "text", ".", "length", "(", ")", "<", "Diff_EditCost", "&&", "(", "post_ins", "||", "post_del", ")", ")", "{", "// Candidate found.", "equalities", ".", "push", "(", "thisDiff", ")", ";", "pre_ins", "=", "post_ins", ";", "pre_del", "=", "post_del", ";", "lastequality", "=", "thisDiff", ".", "text", ";", "}", "else", "{", "// Not a candidate, and can never become one.", "equalities", ".", "clear", "(", ")", ";", "lastequality", "=", "null", ";", "safeDiff", "=", "thisDiff", ";", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "else", "{", "// An insertion or deletion.", "if", "(", "thisDiff", ".", "operation", "==", "Operation", ".", "DELETE", ")", "{", "post_del", "=", "true", ";", "}", "else", "{", "post_ins", "=", "true", ";", "}", "/*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */", "if", "(", "lastequality", "!=", "null", "&&", "(", "(", "pre_ins", "&&", "pre_del", "&&", "post_ins", "&&", "post_del", ")", "||", "(", "(", "lastequality", ".", "length", "(", ")", "<", "Diff_EditCost", "/", "2", ")", "&&", "(", "(", "pre_ins", "?", "1", ":", "0", ")", "+", "(", "pre_del", "?", "1", ":", "0", ")", "+", "(", "post_ins", "?", "1", ":", "0", ")", "+", "(", "post_del", "?", "1", ":", "0", ")", ")", "==", "3", ")", ")", ")", "{", "//System.out.println(\"Splitting: '\" + lastequality + \"'\");", "// Walk back to offending equality.", "while", "(", "thisDiff", "!=", "equalities", ".", "lastElement", "(", ")", ")", "{", "thisDiff", "=", "pointer", ".", "previous", "(", ")", ";", "}", "pointer", ".", "next", "(", ")", ";", "// Replace equality with a delete.", "pointer", ".", "set", "(", "new", "Diff", "(", "Operation", ".", "DELETE", ",", "lastequality", ")", ")", ";", "// Insert a corresponding an insert.", "pointer", ".", "add", "(", "thisDiff", "=", "new", "Diff", "(", "Operation", ".", "INSERT", ",", "lastequality", ")", ")", ";", "equalities", ".", "pop", "(", ")", ";", "// Throw away the equality we just deleted.", "lastequality", "=", "null", ";", "if", "(", "pre_ins", "&&", "pre_del", ")", "{", "// No changes made which could affect previous entry, keep going.", "post_ins", "=", "post_del", "=", "true", ";", "equalities", ".", "clear", "(", ")", ";", "safeDiff", "=", "thisDiff", ";", "}", "else", "{", "if", "(", "!", "equalities", ".", "empty", "(", ")", ")", "{", "// Throw away the previous equality (it needs to be reevaluated).", "equalities", ".", "pop", "(", ")", ";", "}", "if", "(", "equalities", ".", "empty", "(", ")", ")", "{", "// There are no previous questionable equalities,", "// walk back to the last known safe diff.", "thisDiff", "=", "safeDiff", ";", "}", "else", "{", "// There is an equality we can fall back to.", "thisDiff", "=", "equalities", ".", "lastElement", "(", ")", ";", "}", "while", "(", "thisDiff", "!=", "pointer", ".", "previous", "(", ")", ")", "{", "// Intentionally empty loop.", "}", "post_ins", "=", "post_del", "=", "false", ";", "}", "changes", "=", "true", ";", "}", "}", "thisDiff", "=", "pointer", ".", "hasNext", "(", ")", "?", "pointer", ".", "next", "(", ")", ":", "null", ";", "}", "if", "(", "changes", ")", "{", "diff_cleanupMerge", "(", "diffs", ")", ";", "}", "}"], "docstring": "Reduce the number of edits by eliminating operationally trivial equalities.\n@param diffs LinkedList of Diff objects.", "docstring_tokens": ["Reduce", "the", "number", "of", "edits", "by", "eliminating", "operationally", "trivial", "equalities", "."]}
{"code": "return patches;", "comments": "Get rid of the null case.", "lines": 8, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.patch_make", "original_string": "public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {\n    if (text1 == null || diffs == null) {\n      throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\n    }\n\n    LinkedList<Patch> patches = new LinkedList<Patch>();\n    if (diffs.isEmpty()) {\n      return patches;  // Get rid of the null case.\n    }\n    Patch patch = new Patch();\n    int char_count1 = 0;  // Number of characters into the text1 string.\n    int char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text). We recreate the patches one by one to determine\n    // context info.\n    String prepatch_text = text1;\n    String postpatch_text = text1;\n    for (Diff aDiff : diffs) {\n      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (aDiff.operation) {\n      case INSERT:\n        patch.diffs.add(aDiff);\n        patch.length2 += aDiff.text.length();\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + aDiff.text + postpatch_text.substring(char_count2);\n        break;\n      case DELETE:\n        patch.length1 += aDiff.text.length();\n        patch.diffs.add(aDiff);\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + postpatch_text.substring(char_count2 + aDiff.text.length());\n        break;\n      case EQUAL:\n        if (aDiff.text.length() <= 2 * Patch_Margin\n            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\n          // Small equality inside a patch.\n          patch.diffs.add(aDiff);\n          patch.length1 += aDiff.text.length();\n          patch.length2 += aDiff.text.length();\n        }\n\n        if (aDiff.text.length() >= 2 * Patch_Margin) {\n          // Time for a new patch.\n          if (!patch.diffs.isEmpty()) {\n            patch_addContext(patch, prepatch_text);\n            patches.add(patch);\n            patch = new Patch();\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n      }\n\n      // Update the current character count.\n      if (aDiff.operation != Operation.INSERT) {\n        char_count1 += aDiff.text.length();\n      }\n      if (aDiff.operation != Operation.DELETE) {\n        char_count2 += aDiff.text.length();\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (!patch.diffs.isEmpty()) {\n      patch_addContext(patch, prepatch_text);\n      patches.add(patch);\n    }\n\n    return patches;\n  }", "language": "java", "Allcodes": "public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {\n    if (text1 == null || diffs == null) {\n      throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\n    }\n\n    LinkedList<Patch> patches = new LinkedList<Patch>();\n    if (diffs.isEmpty()) {\n      return patches;  // Get rid of the null case.\n    }\n    Patch patch = new Patch();\n    int char_count1 = 0;  // Number of characters into the text1 string.\n    int char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text). We recreate the patches one by one to determine\n    // context info.\n    String prepatch_text = text1;\n    String postpatch_text = text1;\n    for (Diff aDiff : diffs) {\n      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (aDiff.operation) {\n      case INSERT:\n        patch.diffs.add(aDiff);\n        patch.length2 += aDiff.text.length();\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + aDiff.text + postpatch_text.substring(char_count2);\n        break;\n      case DELETE:\n        patch.length1 += aDiff.text.length();\n        patch.diffs.add(aDiff);\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + postpatch_text.substring(char_count2 + aDiff.text.length());\n        break;\n      case EQUAL:\n        if (aDiff.text.length() <= 2 * Patch_Margin\n            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\n          // Small equality inside a patch.\n          patch.diffs.add(aDiff);\n          patch.length1 += aDiff.text.length();\n          patch.length2 += aDiff.text.length();\n        }\n\n        if (aDiff.text.length() >= 2 * Patch_Margin) {\n          // Time for a new patch.\n          if (!patch.diffs.isEmpty()) {\n            patch_addContext(patch, prepatch_text);\n            patches.add(patch);\n            patch = new Patch();\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n      }\n\n      // Update the current character count.\n      if (aDiff.operation != Operation.INSERT) {\n        char_count1 += aDiff.text.length();\n      }\n      if (aDiff.operation != Operation.DELETE) {\n        char_count2 += aDiff.text.length();\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (!patch.diffs.isEmpty()) {\n      patch_addContext(patch, prepatch_text);\n      patches.add(patch);\n    }\n\n    return patches;\n  }", "code_tokens": ["public", "LinkedList", "<", "Patch", ">", "patch_make", "(", "String", "text1", ",", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "text1", "==", "null", "||", "diffs", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Null inputs. (patch_make)\"", ")", ";", "}", "LinkedList", "<", "Patch", ">", "patches", "=", "new", "LinkedList", "<", "Patch", ">", "(", ")", ";", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", "patches", ";", "// Get rid of the null case.", "}", "Patch", "patch", "=", "new", "Patch", "(", ")", ";", "int", "char_count1", "=", "0", ";", "// Number of characters into the text1 string.", "int", "char_count2", "=", "0", ";", "// Number of characters into the text2 string.", "// Start with text1 (prepatch_text) and apply the diffs until we arrive at", "// text2 (postpatch_text). We recreate the patches one by one to determine", "// context info.", "String", "prepatch_text", "=", "text1", ";", "String", "postpatch_text", "=", "text1", ";", "for", "(", "Diff", "aDiff", ":", "diffs", ")", "{", "if", "(", "patch", ".", "diffs", ".", "isEmpty", "(", ")", "&&", "aDiff", ".", "operation", "!=", "Operation", ".", "EQUAL", ")", "{", "// A new patch starts here.", "patch", ".", "start1", "=", "char_count1", ";", "patch", ".", "start2", "=", "char_count2", ";", "}", "switch", "(", "aDiff", ".", "operation", ")", "{", "case", "INSERT", ":", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "patch", ".", "length2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "postpatch_text", "=", "postpatch_text", ".", "substring", "(", "0", ",", "char_count2", ")", "+", "aDiff", ".", "text", "+", "postpatch_text", ".", "substring", "(", "char_count2", ")", ";", "break", ";", "case", "DELETE", ":", "patch", ".", "length1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "postpatch_text", "=", "postpatch_text", ".", "substring", "(", "0", ",", "char_count2", ")", "+", "postpatch_text", ".", "substring", "(", "char_count2", "+", "aDiff", ".", "text", ".", "length", "(", ")", ")", ";", "break", ";", "case", "EQUAL", ":", "if", "(", "aDiff", ".", "text", ".", "length", "(", ")", "<=", "2", "*", "Patch_Margin", "&&", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", "&&", "aDiff", "!=", "diffs", ".", "getLast", "(", ")", ")", "{", "// Small equality inside a patch.", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "patch", ".", "length1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "patch", ".", "length2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "if", "(", "aDiff", ".", "text", ".", "length", "(", ")", ">=", "2", "*", "Patch_Margin", ")", "{", "// Time for a new patch.", "if", "(", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", ")", "{", "patch_addContext", "(", "patch", ",", "prepatch_text", ")", ";", "patches", ".", "add", "(", "patch", ")", ";", "patch", "=", "new", "Patch", "(", ")", ";", "// Unlike Unidiff, our patch lists have a rolling context.", "// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff", "// Update prepatch text & pos to reflect the application of the", "// just completed patch.", "prepatch_text", "=", "postpatch_text", ";", "char_count1", "=", "char_count2", ";", "}", "}", "break", ";", "}", "// Update the current character count.", "if", "(", "aDiff", ".", "operation", "!=", "Operation", ".", "INSERT", ")", "{", "char_count1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "if", "(", "aDiff", ".", "operation", "!=", "Operation", ".", "DELETE", ")", "{", "char_count2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "}", "// Pick up the leftover patch if not empty.", "if", "(", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", ")", "{", "patch_addContext", "(", "patch", ",", "prepatch_text", ")", ";", "patches", ".", "add", "(", "patch", ")", ";", "}", "return", "patches", ";", "}"], "docstring": "Compute a list of patches to turn text1 into text2.\ntext2 is not provided, diffs are the delta between text1 and text2.\n@param text1 Old text.\n@param diffs Array of Diff objects for text1 to text2.\n@return LinkedList of Patch objects.", "docstring_tokens": ["Compute", "a", "list", "of", "patches", "to", "turn", "text1", "into", "text2", ".", "text2", "is", "not", "provided", "diffs", "are", "the", "delta", "between", "text1", "and", "text2", "."]}
{"code": "int char_count1 = 0;", "comments": "Number of characters into the text1 string.", "lines": 11, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.patch_make", "original_string": "public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {\n    if (text1 == null || diffs == null) {\n      throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\n    }\n\n    LinkedList<Patch> patches = new LinkedList<Patch>();\n    if (diffs.isEmpty()) {\n      return patches;  // Get rid of the null case.\n    }\n    Patch patch = new Patch();\n    int char_count1 = 0;  // Number of characters into the text1 string.\n    int char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text). We recreate the patches one by one to determine\n    // context info.\n    String prepatch_text = text1;\n    String postpatch_text = text1;\n    for (Diff aDiff : diffs) {\n      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (aDiff.operation) {\n      case INSERT:\n        patch.diffs.add(aDiff);\n        patch.length2 += aDiff.text.length();\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + aDiff.text + postpatch_text.substring(char_count2);\n        break;\n      case DELETE:\n        patch.length1 += aDiff.text.length();\n        patch.diffs.add(aDiff);\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + postpatch_text.substring(char_count2 + aDiff.text.length());\n        break;\n      case EQUAL:\n        if (aDiff.text.length() <= 2 * Patch_Margin\n            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\n          // Small equality inside a patch.\n          patch.diffs.add(aDiff);\n          patch.length1 += aDiff.text.length();\n          patch.length2 += aDiff.text.length();\n        }\n\n        if (aDiff.text.length() >= 2 * Patch_Margin) {\n          // Time for a new patch.\n          if (!patch.diffs.isEmpty()) {\n            patch_addContext(patch, prepatch_text);\n            patches.add(patch);\n            patch = new Patch();\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n      }\n\n      // Update the current character count.\n      if (aDiff.operation != Operation.INSERT) {\n        char_count1 += aDiff.text.length();\n      }\n      if (aDiff.operation != Operation.DELETE) {\n        char_count2 += aDiff.text.length();\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (!patch.diffs.isEmpty()) {\n      patch_addContext(patch, prepatch_text);\n      patches.add(patch);\n    }\n\n    return patches;\n  }", "language": "java", "Allcodes": "public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {\n    if (text1 == null || diffs == null) {\n      throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\n    }\n\n    LinkedList<Patch> patches = new LinkedList<Patch>();\n    if (diffs.isEmpty()) {\n      return patches;  // Get rid of the null case.\n    }\n    Patch patch = new Patch();\n    int char_count1 = 0;  // Number of characters into the text1 string.\n    int char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text). We recreate the patches one by one to determine\n    // context info.\n    String prepatch_text = text1;\n    String postpatch_text = text1;\n    for (Diff aDiff : diffs) {\n      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (aDiff.operation) {\n      case INSERT:\n        patch.diffs.add(aDiff);\n        patch.length2 += aDiff.text.length();\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + aDiff.text + postpatch_text.substring(char_count2);\n        break;\n      case DELETE:\n        patch.length1 += aDiff.text.length();\n        patch.diffs.add(aDiff);\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + postpatch_text.substring(char_count2 + aDiff.text.length());\n        break;\n      case EQUAL:\n        if (aDiff.text.length() <= 2 * Patch_Margin\n            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\n          // Small equality inside a patch.\n          patch.diffs.add(aDiff);\n          patch.length1 += aDiff.text.length();\n          patch.length2 += aDiff.text.length();\n        }\n\n        if (aDiff.text.length() >= 2 * Patch_Margin) {\n          // Time for a new patch.\n          if (!patch.diffs.isEmpty()) {\n            patch_addContext(patch, prepatch_text);\n            patches.add(patch);\n            patch = new Patch();\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n      }\n\n      // Update the current character count.\n      if (aDiff.operation != Operation.INSERT) {\n        char_count1 += aDiff.text.length();\n      }\n      if (aDiff.operation != Operation.DELETE) {\n        char_count2 += aDiff.text.length();\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (!patch.diffs.isEmpty()) {\n      patch_addContext(patch, prepatch_text);\n      patches.add(patch);\n    }\n\n    return patches;\n  }", "code_tokens": ["public", "LinkedList", "<", "Patch", ">", "patch_make", "(", "String", "text1", ",", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "text1", "==", "null", "||", "diffs", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Null inputs. (patch_make)\"", ")", ";", "}", "LinkedList", "<", "Patch", ">", "patches", "=", "new", "LinkedList", "<", "Patch", ">", "(", ")", ";", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", "patches", ";", "// Get rid of the null case.", "}", "Patch", "patch", "=", "new", "Patch", "(", ")", ";", "int", "char_count1", "=", "0", ";", "// Number of characters into the text1 string.", "int", "char_count2", "=", "0", ";", "// Number of characters into the text2 string.", "// Start with text1 (prepatch_text) and apply the diffs until we arrive at", "// text2 (postpatch_text). We recreate the patches one by one to determine", "// context info.", "String", "prepatch_text", "=", "text1", ";", "String", "postpatch_text", "=", "text1", ";", "for", "(", "Diff", "aDiff", ":", "diffs", ")", "{", "if", "(", "patch", ".", "diffs", ".", "isEmpty", "(", ")", "&&", "aDiff", ".", "operation", "!=", "Operation", ".", "EQUAL", ")", "{", "// A new patch starts here.", "patch", ".", "start1", "=", "char_count1", ";", "patch", ".", "start2", "=", "char_count2", ";", "}", "switch", "(", "aDiff", ".", "operation", ")", "{", "case", "INSERT", ":", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "patch", ".", "length2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "postpatch_text", "=", "postpatch_text", ".", "substring", "(", "0", ",", "char_count2", ")", "+", "aDiff", ".", "text", "+", "postpatch_text", ".", "substring", "(", "char_count2", ")", ";", "break", ";", "case", "DELETE", ":", "patch", ".", "length1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "postpatch_text", "=", "postpatch_text", ".", "substring", "(", "0", ",", "char_count2", ")", "+", "postpatch_text", ".", "substring", "(", "char_count2", "+", "aDiff", ".", "text", ".", "length", "(", ")", ")", ";", "break", ";", "case", "EQUAL", ":", "if", "(", "aDiff", ".", "text", ".", "length", "(", ")", "<=", "2", "*", "Patch_Margin", "&&", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", "&&", "aDiff", "!=", "diffs", ".", "getLast", "(", ")", ")", "{", "// Small equality inside a patch.", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "patch", ".", "length1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "patch", ".", "length2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "if", "(", "aDiff", ".", "text", ".", "length", "(", ")", ">=", "2", "*", "Patch_Margin", ")", "{", "// Time for a new patch.", "if", "(", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", ")", "{", "patch_addContext", "(", "patch", ",", "prepatch_text", ")", ";", "patches", ".", "add", "(", "patch", ")", ";", "patch", "=", "new", "Patch", "(", ")", ";", "// Unlike Unidiff, our patch lists have a rolling context.", "// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff", "// Update prepatch text & pos to reflect the application of the", "// just completed patch.", "prepatch_text", "=", "postpatch_text", ";", "char_count1", "=", "char_count2", ";", "}", "}", "break", ";", "}", "// Update the current character count.", "if", "(", "aDiff", ".", "operation", "!=", "Operation", ".", "INSERT", ")", "{", "char_count1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "if", "(", "aDiff", ".", "operation", "!=", "Operation", ".", "DELETE", ")", "{", "char_count2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "}", "// Pick up the leftover patch if not empty.", "if", "(", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", ")", "{", "patch_addContext", "(", "patch", ",", "prepatch_text", ")", ";", "patches", ".", "add", "(", "patch", ")", ";", "}", "return", "patches", ";", "}"], "docstring": "Compute a list of patches to turn text1 into text2.\ntext2 is not provided, diffs are the delta between text1 and text2.\n@param text1 Old text.\n@param diffs Array of Diff objects for text1 to text2.\n@return LinkedList of Patch objects.", "docstring_tokens": ["Compute", "a", "list", "of", "patches", "to", "turn", "text1", "into", "text2", ".", "text2", "is", "not", "provided", "diffs", "are", "the", "delta", "between", "text1", "and", "text2", "."]}
{"code": "int char_count2 = 0;", "comments": "Number of characters into the text2 string.", "lines": 12, "repo": "sksamuel/google-diff-match-patch", "path": "src/main/java/com/sksamuel/diffpatch/DiffMatchPatch.java", "func_name": "DiffMatchPatch.patch_make", "original_string": "public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {\n    if (text1 == null || diffs == null) {\n      throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\n    }\n\n    LinkedList<Patch> patches = new LinkedList<Patch>();\n    if (diffs.isEmpty()) {\n      return patches;  // Get rid of the null case.\n    }\n    Patch patch = new Patch();\n    int char_count1 = 0;  // Number of characters into the text1 string.\n    int char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text). We recreate the patches one by one to determine\n    // context info.\n    String prepatch_text = text1;\n    String postpatch_text = text1;\n    for (Diff aDiff : diffs) {\n      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (aDiff.operation) {\n      case INSERT:\n        patch.diffs.add(aDiff);\n        patch.length2 += aDiff.text.length();\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + aDiff.text + postpatch_text.substring(char_count2);\n        break;\n      case DELETE:\n        patch.length1 += aDiff.text.length();\n        patch.diffs.add(aDiff);\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + postpatch_text.substring(char_count2 + aDiff.text.length());\n        break;\n      case EQUAL:\n        if (aDiff.text.length() <= 2 * Patch_Margin\n            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\n          // Small equality inside a patch.\n          patch.diffs.add(aDiff);\n          patch.length1 += aDiff.text.length();\n          patch.length2 += aDiff.text.length();\n        }\n\n        if (aDiff.text.length() >= 2 * Patch_Margin) {\n          // Time for a new patch.\n          if (!patch.diffs.isEmpty()) {\n            patch_addContext(patch, prepatch_text);\n            patches.add(patch);\n            patch = new Patch();\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n      }\n\n      // Update the current character count.\n      if (aDiff.operation != Operation.INSERT) {\n        char_count1 += aDiff.text.length();\n      }\n      if (aDiff.operation != Operation.DELETE) {\n        char_count2 += aDiff.text.length();\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (!patch.diffs.isEmpty()) {\n      patch_addContext(patch, prepatch_text);\n      patches.add(patch);\n    }\n\n    return patches;\n  }", "language": "java", "Allcodes": "public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {\n    if (text1 == null || diffs == null) {\n      throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\n    }\n\n    LinkedList<Patch> patches = new LinkedList<Patch>();\n    if (diffs.isEmpty()) {\n      return patches;  // Get rid of the null case.\n    }\n    Patch patch = new Patch();\n    int char_count1 = 0;  // Number of characters into the text1 string.\n    int char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text). We recreate the patches one by one to determine\n    // context info.\n    String prepatch_text = text1;\n    String postpatch_text = text1;\n    for (Diff aDiff : diffs) {\n      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (aDiff.operation) {\n      case INSERT:\n        patch.diffs.add(aDiff);\n        patch.length2 += aDiff.text.length();\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + aDiff.text + postpatch_text.substring(char_count2);\n        break;\n      case DELETE:\n        patch.length1 += aDiff.text.length();\n        patch.diffs.add(aDiff);\n        postpatch_text = postpatch_text.substring(0, char_count2)\n            + postpatch_text.substring(char_count2 + aDiff.text.length());\n        break;\n      case EQUAL:\n        if (aDiff.text.length() <= 2 * Patch_Margin\n            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\n          // Small equality inside a patch.\n          patch.diffs.add(aDiff);\n          patch.length1 += aDiff.text.length();\n          patch.length2 += aDiff.text.length();\n        }\n\n        if (aDiff.text.length() >= 2 * Patch_Margin) {\n          // Time for a new patch.\n          if (!patch.diffs.isEmpty()) {\n            patch_addContext(patch, prepatch_text);\n            patches.add(patch);\n            patch = new Patch();\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n      }\n\n      // Update the current character count.\n      if (aDiff.operation != Operation.INSERT) {\n        char_count1 += aDiff.text.length();\n      }\n      if (aDiff.operation != Operation.DELETE) {\n        char_count2 += aDiff.text.length();\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (!patch.diffs.isEmpty()) {\n      patch_addContext(patch, prepatch_text);\n      patches.add(patch);\n    }\n\n    return patches;\n  }", "code_tokens": ["public", "LinkedList", "<", "Patch", ">", "patch_make", "(", "String", "text1", ",", "LinkedList", "<", "Diff", ">", "diffs", ")", "{", "if", "(", "text1", "==", "null", "||", "diffs", "==", "null", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Null inputs. (patch_make)\"", ")", ";", "}", "LinkedList", "<", "Patch", ">", "patches", "=", "new", "LinkedList", "<", "Patch", ">", "(", ")", ";", "if", "(", "diffs", ".", "isEmpty", "(", ")", ")", "{", "return", "patches", ";", "// Get rid of the null case.", "}", "Patch", "patch", "=", "new", "Patch", "(", ")", ";", "int", "char_count1", "=", "0", ";", "// Number of characters into the text1 string.", "int", "char_count2", "=", "0", ";", "// Number of characters into the text2 string.", "// Start with text1 (prepatch_text) and apply the diffs until we arrive at", "// text2 (postpatch_text). We recreate the patches one by one to determine", "// context info.", "String", "prepatch_text", "=", "text1", ";", "String", "postpatch_text", "=", "text1", ";", "for", "(", "Diff", "aDiff", ":", "diffs", ")", "{", "if", "(", "patch", ".", "diffs", ".", "isEmpty", "(", ")", "&&", "aDiff", ".", "operation", "!=", "Operation", ".", "EQUAL", ")", "{", "// A new patch starts here.", "patch", ".", "start1", "=", "char_count1", ";", "patch", ".", "start2", "=", "char_count2", ";", "}", "switch", "(", "aDiff", ".", "operation", ")", "{", "case", "INSERT", ":", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "patch", ".", "length2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "postpatch_text", "=", "postpatch_text", ".", "substring", "(", "0", ",", "char_count2", ")", "+", "aDiff", ".", "text", "+", "postpatch_text", ".", "substring", "(", "char_count2", ")", ";", "break", ";", "case", "DELETE", ":", "patch", ".", "length1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "postpatch_text", "=", "postpatch_text", ".", "substring", "(", "0", ",", "char_count2", ")", "+", "postpatch_text", ".", "substring", "(", "char_count2", "+", "aDiff", ".", "text", ".", "length", "(", ")", ")", ";", "break", ";", "case", "EQUAL", ":", "if", "(", "aDiff", ".", "text", ".", "length", "(", ")", "<=", "2", "*", "Patch_Margin", "&&", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", "&&", "aDiff", "!=", "diffs", ".", "getLast", "(", ")", ")", "{", "// Small equality inside a patch.", "patch", ".", "diffs", ".", "add", "(", "aDiff", ")", ";", "patch", ".", "length1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "patch", ".", "length2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "if", "(", "aDiff", ".", "text", ".", "length", "(", ")", ">=", "2", "*", "Patch_Margin", ")", "{", "// Time for a new patch.", "if", "(", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", ")", "{", "patch_addContext", "(", "patch", ",", "prepatch_text", ")", ";", "patches", ".", "add", "(", "patch", ")", ";", "patch", "=", "new", "Patch", "(", ")", ";", "// Unlike Unidiff, our patch lists have a rolling context.", "// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff", "// Update prepatch text & pos to reflect the application of the", "// just completed patch.", "prepatch_text", "=", "postpatch_text", ";", "char_count1", "=", "char_count2", ";", "}", "}", "break", ";", "}", "// Update the current character count.", "if", "(", "aDiff", ".", "operation", "!=", "Operation", ".", "INSERT", ")", "{", "char_count1", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "if", "(", "aDiff", ".", "operation", "!=", "Operation", ".", "DELETE", ")", "{", "char_count2", "+=", "aDiff", ".", "text", ".", "length", "(", ")", ";", "}", "}", "// Pick up the leftover patch if not empty.", "if", "(", "!", "patch", ".", "diffs", ".", "isEmpty", "(", ")", ")", "{", "patch_addContext", "(", "patch", ",", "prepatch_text", ")", ";", "patches", ".", "add", "(", "patch", ")", ";", "}", "return", "patches", ";", "}"], "docstring": "Compute a list of patches to turn text1 into text2.\ntext2 is not provided, diffs are the delta between text1 and text2.\n@param text1 Old text.\n@param diffs Array of Diff objects for text1 to text2.\n@return LinkedList of Patch objects.", "docstring_tokens": ["Compute", "a", "list", "of", "patches", "to", "turn", "text1", "into", "text2", ".", "text2", "is", "not", "provided", "diffs", "are", "the", "delta", "between", "text1", "and", "text2", "."]}
{"code": "URIRef Base=URIRef.create(base);", "comments": "NOSONAR", "lines": 2, "repo": "ldp4j/ldp4j", "path": "commons/core/src/main/java/org/ldp4j/commons/net/URIUtils.java", "func_name": "URIUtils.relativeResolution", "original_string": "private static URIRef relativeResolution(URI target, URI base) {\n\t\tURIRef Base=URIRef.create(base); // NOSONAR\n\t\tURIRef R=URIRef.create(target); // NOSONAR\n\t\tURIRef T=URIRef.create(); // NOSONAR\n\t\tif(defined(R.scheme)) {\n\t\t\tT.scheme    = R.scheme;\n\t\t\tT.authority = R.authority;\n\t\t\tT.path      = removeDotSegments(R.path);\n\t\t\tT.query     = R.query;\n\t\t} else {\n\t\t\tif(defined(R.authority)) {\n\t\t\t\tT.authority = R.authority;\n\t\t\t\tT.path      = removeDotSegments(R.path);\n\t\t\t\tT.query     = R.query;\n\t\t\t} else {\n\t\t\t\tresolvePathOnlyTarget(Base, R, T);\n\t\t\t}\n\t\t\tT.scheme = Base.scheme;\n\t\t}\n\t\tT.fragment = R.fragment;\n\t\treturn T;\n\t}", "language": "java", "Allcodes": "private static URIRef relativeResolution(URI target, URI base) {\n\t\tURIRef Base=URIRef.create(base); // NOSONAR\n\t\tURIRef R=URIRef.create(target); // NOSONAR\n\t\tURIRef T=URIRef.create(); // NOSONAR\n\t\tif(defined(R.scheme)) {\n\t\t\tT.scheme    = R.scheme;\n\t\t\tT.authority = R.authority;\n\t\t\tT.path      = removeDotSegments(R.path);\n\t\t\tT.query     = R.query;\n\t\t} else {\n\t\t\tif(defined(R.authority)) {\n\t\t\t\tT.authority = R.authority;\n\t\t\t\tT.path      = removeDotSegments(R.path);\n\t\t\t\tT.query     = R.query;\n\t\t\t} else {\n\t\t\t\tresolvePathOnlyTarget(Base, R, T);\n\t\t\t}\n\t\t\tT.scheme = Base.scheme;\n\t\t}\n\t\tT.fragment = R.fragment;\n\t\treturn T;\n\t}", "code_tokens": ["private", "static", "URIRef", "relativeResolution", "(", "URI", "target", ",", "URI", "base", ")", "{", "URIRef", "Base", "=", "URIRef", ".", "create", "(", "base", ")", ";", "// NOSONAR", "URIRef", "R", "=", "URIRef", ".", "create", "(", "target", ")", ";", "// NOSONAR", "URIRef", "T", "=", "URIRef", ".", "create", "(", ")", ";", "// NOSONAR", "if", "(", "defined", "(", "R", ".", "scheme", ")", ")", "{", "T", ".", "scheme", "=", "R", ".", "scheme", ";", "T", ".", "authority", "=", "R", ".", "authority", ";", "T", ".", "path", "=", "removeDotSegments", "(", "R", ".", "path", ")", ";", "T", ".", "query", "=", "R", ".", "query", ";", "}", "else", "{", "if", "(", "defined", "(", "R", ".", "authority", ")", ")", "{", "T", ".", "authority", "=", "R", ".", "authority", ";", "T", ".", "path", "=", "removeDotSegments", "(", "R", ".", "path", ")", ";", "T", ".", "query", "=", "R", ".", "query", ";", "}", "else", "{", "resolvePathOnlyTarget", "(", "Base", ",", "R", ",", "T", ")", ";", "}", "T", ".", "scheme", "=", "Base", ".", "scheme", ";", "}", "T", ".", "fragment", "=", "R", ".", "fragment", ";", "return", "T", ";", "}"], "docstring": "5.2.  Relative Resolution\n\nThis section describes an algorithm for converting a URI reference\nthat might be relative to a given base URI into the parsed components\nof the reference's target.  The components can then be recomposed, as\ndescribed in Section 5.3, to form the target URI.  This algorithm\nprovides definitive results that can be used to test the output of\nother implementations.  Applications may implement relative reference\nresolution by using some other algorithm, provided that the results\nmatch what would be given by this one.\n\n5.2.1.  Pre-parse the Base URI\n\nThe base URI (Base) is established according to the procedure of\nSection 5.1 and parsed into the five main components described in\nSection 3.  Note that only the scheme component is required to be\npresent in a base URI; the other components may be empty or\nundefined.  A component is undefined if its associated delimiter does\nnot appear in the URI reference; the path component is never\nundefined, though it may be empty.\n\nNormalization of the base URI, as described in Sections 6.2.2 and\n6.2.3, is optional.  A URI reference must be transformed to its\ntarget URI before it can be normalized.\n\n5.2.2.  Transform References\n\nFor each URI reference (R), the following pseudocode describes an\nalgorithm for transforming R into its target URI (T):\n-- The URI reference is parsed into the five URI components\n--\n(R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);\n\n-- A non-strict parser may ignore a scheme in the reference\n-- if it is identical to the base URI's scheme.\n--\nif ((not strict) and (R.scheme == Base.scheme)) then\nundefine(R.scheme);\nendif;\n\nif defined(R.scheme) then\nT.scheme    = R.scheme;\nT.authority = R.authority;\nT.path      = remove_dot_segments(R.path);\nT.query     = R.query;\nelse\nif defined(R.authority) then\nT.authority = R.authority;\nT.path      = remove_dot_segments(R.path);\nT.query     = R.query;\nelse\nif (R.path == \"\") then\nT.path = Base.path;\nif defined(R.query) then\nT.query = R.query;\nelse\nT.query = Base.query;\nendif;\nelse\nif (R.path starts-with \"/\") then\nT.path = remove_dot_segments(R.path);\nelse\nT.path = merge(Base.path, R.path);\nT.path = remove_dot_segments(T.path);\nendif;\nT.query = R.query;\nendif;\nT.authority = Base.authority;\nendif;\nT.scheme = Base.scheme;\nendif;\n\nT.fragment = R.fragment;", "docstring_tokens": ["5", ".", "2", ".", "Relative", "Resolution"]}
{"code": "return Collections.singletonList(map);", "comments": "nothing to do", "lines": 7, "repo": "zandero/utils", "path": "src/main/java/com/zandero/utils/MapUtils.java", "func_name": "MapUtils.split", "original_string": "public static <K, V> List<Map<K, V>> split(Map<K, V> map, int limit) {\n\n\t\tAssert.notNull(map, \"Missing map!\");\n\t\tAssert.isTrue(limit > 0, \"Map limit must be > 0!\");\n\n\t\tif (map.size() <= limit) {\n\t\t\treturn Collections.singletonList(map); // nothing to do\n\t\t}\n\n\t\treturn map.entrySet().parallelStream().collect(mapSizer(limit));\n\t}", "language": "java", "Allcodes": "public static <K, V> List<Map<K, V>> split(Map<K, V> map, int limit) {\n\n\t\tAssert.notNull(map, \"Missing map!\");\n\t\tAssert.isTrue(limit > 0, \"Map limit must be > 0!\");\n\n\t\tif (map.size() <= limit) {\n\t\t\treturn Collections.singletonList(map); // nothing to do\n\t\t}\n\n\t\treturn map.entrySet().parallelStream().collect(mapSizer(limit));\n\t}", "code_tokens": ["public", "static", "<", "K", ",", "V", ">", "List", "<", "Map", "<", "K", ",", "V", ">", ">", "split", "(", "Map", "<", "K", ",", "V", ">", "map", ",", "int", "limit", ")", "{", "Assert", ".", "notNull", "(", "map", ",", "\"Missing map!\"", ")", ";", "Assert", ".", "isTrue", "(", "limit", ">", "0", ",", "\"Map limit must be > 0!\"", ")", ";", "if", "(", "map", ".", "size", "(", ")", "<=", "limit", ")", "{", "return", "Collections", ".", "singletonList", "(", "map", ")", ";", "// nothing to do", "}", "return", "map", ".", "entrySet", "(", ")", ".", "parallelStream", "(", ")", ".", "collect", "(", "mapSizer", "(", "limit", ")", ")", ";", "}"], "docstring": "Splits map to list of maps\n@param map to be split\n@param limit max number of items in splitted map\n@param <K> key type\n@param <V> value type\n@return list of maps", "docstring_tokens": ["Splits", "map", "to", "list", "of", "maps"]}
{"code": "return url.openConnection().getLastModified();", "comments": "get last modified date of resource", "lines": 9, "repo": "zandero/utils", "path": "src/main/java/com/zandero/utils/ResourceUtils.java", "func_name": "ResourceUtils.getLastModifiedTime", "original_string": "@Deprecated\n\tpublic static Long getLastModifiedTime(String resourceFile, Class clazz) {\n\n\n\t\tAssert.notNullOrEmptyTrimmed(resourceFile, \"Missing resource file!\");\n\n\t\ttry {\n\t\t\tURL url = clazz.getResource(resourceFile);\n\t\t\treturn url.openConnection().getLastModified(); // get last modified date of resource\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}", "language": "java", "Allcodes": "@Deprecated\n\tpublic static Long getLastModifiedTime(String resourceFile, Class clazz) {\n\n\n\t\tAssert.notNullOrEmptyTrimmed(resourceFile, \"Missing resource file!\");\n\n\t\ttry {\n\t\t\tURL url = clazz.getResource(resourceFile);\n\t\t\treturn url.openConnection().getLastModified(); // get last modified date of resource\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}", "code_tokens": ["@", "Deprecated", "public", "static", "Long", "getLastModifiedTime", "(", "String", "resourceFile", ",", "Class", "clazz", ")", "{", "Assert", ".", "notNullOrEmptyTrimmed", "(", "resourceFile", ",", "\"Missing resource file!\"", ")", ";", "try", "{", "URL", "url", "=", "clazz", ".", "getResource", "(", "resourceFile", ")", ";", "return", "url", ".", "openConnection", "(", ")", ".", "getLastModified", "(", ")", ";", "// get last modified date of resource", "}", "catch", "(", "IOException", "e", ")", "{", "return", "null", ";", "}", "}"], "docstring": "Get resource last modified date\n\n@param resourceFile to read\n@param clazz        to use for resource access\n@return last modified date or null if resource could not be read", "docstring_tokens": ["Get", "resource", "last", "modified", "date"]}
{"code": "int relevance = -1;", "comments": "start at -1 ... so -1 is returned for no result", "lines": 12, "repo": "zandero/utils", "path": "src/main/java/com/zandero/utils/StringUtils.java", "func_name": "StringUtils.relevance", "original_string": "public static int relevance(String value, String search) {\n\n\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||\n\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (search.length() > value.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint relevance = -1; // start at -1 ... so -1 is returned for no result\n\t\tint delta = 1; // first delta at 1 ... producing a sum of 0 when first letter is found\n\n\t\tint len = value.length();\n\t\tint searchLen = search.length();\n\t\tint letterIndex = 0;\n\n\t\tfor (int searchIndex = 0; searchIndex < searchLen; searchIndex++) {\n\n\t\t\tchar match = search.charAt(searchIndex);\n\n\t\t\twhile (letterIndex < len) {\n\t\t\t\tchar letter = value.charAt(letterIndex);\n\t\t\t\tletterIndex++;\n\n\t\t\t\tif (match == letter) {\n\t\t\t\t\trelevance = relevance + delta; // reverse to get higher value for better match\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we matched all characters ... and found the last one ...\n\t\t\tif (delta == 0 && searchIndex == searchLen - 1) {\n\t\t\t\treturn relevance;\n\t\t\t}\n\n\t\t\tif (letterIndex == len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}", "language": "java", "Allcodes": "public static int relevance(String value, String search) {\n\n\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||\n\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (search.length() > value.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint relevance = -1; // start at -1 ... so -1 is returned for no result\n\t\tint delta = 1; // first delta at 1 ... producing a sum of 0 when first letter is found\n\n\t\tint len = value.length();\n\t\tint searchLen = search.length();\n\t\tint letterIndex = 0;\n\n\t\tfor (int searchIndex = 0; searchIndex < searchLen; searchIndex++) {\n\n\t\t\tchar match = search.charAt(searchIndex);\n\n\t\t\twhile (letterIndex < len) {\n\t\t\t\tchar letter = value.charAt(letterIndex);\n\t\t\t\tletterIndex++;\n\n\t\t\t\tif (match == letter) {\n\t\t\t\t\trelevance = relevance + delta; // reverse to get higher value for better match\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we matched all characters ... and found the last one ...\n\t\t\tif (delta == 0 && searchIndex == searchLen - 1) {\n\t\t\t\treturn relevance;\n\t\t\t}\n\n\t\t\tif (letterIndex == len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}", "code_tokens": ["public", "static", "int", "relevance", "(", "String", "value", ",", "String", "search", ")", "{", "if", "(", "StringUtils", ".", "isNullOrEmptyTrimmed", "(", "value", ")", "||", "StringUtils", ".", "isNullOrEmptyTrimmed", "(", "search", ")", ")", "{", "return", "-", "1", ";", "}", "if", "(", "search", ".", "length", "(", ")", ">", "value", ".", "length", "(", ")", ")", "{", "return", "-", "1", ";", "}", "int", "relevance", "=", "-", "1", ";", "// start at -1 ... so -1 is returned for no result", "int", "delta", "=", "1", ";", "// first delta at 1 ... producing a sum of 0 when first letter is found", "int", "len", "=", "value", ".", "length", "(", ")", ";", "int", "searchLen", "=", "search", ".", "length", "(", ")", ";", "int", "letterIndex", "=", "0", ";", "for", "(", "int", "searchIndex", "=", "0", ";", "searchIndex", "<", "searchLen", ";", "searchIndex", "++", ")", "{", "char", "match", "=", "search", ".", "charAt", "(", "searchIndex", ")", ";", "while", "(", "letterIndex", "<", "len", ")", "{", "char", "letter", "=", "value", ".", "charAt", "(", "letterIndex", ")", ";", "letterIndex", "++", ";", "if", "(", "match", "==", "letter", ")", "{", "relevance", "=", "relevance", "+", "delta", ";", "// reverse to get higher value for better match", "delta", "=", "0", ";", "break", ";", "}", "else", "{", "delta", "++", ";", "}", "}", "// we matched all characters ... and found the last one ...", "if", "(", "delta", "==", "0", "&&", "searchIndex", "==", "searchLen", "-", "1", ")", "{", "return", "relevance", ";", "}", "if", "(", "letterIndex", "==", "len", ")", "{", "break", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "Calculates matching relevance between given string and search expression\n\n@param value  to search in\n@param search to search for\n@return -1 not relevant, 0..N - where lower values represents more relevant results", "docstring_tokens": ["Calculates", "matching", "relevance", "between", "given", "string", "and", "search", "expression"]}
{"code": "int delta = 1;", "comments": "first delta at 1 ... producing a sum of 0 when first letter is found", "lines": 13, "repo": "zandero/utils", "path": "src/main/java/com/zandero/utils/StringUtils.java", "func_name": "StringUtils.relevance", "original_string": "public static int relevance(String value, String search) {\n\n\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||\n\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (search.length() > value.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint relevance = -1; // start at -1 ... so -1 is returned for no result\n\t\tint delta = 1; // first delta at 1 ... producing a sum of 0 when first letter is found\n\n\t\tint len = value.length();\n\t\tint searchLen = search.length();\n\t\tint letterIndex = 0;\n\n\t\tfor (int searchIndex = 0; searchIndex < searchLen; searchIndex++) {\n\n\t\t\tchar match = search.charAt(searchIndex);\n\n\t\t\twhile (letterIndex < len) {\n\t\t\t\tchar letter = value.charAt(letterIndex);\n\t\t\t\tletterIndex++;\n\n\t\t\t\tif (match == letter) {\n\t\t\t\t\trelevance = relevance + delta; // reverse to get higher value for better match\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we matched all characters ... and found the last one ...\n\t\t\tif (delta == 0 && searchIndex == searchLen - 1) {\n\t\t\t\treturn relevance;\n\t\t\t}\n\n\t\t\tif (letterIndex == len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}", "language": "java", "Allcodes": "public static int relevance(String value, String search) {\n\n\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||\n\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (search.length() > value.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint relevance = -1; // start at -1 ... so -1 is returned for no result\n\t\tint delta = 1; // first delta at 1 ... producing a sum of 0 when first letter is found\n\n\t\tint len = value.length();\n\t\tint searchLen = search.length();\n\t\tint letterIndex = 0;\n\n\t\tfor (int searchIndex = 0; searchIndex < searchLen; searchIndex++) {\n\n\t\t\tchar match = search.charAt(searchIndex);\n\n\t\t\twhile (letterIndex < len) {\n\t\t\t\tchar letter = value.charAt(letterIndex);\n\t\t\t\tletterIndex++;\n\n\t\t\t\tif (match == letter) {\n\t\t\t\t\trelevance = relevance + delta; // reverse to get higher value for better match\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we matched all characters ... and found the last one ...\n\t\t\tif (delta == 0 && searchIndex == searchLen - 1) {\n\t\t\t\treturn relevance;\n\t\t\t}\n\n\t\t\tif (letterIndex == len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}", "code_tokens": ["public", "static", "int", "relevance", "(", "String", "value", ",", "String", "search", ")", "{", "if", "(", "StringUtils", ".", "isNullOrEmptyTrimmed", "(", "value", ")", "||", "StringUtils", ".", "isNullOrEmptyTrimmed", "(", "search", ")", ")", "{", "return", "-", "1", ";", "}", "if", "(", "search", ".", "length", "(", ")", ">", "value", ".", "length", "(", ")", ")", "{", "return", "-", "1", ";", "}", "int", "relevance", "=", "-", "1", ";", "// start at -1 ... so -1 is returned for no result", "int", "delta", "=", "1", ";", "// first delta at 1 ... producing a sum of 0 when first letter is found", "int", "len", "=", "value", ".", "length", "(", ")", ";", "int", "searchLen", "=", "search", ".", "length", "(", ")", ";", "int", "letterIndex", "=", "0", ";", "for", "(", "int", "searchIndex", "=", "0", ";", "searchIndex", "<", "searchLen", ";", "searchIndex", "++", ")", "{", "char", "match", "=", "search", ".", "charAt", "(", "searchIndex", ")", ";", "while", "(", "letterIndex", "<", "len", ")", "{", "char", "letter", "=", "value", ".", "charAt", "(", "letterIndex", ")", ";", "letterIndex", "++", ";", "if", "(", "match", "==", "letter", ")", "{", "relevance", "=", "relevance", "+", "delta", ";", "// reverse to get higher value for better match", "delta", "=", "0", ";", "break", ";", "}", "else", "{", "delta", "++", ";", "}", "}", "// we matched all characters ... and found the last one ...", "if", "(", "delta", "==", "0", "&&", "searchIndex", "==", "searchLen", "-", "1", ")", "{", "return", "relevance", ";", "}", "if", "(", "letterIndex", "==", "len", ")", "{", "break", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "Calculates matching relevance between given string and search expression\n\n@param value  to search in\n@param search to search for\n@return -1 not relevant, 0..N - where lower values represents more relevant results", "docstring_tokens": ["Calculates", "matching", "relevance", "between", "given", "string", "and", "search", "expression"]}
{"code": "relevance = relevance + delta;", "comments": "reverse to get higher value for better match", "lines": 28, "repo": "zandero/utils", "path": "src/main/java/com/zandero/utils/StringUtils.java", "func_name": "StringUtils.relevance", "original_string": "public static int relevance(String value, String search) {\n\n\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||\n\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (search.length() > value.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint relevance = -1; // start at -1 ... so -1 is returned for no result\n\t\tint delta = 1; // first delta at 1 ... producing a sum of 0 when first letter is found\n\n\t\tint len = value.length();\n\t\tint searchLen = search.length();\n\t\tint letterIndex = 0;\n\n\t\tfor (int searchIndex = 0; searchIndex < searchLen; searchIndex++) {\n\n\t\t\tchar match = search.charAt(searchIndex);\n\n\t\t\twhile (letterIndex < len) {\n\t\t\t\tchar letter = value.charAt(letterIndex);\n\t\t\t\tletterIndex++;\n\n\t\t\t\tif (match == letter) {\n\t\t\t\t\trelevance = relevance + delta; // reverse to get higher value for better match\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we matched all characters ... and found the last one ...\n\t\t\tif (delta == 0 && searchIndex == searchLen - 1) {\n\t\t\t\treturn relevance;\n\t\t\t}\n\n\t\t\tif (letterIndex == len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}", "language": "java", "Allcodes": "public static int relevance(String value, String search) {\n\n\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||\n\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (search.length() > value.length()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint relevance = -1; // start at -1 ... so -1 is returned for no result\n\t\tint delta = 1; // first delta at 1 ... producing a sum of 0 when first letter is found\n\n\t\tint len = value.length();\n\t\tint searchLen = search.length();\n\t\tint letterIndex = 0;\n\n\t\tfor (int searchIndex = 0; searchIndex < searchLen; searchIndex++) {\n\n\t\t\tchar match = search.charAt(searchIndex);\n\n\t\t\twhile (letterIndex < len) {\n\t\t\t\tchar letter = value.charAt(letterIndex);\n\t\t\t\tletterIndex++;\n\n\t\t\t\tif (match == letter) {\n\t\t\t\t\trelevance = relevance + delta; // reverse to get higher value for better match\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we matched all characters ... and found the last one ...\n\t\t\tif (delta == 0 && searchIndex == searchLen - 1) {\n\t\t\t\treturn relevance;\n\t\t\t}\n\n\t\t\tif (letterIndex == len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}", "code_tokens": ["public", "static", "int", "relevance", "(", "String", "value", ",", "String", "search", ")", "{", "if", "(", "StringUtils", ".", "isNullOrEmptyTrimmed", "(", "value", ")", "||", "StringUtils", ".", "isNullOrEmptyTrimmed", "(", "search", ")", ")", "{", "return", "-", "1", ";", "}", "if", "(", "search", ".", "length", "(", ")", ">", "value", ".", "length", "(", ")", ")", "{", "return", "-", "1", ";", "}", "int", "relevance", "=", "-", "1", ";", "// start at -1 ... so -1 is returned for no result", "int", "delta", "=", "1", ";", "// first delta at 1 ... producing a sum of 0 when first letter is found", "int", "len", "=", "value", ".", "length", "(", ")", ";", "int", "searchLen", "=", "search", ".", "length", "(", ")", ";", "int", "letterIndex", "=", "0", ";", "for", "(", "int", "searchIndex", "=", "0", ";", "searchIndex", "<", "searchLen", ";", "searchIndex", "++", ")", "{", "char", "match", "=", "search", ".", "charAt", "(", "searchIndex", ")", ";", "while", "(", "letterIndex", "<", "len", ")", "{", "char", "letter", "=", "value", ".", "charAt", "(", "letterIndex", ")", ";", "letterIndex", "++", ";", "if", "(", "match", "==", "letter", ")", "{", "relevance", "=", "relevance", "+", "delta", ";", "// reverse to get higher value for better match", "delta", "=", "0", ";", "break", ";", "}", "else", "{", "delta", "++", ";", "}", "}", "// we matched all characters ... and found the last one ...", "if", "(", "delta", "==", "0", "&&", "searchIndex", "==", "searchLen", "-", "1", ")", "{", "return", "relevance", ";", "}", "if", "(", "letterIndex", "==", "len", ")", "{", "break", ";", "}", "}", "return", "-", "1", ";", "}"], "docstring": "Calculates matching relevance between given string and search expression\n\n@param value  to search in\n@param search to search for\n@return -1 not relevant, 0..N - where lower values represents more relevant results", "docstring_tokens": ["Calculates", "matching", "relevance", "between", "given", "string", "and", "search", "expression"]}
{"code": "List<Object> attributeList = new ArrayList<Object>(Arrays.asList(attributes));", "comments": "kinda wacky but Arrays.asList returns a unmodifiable list", "lines": 2, "repo": "pascalw/jFactory", "path": "core/src/main/java/nl/pwiddershoven/jfactory/ObjectFactory.java", "func_name": "ObjectFactory.build", "original_string": "public T build(Object... attributes) {\n        List<Object> attributeList = new ArrayList<Object>(Arrays.asList(attributes)); //kinda wacky but Arrays.asList returns a unmodifiable list\n\n        String[] traitNames = getTraitNames(attributeList);\n        applyTraits(traitNames);\n\n        T object = ReflectionUtils.createObject(factoryClass, constructorArgs);\n\n        // merge default properties with supplied attributes\n        Map<String, Object> propertyValues = createObjectPropertyValues(this.propertyValues, attributeList);\n\n        // now set properties and fields to the created object\n        setProperties(object, propertyValues);\n        setFields(object, fieldValues);\n\n        executeCallbacks(AfterFactoryBuild.class, object);\n        return object;\n    }", "language": "java", "Allcodes": "public T build(Object... attributes) {\n        List<Object> attributeList = new ArrayList<Object>(Arrays.asList(attributes)); //kinda wacky but Arrays.asList returns a unmodifiable list\n\n        String[] traitNames = getTraitNames(attributeList);\n        applyTraits(traitNames);\n\n        T object = ReflectionUtils.createObject(factoryClass, constructorArgs);\n\n        // merge default properties with supplied attributes\n        Map<String, Object> propertyValues = createObjectPropertyValues(this.propertyValues, attributeList);\n\n        // now set properties and fields to the created object\n        setProperties(object, propertyValues);\n        setFields(object, fieldValues);\n\n        executeCallbacks(AfterFactoryBuild.class, object);\n        return object;\n    }", "code_tokens": ["public", "T", "build", "(", "Object", "...", "attributes", ")", "{", "List", "<", "Object", ">", "attributeList", "=", "new", "ArrayList", "<", "Object", ">", "(", "Arrays", ".", "asList", "(", "attributes", ")", ")", ";", "//kinda wacky but Arrays.asList returns a unmodifiable list", "String", "[", "]", "traitNames", "=", "getTraitNames", "(", "attributeList", ")", ";", "applyTraits", "(", "traitNames", ")", ";", "T", "object", "=", "ReflectionUtils", ".", "createObject", "(", "factoryClass", ",", "constructorArgs", ")", ";", "// merge default properties with supplied attributes", "Map", "<", "String", ",", "Object", ">", "propertyValues", "=", "createObjectPropertyValues", "(", "this", ".", "propertyValues", ",", "attributeList", ")", ";", "// now set properties and fields to the created object", "setProperties", "(", "object", ",", "propertyValues", ")", ";", "setFields", "(", "object", ",", "fieldValues", ")", ";", "executeCallbacks", "(", "AfterFactoryBuild", ".", "class", ",", "object", ")", ";", "return", "object", ";", "}"], "docstring": "Build object.\n@return", "docstring_tokens": ["Build", "object", "."]}
{"code": "method.setAccessible(true);", "comments": "so we can call private and protected methods too", "lines": 2, "repo": "pascalw/jFactory", "path": "core/src/main/java/nl/pwiddershoven/jfactory/ReflectionUtils.java", "func_name": "ReflectionUtils.invokeMethod", "original_string": "public static void invokeMethod(Object target, Method method, Object... arguments) {\n        method.setAccessible(true); // so we can call private and protected methods too\n\n        try {\n            method.invoke(target, arguments);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "language": "java", "Allcodes": "public static void invokeMethod(Object target, Method method, Object... arguments) {\n        method.setAccessible(true); // so we can call private and protected methods too\n\n        try {\n            method.invoke(target, arguments);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }", "code_tokens": ["public", "static", "void", "invokeMethod", "(", "Object", "target", ",", "Method", "method", ",", "Object", "...", "arguments", ")", "{", "method", ".", "setAccessible", "(", "true", ")", ";", "// so we can call private and protected methods too", "try", "{", "method", ".", "invoke", "(", "target", ",", "arguments", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "}", "}"], "docstring": "Invoke the given method on the given target using the given arguments.\nAllows to call private and protected methods.\n@throws RuntimeException if method could not be invoked.\n@param target\n@param method\n@param arguments", "docstring_tokens": ["Invoke", "the", "given", "method", "on", "the", "given", "target", "using", "the", "given", "arguments", ".", "Allows", "to", "call", "private", "and", "protected", "methods", "."]}
{"code": "throw new RuntimeException(e);", "comments": "should not happen, compiler forces factory classes to implement correct constructor.", "lines": 15, "repo": "pascalw/jFactory", "path": "core/src/main/java/nl/pwiddershoven/jfactory/Factory.java", "func_name": "Factory.getFactoryClass", "original_string": "private static Class<?extends ObjectFactory> getFactoryClass(Class<?> factoryClass) {\n        if(factoryPackages.size() == 0) throw new IllegalArgumentException(\"No package provide to look for factories.\");\n\n        if(factoryClasses == null) {\n            factoryClasses = new HashMap<Class<?>, Class<? extends ObjectFactory>>();\n            Set<Class<?extends ObjectFactory>> classes = ReflectionUtils.getSubclassesOf(ObjectFactory.class, factoryPackages);\n\n            for(Class<?extends ObjectFactory> clazz : classes) {\n                if(! Modifier.isAbstract(clazz.getModifiers())) {\n                    try {\n                        Constructor constructor = clazz.getConstructor();\n                        ObjectFactory factory = (ObjectFactory)constructor.newInstance();\n                        factoryClasses.put(factory.getFactoryClass(), factory.getClass());\n                    } catch (Exception e) {\n                        throw new RuntimeException(e); //should not happen, compiler forces factory classes to implement correct constructor.\n                    }\n                }\n            }\n        }\n\n        return factoryClasses.get(factoryClass);\n    }", "language": "java", "Allcodes": "private static Class<?extends ObjectFactory> getFactoryClass(Class<?> factoryClass) {\n        if(factoryPackages.size() == 0) throw new IllegalArgumentException(\"No package provide to look for factories.\");\n\n        if(factoryClasses == null) {\n            factoryClasses = new HashMap<Class<?>, Class<? extends ObjectFactory>>();\n            Set<Class<?extends ObjectFactory>> classes = ReflectionUtils.getSubclassesOf(ObjectFactory.class, factoryPackages);\n\n            for(Class<?extends ObjectFactory> clazz : classes) {\n                if(! Modifier.isAbstract(clazz.getModifiers())) {\n                    try {\n                        Constructor constructor = clazz.getConstructor();\n                        ObjectFactory factory = (ObjectFactory)constructor.newInstance();\n                        factoryClasses.put(factory.getFactoryClass(), factory.getClass());\n                    } catch (Exception e) {\n                        throw new RuntimeException(e); //should not happen, compiler forces factory classes to implement correct constructor.\n                    }\n                }\n            }\n        }\n\n        return factoryClasses.get(factoryClass);\n    }", "code_tokens": ["private", "static", "Class", "<", "?", "extends", "ObjectFactory", ">", "getFactoryClass", "(", "Class", "<", "?", ">", "factoryClass", ")", "{", "if", "(", "factoryPackages", ".", "size", "(", ")", "==", "0", ")", "throw", "new", "IllegalArgumentException", "(", "\"No package provide to look for factories.\"", ")", ";", "if", "(", "factoryClasses", "==", "null", ")", "{", "factoryClasses", "=", "new", "HashMap", "<", "Class", "<", "?", ">", ",", "Class", "<", "?", "extends", "ObjectFactory", ">", ">", "(", ")", ";", "Set", "<", "Class", "<", "?", "extends", "ObjectFactory", ">", ">", "classes", "=", "ReflectionUtils", ".", "getSubclassesOf", "(", "ObjectFactory", ".", "class", ",", "factoryPackages", ")", ";", "for", "(", "Class", "<", "?", "extends", "ObjectFactory", ">", "clazz", ":", "classes", ")", "{", "if", "(", "!", "Modifier", ".", "isAbstract", "(", "clazz", ".", "getModifiers", "(", ")", ")", ")", "{", "try", "{", "Constructor", "constructor", "=", "clazz", ".", "getConstructor", "(", ")", ";", "ObjectFactory", "factory", "=", "(", "ObjectFactory", ")", "constructor", ".", "newInstance", "(", ")", ";", "factoryClasses", ".", "put", "(", "factory", ".", "getFactoryClass", "(", ")", ",", "factory", ".", "getClass", "(", ")", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "RuntimeException", "(", "e", ")", ";", "//should not happen, compiler forces factory classes to implement correct constructor.", "}", "}", "}", "}", "return", "factoryClasses", ".", "get", "(", "factoryClass", ")", ";", "}"], "docstring": "Get the class of the Factory for the given factoryClass.\n@param factoryClass\n@return", "docstring_tokens": ["Get", "the", "class", "of", "the", "Factory", "for", "the", "given", "factoryClass", "."]}
{"code": "e.printStackTrace();", "comments": "To change body of catch statement use File | Settings | File Templates.", "lines": 7, "repo": "icegem/icegem", "path": "icegem-core/src/main/java/com/googlecode/icegem/utils/ConsoleUtils.java", "func_name": "ConsoleUtils.waitForEnter", "original_string": "public static void waitForEnter(String message) {\n        System.out.println(message);\n        \n        try {\n            getReader().readLine();\n        } catch (IOException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n    }", "language": "java", "Allcodes": "public static void waitForEnter(String message) {\n        System.out.println(message);\n        \n        try {\n            getReader().readLine();\n        } catch (IOException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n    }", "code_tokens": ["public", "static", "void", "waitForEnter", "(", "String", "message", ")", "{", "System", ".", "out", ".", "println", "(", "message", ")", ";", "try", "{", "getReader", "(", ")", ".", "readLine", "(", ")", ";", "}", "catch", "(", "IOException", "e", ")", "{", "e", ".", "printStackTrace", "(", ")", ";", "//To change body of catch statement use File | Settings | File Templates.", "}", "}"], "docstring": "Waits for enter with specified message.\n\n@param message of type String", "docstring_tokens": ["Waits", "for", "enter", "with", "specified", "message", "."]}
{"code": "throw e;", "comments": "to get past generic catch for Exception.", "lines": 25, "repo": "lennartj/nazgul_tools", "path": "plugin/checkstyle/src/main/java/se/jguru/nazgul/tools/plugin/checkstyle/rss/VelocityTemplate.java", "func_name": "VelocityTemplate.generate", "original_string": "public void generate( String outputFilename, String template, Context context )\n        throws VelocityException, MojoExecutionException, IOException\n    {\n        Writer writer = null;\n\n        try\n        {\n            File f = new File( outputFilename );\n\n            if ( !f.getParentFile().exists() )\n            {\n                f.getParentFile().mkdirs();\n            }\n\n            writer = new FileWriter( f );\n\n            getVelocity().getEngine().mergeTemplate( templateDirectory + \"/\" + template, context, writer );\n        }\n        catch ( ResourceNotFoundException e )\n        {\n            throw new ResourceNotFoundException( \"Template not found: \" + templateDirectory + \"/\" + template, e );\n        }\n        catch ( VelocityException | IOException e )\n        {\n            throw e; // to get past generic catch for Exception.\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( e.getMessage(), e );\n        }\n        finally\n        {\n            if ( writer != null )\n            {\n                writer.flush();\n                writer.close();\n\n                getLog().debug( \"File \" + outputFilename + \" created...\" );\n            }\n        }\n    }", "language": "java", "Allcodes": "public void generate( String outputFilename, String template, Context context )\n        throws VelocityException, MojoExecutionException, IOException\n    {\n        Writer writer = null;\n\n        try\n        {\n            File f = new File( outputFilename );\n\n            if ( !f.getParentFile().exists() )\n            {\n                f.getParentFile().mkdirs();\n            }\n\n            writer = new FileWriter( f );\n\n            getVelocity().getEngine().mergeTemplate( templateDirectory + \"/\" + template, context, writer );\n        }\n        catch ( ResourceNotFoundException e )\n        {\n            throw new ResourceNotFoundException( \"Template not found: \" + templateDirectory + \"/\" + template, e );\n        }\n        catch ( VelocityException | IOException e )\n        {\n            throw e; // to get past generic catch for Exception.\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( e.getMessage(), e );\n        }\n        finally\n        {\n            if ( writer != null )\n            {\n                writer.flush();\n                writer.close();\n\n                getLog().debug( \"File \" + outputFilename + \" created...\" );\n            }\n        }\n    }", "code_tokens": ["public", "void", "generate", "(", "String", "outputFilename", ",", "String", "template", ",", "Context", "context", ")", "throws", "VelocityException", ",", "MojoExecutionException", ",", "IOException", "{", "Writer", "writer", "=", "null", ";", "try", "{", "File", "f", "=", "new", "File", "(", "outputFilename", ")", ";", "if", "(", "!", "f", ".", "getParentFile", "(", ")", ".", "exists", "(", ")", ")", "{", "f", ".", "getParentFile", "(", ")", ".", "mkdirs", "(", ")", ";", "}", "writer", "=", "new", "FileWriter", "(", "f", ")", ";", "getVelocity", "(", ")", ".", "getEngine", "(", ")", ".", "mergeTemplate", "(", "templateDirectory", "+", "\"/\"", "+", "template", ",", "context", ",", "writer", ")", ";", "}", "catch", "(", "ResourceNotFoundException", "e", ")", "{", "throw", "new", "ResourceNotFoundException", "(", "\"Template not found: \"", "+", "templateDirectory", "+", "\"/\"", "+", "template", ",", "e", ")", ";", "}", "catch", "(", "VelocityException", "|", "IOException", "e", ")", "{", "throw", "e", ";", "// to get past generic catch for Exception.", "}", "catch", "(", "Exception", "e", ")", "{", "throw", "new", "MojoExecutionException", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "finally", "{", "if", "(", "writer", "!=", "null", ")", "{", "writer", ".", "flush", "(", ")", ";", "writer", ".", "close", "(", ")", ";", "getLog", "(", ")", ".", "debug", "(", "\"File \"", "+", "outputFilename", "+", "\" created...\"", ")", ";", "}", "}", "}"], "docstring": "Using a specified Velocity Template and provided context, create the outputFilename.\n\n@param outputFilename the file to be generated.\n@param template       the velocity template to use.\n@param context        the velocity context map.\n@throws VelocityException if the template was not found or any other Velocity exception.\n@throws MojoExecutionException\n@throws IOException", "docstring_tokens": ["Using", "a", "specified", "Velocity", "Template", "and", "provided", "context", "create", "the", "outputFilename", "."]}
{"code": "return false;", "comments": "unknown variable", "lines": 34, "repo": "tstirrat/ucm-twine", "path": "src/main/java/org/ucmtwine/proxy/ScriptProxy.java", "func_name": "ScriptProxy.evaluateValue", "original_string": "public boolean evaluateValue(ScriptInfo info, boolean[] returnBool, String[] returnString, ExecutionContext context,\n      boolean isConditional) throws ServiceException {\n    /**\n     * This code, like the beginning block of code in evaluateFunction, is\n     * required for preparing the data for evaluation. It should not be altered.\n     * Only customize the switch statement below.\n     */\n    int config[] = (int[]) info.m_entry;\n    String key = info.m_key;\n\n    if ((context instanceof Service) == false) {\n      // Some variables will evaluate trivially instead of throwing an\n      // exception.\n      if (config[1] == RETURN_BOOLEAN) {\n        returnBool[0] = false;\n        returnString[0] = \"\";\n        return true;\n      }\n\n      throw new ServiceException(\"Script variable \" + key + \" must have be evaluated in \"\n          + \"context of a Service object.\");\n    }\n\n    UserData userData = (UserData) context.getCachedObject(\"UserData\");\n\n    if (userData == null) {\n      throw new ServiceException(\"Script variable \" + key + \" must have user data context.\");\n    }\n\n    int variableIndex = config[0];\n    String variableRequested = m_variableTable[variableIndex];\n\n    if (variableIndex > m_variableTable.length) {\n      return false; // unknown variable\n    }\n\n    Object result = null;\n\n    try {\n      result = runVariableMethod(variableIndex, context);\n\n    } catch (Exception e) {\n      String msg = \"Unable to handle variable \" + variableRequested + \": \" + e.getMessage();\n      SystemUtils.err(e, msg);\n      SystemUtils.trace(\"twine\", msg);\n      throw new ServiceException(msg);\n    }\n\n    if (isConditional) {\n      returnBool[0] = ObjectConverter.convert(result, boolean.class);\n    } else {\n      returnString[0] = ObjectConverter.convert(result, String.class);\n    }\n\n    return true;\n  }", "language": "java", "Allcodes": "public boolean evaluateValue(ScriptInfo info, boolean[] returnBool, String[] returnString, ExecutionContext context,\n      boolean isConditional) throws ServiceException {\n    /**\n     * This code, like the beginning block of code in evaluateFunction, is\n     * required for preparing the data for evaluation. It should not be altered.\n     * Only customize the switch statement below.\n     */\n    int config[] = (int[]) info.m_entry;\n    String key = info.m_key;\n\n    if ((context instanceof Service) == false) {\n      // Some variables will evaluate trivially instead of throwing an\n      // exception.\n      if (config[1] == RETURN_BOOLEAN) {\n        returnBool[0] = false;\n        returnString[0] = \"\";\n        return true;\n      }\n\n      throw new ServiceException(\"Script variable \" + key + \" must have be evaluated in \"\n          + \"context of a Service object.\");\n    }\n\n    UserData userData = (UserData) context.getCachedObject(\"UserData\");\n\n    if (userData == null) {\n      throw new ServiceException(\"Script variable \" + key + \" must have user data context.\");\n    }\n\n    int variableIndex = config[0];\n    String variableRequested = m_variableTable[variableIndex];\n\n    if (variableIndex > m_variableTable.length) {\n      return false; // unknown variable\n    }\n\n    Object result = null;\n\n    try {\n      result = runVariableMethod(variableIndex, context);\n\n    } catch (Exception e) {\n      String msg = \"Unable to handle variable \" + variableRequested + \": \" + e.getMessage();\n      SystemUtils.err(e, msg);\n      SystemUtils.trace(\"twine\", msg);\n      throw new ServiceException(msg);\n    }\n\n    if (isConditional) {\n      returnBool[0] = ObjectConverter.convert(result, boolean.class);\n    } else {\n      returnString[0] = ObjectConverter.convert(result, String.class);\n    }\n\n    return true;\n  }", "code_tokens": ["public", "boolean", "evaluateValue", "(", "ScriptInfo", "info", ",", "boolean", "[", "]", "returnBool", ",", "String", "[", "]", "returnString", ",", "ExecutionContext", "context", ",", "boolean", "isConditional", ")", "throws", "ServiceException", "{", "/**\n     * This code, like the beginning block of code in evaluateFunction, is\n     * required for preparing the data for evaluation. It should not be altered.\n     * Only customize the switch statement below.\n     */", "int", "config", "[", "]", "=", "(", "int", "[", "]", ")", "info", ".", "m_entry", ";", "String", "key", "=", "info", ".", "m_key", ";", "if", "(", "(", "context", "instanceof", "Service", ")", "==", "false", ")", "{", "// Some variables will evaluate trivially instead of throwing an", "// exception.", "if", "(", "config", "[", "1", "]", "==", "RETURN_BOOLEAN", ")", "{", "returnBool", "[", "0", "]", "=", "false", ";", "returnString", "[", "0", "]", "=", "\"\"", ";", "return", "true", ";", "}", "throw", "new", "ServiceException", "(", "\"Script variable \"", "+", "key", "+", "\" must have be evaluated in \"", "+", "\"context of a Service object.\"", ")", ";", "}", "UserData", "userData", "=", "(", "UserData", ")", "context", ".", "getCachedObject", "(", "\"UserData\"", ")", ";", "if", "(", "userData", "==", "null", ")", "{", "throw", "new", "ServiceException", "(", "\"Script variable \"", "+", "key", "+", "\" must have user data context.\"", ")", ";", "}", "int", "variableIndex", "=", "config", "[", "0", "]", ";", "String", "variableRequested", "=", "m_variableTable", "[", "variableIndex", "]", ";", "if", "(", "variableIndex", ">", "m_variableTable", ".", "length", ")", "{", "return", "false", ";", "// unknown variable", "}", "Object", "result", "=", "null", ";", "try", "{", "result", "=", "runVariableMethod", "(", "variableIndex", ",", "context", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "String", "msg", "=", "\"Unable to handle variable \"", "+", "variableRequested", "+", "\": \"", "+", "e", ".", "getMessage", "(", ")", ";", "SystemUtils", ".", "err", "(", "e", ",", "msg", ")", ";", "SystemUtils", ".", "trace", "(", "\"twine\"", ",", "msg", ")", ";", "throw", "new", "ServiceException", "(", "msg", ")", ";", "}", "if", "(", "isConditional", ")", "{", "returnBool", "[", "0", "]", "=", "ObjectConverter", ".", "convert", "(", "result", ",", "boolean", ".", "class", ")", ";", "}", "else", "{", "returnString", "[", "0", "]", "=", "ObjectConverter", ".", "convert", "(", "result", ",", "String", ".", "class", ")", ";", "}", "return", "true", ";", "}"], "docstring": "This is where the custom IdocScript variable is evaluated.", "docstring_tokens": ["This", "is", "where", "the", "custom", "IdocScript", "variable", "is", "evaluated", "."]}
{"code": "fLastSelectedTemplateName = \"\";", "comments": "$NON-NLS-1$", "lines": 2, "repo": "eteration/glassmaker", "path": "org.glassmaker.eclipse/org.glassmaker.ui.editor/src/main/java/org/glassmaker/ui/editor/wizards/NewCardTemplatesWizardPage.java", "func_name": "NewCardTemplatesWizardPage.loadLastSavedPreferences", "original_string": "private void loadLastSavedPreferences() {\n\t\tfLastSelectedTemplateName = \"\"; //$NON-NLS-1$\n\t\tboolean setSelection = false;\n\t\tString templateName = GlassmakerUIPlugin.getDefault().getPreferenceStore().getString(HTMLUIPreferenceNames.NEW_FILE_TEMPLATE_NAME);\n\t\tif (templateName == null || templateName.length() == 0) {\n\t\t\ttemplateName = GlassmakerUIPlugin.getDefault().getPreferenceStore().getString(HTMLUIPreferenceNames.NEW_FILE_TEMPLATE_ID);\n\t\t\tif (templateName != null && templateName.length() > 0) {\n\t\t\t\tTemplate template = fTemplateStore.findTemplateById(templateName);\n\t\t\t\tif (template != null) {\n\t\t\t\t\tfLastSelectedTemplateName = template.getName();\n\t\t\t\t\tsetSelection = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfLastSelectedTemplateName = templateName;\n\t\t\tsetSelection = true;\n\t\t}\n\t\tfUseTemplateButton.setSelection(setSelection);\n\t\tenableTemplates();\n\t}", "language": "java", "Allcodes": "private void loadLastSavedPreferences() {\n\t\tfLastSelectedTemplateName = \"\"; //$NON-NLS-1$\n\t\tboolean setSelection = false;\n\t\tString templateName = GlassmakerUIPlugin.getDefault().getPreferenceStore().getString(HTMLUIPreferenceNames.NEW_FILE_TEMPLATE_NAME);\n\t\tif (templateName == null || templateName.length() == 0) {\n\t\t\ttemplateName = GlassmakerUIPlugin.getDefault().getPreferenceStore().getString(HTMLUIPreferenceNames.NEW_FILE_TEMPLATE_ID);\n\t\t\tif (templateName != null && templateName.length() > 0) {\n\t\t\t\tTemplate template = fTemplateStore.findTemplateById(templateName);\n\t\t\t\tif (template != null) {\n\t\t\t\t\tfLastSelectedTemplateName = template.getName();\n\t\t\t\t\tsetSelection = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfLastSelectedTemplateName = templateName;\n\t\t\tsetSelection = true;\n\t\t}\n\t\tfUseTemplateButton.setSelection(setSelection);\n\t\tenableTemplates();\n\t}", "code_tokens": ["private", "void", "loadLastSavedPreferences", "(", ")", "{", "fLastSelectedTemplateName", "=", "\"\"", ";", "//$NON-NLS-1$", "boolean", "setSelection", "=", "false", ";", "String", "templateName", "=", "GlassmakerUIPlugin", ".", "getDefault", "(", ")", ".", "getPreferenceStore", "(", ")", ".", "getString", "(", "HTMLUIPreferenceNames", ".", "NEW_FILE_TEMPLATE_NAME", ")", ";", "if", "(", "templateName", "==", "null", "||", "templateName", ".", "length", "(", ")", "==", "0", ")", "{", "templateName", "=", "GlassmakerUIPlugin", ".", "getDefault", "(", ")", ".", "getPreferenceStore", "(", ")", ".", "getString", "(", "HTMLUIPreferenceNames", ".", "NEW_FILE_TEMPLATE_ID", ")", ";", "if", "(", "templateName", "!=", "null", "&&", "templateName", ".", "length", "(", ")", ">", "0", ")", "{", "Template", "template", "=", "fTemplateStore", ".", "findTemplateById", "(", "templateName", ")", ";", "if", "(", "template", "!=", "null", ")", "{", "fLastSelectedTemplateName", "=", "template", ".", "getName", "(", ")", ";", "setSelection", "=", "true", ";", "}", "}", "}", "else", "{", "fLastSelectedTemplateName", "=", "templateName", ";", "setSelection", "=", "true", ";", "}", "fUseTemplateButton", ".", "setSelection", "(", "setSelection", ")", ";", "enableTemplates", "(", ")", ";", "}"], "docstring": "Load the last template name used in New HTML File wizard.", "docstring_tokens": ["Load", "the", "last", "template", "name", "used", "in", "New", "HTML", "File", "wizard", "."]}
{"code": "valid = true;", "comments": "no extension so valid", "lines": 15, "repo": "eteration/glassmaker", "path": "org.glassmaker.eclipse/org.glassmaker.ui.editor/src/main/java/org/glassmaker/ui/editor/wizards/NewCardFileWizardPage.java", "func_name": "NewCardFileWizardPage.extensionValidForContentType", "original_string": "private boolean extensionValidForContentType(String fileName) {\n\t\tboolean valid = false;\n\n\t\tIContentType type = getContentType();\n\t\t// there is currently an extension\n\t\tif (fileName.lastIndexOf('.') != -1) {\n\t\t\t// check what content types are associated with current extension\n\t\t\tIContentType[] types = Platform.getContentTypeManager().findContentTypesFor(fileName);\n\t\t\tint i = 0;\n\t\t\twhile (i < types.length && !valid) {\n\t\t\t\tvalid = types[i].isKindOf(type);\n\t\t\t\t++i;\n\t\t\t}\n\t\t} else\n\t\t\tvalid = true; // no extension so valid\n\t\treturn valid;\n\t}", "language": "java", "Allcodes": "private boolean extensionValidForContentType(String fileName) {\n\t\tboolean valid = false;\n\n\t\tIContentType type = getContentType();\n\t\t// there is currently an extension\n\t\tif (fileName.lastIndexOf('.') != -1) {\n\t\t\t// check what content types are associated with current extension\n\t\t\tIContentType[] types = Platform.getContentTypeManager().findContentTypesFor(fileName);\n\t\t\tint i = 0;\n\t\t\twhile (i < types.length && !valid) {\n\t\t\t\tvalid = types[i].isKindOf(type);\n\t\t\t\t++i;\n\t\t\t}\n\t\t} else\n\t\t\tvalid = true; // no extension so valid\n\t\treturn valid;\n\t}", "code_tokens": ["private", "boolean", "extensionValidForContentType", "(", "String", "fileName", ")", "{", "boolean", "valid", "=", "false", ";", "IContentType", "type", "=", "getContentType", "(", ")", ";", "// there is currently an extension", "if", "(", "fileName", ".", "lastIndexOf", "(", "'", "'", ")", "!=", "-", "1", ")", "{", "// check what content types are associated with current extension", "IContentType", "[", "]", "types", "=", "Platform", ".", "getContentTypeManager", "(", ")", ".", "findContentTypesFor", "(", "fileName", ")", ";", "int", "i", "=", "0", ";", "while", "(", "i", "<", "types", ".", "length", "&&", "!", "valid", ")", "{", "valid", "=", "types", "[", "i", "]", ".", "isKindOf", "(", "type", ")", ";", "++", "i", ";", "}", "}", "else", "valid", "=", "true", ";", "// no extension so valid", "return", "valid", ";", "}"], "docstring": "Verifies if fileName is valid name for content type. Takes base content\ntype into consideration.\n\n@param fileName\n@return true if extension is valid for this content type", "docstring_tokens": ["Verifies", "if", "fileName", "is", "valid", "name", "for", "content", "type", ".", "Takes", "base", "content", "type", "into", "consideration", "."]}
{"code": "continue;", "comments": "for", "lines": 24, "repo": "NessComputing/migratory", "path": "migratory-core/src/main/java/com/nesscomputing/migratory/migration/sql/SqlScript.java", "func_name": "SqlScript.linesToStatements", "original_string": "List<SqlStatement> linesToStatements(List<String> lines)\n    {\n        final List<SqlStatement> statements = Lists.newArrayList();\n        final StringBuilder statementSql = new StringBuilder();\n        int count = 0;\n\n        String delimiter = DEFAULT_STATEMENT_DELIMITER;\n\n        for (final String line : lines)\n        {\n            if (StringUtils.isBlank(line)) {\n                continue;\n            }\n\n            if (statementSql.length() > 0) {\n                statementSql.append(\" \");\n            }\n            statementSql.append(line);\n\n            final String oldDelimiter = delimiter;\n            delimiter = changeDelimiterIfNecessary(statementSql.toString(), line, delimiter);\n            if (!StringUtils.equals(delimiter, oldDelimiter) && isDelimiterChangeExplicit()) {\n                statementSql.setLength(0);\n                continue; // for\n            }\n\n            if (StringUtils.endsWith(line, delimiter)) {\n                // Trim off the delimiter at the end.\n                statementSql.setLength(statementSql.length() - delimiter.length());\n                statements.add(new SqlStatement(count++, StringUtils.trimToEmpty(statementSql.toString())));\n                LOG.debug(\"Found statement: {}\", statementSql);\n\n                if (!isDelimiterChangeExplicit()) {\n                    delimiter = DEFAULT_STATEMENT_DELIMITER;\n                }\n                statementSql.setLength(0);\n            }\n        }\n\n        // Catch any statements not followed by delimiter.\n        if (statementSql.length() > 0) {\n            statements.add(new SqlStatement(count++, StringUtils.trimToEmpty(statementSql.toString())));\n        }\n\n        return statements;\n    }", "language": "java", "Allcodes": "List<SqlStatement> linesToStatements(List<String> lines)\n    {\n        final List<SqlStatement> statements = Lists.newArrayList();\n        final StringBuilder statementSql = new StringBuilder();\n        int count = 0;\n\n        String delimiter = DEFAULT_STATEMENT_DELIMITER;\n\n        for (final String line : lines)\n        {\n            if (StringUtils.isBlank(line)) {\n                continue;\n            }\n\n            if (statementSql.length() > 0) {\n                statementSql.append(\" \");\n            }\n            statementSql.append(line);\n\n            final String oldDelimiter = delimiter;\n            delimiter = changeDelimiterIfNecessary(statementSql.toString(), line, delimiter);\n            if (!StringUtils.equals(delimiter, oldDelimiter) && isDelimiterChangeExplicit()) {\n                statementSql.setLength(0);\n                continue; // for\n            }\n\n            if (StringUtils.endsWith(line, delimiter)) {\n                // Trim off the delimiter at the end.\n                statementSql.setLength(statementSql.length() - delimiter.length());\n                statements.add(new SqlStatement(count++, StringUtils.trimToEmpty(statementSql.toString())));\n                LOG.debug(\"Found statement: {}\", statementSql);\n\n                if (!isDelimiterChangeExplicit()) {\n                    delimiter = DEFAULT_STATEMENT_DELIMITER;\n                }\n                statementSql.setLength(0);\n            }\n        }\n\n        // Catch any statements not followed by delimiter.\n        if (statementSql.length() > 0) {\n            statements.add(new SqlStatement(count++, StringUtils.trimToEmpty(statementSql.toString())));\n        }\n\n        return statements;\n    }", "code_tokens": ["List", "<", "SqlStatement", ">", "linesToStatements", "(", "List", "<", "String", ">", "lines", ")", "{", "final", "List", "<", "SqlStatement", ">", "statements", "=", "Lists", ".", "newArrayList", "(", ")", ";", "final", "StringBuilder", "statementSql", "=", "new", "StringBuilder", "(", ")", ";", "int", "count", "=", "0", ";", "String", "delimiter", "=", "DEFAULT_STATEMENT_DELIMITER", ";", "for", "(", "final", "String", "line", ":", "lines", ")", "{", "if", "(", "StringUtils", ".", "isBlank", "(", "line", ")", ")", "{", "continue", ";", "}", "if", "(", "statementSql", ".", "length", "(", ")", ">", "0", ")", "{", "statementSql", ".", "append", "(", "\" \"", ")", ";", "}", "statementSql", ".", "append", "(", "line", ")", ";", "final", "String", "oldDelimiter", "=", "delimiter", ";", "delimiter", "=", "changeDelimiterIfNecessary", "(", "statementSql", ".", "toString", "(", ")", ",", "line", ",", "delimiter", ")", ";", "if", "(", "!", "StringUtils", ".", "equals", "(", "delimiter", ",", "oldDelimiter", ")", "&&", "isDelimiterChangeExplicit", "(", ")", ")", "{", "statementSql", ".", "setLength", "(", "0", ")", ";", "continue", ";", "// for", "}", "if", "(", "StringUtils", ".", "endsWith", "(", "line", ",", "delimiter", ")", ")", "{", "// Trim off the delimiter at the end.", "statementSql", ".", "setLength", "(", "statementSql", ".", "length", "(", ")", "-", "delimiter", ".", "length", "(", ")", ")", ";", "statements", ".", "add", "(", "new", "SqlStatement", "(", "count", "++", ",", "StringUtils", ".", "trimToEmpty", "(", "statementSql", ".", "toString", "(", ")", ")", ")", ")", ";", "LOG", ".", "debug", "(", "\"Found statement: {}\"", ",", "statementSql", ")", ";", "if", "(", "!", "isDelimiterChangeExplicit", "(", ")", ")", "{", "delimiter", "=", "DEFAULT_STATEMENT_DELIMITER", ";", "}", "statementSql", ".", "setLength", "(", "0", ")", ";", "}", "}", "// Catch any statements not followed by delimiter.", "if", "(", "statementSql", ".", "length", "(", ")", ">", "0", ")", "{", "statements", ".", "add", "(", "new", "SqlStatement", "(", "count", "++", ",", "StringUtils", ".", "trimToEmpty", "(", "statementSql", ".", "toString", "(", ")", ")", ")", ")", ";", "}", "return", "statements", ";", "}"], "docstring": "Turns these lines in a series of statements.", "docstring_tokens": ["Turns", "these", "lines", "in", "a", "series", "of", "statements", "."]}
{"code": "cy1 >= py1 && cy1 <= py2) xcnt++;", "comments": "top left", "lines": 15, "repo": "FitLayout/layout-cssbox", "path": "src/main/java/org/fit/layout/cssbox/BoxNode.java", "func_name": "BoxNode.visuallyEncloses1", "original_string": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "language": "java", "Allcodes": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "code_tokens": ["public", "boolean", "visuallyEncloses1", "(", "BoxNode", "childNode", ")", "{", "int", "cx1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "cy1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "cx2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "cy2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "int", "px1", "=", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "py1", "=", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "px2", "=", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "py2", "=", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "//check how many corners of the child are inside the parent exactly", "int", "xcnt", "=", "0", ";", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top right", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom right", "/*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/", "if", "(", "(", "cx1", "==", "px1", "&&", "cy1", "==", "py1", "&&", "cx2", "==", "px2", "&&", "cy2", "==", "py2", ")", ")", "//exact overlap", "return", "this", ".", "getOrder", "(", ")", "<", "childNode", ".", "getOrder", "(", ")", ";", "else", "return", "xcnt", "==", "4", ";", "}"], "docstring": "Checks if another node is fully located inside the content bounds of this box.\n@param childNode the node to check\n@return <code>true</code> if the child node is completely inside this node, <code>false</code> otherwise", "docstring_tokens": ["Checks", "if", "another", "node", "is", "fully", "located", "inside", "the", "content", "bounds", "of", "this", "box", "."]}
{"code": "cy1 >= py1 && cy1 <= py2) xcnt++;", "comments": "top right", "lines": 17, "repo": "FitLayout/layout-cssbox", "path": "src/main/java/org/fit/layout/cssbox/BoxNode.java", "func_name": "BoxNode.visuallyEncloses1", "original_string": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "language": "java", "Allcodes": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "code_tokens": ["public", "boolean", "visuallyEncloses1", "(", "BoxNode", "childNode", ")", "{", "int", "cx1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "cy1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "cx2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "cy2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "int", "px1", "=", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "py1", "=", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "px2", "=", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "py2", "=", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "//check how many corners of the child are inside the parent exactly", "int", "xcnt", "=", "0", ";", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top right", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom right", "/*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/", "if", "(", "(", "cx1", "==", "px1", "&&", "cy1", "==", "py1", "&&", "cx2", "==", "px2", "&&", "cy2", "==", "py2", ")", ")", "//exact overlap", "return", "this", ".", "getOrder", "(", ")", "<", "childNode", ".", "getOrder", "(", ")", ";", "else", "return", "xcnt", "==", "4", ";", "}"], "docstring": "Checks if another node is fully located inside the content bounds of this box.\n@param childNode the node to check\n@return <code>true</code> if the child node is completely inside this node, <code>false</code> otherwise", "docstring_tokens": ["Checks", "if", "another", "node", "is", "fully", "located", "inside", "the", "content", "bounds", "of", "this", "box", "."]}
{"code": "cy2 >= py1 && cy2 <= py2) xcnt++;", "comments": "bottom left", "lines": 19, "repo": "FitLayout/layout-cssbox", "path": "src/main/java/org/fit/layout/cssbox/BoxNode.java", "func_name": "BoxNode.visuallyEncloses1", "original_string": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "language": "java", "Allcodes": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "code_tokens": ["public", "boolean", "visuallyEncloses1", "(", "BoxNode", "childNode", ")", "{", "int", "cx1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "cy1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "cx2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "cy2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "int", "px1", "=", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "py1", "=", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "px2", "=", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "py2", "=", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "//check how many corners of the child are inside the parent exactly", "int", "xcnt", "=", "0", ";", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top right", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom right", "/*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/", "if", "(", "(", "cx1", "==", "px1", "&&", "cy1", "==", "py1", "&&", "cx2", "==", "px2", "&&", "cy2", "==", "py2", ")", ")", "//exact overlap", "return", "this", ".", "getOrder", "(", ")", "<", "childNode", ".", "getOrder", "(", ")", ";", "else", "return", "xcnt", "==", "4", ";", "}"], "docstring": "Checks if another node is fully located inside the content bounds of this box.\n@param childNode the node to check\n@return <code>true</code> if the child node is completely inside this node, <code>false</code> otherwise", "docstring_tokens": ["Checks", "if", "another", "node", "is", "fully", "located", "inside", "the", "content", "bounds", "of", "this", "box", "."]}
{"code": "cy2 >= py1 && cy2 <= py2) xcnt++;", "comments": "bottom right", "lines": 21, "repo": "FitLayout/layout-cssbox", "path": "src/main/java/org/fit/layout/cssbox/BoxNode.java", "func_name": "BoxNode.visuallyEncloses1", "original_string": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "language": "java", "Allcodes": "public boolean visuallyEncloses1(BoxNode childNode)\n    {\n        int cx1 = childNode.getVisualBounds().getX1();\n        int cy1 = childNode.getVisualBounds().getY1();\n        int cx2 = childNode.getVisualBounds().getX2();\n        int cy2 = childNode.getVisualBounds().getY2();\n        int px1 = getVisualBounds().getX1();\n        int py1 = getVisualBounds().getY1();\n        int px2 = getVisualBounds().getX2();\n        int py2 = getVisualBounds().getY2();\n        \n        //check how many corners of the child are inside the parent exactly\n        int xcnt = 0;\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy1 >= py1 && cy1 <= py2) xcnt++; //top right\n        if (cx1 >= px1 && cx1 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom left\n        if (cx2 >= px1 && cx2 <= px2 &&\n            cy2 >= py1 && cy2 <= py2) xcnt++; //bottom right\n        \n        /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/\n        \n        if ((cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2)) //exact overlap\n           return this.getOrder() < childNode.getOrder();\n        else\n            return xcnt == 4;\n    }", "code_tokens": ["public", "boolean", "visuallyEncloses1", "(", "BoxNode", "childNode", ")", "{", "int", "cx1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "cy1", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "cx2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "cy2", "=", "childNode", ".", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "int", "px1", "=", "getVisualBounds", "(", ")", ".", "getX1", "(", ")", ";", "int", "py1", "=", "getVisualBounds", "(", ")", ".", "getY1", "(", ")", ";", "int", "px2", "=", "getVisualBounds", "(", ")", ".", "getX2", "(", ")", ";", "int", "py2", "=", "getVisualBounds", "(", ")", ".", "getY2", "(", ")", ";", "//check how many corners of the child are inside the parent exactly", "int", "xcnt", "=", "0", ";", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy1", ">=", "py1", "&&", "cy1", "<=", "py2", ")", "xcnt", "++", ";", "//top right", "if", "(", "cx1", ">=", "px1", "&&", "cx1", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom left", "if", "(", "cx2", ">=", "px1", "&&", "cx2", "<=", "px2", "&&", "cy2", ">=", "py1", "&&", "cy2", "<=", "py2", ")", "xcnt", "++", ";", "//bottom right", "/*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\n            System.out.println(\"jo!\");*/", "if", "(", "(", "cx1", "==", "px1", "&&", "cy1", "==", "py1", "&&", "cx2", "==", "px2", "&&", "cy2", "==", "py2", ")", ")", "//exact overlap", "return", "this", ".", "getOrder", "(", ")", "<", "childNode", ".", "getOrder", "(", ")", ";", "else", "return", "xcnt", "==", "4", ";", "}"], "docstring": "Checks if another node is fully located inside the content bounds of this box.\n@param childNode the node to check\n@return <code>true</code> if the child node is completely inside this node, <code>false</code> otherwise", "docstring_tokens": ["Checks", "if", "another", "node", "is", "fully", "located", "inside", "the", "content", "bounds", "of", "this", "box", "."]}
